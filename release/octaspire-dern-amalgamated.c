/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017, 2018 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*******************************************************************************

  This file is amalgamated version of the header files, implementation files
  and unit tests of Octaspire Dern. It is created automatically by a script.

                            DO NOT EDIT MANUALLY!

  Edit the separate .h and .c files in the source distribution and then let
  the script create this file again with the modifications.

******************************************************************************/
#ifndef OCTASPIRE_DERN_AMALGAMATED_H
#define OCTASPIRE_DERN_AMALGAMATED_H

#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#ifdef _WIN32
#include <windows.h>
#else
#include <dlfcn.h>
#endif
#endif


#ifdef OCTASPIRE_PLAN9_IMPLEMENTATION

#include <u.h>
#include <libc.h>
#include <mp.h>
#include <stdio.h>
#include <ctype.h>

#else

#ifndef OCTASPIRE_DERN_AMALGAMATED_NO_BOOL
#include <stdbool.h>
#endif
#include <stddef.h>
#include <stdint.h>

#include <string.h>
#include <inttypes.h>
#include <ctype.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <stdarg.h>
#include <limits.h>
#include <wchar.h>
#include <locale.h>

#endif

#ifdef OCTASPIRE_DERN_AMALGAMATED_UNIT_TEST_IMPLEMENTATION
#define OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION 1
#endif

#ifdef OCTASPIRE_DERN_AMALGAMATED_REPL_IMPLEMENTATION
#define OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION 1
#endif

#ifdef OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION
#define OCTASPIRE_CORE_AMALGAMATED_IMPLEMENTATION 1
#endif

#ifdef __cplusplus
extern "C" {
#endif
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/external/octaspire_core/release/octaspire-core-amalgamated.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*******************************************************************************

  This file is amalgamated version of the header files, implementation files
  and unit tests of Octaspire Core. It is created automatically by a script.

                            DO NOT EDIT MANUALLY!

  Edit the separate .h and .c files in the source distribution and then let
  the script create this file again with the modifications.

******************************************************************************/
#ifndef OCTASPIRE_CORE_AMALGAMATED_H
#define OCTASPIRE_CORE_AMALGAMATED_H

#ifdef OCTASPIRE_PLAN9_IMPLEMENTATION


typedef long               int32_t;
typedef unsigned long      uint32_t;
typedef char               bool;
typedef char               int8_t;
typedef unsigned char      uint8_t;
typedef long               ptrdiff_t;
typedef unsigned long      size_t;
typedef unsigned long long uintmax_t;

#define true 1
#define false 0

#define CHAR_BIT 8
#define INT32_MAX 2147483647
#define UINTMAX_MAX 0xFFFFFFFF
#define va_copy(x,y) (x) = (y)
#define PRId32 "ld"
#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0

void exit(int32_t const status)
{
    exits(status == 0 ? "" : "error");
}

#else



#endif

#define OCTASPIRE_CORE_CONFIG_TEST_RES_PATH ""

#ifdef OCTASPIRE_CORE_AMALGAMATED_UNIT_TEST_IMPLEMENTATION
#define OCTASPIRE_CORE_AMALGAMATED_IMPLEMENTATION 1
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/external/jenkins_one_at_a_time.h
//////////////////////////////////////////////////////////////////////////////////////////////////
// Based on public domain code from:
// burtleburtle.net/bob/hash/doobs.html
#ifndef OCTASPIRE_CORE_JENKINS_ONE_AT_A_TIME_H
#define OCTASPIRE_CORE_JENKINS_ONE_AT_A_TIME_H


#ifdef __cplusplus
extern "C"
{
#endif

uint32_t jenkins_one_at_a_time_hash(void const * const data, size_t const lengthInOctets);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/external/jenkins_one_at_a_time.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_core_config.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_CORE_CONFIG_H
#define OCTASPIRE_CORE_CONFIG_H

#define OCTASPIRE_CORE_CONFIG_VERSION_MAJOR "0"
#define OCTASPIRE_CORE_CONFIG_VERSION_MINOR "105"
#define OCTASPIRE_CORE_CONFIG_VERSION_PATCH "0"

#define OCTASPIRE_CORE_CONFIG_VERSION_STR "Octaspire Core version " \
    OCTASPIRE_CORE_CONFIG_VERSION_MAJOR "." \
    OCTASPIRE_CORE_CONFIG_VERSION_MINOR "." \
    OCTASPIRE_CORE_CONFIG_VERSION_PATCH

#define OCTASPIRE_CORE_CONFIG_TEST_RES_PATH ""

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_core_config.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_utf8.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_UTF8_H
#define OCTASPIRE_UTF8_H


#ifdef __cplusplus
extern "C"       {
#endif

typedef enum octaspire_utf8_decode_status_t
{
    OCTASPIRE_UTF8_DECODE_STATUS_OK = 0,
    OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL,
    OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
    OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
    OCTASPIRE_UTF8_DECODE_STATUS_INPUT_NOT_ENOUGH_OCTETS_AVAILABLE
}
octaspire_utf8_decode_status_t;

typedef enum octaspire_utf8_encode_status_t
{
    OCTASPIRE_UTF8_ENCODE_STATUS_OK = 0,
    OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER
}
octaspire_utf8_encode_status_t;

typedef struct octaspire_utf8_character_t
{
    size_t        numoctets;
    unsigned char octets[4];
    char          padding[4];
}
octaspire_utf8_character_t;

octaspire_utf8_encode_status_t octaspire_utf8_encode_character(
    uint32_t const character,
    octaspire_utf8_character_t * const result);

octaspire_utf8_decode_status_t octaspire_utf8_decode_character(
    char const * const text,
    size_t const textLengthInOctets,
    uint32_t *result,
    int *numoctets);

octaspire_utf8_decode_status_t octaspire_utf8_decode_character_from_buffer(
    char const * const buffer,
    size_t const bufferLengthInOctets,
    size_t const currentIndex,
    uint32_t *result,
    int *numoctets);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_utf8.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_memory.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_MEMORY_H
#define OCTASPIRE_MEMORY_H


#ifdef __cplusplus
extern "C"       {
#endif

typedef void *(*octaspire_allocator_custom_malloc_function_t)(size_t size);
typedef void  (*octaspire_allocator_custom_free_function_t)(void *ptr);
typedef void *(*octaspire_allocator_custom_realloc_function_t)(void *ptr, size_t size);

typedef struct octaspire_allocator_config_t
{
    octaspire_allocator_custom_malloc_function_t  customMallocFunction;
    octaspire_allocator_custom_free_function_t    customFreeFunction;
    octaspire_allocator_custom_realloc_function_t customReallocFunction;
}
octaspire_allocator_config_t;

octaspire_allocator_config_t octaspire_allocator_config_default(void);


typedef struct octaspire_allocator_t octaspire_allocator_t;

octaspire_allocator_t *octaspire_allocator_new(
    octaspire_allocator_config_t const * config);

void octaspire_allocator_release(octaspire_allocator_t *self);

void *octaspire_allocator_malloc(
    octaspire_allocator_t *self,
    size_t const size);

void *octaspire_allocator_realloc(
    octaspire_allocator_t *self,
    void *ptr, size_t const size);

void octaspire_allocator_free(
    octaspire_allocator_t *self,
    void *ptr);

void octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
    octaspire_allocator_t *self,
    size_t const count,
    uint32_t const bitQueue0);

void octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged_when_larger_than_32(
    octaspire_allocator_t *self,
    size_t const count,
    uint32_t const bitQueue0,
    uint32_t const bitQueue1,
    uint32_t const bitQueue2,
    uint32_t const bitQueue3,
    uint32_t const bitQueue4,
    uint32_t const bitQueue5,
    uint32_t const bitQueue6,
    uint32_t const bitQueue7,
    uint32_t const bitQueue8,
    uint32_t const bitQueue9,
    uint32_t const bitQueue10,
    uint32_t const bitQueue11,
    uint32_t const bitQueue12,
    uint32_t const bitQueue13,
    uint32_t const bitQueue14,
    uint32_t const bitQueue15,
    uint32_t const bitQueue16,
    uint32_t const bitQueue17,
    uint32_t const bitQueue18,
    uint32_t const bitQueue19);

size_t octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
    octaspire_allocator_t const * const self);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_memory.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_vector.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_VECTOR_H
#define OCTASPIRE_VECTOR_H


#ifdef __cplusplus
extern "C"       {
#endif

typedef struct octaspire_vector_t octaspire_vector_t;

typedef void  (*octaspire_vector_element_callback_t)(void *element);

typedef int (*octaspire_vector_element_compare_function_t)(void const *a, void const *b);

octaspire_vector_t *octaspire_vector_new(
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_vector_element_callback_t elementReleaseCallback,
    octaspire_allocator_t *allocator);

octaspire_vector_t *octaspire_vector_new_with_preallocated_elements(
    size_t const elementSize,
    bool const elementIsPointer,
    size_t const numElementsPreAllocated,
    octaspire_vector_element_callback_t elementReleaseCallback,
    octaspire_allocator_t *allocator);

octaspire_vector_t *octaspire_vector_new_shallow_copy(
    octaspire_vector_t * other,
    octaspire_allocator_t * allocator);

void octaspire_vector_release(octaspire_vector_t *self);

// Vector can never be compacted smaller than this limit, if set
void octaspire_vector_set_compacting_limit_for_preallocated_elements(
    octaspire_vector_t * const self,
    size_t const numPreAllocatedElementsAtLeastPresentAtAnyMoment);

size_t octaspire_vector_get_length(
    octaspire_vector_t const * const self);

size_t octaspire_vector_get_length_in_octets(
    octaspire_vector_t const * const self);

bool octaspire_vector_is_empty(
    octaspire_vector_t const * const self);

bool octaspire_vector_remove_element_at(
    octaspire_vector_t * const self,
    ptrdiff_t const possiblyNegativeIndex);

void *octaspire_vector_get_element_at(
    octaspire_vector_t * const self,
    ptrdiff_t const possiblyNegativeIndex);

void const *octaspire_vector_get_element_at_const(
    octaspire_vector_t const * const self,
    ptrdiff_t const possiblyNegativeIndex);

void *octaspire_vector_get_raw_data_for_element_at(
    octaspire_vector_t * const self,
    ptrdiff_t const possiblyNegativeIndex);

void const *octaspire_vector_get_raw_data_for_element_at_const(
    octaspire_vector_t const * const self,
    ptrdiff_t const possiblyNegativeIndex);

size_t octaspire_vector_get_element_size_in_octets(
    octaspire_vector_t const * const self);

bool octaspire_vector_insert_element_before_the_element_at_index(
    octaspire_vector_t *self,
    void const *element,
    ptrdiff_t const possiblyNegativeIndex);

bool octaspire_vector_replace_element_at_index_or_push_back(
    octaspire_vector_t *self,
    void const *element,
    ptrdiff_t const possiblyNegativeIndex);

bool octaspire_vector_insert_element_at(
    octaspire_vector_t * const self,
    void const * const element,
    size_t const index);

bool octaspire_vector_replace_element_at(
    octaspire_vector_t *self,
    ptrdiff_t const possiblyNegativeIndex,
    void const *element);

bool octaspire_vector_push_front_element(
    octaspire_vector_t *self,
    void const *element);

bool octaspire_vector_push_back_element(
    octaspire_vector_t * const self,
    void const * const element);

bool octaspire_vector_push_back_char(
    octaspire_vector_t *self,
    char const element);

void octaspire_vector_for_each(
    octaspire_vector_t *self,
    octaspire_vector_element_callback_t callback);

bool octaspire_vector_pop_back_element(
    octaspire_vector_t *self);

void *octaspire_vector_peek_back_element(
    octaspire_vector_t *self);

void const * octaspire_vector_peek_back_element_const(
    octaspire_vector_t const * const self);

bool octaspire_vector_pop_front_element(
    octaspire_vector_t *self);

void *octaspire_vector_peek_front_element(
    octaspire_vector_t *self);

void const * octaspire_vector_peek_front_element_const(
    octaspire_vector_t const * const self);

octaspire_vector_element_callback_t
octaspire_vector_get_element_release_callback_const(
    octaspire_vector_t const * const self);

bool octaspire_vector_clear(
    octaspire_vector_t * const self);

void octaspire_vector_sort(
    octaspire_vector_t * const self,
    octaspire_vector_element_compare_function_t elementCompareFunction);

bool octaspire_vector_is_valid_index(
    octaspire_vector_t const * const self,
    ptrdiff_t const index);

bool octaspire_vector_swap(
    octaspire_vector_t * const self,
    ptrdiff_t const indexA,
    ptrdiff_t const indexB);

/*
void octaspire_vector_debug_print(
    octaspire_vector_t const * const self,
    FILE * const stream);
*/


typedef struct octaspire_vector_permutation_iterator_t
    octaspire_vector_permutation_iterator_t;

octaspire_vector_permutation_iterator_t
*octaspire_vector_permutation_iterator_new(
    octaspire_vector_t * const vector,
    octaspire_allocator_t * const allocator);

void octaspire_vector_permutation_iterator_release(
    octaspire_vector_permutation_iterator_t * const self);

bool octaspire_vector_permutation_iterator_next(
    octaspire_vector_permutation_iterator_t * const self);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_vector.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_list.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_CONTAINER_LIST_H
#define OCTASPIRE_CONTAINER_LIST_H


#ifdef __cplusplus
extern "C"
{
#endif

typedef struct octaspire_list_node_t octaspire_list_node_t;

typedef void (*octaspire_list_element_callback_t)(void *element);

octaspire_list_node_t *octaspire_list_node_new(
    octaspire_list_node_t * const previous,
    octaspire_list_node_t * const next,
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_list_element_callback_t const elementReleaseCallback,
    void const * const element,
    octaspire_allocator_t * const allocator);

void octaspire_list_node_release(octaspire_list_node_t *self);

void *octaspire_list_node_get_element(octaspire_list_node_t *self);

void const *octaspire_list_node_get_element_const(
    octaspire_list_node_t const * const self);

size_t octaspire_list_node_get_size_of_element_in_octets(
    octaspire_list_node_t const * const self);

void octaspire_list_node_set_next(
    octaspire_list_node_t * const self,
    octaspire_list_node_t * const next);

octaspire_list_node_t *octaspire_list_node_get_next(
    octaspire_list_node_t * const self);

octaspire_list_node_t const *octaspire_list_node_get_next_const(
    octaspire_list_node_t const * const self);

void octaspire_list_node_set_previous(
    octaspire_list_node_t * const self,
    octaspire_list_node_t * const previous);

octaspire_list_node_t *octaspire_list_node_get_previous(
    octaspire_list_node_t * const self);

octaspire_list_node_t const *octaspire_list_node_get_previous_const(
    octaspire_list_node_t const * const self);



typedef struct octaspire_list_t octaspire_list_t;

octaspire_list_t *octaspire_list_new(
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_list_element_callback_t const elementReleaseCallback,
    octaspire_allocator_t *allocator);

void octaspire_list_release(octaspire_list_t *self);

octaspire_list_node_t *octaspire_list_get_front(
    octaspire_list_t *self);

octaspire_list_node_t const *octaspire_list_get_front_const(
    octaspire_list_t const * const self);

octaspire_list_node_t *octaspire_list_get_back(
    octaspire_list_t *self);

octaspire_list_node_t const *octaspire_list_get_back_const(
    octaspire_list_t const * const self);

bool octaspire_list_push_front(
    octaspire_list_t *self,
    void const * const element);

bool octaspire_list_push_back(
    octaspire_list_t *self,
    void const * const element);

bool octaspire_list_pop_front(
    octaspire_list_t * const self);

bool octaspire_list_pop_back(
    octaspire_list_t * const self);

bool octaspire_list_remove(
    octaspire_list_t * const self,
    octaspire_list_node_t * const node);

bool octaspire_list_clear(
    octaspire_list_t * const self);

size_t octaspire_list_get_length(
    octaspire_list_t const * const self);

bool octaspire_list_is_empty(
    octaspire_list_t const * const self);

octaspire_list_node_t *octaspire_list_get_at(
    octaspire_list_t * const self,
    ptrdiff_t const possiblyNegativeIndex);

octaspire_list_node_t const *octaspire_list_get_at_const(
    octaspire_list_t const * const self,
    ptrdiff_t const possiblyNegativeIndex);


typedef struct octaspire_list_node_iterator_t
{
    octaspire_list_t      *list;
    octaspire_list_node_t *currentNode;
}
octaspire_list_node_iterator_t;

octaspire_list_node_iterator_t octaspire_list_node_iterator_init(
    octaspire_list_t * const self);

bool octaspire_list_node_iterator_next(
    octaspire_list_node_iterator_t * const self);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_list.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_queue.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_QUEUE_H
#define OCTASPIRE_QUEUE_H


#ifdef __cplusplus
extern "C"
{
#endif

typedef void (*octaspire_queue_element_callback_t)(void *element);

typedef struct octaspire_queue_t octaspire_queue_t;

octaspire_queue_t *octaspire_queue_new(
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_queue_element_callback_t const elementReleaseCallback,
    octaspire_allocator_t *allocator);

octaspire_queue_t *octaspire_queue_new_with_max_length(
    size_t const maxLength,
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_queue_element_callback_t const elementReleaseCallback,
    octaspire_allocator_t *allocator);

void octaspire_queue_release(octaspire_queue_t *self);

void *octaspire_queue_peek(
    octaspire_queue_t * const self);

void const *octaspire_queue_peek_const(
    octaspire_queue_t const * const self);

bool octaspire_queue_pop(
    octaspire_queue_t * const self);

bool octaspire_queue_push(
    octaspire_queue_t *self,
    void const * const element);

bool octaspire_queue_clear(
    octaspire_queue_t * const self);

size_t octaspire_queue_get_length(
    octaspire_queue_t const * const self);

bool octaspire_queue_is_empty(
    octaspire_queue_t const * const self);

void *octaspire_queue_get_at(
    octaspire_queue_t * const self,
    ptrdiff_t const possiblyNegativeIndex);

void const *octaspire_queue_get_at_const(
    octaspire_queue_t const * const self,
    ptrdiff_t const possiblyNegativeIndex);

size_t octaspire_queue_get_max_length(
    octaspire_queue_t const * const self);

bool octaspire_queue_has_max_length(
    octaspire_queue_t const * const self);

bool octaspire_queue_set_max_length(
    octaspire_queue_t * const self,
    size_t maxLength);

bool octaspire_queue_set_has_max_length(
    octaspire_queue_t * const self,
    bool hasMaxLength);



typedef struct octaspire_queue_iterator_t
{
    octaspire_queue_t *queue;
    octaspire_list_node_iterator_t iterator;
}
octaspire_queue_iterator_t;

octaspire_queue_iterator_t octaspire_queue_iterator_init(
    octaspire_queue_t * const self);

bool octaspire_queue_iterator_next(
    octaspire_queue_iterator_t * const self);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_queue.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_string.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_STRING_H
#define OCTASPIRE_STRING_H


#ifdef __cplusplus
extern "C"
{
#endif

typedef enum
{
    OCTASPIRE_STRING_ERROR_STATUS_OK,
    OCTASPIRE_STRING_ERROR_STATUS_ENCODING_ERROR,
    OCTASPIRE_STRING_ERROR_STATUS_DECODING_ERROR
}
octaspire_string_error_status_t;

typedef struct octaspire_string_t octaspire_string_t;

octaspire_string_t *octaspire_string_new(
    char const * const str,
    octaspire_allocator_t *allocator);

octaspire_string_t *octaspire_string_new_from_buffer(
    char const * const buffer,
    size_t const lengthInOctets,
    octaspire_allocator_t *allocator);

octaspire_string_t *octaspire_string_new_format(
    octaspire_allocator_t *allocator,
    char const * const fmt,
    ...);

octaspire_string_t *octaspire_string_new_vformat(
    octaspire_allocator_t *allocator,
    char const * const fmt,
    va_list arguments);

octaspire_string_t *octaspire_string_new_copy(
    octaspire_string_t const * const other,
    octaspire_allocator_t *allocator);

octaspire_string_t *octaspire_string_new_substring_from_given_index_and_length(
    octaspire_string_t const * const other,
    octaspire_allocator_t *allocator,
    size_t const ucsCharStartIndex,
    size_t const lengthInUcsChars);

void octaspire_string_release(octaspire_string_t *self);

bool octaspire_string_set_from_c_string(
    octaspire_string_t * const self,
    char const * const str);

bool octaspire_string_is_empty(
    octaspire_string_t const * const self);

size_t octaspire_string_get_length_in_ucs_characters(
    octaspire_string_t const * const self);

size_t octaspire_string_get_length_in_octets(
    octaspire_string_t const * const self);

bool octaspire_string_is_index_valid(
    octaspire_string_t const * const self,
    ptrdiff_t const possiblyNegativeIndex);

uint32_t octaspire_string_get_ucs_character_at_index(
    octaspire_string_t const * const self,
    ptrdiff_t const possiblyNegativeIndex);

char const * octaspire_string_get_c_string(
    octaspire_string_t const * const self);

bool octaspire_string_is_error(
    octaspire_string_t const * const self);

octaspire_string_error_status_t octaspire_string_get_error_status(
    octaspire_string_t const * const self);

size_t octaspire_string_get_error_position_in_octets(
    octaspire_string_t const * const self);

void octaspire_string_reset_error_status(
    octaspire_string_t * const self);

bool octaspire_string_concatenate(
    octaspire_string_t * const self,
    octaspire_string_t const * const other);

bool octaspire_string_concatenate_c_string(
    octaspire_string_t * const self,
    char const * const str);

bool octaspire_string_concatenate_format(
    octaspire_string_t * const self,
    char const * const fmt,
    ...);

ptrdiff_t octaspire_string_find_first_substring(
    octaspire_string_t const * const self,
    ptrdiff_t const startFromIndexPossiblyNegative,
    octaspire_string_t const * const substring);

bool octaspire_string_remove_character_at(
    octaspire_string_t * const self,
    ptrdiff_t const possiblyNegativeIndex);

size_t octaspire_string_remove_characters_at(
    octaspire_string_t * const self,
    ptrdiff_t const startFromIndexPossiblyNegative,
    size_t const numCharacters);

size_t octaspire_string_remove_all_substrings(
    octaspire_string_t * const self,
    octaspire_string_t const * const substring);

bool octaspire_string_clear(
    octaspire_string_t * const self);

bool octaspire_string_is_equal(
    octaspire_string_t const * const self,
    octaspire_string_t const * const other);

bool octaspire_string_is_equal_to_c_string(
    octaspire_string_t const * const self,
    char const * const str);

int octaspire_string_compare(
    octaspire_string_t const * const self,
    octaspire_string_t const * const other);

int octaspire_string_compare_to_c_string(
    octaspire_string_t const * const self,
    char const * const str);

bool octaspire_string_starts_with(
    octaspire_string_t const * const self,
    octaspire_string_t const * const other);

bool octaspire_string_ends_with(
    octaspire_string_t const * const self,
    octaspire_string_t const * const other);

uint32_t octaspire_string_get_hash(
    octaspire_string_t const * const self);

bool octaspire_string_push_back_ucs_character(
    octaspire_string_t *self,
    uint32_t const character);

bool octaspire_string_pop_front_ucs_character(
    octaspire_string_t *self);

bool octaspire_string_pop_back_ucs_character(
    octaspire_string_t *self);

bool octaspire_string_insert_string_to(
    octaspire_string_t * const self,
    octaspire_string_t const * const str,
    ptrdiff_t const indexToPutFirstCharacterPossiblyNegative);

bool octaspire_string_overwrite_with_string_at(
    octaspire_string_t * const self,
    octaspire_string_t const * const str,
    ptrdiff_t const indexToPutFirstCharacterPossiblyNegative);

octaspire_vector_t *octaspire_string_split(
    octaspire_string_t *self,
    char const * const delimiter);

// TODO make API consistent, now this differs from find_char below
bool octaspire_string_contains_char(
    octaspire_string_t const * const self,
    uint32_t const character);

bool octaspire_string_contains_only_these_chars(
    octaspire_string_t const * const self,
    octaspire_string_t const * const chars);

bool octaspire_string_contains_only_these_chars_c_string(
    octaspire_string_t const * const self,
    char const * const chars);

octaspire_vector_t *octaspire_string_find_char(
    octaspire_string_t const * const self,
    octaspire_string_t const * const character,
    ptrdiff_t const characterIndexPossiblyNegative);

octaspire_vector_t *octaspire_string_find_string(
    octaspire_string_t const * const self,
    octaspire_string_t const * const str,
    ptrdiff_t const strStartIndexPossiblyNegative,
    size_t const strLength);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_string.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_pair.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_CONTAINER_PAIR_H
#define OCTASPIRE_CONTAINER_PAIR_H


#ifdef __cplusplus
extern "C"
{
#endif

typedef struct octaspire_pair_t octaspire_pair_t;

typedef void (*octaspire_pair_element_callback_t)(void *element);

size_t octaspire_pair_t_get_sizeof(void);

octaspire_pair_t *octaspire_pair_new(
    size_t const firstElementSize,
    bool firstElementIsPointer,
    size_t const secondElementSize,
    bool secondElementIsPointer,
    octaspire_pair_element_callback_t firstElementReleaseCallback,
    octaspire_pair_element_callback_t secondElementReleaseCallback,
    octaspire_allocator_t *allocator);

octaspire_pair_t *octaspire_pair_new_shallow_copy(
    octaspire_pair_t   *other,
    octaspire_allocator_t *allocator);

void octaspire_pair_release(octaspire_pair_t *self);

void *octaspire_pair_get_first(octaspire_pair_t *self);

void const *octaspire_pair_get_first_const(octaspire_pair_t const * const self);

void *octaspire_pair_get_second(octaspire_pair_t *self);

void const *octaspire_pair_get_second_const(
    octaspire_pair_t const * const self);

size_t octaspire_pair_get_size_of_first_element_in_octets(
    octaspire_pair_t const * const self);

size_t octaspire_pair_get_size_of_second_element_in_octets(
    octaspire_pair_t const * const self);

void octaspire_pair_set(
    octaspire_pair_t *self,
    void const *first,
    void const *second);

void octaspire_pair_set_first(
    octaspire_pair_t *self,
    void const *first);

void octaspire_pair_set_second(
    octaspire_pair_t *self,
    void const *second);

bool octaspire_pair_set_first_to_void_pointer(
    octaspire_pair_t *self,
    void *element);

bool octaspire_pair_set_second_to_void_pointer(
    octaspire_pair_t *self,
    void *second);

void octaspire_pair_clear(
    octaspire_pair_t * const self);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_pair.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_stdio.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_STDIO_H
#define OCTASPIRE_STDIO_H


#ifdef __cplusplus
extern "C"       {
#endif

typedef struct octaspire_stdio_t octaspire_stdio_t;

octaspire_stdio_t *octaspire_stdio_new(octaspire_allocator_t *allocator);

void octaspire_stdio_release(octaspire_stdio_t *self);

size_t octaspire_stdio_fread(
    octaspire_stdio_t *self,
    void *ptr,
    size_t const size,
    size_t const nmemb,
    FILE *stream);

void octaspire_stdio_set_number_and_type_of_future_reads_to_be_rigged(
    octaspire_stdio_t *self,
    size_t const count,
    uint32_t const bitQueue);

size_t octaspire_stdio_get_number_of_future_reads_to_be_rigged(
    octaspire_stdio_t const * const self);

octaspire_string_t *octaspire_stdio_read_line(octaspire_stdio_t *self, FILE *stream);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_stdio.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_input.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_INPUT_H
#define OCTASPIRE_INPUT_H


#ifdef __cplusplus
extern "C"       {
#endif

typedef struct octaspire_input_t octaspire_input_t;

octaspire_input_t *octaspire_input_new_from_c_string(
    char const * const str,
    octaspire_allocator_t *allocator);

octaspire_input_t *octaspire_input_new_from_buffer(
    char const * const buffer,
    size_t const lengthInOctets,
    octaspire_allocator_t *allocator);

octaspire_input_t *octaspire_input_new_from_path(
    char const * const path,
    octaspire_allocator_t *octaspireAllocator,
    octaspire_stdio_t *octaspireStdio);

void octaspire_input_release(octaspire_input_t *self);

size_t octaspire_input_get_length_in_ucs_characters(octaspire_input_t const * const self);

void   octaspire_input_clear(octaspire_input_t *self);

void   octaspire_input_rewind(octaspire_input_t *self);

uint32_t octaspire_input_peek_next_ucs_character(octaspire_input_t *self);
uint32_t octaspire_input_peek_next_next_ucs_character(octaspire_input_t *self);

bool octaspire_input_pop_next_ucs_character(octaspire_input_t *self);

bool octaspire_input_is_good(octaspire_input_t const * const self);

bool octaspire_input_push_back_from_string(
    octaspire_input_t * const self,
    octaspire_string_t const * const str);

bool octaspire_input_push_back_from_c_string(octaspire_input_t * const self, char const * const str);

size_t octaspire_input_get_line_number(octaspire_input_t const * const self);
size_t octaspire_input_get_column_number(octaspire_input_t const * const self);
size_t octaspire_input_get_ucs_character_index(octaspire_input_t const * const self);

void octaspire_input_print(octaspire_input_t const * const self);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_input.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_map.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_MAP_H
#define OCTASPIRE_MAP_H


#ifdef __cplusplus
extern "C"       {
#endif

// Hash map element
typedef struct octaspire_map_element_t octaspire_map_element_t;

octaspire_map_element_t *octaspire_map_element_new(
    uint32_t const hash,
    size_t const keySizeInOctets,
    bool const keyIsPointer,
    void const * const key,
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    void const * const value,
    octaspire_allocator_t * const allocator);

void octaspire_map_element_release(octaspire_map_element_t *self);

uint32_t octaspire_map_element_get_hash(
    octaspire_map_element_t const * const self);

void *octaspire_map_element_get_key(
    octaspire_map_element_t const * const self);

octaspire_vector_t *octaspire_map_element_get_values(
    octaspire_map_element_t * const self);

void *octaspire_map_element_get_value(
    octaspire_map_element_t const * const self);

void const *octaspire_map_element_get_key_const(
    octaspire_map_element_t const * const self);

void const *octaspire_map_element_get_value_const(
    octaspire_map_element_t const * const self);


// Hash map
typedef struct octaspire_map_t octaspire_map_t;

typedef bool (*octaspire_map_key_compare_function_t)(
    void const * const key1,
    void const * const key2);

typedef uint32_t (*octaspire_map_key_hash_function_t)(
    void const * const key);

typedef void (*octaspire_map_element_callback_t)(
    void * element);

octaspire_map_t *octaspire_map_new(
    size_t const keySizeInOctets,
    bool const keyIsPointer,
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    octaspire_map_key_compare_function_t keyCompareFunction,
    octaspire_map_key_hash_function_t keyHashFunction,
    octaspire_map_element_callback_t keyReleaseCallback,
    octaspire_map_element_callback_t valueReleaseCallback,
    octaspire_allocator_t *allocator);

octaspire_map_t *octaspire_map_new_with_octaspire_string_keys(
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    octaspire_map_element_callback_t valueReleaseCallback,
    octaspire_allocator_t *allocator);

octaspire_map_t *octaspire_map_new_with_size_t_keys(
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    octaspire_map_element_callback_t valueReleaseCallback,
    octaspire_allocator_t *allocator);

void octaspire_map_release(octaspire_map_t *self);

bool octaspire_map_remove(
    octaspire_map_t *self,
    uint32_t const hash,
    void const * const key);

bool octaspire_map_clear(
    octaspire_map_t * const self);

bool octaspire_map_add_hash_map(
    octaspire_map_t * const self,
    octaspire_map_t * const other);

bool octaspire_map_put(
    octaspire_map_t *self,
    uint32_t const hash,
    void const * const key,
    void const * const value);

octaspire_map_element_t *octaspire_map_get(
    octaspire_map_t *self,
    uint32_t const hash,
    void const * const key);

octaspire_map_element_t const * octaspire_map_get_const(
    octaspire_map_t const * const self,
    uint32_t const hash,
    void const * const key);

bool octaspire_map_is_empty(
    octaspire_map_t const * const self);

size_t octaspire_map_get_number_of_elements(
    octaspire_map_t const * const self);

octaspire_map_element_t *octaspire_map_get_at_index(
    octaspire_map_t *self,
    ptrdiff_t const possiblyNegativeIndex);


typedef struct octaspire_map_element_iterator_t
{
    octaspire_map_t *hashMap;
    octaspire_map_element_t *element;
    size_t bucketIndex;
    size_t elementInsideBucketIndex;
}
octaspire_map_element_iterator_t;

octaspire_map_element_iterator_t octaspire_map_element_iterator_init(
    octaspire_map_t * const self);

bool octaspire_map_element_iterator_next(
    octaspire_map_element_iterator_t * const self);


typedef struct octaspire_map_element_const_iterator_t
{
    octaspire_map_t const *hashMap;
    octaspire_map_element_t const *element;
    size_t bucketIndex;
    size_t elementInsideBucketIndex;
}
octaspire_map_element_const_iterator_t;

octaspire_map_element_const_iterator_t
octaspire_map_element_const_iterator_init(
    octaspire_map_t const * const self);

bool octaspire_map_element_const_iterator_next(
    octaspire_map_element_const_iterator_t * const self);



uint32_t octaspire_map_helper_size_t_get_hash(
    size_t const value);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_map.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_helpers.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_HELPERS_H
#define OCTASPIRE_HELPERS_H


#ifdef __cplusplus
extern "C"       {
#endif

#define OCTASPIRE_HELPERS_UNUSED_PARAMETER(x) (void)(x)

bool  octaspire_helpers_test_bit(uint32_t const bitSet, size_t const index);

char *octaspire_helpers_path_to_buffer(
    char const * const path,
    size_t *octetsAllocated,
    octaspire_allocator_t *allocator,
    octaspire_stdio_t *stdio);

uint32_t octaspire_helpers_calculate_hash_for_size_t_argument(size_t const value);
uint32_t octaspire_helpers_calculate_hash_for_bool_argument(bool const value);
uint32_t octaspire_helpers_calculate_hash_for_int32_t_argument(int32_t const value);
uint32_t octaspire_helpers_calculate_hash_for_double_argument(double const value);
uint32_t octaspire_helpers_calculate_hash_for_void_pointer_argument(void const * const value);

uint32_t octaspire_helpers_calculate_hash_for_memory_buffer_argument(
    void const * const value,
    size_t const lengthInOctets);

size_t octaspire_helpers_character_digit_to_number(uint32_t const c);

size_t octaspire_helpers_min_size_t(size_t const a, size_t const b);
size_t octaspire_helpers_max_size_t(size_t const a, size_t const b);

void octaspire_helpers_verify_true(bool const condition);
void octaspire_helpers_verify_null(void const * const ptr);
void octaspire_helpers_verify_not_null(void const * const ptr);

void octaspire_helpers_verify_not_null_void_funptr_void_ptr_const(
        void (*ptr)(void * const));

float octaspire_helpers_maxf(float const a, float const b);
float octaspire_helpers_ceilf(float const value);

bool octaspire_helpers_is_even_size_t(size_t const value);
bool octaspire_helpers_is_odd_size_t( size_t const value);

uint8_t octaspire_helpers_get_char_or_default_from_buf(
    uint8_t const * const input,
    size_t const inLen,
    size_t const getAtIndex,
    uint8_t const defaultChar);

size_t octaspire_helpers_measure_length_of_last_line(
    octaspire_string_t const * const str);

octaspire_vector_t * octaspire_helpers_base64_decode(
    char const * const input,
    int32_t const inputLenOrNegativeToMeasure,
    octaspire_allocator_t * const allocator);

octaspire_string_t * octaspire_helpers_base64_encode(
    char const * const input,
    size_t const inLen,
    size_t const lineLen,
    octaspire_allocator_t * const allocator);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_helpers.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/core/octaspire_semver.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_SEMVER_H
#define OCTASPIRE_SEMVER_H



#ifdef __cplusplus
extern "C"       {
#endif

typedef enum octaspire_semver_pre_release_elem_type_t
{
    OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_UNKNOWN,
    OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_NUMERICAL,
    OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_LEXICAL
}
octaspire_semver_pre_release_elem_type_t;

typedef struct octaspire_semver_t octaspire_semver_t;

octaspire_semver_t *octaspire_semver_new(
    size_t                const         major,
    size_t                const         minor,
    size_t                const         patch,
    octaspire_vector_t    const * const preRelease,
    octaspire_vector_t    const * const buildMetadata,
    octaspire_allocator_t       * const allocator);

octaspire_semver_t *octaspire_semver_new_prerelease(
    size_t                const         major,
    size_t                const         minor,
    size_t                const         patch,
    octaspire_allocator_t       * const allocator,
    ...);

octaspire_semver_t *octaspire_semver_new_prerelease_va(
    size_t                const         major,
    size_t                const         minor,
    size_t                const         patch,
    octaspire_allocator_t       * const allocator,
    va_list                             preRelease);

void octaspire_semver_release(octaspire_semver_t *self);

bool octaspire_semver_add_prerelease(
    octaspire_semver_t * const self,
    char const * const preRelease);

bool octaspire_semver_add_prerelease_numerical(
    octaspire_semver_t * const self,
    size_t const preRelease);

bool octaspire_semver_remove_prerelease(
    octaspire_semver_t * const self,
    char const * const prerelease);

bool octaspire_semver_remove_prerelease_numerical(
    octaspire_semver_t * const self,
    size_t const prerelease);

octaspire_semver_pre_release_elem_type_t octaspire_semver_get_prerelease_at(
    octaspire_semver_t const * const self,
    size_t const index,
    size_t * outNumerical,
    char const ** outLexical);

bool octaspire_semver_add_buildmetadata(
    octaspire_semver_t * const self,
    char const * const buildMetaData);

octaspire_string_t * octaspire_semver_to_string(
    octaspire_semver_t const * const self);

int octaspire_semver_compare(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other);

bool octaspire_semver_is_smaller_than(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other);

bool octaspire_semver_is_smaller_or_equal_to(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other);

bool octaspire_semver_is_greater_than(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other);

bool octaspire_semver_is_greater_or_equal_to(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other);

bool octaspire_semver_is_equal_to(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other);

bool octaspire_semver_is_unequal_to(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other);

size_t octaspire_semver_get_num_pre_release_identifiers(
    octaspire_semver_t const * const self);

size_t octaspire_semver_get_num_build_metadata_identifiers(
    octaspire_semver_t const * const self);

bool octaspire_semver_add_or_subtract(
    octaspire_semver_t       * const self,
    octaspire_semver_t const * const other,
    bool                       const add);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/core/octaspire_semver.h
//////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef OCTASPIRE_CORE_AMALGAMATED_IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/external/jenkins_one_at_a_time.c
//////////////////////////////////////////////////////////////////////////////////////////////////
// Based on public domain code from:
// burtleburtle.net/bob/hash/doobs.html


uint32_t jenkins_one_at_a_time_hash(void const * const data, size_t const lengthInOctets)
{
    uint32_t hash = 0;

    for (size_t i = 0; i < lengthInOctets; ++i)
    {
        hash += ((uint8_t const * const)data)[i];
        hash += (hash << 10);
        hash ^= (hash >>  6);
    }

    hash += (hash <<  3);
    hash ^= (hash >> 11);
    hash += (hash << 15);

    return hash;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/external/jenkins_one_at_a_time.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_memory.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/


struct octaspire_allocator_t
{
    size_t                                               numberOfFutureAllocationsToBeRigged;
    size_t                                               bitIndex;
    uint32_t                                             bitQueue[20];
    octaspire_allocator_custom_malloc_function_t  customMallocFunction;
    octaspire_allocator_custom_free_function_t    customFreeFunction;
    octaspire_allocator_custom_realloc_function_t customReallocFunction;
};

octaspire_allocator_config_t octaspire_allocator_config_default(void)
{
    octaspire_allocator_config_t result =
    {
        .customMallocFunction  = 0,
        .customFreeFunction    = 0,
        .customReallocFunction = 0
    };

    return result;
}

octaspire_allocator_t *octaspire_allocator_new(
    octaspire_allocator_config_t const * config)
{
    octaspire_allocator_config_t defaultConfig = octaspire_allocator_config_default();

    if (!config)
    {
        config = &defaultConfig;
    }

    size_t const size = sizeof(octaspire_allocator_t);

    octaspire_allocator_t *self = malloc(size);

    if (!self)
    {
        return self;
    }

    memset(self, 0, size);

    self->numberOfFutureAllocationsToBeRigged = 0;
    self->bitIndex = 0;

    if (self->bitQueue != memset(self->bitQueue, 0, sizeof(self->bitQueue)))
    {
        abort();
    }

    self->customMallocFunction  = config->customMallocFunction;
    self->customFreeFunction    = config->customFreeFunction;
    self->customReallocFunction = config->customReallocFunction;

    return self;
}

void octaspire_allocator_release(octaspire_allocator_t *self)
{
    if (!self)
    {
        return;
    }

    free(self);
}

bool octaspire_allocator_private_test_bit(octaspire_allocator_t const * const self);

bool octaspire_allocator_private_test_bit(octaspire_allocator_t const * const self)
{
    size_t const arrayIndex = (size_t)((float)self->bitIndex / 32.0f);
    size_t const bitIndex   = self->bitIndex % 8;
    assert(bitIndex < 32);
    assert(arrayIndex < (sizeof(self->bitQueue) / sizeof(self->bitQueue[0])));
    return octaspire_helpers_test_bit(self->bitQueue[arrayIndex], bitIndex);
}

void *octaspire_allocator_malloc(
    octaspire_allocator_t *self,
    size_t const size)
{
    if (self->numberOfFutureAllocationsToBeRigged)
    {
        --(self->numberOfFutureAllocationsToBeRigged);

        if (!octaspire_allocator_private_test_bit(self))
        {
            ++(self->bitIndex);
            return 0;
        }

        ++(self->bitIndex);
    }

    assert(size);

    void * const result =
        self->customMallocFunction ? self->customMallocFunction(size) : malloc(size);

    if (!result)
    {
        return result;
    }

    if (!self->customMallocFunction)
    {
        if (result != memset(result, 0, size))
        {
            abort();
        }
    }

    return result;
}

void *octaspire_allocator_realloc(
    octaspire_allocator_t *self,
    void *ptr, size_t const size)
{
    if (self->numberOfFutureAllocationsToBeRigged)
    {
        --(self->numberOfFutureAllocationsToBeRigged);

        if (!octaspire_allocator_private_test_bit(self))
        {
            ++(self->bitIndex);
            return 0;
        }

        ++(self->bitIndex);
    }

    return self->customReallocFunction ? self->customReallocFunction(ptr, size) : realloc(ptr, size);
}

void octaspire_allocator_free(
    octaspire_allocator_t *self,
    void *ptr)
{
    assert(self);

    self->customFreeFunction ? self->customFreeFunction(ptr) : free(ptr);
}

void octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
    octaspire_allocator_t *self,
    size_t const count,
    uint32_t const bitQueue0)
{
    assert(count <= 32);
    self->numberOfFutureAllocationsToBeRigged = count;
    self->bitIndex  = 0;

    if (self->bitQueue != memset(self->bitQueue, 0, sizeof(self->bitQueue)))
    {
        abort();
    }

    self->bitQueue[0] = bitQueue0;
}

void octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged_when_larger_than_32(
    octaspire_allocator_t *self,
    size_t const count,
    uint32_t const bitQueue0,
    uint32_t const bitQueue1,
    uint32_t const bitQueue2,
    uint32_t const bitQueue3,
    uint32_t const bitQueue4,
    uint32_t const bitQueue5,
    uint32_t const bitQueue6,
    uint32_t const bitQueue7,
    uint32_t const bitQueue8,
    uint32_t const bitQueue9,
    uint32_t const bitQueue10,
    uint32_t const bitQueue11,
    uint32_t const bitQueue12,
    uint32_t const bitQueue13,
    uint32_t const bitQueue14,
    uint32_t const bitQueue15,
    uint32_t const bitQueue16,
    uint32_t const bitQueue17,
    uint32_t const bitQueue18,
    uint32_t const bitQueue19)
{
    assert(count <= 640);
    self->numberOfFutureAllocationsToBeRigged = count;
    self->bitIndex = 0;

    if (self->bitQueue != memset(self->bitQueue, 0, sizeof(self->bitQueue)))
    {
        abort();
    }

    self->bitQueue[0]  = bitQueue0;
    self->bitQueue[1]  = bitQueue1;
    self->bitQueue[2]  = bitQueue2;
    self->bitQueue[3]  = bitQueue3;
    self->bitQueue[4]  = bitQueue4;
    self->bitQueue[5]  = bitQueue5;
    self->bitQueue[6]  = bitQueue6;
    self->bitQueue[7]  = bitQueue7;
    self->bitQueue[8]  = bitQueue8;
    self->bitQueue[9]  = bitQueue9;
    self->bitQueue[10] = bitQueue10;
    self->bitQueue[11] = bitQueue11;
    self->bitQueue[12] = bitQueue12;
    self->bitQueue[13] = bitQueue13;
    self->bitQueue[14] = bitQueue14;
    self->bitQueue[15] = bitQueue15;
    self->bitQueue[16] = bitQueue16;
    self->bitQueue[17] = bitQueue17;
    self->bitQueue[18] = bitQueue18;
    self->bitQueue[19] = bitQueue19;
}

size_t octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
    octaspire_allocator_t const * const self)
{
    return self->numberOfFutureAllocationsToBeRigged;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_memory.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_helpers.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

bool octaspire_helpers_test_bit(uint32_t const bitSet, size_t const index)
{
    assert(index < 32);
    return bitSet & ((uint32_t)0x01 << index);
}

char *octaspire_helpers_path_to_buffer(
    char const * const path,
    size_t *octetsAllocated,
    octaspire_allocator_t *allocator,
    octaspire_stdio_t *stdio)
{
    *octetsAllocated = 0;
    FILE *f = fopen(path, "rb");

    if (!f)
    {
        return 0;
    }

    fseek(f, 0, SEEK_END);

    long const length = ftell(f);

    if (length <= 0)
    {
        fclose(f);
        f = 0;
        return 0;
    }

    fseek(f, 0, SEEK_SET);

    char *result = octaspire_allocator_malloc(allocator, sizeof(char) * (size_t)length);

    if (!result)
    {
        fclose(f);
        f = 0;
        return 0;
    }

    *octetsAllocated = (size_t)length;

    if (*octetsAllocated != octaspire_stdio_fread(stdio, result, sizeof(char), *octetsAllocated, f))
    {
        fclose(f);
        f = 0;
        octaspire_allocator_free(allocator, result);
        result = 0;
        *octetsAllocated = 0;
        return 0;
    }

    fclose(f);
    f = 0;

    return result;
}

uint32_t octaspire_helpers_calculate_hash_for_size_t_argument(size_t const value)
{
    return jenkins_one_at_a_time_hash(&value, sizeof(value));
}

uint32_t octaspire_helpers_calculate_hash_for_bool_argument(bool const value)
{
    return jenkins_one_at_a_time_hash(&value, sizeof(value));
}

uint32_t octaspire_helpers_calculate_hash_for_int32_t_argument(int32_t const value)
{
    return jenkins_one_at_a_time_hash(&value, sizeof(value));
}

uint32_t octaspire_helpers_calculate_hash_for_double_argument(double const value)
{
    return jenkins_one_at_a_time_hash(&value, sizeof(value));
}

uint32_t octaspire_helpers_calculate_hash_for_void_pointer_argument(void const * const value)
{
    return jenkins_one_at_a_time_hash(&value, sizeof(value));
}

uint32_t octaspire_helpers_calculate_hash_for_memory_buffer_argument(
    void const * const value,
    size_t const lengthInOctets)
{
    return jenkins_one_at_a_time_hash(value, lengthInOctets);
}

size_t octaspire_helpers_character_digit_to_number(uint32_t const c)
{
    return c - '0';
}

size_t octaspire_helpers_min_size_t(size_t const a, size_t const b)
{
    if (a < b)
    {
        return a;
    }

    return b;
}

size_t octaspire_helpers_max_size_t(size_t const a, size_t const b)
{
    if (a > b)
    {
        return a;
    }

    return b;
}

void octaspire_helpers_verify_true(bool const condition)
{
    if (!condition)
    {
        abort();
    }
}

void octaspire_helpers_verify_null(void const * const ptr)
{
    if (ptr)
    {
        abort();
    }
}

void octaspire_helpers_verify_not_null(void const * const ptr)
{
    if (!ptr)
    {
        abort();
    }
}

void octaspire_helpers_verify_not_null_void_funptr_void_ptr_const(
    void (*ptr)(void * const))
{
    if (!ptr)
    {
        abort();
    }
}

float octaspire_helpers_maxf(float const a, float const b)
{
    if (a > b)
    {
        return a;
    }

    return b;
}

float octaspire_helpers_ceilf(float const value)
{
    return (float)ceil((double)value);
}

bool octaspire_helpers_is_even_size_t(size_t const value)
{
    return (value % 2 == 0);
}

bool octaspire_helpers_is_odd_size_t( size_t const value)
{
    return (!octaspire_helpers_is_even_size_t(value));
}

static uint8_t const octaspire_helpers_base64_private_bad_num = 64;

static uint8_t octaspire_helpers_base64_private_base64_char_into_num(char const c)
{
    if (c >= 'A' && c <= 'Z')
    {
        return (uint8_t)c - 65;
    }

    if (c >= 'a' && c <= 'z')
    {
        return 26 + ((uint8_t)c - 97);
    }

    if (c >= '0' && c <= '9')
    {
        return 52 + ((uint8_t)c - 48);
    }

    if (c == '+')
    {
        return 62;
    }

    if (c == '/')
    {
        return 63;
    }

    return octaspire_helpers_base64_private_bad_num;
}

uint8_t octaspire_helpers_get_char_or_default_from_buf(
    uint8_t const * const input,
    size_t const inLen,
    size_t const getAtIndex,
    uint8_t const defaultChar)
{
    if (!input || getAtIndex >= inLen)
    {
        return defaultChar;
    }

    return input[getAtIndex];
}

size_t octaspire_helpers_measure_length_of_last_line(
    octaspire_string_t const * const str)
{
    size_t result = 0;
    while (result < octaspire_string_get_length_in_ucs_characters(str))
    {
        ++result;
        if (octaspire_string_get_ucs_character_at_index(
            str,
            -(ptrdiff_t)result) == '\n')
        {
            return result;
        }
    }

    return result;
}

static size_t octaspire_helpers_base64_private_skip_whitespace(
    char const * const input,
    size_t const inLen,
    size_t index)
{
    while (index < inLen && isspace((int)input[index]))
    {
        ++index;
    }

    return index;
}

octaspire_vector_t * octaspire_helpers_base64_decode(
    char const * const input,
    int32_t const inputLenOrNegativeToMeasure,
    octaspire_allocator_t * const allocator)
{
    if (inputLenOrNegativeToMeasure < 2)
    {
        return 0;
    }

    size_t numPadding = 0;

    octaspire_vector_t * result = octaspire_vector_new(
        sizeof(char),
        false,
        0,
        allocator);

    if (!result)
    {
        return result;
    }

    // Negative length means that the length must be measured here.
    size_t const inLen = (inputLenOrNegativeToMeasure < 0)
        ? strlen(input)
        : (size_t)inputLenOrNegativeToMeasure;

    uint32_t indices[4] = {0, 0, 0, 0};
    size_t   numIndices = 0;

    for (size_t i = 0; i <= inLen; /*NOP*/)
    {
        if (numIndices == 4)
        {
            // Generate the number with 24 bits.
            uint32_t const num24bits =
                ((indices[0] & 63) << (24 -  6)) +
                ((indices[1] & 63) << (24 - 12)) +
                ((indices[2] & 63) << (24 - 18)) +
                ( indices[3] & 63);

            // Break the number with 24 bits into the three original octets
            // and save those into the result.

            for (size_t j = 0; j < 3; ++j)
            {
                char octet = (char)((num24bits >> (16 - (j * 8))) & 0xFF);
                if (!octaspire_vector_push_back_element(result, &octet))
                {
                    octaspire_vector_release(result);
                    result = 0;
                    return result;
                }
            }

            numIndices = 0;
        }

        i = octaspire_helpers_base64_private_skip_whitespace(input, inLen, i);

        if (i >= inLen)
        {
            break;
        }

        char currentChar = input[i];

        if (currentChar == '=')
        {
            ++numPadding;
            currentChar = 'A';
        }

        uint32_t const index =
            octaspire_helpers_base64_private_base64_char_into_num(currentChar);

        if (index == octaspire_helpers_base64_private_bad_num)
        {
            octaspire_vector_release(result);
            result = 0;
            return result;
        }

        indices[numIndices] = index;
        ++numIndices;
        ++i;
    }

    if (numIndices != 0 || numPadding >= octaspire_vector_get_length(result))
    {
        octaspire_vector_release(result);
        result = 0;
        return result;
    }

    for (size_t i = 0; i < numPadding; ++i)
    {
        while (isspace(
            (int)*(char const * const)
            octaspire_vector_peek_back_element_const(result)))
        {
            if (!octaspire_vector_pop_back_element(result))
            {
                octaspire_vector_release(result);
                result = 0;
                return result;
            }
        }

        if (!octaspire_vector_pop_back_element(result))
        {
            octaspire_vector_release(result);
            result = 0;
            return result;
        }
    }

    return result;
}

octaspire_string_t * octaspire_helpers_base64_encode(
    char const * const input,
    size_t const inLen,
    size_t const lineLen,
    octaspire_allocator_t * const allocator)
{
    char const * const base64chars =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    octaspire_string_t * result = octaspire_string_new(
        "",
        allocator);

    if (!result)
    {
        return result;
    }

    size_t numPadding = inLen % 3;

    if (numPadding)
    {
        numPadding = 3 - numPadding;
    }

    size_t currentLineLen = 0;

    for (size_t i = 0; i < inLen; i += 3)
    {
        // Three octets of input is converted into a number with 24 bits.
        // Any missing characters are replaced with the NULL char.

        uint32_t num24bits = 0;

        for (size_t j = 0; j < 3; ++j)
        {
            uint32_t const val = (uint32_t)octaspire_helpers_get_char_or_default_from_buf(
                (uint8_t const * const)input,
                (size_t)inLen,
                i + j,
                '\0');

            num24bits += (val << (16 - (j * 8)));
        }

        // This 24 bit number is broken down into four 6 bit numbers.
        // Number 63 has bit pattern 111111.
        uint8_t n[4];
        n[0] = (num24bits >> (24 -  6)) & 63;
        n[1] = (num24bits >> (24 - 12)) & 63;
        n[2] = (num24bits >> (24 - 18)) & 63;
        n[3] = (num24bits             ) & 63;

        // Four six bit numbers are used as indices into the
        // array of base64 characters.
        for (size_t j = 0; j < 4; ++j)
        {
            if (!octaspire_string_push_back_ucs_character(
                result,
                (uint32_t)base64chars[n[j]]))
            {
                octaspire_string_release(result);
                result = 0;
                return result;
            }

            ++currentLineLen;

            if (lineLen && currentLineLen >= lineLen)
            {
                if (!octaspire_string_push_back_ucs_character(
                        result,
                        '\n'))
                {
                    octaspire_string_release(result);
                    result = 0;
                    return result;
                }

                currentLineLen = 0;
            }
        }
    }

    if (numPadding)
    {
        size_t numZerosRemoved = 0;

        for (size_t i = 0;
            i < octaspire_string_get_length_in_ucs_characters(result);
            ++i)
        {
            if (octaspire_string_get_ucs_character_at_index(result, -1) != '\n')
            {
                ++numZerosRemoved;
                --currentLineLen;
            }
            else
            {
                currentLineLen = octaspire_helpers_measure_length_of_last_line(result);
            }

            if (!octaspire_string_pop_back_ucs_character(result))
            {
                octaspire_string_release(result);
                result = 0;
                return result;
            }

            if (numZerosRemoved == numPadding)
            {
                break;
            }
        }
    }

    for (size_t i = 0; i < numPadding; ++i)
    {
        if (lineLen && currentLineLen >= lineLen)
        {
            if (!octaspire_string_push_back_ucs_character(
                    result,
                    '\n'))
            {
                octaspire_string_release(result);
                result = 0;
                return result;
            }

            currentLineLen = 0;
        }

        if (!octaspire_string_push_back_ucs_character(
                result,
                (uint32_t)'='))
        {
            octaspire_string_release(result);
            result = 0;

            return result;
        }

        ++currentLineLen;
    }

    return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_helpers.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_utf8.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

typedef enum octaspire_utf8_character_range_t
{
    OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST,
    OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND,
    OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD,
    OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH,
    OCTASPIRE_UTF8_CHARACTER_RANGE_ILLEGAL
}
octaspire_utf8_character_range_t;

static octaspire_utf8_character_range_t octaspire_utf8_private_rangeof(uint32_t const character);
static uint32_t octaspire_utf8_private_high_order_bits  (octaspire_utf8_character_range_t const range);

static int octaspire_utf8_private_octets_in_next(char const * const text, size_t const textLengthInOctets);

static int octaspire_utf8_private_octets_in_next_from_buffer(
    char const * const buffer,
    size_t const lengthInOctets,
    size_t const currentIndex);

octaspire_utf8_decode_status_t octaspire_utf8_private_decode_helper(
    char const * const buffer,
    size_t const numOctetsNeeded,
    size_t const numOctetsAvailable,
    uint32_t * const result);

static uint32_t const octaspire_utf8_private_range1_end   = ((uint32_t)0x007F);

static uint32_t const octaspire_utf8_private_range2_start = ((uint32_t)0x0080);
static uint32_t const octaspire_utf8_private_range2_end   = ((uint32_t)0x07FF);

static uint32_t const octaspire_utf8_private_range3_start = ((uint32_t)0x0800);
static uint32_t const octaspire_utf8_private_range3_end   = ((uint32_t)0xFFFF);

static uint32_t const octaspire_utf8_private_range4_start = ((uint32_t)0x00010000);
static uint32_t const octaspire_utf8_private_range4_end   = ((uint32_t)0x0010FFFF);

static octaspire_utf8_character_range_t octaspire_utf8_private_rangeof(uint32_t const character)
{
    if (character <= octaspire_utf8_private_range1_end)
        return OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST;

    if (character >= octaspire_utf8_private_range2_start && character <= octaspire_utf8_private_range2_end)
        return OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND;

    if (character >= octaspire_utf8_private_range3_start && character <= octaspire_utf8_private_range3_end)
        return OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD;

    if (character >= octaspire_utf8_private_range4_start && character <= octaspire_utf8_private_range4_end)
        return OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH;

    return OCTASPIRE_UTF8_CHARACTER_RANGE_ILLEGAL;
}

static uint32_t octaspire_utf8_private_high_order_bits(octaspire_utf8_character_range_t const range)
{
    if (range == OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST)
        return 0;

    if (range == OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND)
        return 0xC080;

    if (range == OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD)
        return 0xE08080;

    if (range == OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH)
        return 0xF0808080;

    // Error, illegal range. Should there be another/better way of reporting it?
    return ((uint32_t)0xFFFFFFFF);
}

octaspire_utf8_encode_status_t octaspire_utf8_encode_character(
    uint32_t const character,
    octaspire_utf8_character_t * const result)
{
    memset(result->octets, 0, 4);
    result->numoctets = 0;

    // TODO XXX are the upper and lower bounds inclusive or not?
    // Check that and remove the equality operator part if necessary.
    if (character >= 0xD800 && character <= 0xDFFF)
    {
        return OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER;
    }

    octaspire_utf8_character_range_t const range = octaspire_utf8_private_rangeof(character);

    uint32_t bitset = octaspire_utf8_private_high_order_bits(range);

    switch (range)
    {
        case OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST:
        {
            uint32_t const mask = 0x7F;       // Least significant 7 bits on
            bitset |= ((bitset & ~mask) | (character & mask));

            result->numoctets = 1;
        }
        break;

        case OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND:
        {
            uint32_t const mask = 0x3F;     // Least significant 6 bits on
            bitset |= ((bitset & ~mask) | (character & mask));

            uint32_t const bitsetMask = 0x1F00; // Least significant bits 8,9,10,11,12 on
            uint32_t const charMask   = 0x7C0;  // Least significant bits 6,7, 8, 9,10 on
            bitset |= ((bitset & ~bitsetMask) | (((character & charMask) << 2) & bitsetMask));

            result->numoctets = 2;
        }
        break;

        case OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD:
        {
            uint32_t mask = 0x3F;       // Least significant 6 bits on
            bitset |= ((bitset & ~mask) | (character & mask));

            uint32_t bitsetMask = 0x3F00; // Least significant bits 8,9,10,11,12,13 on
            uint32_t charMask   = 0xFC0;  // Least significant bits 6,7, 8, 9,10,11 on
            bitset |= ((bitset & ~bitsetMask) | (((character & charMask) << 2) & bitsetMask));

            bitsetMask = 0xF0000; // Least significant bits 16,17,18,19 on
            charMask   = 0xF000;  // Least significant bits 12,13,14,15 on
            bitset |= ((bitset & ~bitsetMask) | (((character & charMask) << 4) & bitsetMask));

            result->numoctets = 3;
        }
        break;

        case OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH:
        {
            uint32_t mask = 0x3F;       // Least significant 6 bits on
            bitset |= ((bitset & ~mask) | (character & mask));

            uint32_t bitsetMask = 0x3F00; // Least significant bits 8,9,10,11,12,13 on
            uint32_t charMask   = 0xFC0;  // Least significant bits 6,7, 8, 9,10,11 on
            bitset |= ((bitset & ~bitsetMask) | (((character & charMask) << 2) & bitsetMask));

            bitsetMask = 0x3F0000; // Least significant bits 16,17,18,19,20,21 on
            charMask   = 0x3F000; // Least significant bits 12,13,14,15,16,17 on
            bitset |= ((bitset & ~bitsetMask) | (((character & charMask) << 4) & bitsetMask));

            bitsetMask = 0x7000000; // Least significant bits 24,25,26 on
            charMask   = 0x1C0000;  // Most significant bits 18,19,20 on
            bitset |= ((bitset & ~bitsetMask) | (((character & charMask) << 6) & bitsetMask));

            result->numoctets = 4;
        }
        break;

        case OCTASPIRE_UTF8_CHARACTER_RANGE_ILLEGAL:
        {
            return OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER;
        }
    }

    uint8_t const resultMask = 0xFF; // First 8 bits on
    uint32_t      inputMask  = 0xFF; // Least significant 8 bits on
    result->octets[3] = ((result->octets[3] & ~resultMask) | (bitset & inputMask));

    inputMask  = 0x0000FF00; // Lest significant 8 bits off then 8 bits on
    result->octets[2] = ((result->octets[2] & ~resultMask) | ((bitset & inputMask) >> 8));

    inputMask  = 0x00FF0000; // Least significant 16 bits off then 8 bits on
    result->octets[1] = ((result->octets[1] & ~resultMask) | ((bitset & inputMask) >> 16));

    inputMask  = 0xFF000000; // Least significant 24 bits off then 8 bits on
    result->octets[0] = ((result->octets[0] & ~resultMask) | ((bitset & inputMask) >> 24));

    return OCTASPIRE_UTF8_ENCODE_STATUS_OK;
}

static int octaspire_utf8_private_octets_in_next(char const * const text, size_t const textLengthInOctets)
{
    size_t lengthInOctets = 0;

    if (!text || textLengthInOctets == 0 || text[0] == '\0')
    {
        return 0;
    }

    for (size_t i = 0; i < octaspire_helpers_min_size_t(4, textLengthInOctets); ++i)
    {
        if (text[i] == '\0')
        {
            break;
        }
        else
        {
            ++lengthInOctets;
        }
    }

    return octaspire_utf8_private_octets_in_next_from_buffer(text, lengthInOctets, 0);
}

static int octaspire_utf8_private_octets_in_next_from_buffer(
    char const * const buffer,
    size_t const lengthInOctets,
    size_t const currentIndex)
{
    if (!buffer || currentIndex >= lengthInOctets)
        return 0;

    size_t const octetsAvailable = lengthInOctets - currentIndex;

    uint8_t const octet0 = buffer[currentIndex];
    if (((octet0 >> 7) & 1) == 0) // If 0xxxxxx
    {
        return 1;
    }

    if (((octet0 >> 5) & 7) == 6) // If 110xxxxx
    {
        if (octetsAvailable < 2)
        {
            return -1;
        }

        uint8_t const octet1 = buffer[currentIndex + 1];
        if (((octet1 >> 6) & 3) == 2) // If 10xxxxxx
        {
            return 2;
        }

        return -1;
    }

    if (((octet0 >> 4) & 15) == 14) // If 1110xxxx
    {
        if (octetsAvailable < 3)
        {
            return -1;
        }

        uint8_t const octet1 = buffer[currentIndex + 1];
        uint8_t const octet2 = buffer[currentIndex + 2];

        if ((((octet1 >> 6) & 3) == 2) && (((octet2 >> 6) & 3) == 2)) // If 10xxxxxx && 10xxxxxx
        {
            return 3;
        }

        return -1;
    }

    if (((octet0 >> 3) & 31) == 30) // If 11110xxx
    {
        if (octetsAvailable < 4)
        {
            return -1;
        }

        uint8_t const octet1 = buffer[currentIndex + 1];
        uint8_t const octet2 = buffer[currentIndex + 2];
        uint8_t const octet3 = buffer[currentIndex + 3];

        // If 10xxxxxx && 10xxxxxx && 10xxxxxx
        if ((((octet1 >> 6) & 3) == 2) && (((octet2 >> 6) & 3) == 2) && (((octet3 >> 6) & 3) == 2))
        {
            return 4;
        }

        return -1;
    }

    return -1;
}

octaspire_utf8_decode_status_t octaspire_utf8_private_decode_helper(
    char const * const buffer,
    size_t const numOctetsNeeded,
    size_t const numOctetsAvailable,
    uint32_t * const result)
{
    assert(numOctetsNeeded <= 4);

    if (numOctetsNeeded > numOctetsAvailable || !buffer)
    {
        return OCTASPIRE_UTF8_DECODE_STATUS_INPUT_NOT_ENOUGH_OCTETS_AVAILABLE;
    }

    switch (numOctetsNeeded)
    {
        case 1:
        {
            // 0xxxxxxx

            uint32_t const resultMask = 0x7F; // 7 least significant bits on
            uint8_t  const inputMask  = 0x7F; // 7 least significant bits on
            *result = 0;
            *result |= ((*result & ~resultMask) | (buffer[0] & inputMask));
        }
        break;

        case 2:
        {
            // 110xxxxx 10xxxxxx

            uint32_t resultMask = 0x7C0; // 6 least significant bits off, then 5 on
            uint8_t  inputMask  = 0x1F;  // 5 least significant bits on
            *result = 0;
            *result |= ((*result & ~resultMask) | ((buffer[0] & inputMask) << 6));

            resultMask = 0x3F; // 6 least significant bits on
            inputMask  = 0x3F; // 6 least significant bits on
            *result |= ((*result & ~resultMask) | (buffer[1] & inputMask));

            if (*result <= 0x7F)
            {
                return OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER;
            }
        }
        break;

        case 3:
        {
            // 1110xxxx 10xxxxxx 10xxxxxx

            uint32_t resultMask = 0xF000; // 12 least significant bits off, then 4 on
            uint8_t  inputMask  = 0xF;    // 4 least significant bits on
            *result = 0;
            *result |= ((*result & ~resultMask) | ((buffer[0] & inputMask) << 12));

            resultMask = 0xFC0; // 6 least significant bits off, then 6 on
            inputMask  = 0x3F;  // 6 least significant bits on
            *result |= ((*result & ~resultMask) | ((buffer[1] & inputMask) << 6));

            resultMask = 0x3F; // 6 least significant bits on
            inputMask  = 0x3F; // 6 least significant bits on
            *result |= ((*result & ~resultMask) | (buffer[2] & inputMask));

            if (*result <= 2047)
            {
                return OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER;
            }
        }
        break;

        case 4:
        {
            // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

            uint32_t resultMask = 0x1C0000; // 18 least significant bits off, then 3 on
            uint8_t  inputMask  = 0x7;      // 3 least significant bits on
            *result = 0;
            *result |= ((*result & ~resultMask) | ((buffer[0] & inputMask) << 18));

            resultMask = 0x3F000; // 12 least significant bits off, then 6 on
            inputMask  = 0x3F;    // 6 least significant bits on
            *result |= ((*result & ~resultMask) | ((buffer[1] & inputMask) << 12));

            resultMask = 0xFC0; // 6 least significant bits off, then 6 on
            inputMask  = 0x3F;  // 6 least significant bits on
            *result |= ((*result & ~resultMask) | ((buffer[2] & inputMask) << 6));

            resultMask = 0x3F; // 6 least significant bits on
            inputMask  = 0x3F; // 6 least significant bits on
            *result |= ((*result & ~resultMask) | (buffer[3] & inputMask));

            if (*result <= 65535)
            {
                return OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER;
            }
        }
        break;
    }

    return OCTASPIRE_UTF8_DECODE_STATUS_OK;
}

octaspire_utf8_decode_status_t octaspire_utf8_decode_character(
    char const * const text,
    size_t const textLengthInOctets,
    uint32_t *result,
    int *numoctets)
{
    *result = 0;
    *numoctets = octaspire_utf8_private_octets_in_next(text, textLengthInOctets);

    size_t const numoctetsRef = *numoctets;

    if (numoctetsRef <= 0 || numoctetsRef > 4)
    {
        if (!text || textLengthInOctets == 0 || text[0] == '\0')
        {
            return OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL;
        }

        return OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS;
    }

    if (numoctetsRef > textLengthInOctets)
    {
        return OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS;
    }

    return octaspire_utf8_private_decode_helper(text, numoctetsRef, numoctetsRef, result);
}

octaspire_utf8_decode_status_t octaspire_utf8_decode_character_from_buffer(
    char const * const buffer,
    size_t const bufferLengthInOctets,
    size_t const currentIndex,
    uint32_t *result,
    int *numoctets)
{
    if (!buffer)
    {
        *result = 0;
        *numoctets = 0;
        return OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL;
    }

    *result = 0;

    *numoctets =
        octaspire_utf8_private_octets_in_next_from_buffer(buffer, bufferLengthInOctets, currentIndex);

    if (*numoctets <= 0 || *numoctets > 4)
    {
        return OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS;
    }

    size_t numOctetsAvailable = 0;

    if (bufferLengthInOctets > currentIndex)
    {
        numOctetsAvailable = bufferLengthInOctets - currentIndex;
    }

    return octaspire_utf8_private_decode_helper(buffer, (size_t)*numoctets, numOctetsAvailable, result);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_utf8.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_vector.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/


struct octaspire_vector_t
{
    void   *elements;
    size_t  elementSize;
    size_t  numElements;
    size_t  numAllocated;
    size_t  compactingLimitForAllocated;
    octaspire_vector_element_callback_t elementReleaseCallback;
    octaspire_allocator_t *allocator;
    bool    elementIsPointer;
    char    padding[7];
};

static size_t const OCTASPIRE_VECTOR_INITIAL_SIZE = 1;

static void *octaspire_vector_private_index_to_pointer(
    octaspire_vector_t * const self,
    size_t const index)
{
    assert(self->elements);
    assert(index < self->numAllocated);
    return ((char*)self->elements) + (self->elementSize * index);
}

static void const *octaspire_vector_private_index_to_pointer_const(
    octaspire_vector_t const * const self,
    size_t const index)
{
    return ((char const * const)self->elements) + (self->elementSize * index);
}

static bool octaspire_vector_private_grow(
    octaspire_vector_t *self,
    float const factor)
{
    size_t const newNumAllocated = (size_t)(self->numAllocated * octaspire_helpers_maxf(2, factor));

    void *newElements = octaspire_allocator_realloc(
        self->allocator,
        self->elements,
        self->elementSize * newNumAllocated);

    if (!newElements)
    {
        return false;
    }

    self->elements     = newElements;
    self->numAllocated = newNumAllocated;

    // Initialize new elements to zero.
    for (size_t i = self->numElements; i < self->numAllocated; ++i)
    {
        void *s = ((char*)self->elements) + (i * self->elementSize);

        if (s != memset(s, 0, self->elementSize))
        {
            abort();
        }
    }

    return true;
}

static bool octaspire_vector_private_compact(
    octaspire_vector_t *self)
{
    if (self->numAllocated <= 1)
    {
        return true;
    }

    if (self->numAllocated <= (self->numElements * 3))
    {
        return true;
    }

    if (self->numAllocated <= self->compactingLimitForAllocated)
    {
        return true;
    }

    size_t newNumAllocated =
        self->numElements ? self->numElements : OCTASPIRE_VECTOR_INITIAL_SIZE;

    if (newNumAllocated < self->compactingLimitForAllocated)
    {
        newNumAllocated = self->compactingLimitForAllocated;
    }

    void *newElements = octaspire_allocator_realloc(
        self->allocator,
        self->elements,
        self->elementSize * newNumAllocated);

    if (!newElements)
    {
        return false;
    }

    self->elements     = newElements;
    self->numAllocated = newNumAllocated;

    return true;
}

octaspire_vector_t *octaspire_vector_new(
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_vector_element_callback_t elementReleaseCallback,
    octaspire_allocator_t *allocator)
{
    return octaspire_vector_new_with_preallocated_elements(
        elementSize,
        elementIsPointer,
        OCTASPIRE_VECTOR_INITIAL_SIZE,
        elementReleaseCallback,
        allocator);
}

octaspire_vector_t *octaspire_vector_new_with_preallocated_elements(
    size_t const elementSize,
    bool const elementIsPointer,
    size_t const numElementsPreAllocated,
    octaspire_vector_element_callback_t elementReleaseCallback,
    octaspire_allocator_t *allocator)
{
    octaspire_vector_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_vector_t));

    if (!self)
    {
        return self;
    }

    self->allocator        = allocator;
    self->elementSize      = elementSize ? elementSize : sizeof(char);
    self->elementIsPointer = elementIsPointer;
    self->numElements      = 0;

    self->numAllocated = numElementsPreAllocated ?
        numElementsPreAllocated : OCTASPIRE_VECTOR_INITIAL_SIZE;

    self->compactingLimitForAllocated = self->numAllocated;

    self->elements     =
        octaspire_allocator_malloc(self->allocator, self->elementSize * self->numAllocated);

    if (!self->elements)
    {
        octaspire_vector_release(self);
        self = 0;
        return 0;
    }

    self->elementReleaseCallback  = elementReleaseCallback;

    return self;
}

octaspire_vector_t *octaspire_vector_new_shallow_copy(
    octaspire_vector_t * other,
    octaspire_allocator_t * allocator)
{
    octaspire_vector_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_vector_t));

    if (!self)
    {
        return self;
    }

    self->allocator    = allocator;

    self->elementSize  = octaspire_vector_get_element_size_in_octets(other);
    self->numElements  = octaspire_vector_get_length(other);
    self->numAllocated = self->numElements;
    self->compactingLimitForAllocated = other->compactingLimitForAllocated;

    // This is here to prevent assert on octaspire_allocator_malloc
    // on 0 size of allocation. Should that check be removed, or this?
    if (self->numAllocated == 0)
    {
        self->numAllocated = 1;
    }

    self->elements     = octaspire_allocator_malloc(
        self->allocator,
        self->elementSize * self->numAllocated);

    if (!self->elements)
    {
        octaspire_vector_release(self);
        self = 0;
        return 0;
    }

    self->elementReleaseCallback =
        octaspire_vector_get_element_release_callback_const(other);

    if (memcpy(
        self->elements,
        octaspire_vector_get_element_at_const(other, 0),
        (self->numElements * self->elementSize)) != self->elements)
    {
        abort();
    }

    return self;
}

void octaspire_vector_release(octaspire_vector_t *self)
{
    if (!self)
    {
        return;
    }

    if (self->elementReleaseCallback)
    {
        octaspire_vector_for_each(self, self->elementReleaseCallback);
    }

    assert(self->allocator);

    octaspire_allocator_free(self->allocator, self->elements);
    octaspire_allocator_free(self->allocator, self);
}

// Vector can never be compacted smaller than this limit, if set
void octaspire_vector_set_compacting_limit_for_preallocated_elements(
    octaspire_vector_t * const self,
    size_t const numPreAllocatedElementsAtLeastPresentAtAnyMoment)
{
    self->compactingLimitForAllocated = numPreAllocatedElementsAtLeastPresentAtAnyMoment;
}

size_t octaspire_vector_get_length(
    octaspire_vector_t const * const self)
{
    assert(self);
    return self->numElements;
}

size_t octaspire_vector_get_length_in_octets(
    octaspire_vector_t const * const self)
{
    return self->numElements * self->elementSize;
}

bool octaspire_vector_is_empty(
    octaspire_vector_t const * const self)
{
    return (self->numElements == 0);
}

typedef struct octaspire_vector_private_index_t
{
    size_t index;
    bool   isValid;
    char   padding[7];

} octaspire_vector_private_index_t;

static octaspire_vector_private_index_t octaspire_vector_private_is_index_valid(
    octaspire_vector_t const * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_vector_private_index_t result = {.isValid=true, .index=(size_t)possiblyNegativeIndex};

    size_t const selfLen = octaspire_vector_get_length(self);

    if (possiblyNegativeIndex < 0)
    {
        ptrdiff_t const tmpIndex = (ptrdiff_t)selfLen + possiblyNegativeIndex;

        if (tmpIndex >= 0 && (size_t)tmpIndex < selfLen)
        {
            result.index = (size_t)tmpIndex;
            return result;
        }
    }

    if ((size_t)possiblyNegativeIndex < selfLen)
    {
        return result;
    }

    result.isValid = false;
    result.index   = 0;
    return result;
}

bool octaspire_vector_remove_element_at(
    octaspire_vector_t * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_vector_private_index_t const realIndex =
        octaspire_vector_private_is_index_valid(self, possiblyNegativeIndex);

    if (!realIndex.isValid)
    {
        return false;
    }

    if (self->elementReleaseCallback)
    {
        if (self->elementIsPointer)
        {
            void* const * const tmpPtr =
                octaspire_vector_private_index_to_pointer(
                    self,
                    realIndex.index);

            octaspire_helpers_verify_not_null(tmpPtr);

            self->elementReleaseCallback(*tmpPtr);
        }
        else
        {
            self->elementReleaseCallback(
                octaspire_vector_private_index_to_pointer(self, realIndex.index));
        }
    }

    if ((realIndex.index + 1) != self->numElements)
    {
        size_t const numOctetsToMove = (self->numElements - realIndex.index - 1) * self->elementSize;
        void *moveTarget = octaspire_vector_private_index_to_pointer(self, realIndex.index);
        void *moveSource = octaspire_vector_private_index_to_pointer(self, realIndex.index + 1);

        if (moveTarget != memmove(moveTarget, moveSource, numOctetsToMove))
        {
            abort();
        }
    }

    --(self->numElements);

    return true;
}

void *octaspire_vector_get_element_at(
    octaspire_vector_t * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    void * const result =
        octaspire_vector_get_raw_data_for_element_at(
            self,
            possiblyNegativeIndex);

    if (!result)
    {
        return result;
    }

    if (self->elementIsPointer)
    {
        return *(void**)result;
    }

    return result;
}

void const *octaspire_vector_get_element_at_const(
    octaspire_vector_t const * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    void const * const result =
        octaspire_vector_get_raw_data_for_element_at_const(
            self,
            possiblyNegativeIndex);

    if (!result)
    {
        return result;
    }

    if (self->elementIsPointer)
    {
        octaspire_helpers_verify_not_null(result);
        return *(void const * const *)result;
    }

    return result;
}

void *octaspire_vector_get_raw_data_for_element_at(
    octaspire_vector_t * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_vector_private_index_t const realIndex =
        octaspire_vector_private_is_index_valid(self, possiblyNegativeIndex);

    if (!realIndex.isValid)
    {
        return 0;
    }

    return octaspire_vector_private_index_to_pointer(self, realIndex.index);
}

void const *octaspire_vector_get_raw_data_for_element_at_const(
    octaspire_vector_t const * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_vector_private_index_t const realIndex =
        octaspire_vector_private_is_index_valid(self, possiblyNegativeIndex);

    if (!realIndex.isValid)
    {
        return 0;
    }

    return octaspire_vector_private_index_to_pointer_const(
        self,
        realIndex.index);
}

size_t octaspire_vector_get_element_size_in_octets(
    octaspire_vector_t const * const self)
{
    return self->elementSize;
}

bool octaspire_vector_insert_element_before_the_element_at_index(
    octaspire_vector_t *self,
    void const *element,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_vector_private_index_t const realIndex =
        octaspire_vector_private_is_index_valid(
            self,
            possiblyNegativeIndex);

    if (!realIndex.isValid)
    {
        return false;
    }

    assert(realIndex.index < octaspire_vector_get_length(self));

    // Make room for the new element
    if (self->numElements >= self->numAllocated)
    {
        if (!octaspire_vector_private_grow(self, 2))
        {
            return false;
        }
    }

    size_t const numOctetsToMove = (self->numElements - realIndex.index) * self->elementSize;
    void *moveTarget = octaspire_vector_private_index_to_pointer(self, realIndex.index + 1);
    void *moveSource = octaspire_vector_private_index_to_pointer(self, realIndex.index);

    if (moveTarget != memmove(moveTarget, moveSource, numOctetsToMove))
    {
        abort();
    }

    // Copy the new element into the vector
    void *copyTarget = octaspire_vector_private_index_to_pointer(self, realIndex.index);

    if (copyTarget != memcpy(copyTarget, element, self->elementSize))
    {
        abort();
    }

    ++(self->numElements);

    return true;
}

bool octaspire_vector_replace_element_at_index_or_push_back(
    octaspire_vector_t *self,
    void const *element,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_vector_private_index_t const realIndex =
        octaspire_vector_private_is_index_valid(
            self,
            possiblyNegativeIndex);

    if (!realIndex.isValid)
    {
        return octaspire_vector_push_back_element(self, element);
    }

    return octaspire_vector_insert_element_at(self, element, realIndex.index);
}

bool octaspire_vector_insert_element_at(
    octaspire_vector_t * const self,
    void const * const element,
    size_t const index)
{
    size_t const originalNumElements = self->numElements;

    while (index >= self->numAllocated)
    {
        if (!octaspire_vector_private_grow(
                self,
                octaspire_helpers_ceilf((float)index / (float)self->numAllocated)))
        {
            return false;
        }
    }

    // octaspire_vector_private_grow initializes new memory into zero,
    // so no need do it here again.

    long const numAdded = (index - originalNumElements);
    if (numAdded > 0)
    {
        self->numElements += numAdded;
    }

    void *target = octaspire_vector_private_index_to_pointer(self, index);

    if (target != memcpy(target, element, self->elementSize))
    {
        abort();
    }

    if (index >= self->numElements)
    {
        ++(self->numElements);
    }

    return true;
}

bool octaspire_vector_replace_element_at(
    octaspire_vector_t *self,
    ptrdiff_t const possiblyNegativeIndex,
    void const *element)
{
    octaspire_vector_private_index_t const realIndex =
        octaspire_vector_private_is_index_valid(
            self,
            possiblyNegativeIndex);

    if (!realIndex.isValid)
    {
        return false;
    }

    if (self->elementReleaseCallback)
    {
        if (self->elementIsPointer)
        {
            void* const * const tmpPtr =
                octaspire_vector_private_index_to_pointer(
                    self,
                    realIndex.index);

            octaspire_helpers_verify_not_null(tmpPtr);
            self->elementReleaseCallback(*tmpPtr);
        }
        else
        {
            self->elementReleaseCallback(
                octaspire_vector_private_index_to_pointer(self, realIndex.index));
        }
    }

    return octaspire_vector_insert_element_at(self, element, realIndex.index);
}

bool octaspire_vector_push_front_element(
    octaspire_vector_t *self,
    void const *element)
{
    if (octaspire_vector_is_empty(self))
    {
        return octaspire_vector_push_back_element(self, element);
    }

    return octaspire_vector_insert_element_before_the_element_at_index(
        self,
        element,
        0);
}

bool octaspire_vector_push_back_element(
    octaspire_vector_t * const self,
    void const * const element)
{
    return octaspire_vector_insert_element_at(
        self,
        element,
        octaspire_vector_get_length(self));
}

bool octaspire_vector_push_back_char(
    octaspire_vector_t *self,
    char const element)
{
    if (self->elementSize != sizeof(element))
    {
        return false;
    }

    return octaspire_vector_insert_element_at(
        self,
        &element,
        octaspire_vector_get_length(self));
}

void octaspire_vector_for_each(
    octaspire_vector_t *self,
    octaspire_vector_element_callback_t callback)
{
    assert(self);
    assert(callback);

    for (size_t i = 0; i < octaspire_vector_get_length(self); ++i)
    {
        callback(octaspire_vector_get_element_at(self, (ptrdiff_t)i));
    }
}

bool octaspire_vector_pop_back_element(
    octaspire_vector_t *self)
{
    if (octaspire_vector_is_empty(self))
    {
        return false;
    }

    --(self->numElements);

    return octaspire_vector_private_compact(self);
}

void *octaspire_vector_peek_back_element(
    octaspire_vector_t *self)
{
    if (octaspire_vector_is_empty(self))
    {
        return 0;
    }

    return octaspire_vector_get_element_at(
        self,
        (ptrdiff_t)(octaspire_vector_get_length(self) - 1));
}

void const * octaspire_vector_peek_back_element_const(
    octaspire_vector_t const * const self)
{
    if (octaspire_vector_is_empty(self))
    {
        return 0;
    }

    return octaspire_vector_get_element_at_const(
        self,
        (ptrdiff_t)(octaspire_vector_get_length(self) - 1));
}

bool octaspire_vector_pop_front_element(
    octaspire_vector_t *self)
{
    if (octaspire_vector_is_empty(self))
    {
        return false;
    }

    --(self->numElements);

    if (self->numElements > 0)
    {
        void *dest = octaspire_vector_private_index_to_pointer(self, 0);
        void *src  = octaspire_vector_private_index_to_pointer(self, 1);

        if (dest != memmove(dest, src, (self->elementSize * self->numElements)))
        {
            abort();
        }
    }

    return octaspire_vector_private_compact(self);
}

void *octaspire_vector_peek_front_element(
    octaspire_vector_t *self)
{
    if (octaspire_vector_is_empty(self))
    {
        return 0;
    }

    return octaspire_vector_get_element_at(self, 0);
}

void const * octaspire_vector_peek_front_element_const(
    octaspire_vector_t const * const self)
{
    if (octaspire_vector_is_empty(self))
    {
        return 0;
    }

    return octaspire_vector_get_element_at_const(self, 0);
}

octaspire_vector_element_callback_t
octaspire_vector_get_element_release_callback_const(octaspire_vector_t const * const self)
{
    return self->elementReleaseCallback;
}

bool octaspire_vector_clear(
    octaspire_vector_t * const self)
{
    if (octaspire_vector_is_empty(self))
    {
        return true;
    }

    self->numElements = 0;

    return octaspire_vector_private_compact(self);
}

void octaspire_vector_sort(
    octaspire_vector_t * const self,
    octaspire_vector_element_compare_function_t elementCompareFunction)
{
    qsort(
        self->elements,
        octaspire_vector_get_length(self),
        octaspire_vector_get_element_size_in_octets(self),
        elementCompareFunction);
}

bool octaspire_vector_is_valid_index(
    octaspire_vector_t const * const self,
    ptrdiff_t const index)
{
    octaspire_vector_private_index_t result =
        octaspire_vector_private_is_index_valid(self, index);

    return result.isValid;
}

bool octaspire_vector_swap(
    octaspire_vector_t * const self,
    ptrdiff_t const indexA,
    ptrdiff_t const indexB)
{
    if (!octaspire_vector_is_valid_index(self, indexA))
    {
        return false;
    }

    if (!octaspire_vector_is_valid_index(self, indexB))
    {
        return false;
    }

    void *tmpBuffer =
        octaspire_allocator_malloc(self->allocator, self->elementSize);

    if (!tmpBuffer)
    {
        return false;
    }

    void * const elementA =
        octaspire_vector_get_raw_data_for_element_at(self, indexA);

    void * const elementB =
        octaspire_vector_get_raw_data_for_element_at(self, indexB);

    if (tmpBuffer != memcpy(tmpBuffer, elementA, self->elementSize))
    {
        abort();
    }

    if (elementA != memcpy(elementA, elementB, self->elementSize))
    {
        abort();
    }

    if (elementB != memcpy(elementB, tmpBuffer, self->elementSize))
    {
        abort();
    }

    octaspire_allocator_free(self->allocator, tmpBuffer);
    tmpBuffer = 0;

    return true;
}

/*
void octaspire_vector_debug_print(
    octaspire_vector_t const * const self,
    FILE * const stream)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(stream);

    fprintf(stream, "[");

    for (size_t i = 0; i < octaspire_vector_get_length(self); ++i)
    {
        char const * const ptr =
            octaspire_vector_private_index_to_pointer_const(
                self,
                i);

        for (size_t j = 0;
             j < octaspire_vector_get_element_size_in_octets(self);
             ++j)
        {
            unsigned int const tmpUint = (unsigned int)*(ptr + j);
            fprintf(stream, "%02X", tmpUint);
        }

        if ((i + 1) < octaspire_vector_get_length(self))
        {
            fprintf(stream, "|");
        }
    }

    fprintf(stream, "]\n");
}
*/



struct octaspire_vector_permutation_iterator_t
{
    octaspire_allocator_t        *allocator;
    octaspire_vector_t *vector;
    octaspire_vector_t *counts;
    size_t                        stepsLeft;
    size_t                        i;
};

octaspire_vector_permutation_iterator_t
*octaspire_vector_permutation_iterator_new(
    octaspire_vector_t * const vector,
    octaspire_allocator_t * const allocator)
{
    octaspire_vector_permutation_iterator_t *self =
        octaspire_allocator_malloc(
            allocator,
            sizeof(octaspire_vector_permutation_iterator_t));

    if (!self)
    {
        return self;
    }

    self->allocator        = allocator;
    self->vector           = vector;

    self->counts = octaspire_vector_new(sizeof(int), false, 0, allocator);

    if (!self->counts)
    {
        octaspire_vector_permutation_iterator_release(self);
        self = 0;
        return 0;
    }

    self->stepsLeft     = octaspire_vector_get_length(self->vector);
    self->i             = 1;

    for (size_t i = 0; i < self->stepsLeft; ++i)
    {
        int const zero = 0;
        if (!octaspire_vector_push_back_element(self->counts, &zero))
        {
            octaspire_vector_permutation_iterator_release(self);
            self = 0;
            return 0;
        }
    }

    return self;
}

void octaspire_vector_permutation_iterator_release(
    octaspire_vector_permutation_iterator_t * const self)
{
    if (!self)
    {
        return;
    }

    octaspire_vector_release(self->counts);
    self->counts = 0;

    octaspire_allocator_free(self->allocator, self);
}

bool octaspire_vector_permutation_iterator_next(
    octaspire_vector_permutation_iterator_t * const self)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(self->vector);
    octaspire_helpers_verify_not_null(self->counts);

    octaspire_helpers_verify_true(
        octaspire_vector_get_length(self->counts) ==
        octaspire_vector_get_length(self->vector));

    while (self->i < octaspire_vector_get_length(self->vector))
    {
        int ci = *(int const * const) octaspire_vector_get_element_at(
            self->counts,
            (ptrdiff_t)self->i);

        if (ci < (int)self->i)
        {
            if (self->i % 2 == 0)
            {
                octaspire_helpers_verify_true(octaspire_vector_swap(
                        self->vector,
                        0,
                        (ptrdiff_t)self->i));
            }
            else
            {
                octaspire_helpers_verify_true(octaspire_vector_swap(
                        self->vector,
                        ci,
                        (ptrdiff_t)self->i));
            }

            ++ci;

            octaspire_helpers_verify_true(
                octaspire_vector_replace_element_at(
                    self->counts,
                    (ptrdiff_t)self->i,
                    &ci));

            self->i = 1;

            if (self->stepsLeft == 0)
            {
                return true;
            }

            --(self->stepsLeft);

            return true;
        }
        else
        {
            ci = 0;

            octaspire_helpers_verify_true(
                octaspire_vector_replace_element_at(
                    self->counts,
                    (ptrdiff_t)self->i,
                    &ci));

            ++(self->i);
        }
    }

    return false;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_vector.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_list.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_list_node_t
{
    void                                        *element;
    octaspire_list_node_t             *next;
    octaspire_list_node_t             *previous;
    octaspire_allocator_t                       *allocator;
    size_t                                       elementSize;
    octaspire_list_element_callback_t  elementReleaseCallback;
    bool                                         elementIsPointer;
    char                                         padding[7];
};

octaspire_list_node_t *octaspire_list_node_new(
    octaspire_list_node_t * const previous,
    octaspire_list_node_t * const next,
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_list_element_callback_t const elementReleaseCallback,
    void const * const element,
    octaspire_allocator_t * const allocator)
{
    octaspire_list_node_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_list_node_t));

    if (!self)
    {
        return self;
    }

    self->allocator              = allocator;
    self->elementSize            = elementSize;
    self->elementIsPointer       = elementIsPointer;
    self->elementReleaseCallback = elementReleaseCallback;
    self->next                   = next;
    self->previous               = previous;

    self->element = octaspire_allocator_malloc(self->allocator, elementSize);

    if (!self->element)
    {
        octaspire_list_node_release(self);
        self = 0;
        return self;
    }

    if (self->element != memcpy(self->element, element, self->elementSize))
    {
        octaspire_list_node_release(self);
        self = 0;
        return self;
    }

    return self;
}

void octaspire_list_node_release(octaspire_list_node_t *self)
{
    if (!self)
    {
        return;
    }

    if (self->elementReleaseCallback)
    {
        self->elementReleaseCallback(self->elementIsPointer ? *(void**)self->element : self->element);
    }

    octaspire_allocator_free(self->allocator, self->element);
    self->element = 0;

    octaspire_allocator_free(self->allocator, self);
}

void *octaspire_list_node_get_element(octaspire_list_node_t *self)
{
    octaspire_helpers_verify_not_null(self);

    if (!self->element)
    {
        return self->element;
    }

    return self->elementIsPointer ? *(void**)self->element : self->element;
}

void const *octaspire_list_node_get_element_const(
    octaspire_list_node_t const * const self)
{
    octaspire_helpers_verify_not_null(self);

    if (!self->element)
    {
        return self->element;
    }

    return self->elementIsPointer ? *(void**)self->element : self->element;
}

size_t octaspire_list_node_get_size_of_element_in_octets(
    octaspire_list_node_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->elementSize;
}

void octaspire_list_node_set_next(
    octaspire_list_node_t * const self,
    octaspire_list_node_t * const next)
{
    octaspire_helpers_verify_not_null(self);
    self->next = next;
}

octaspire_list_node_t *octaspire_list_node_get_next(
    octaspire_list_node_t * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->next;
}

octaspire_list_node_t const *octaspire_list_node_get_next_const(
    octaspire_list_node_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->next;
}

void octaspire_list_node_set_previous(
    octaspire_list_node_t * const self,
    octaspire_list_node_t * const previous)
{
    octaspire_helpers_verify_not_null(self);
    self->previous = previous;
}

octaspire_list_node_t *octaspire_list_node_get_previous(
    octaspire_list_node_t * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->previous;
}

octaspire_list_node_t const *octaspire_list_node_get_previous_const(
    octaspire_list_node_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->previous;
}


struct octaspire_list_t
{
    octaspire_allocator_t                       *allocator;
    octaspire_list_node_t             *front;
    octaspire_list_node_t             *back;
    size_t                                       elementSize;
    octaspire_list_element_callback_t  elementReleaseCallback;
    size_t                                       numElements;
    bool                                         elementIsPointer;
    char                                         padding[7];
};

octaspire_list_t *octaspire_list_new(
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_list_element_callback_t const elementReleaseCallback,
    octaspire_allocator_t *allocator)
{
    octaspire_list_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_list_t));

    if (!self)
    {
        return self;
    }

    self->allocator              = allocator;
    self->front                  = 0;
    self->back                   = 0;
    self->elementSize            = elementSize;
    self->elementReleaseCallback = elementReleaseCallback;
    self->numElements            = 0;
    self->elementIsPointer       = elementIsPointer;

    return self;
}

void octaspire_list_release(octaspire_list_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_helpers_verify_true(octaspire_list_clear(self));
    octaspire_allocator_free(self->allocator, self);
}

octaspire_list_node_t *octaspire_list_get_front(
    octaspire_list_t *self)
{
    octaspire_helpers_verify_not_null(self);
    return self->front;
}

octaspire_list_node_t const *octaspire_list_get_front_const(
    octaspire_list_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->front;
}

octaspire_list_node_t *octaspire_list_get_back(
    octaspire_list_t *self)
{
    octaspire_helpers_verify_not_null(self);
    return self->back;
}

octaspire_list_node_t const *octaspire_list_get_back_const(
    octaspire_list_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->back;
}

bool octaspire_list_push_front(
    octaspire_list_t *self,
    void const * const element)
{
    octaspire_helpers_verify_not_null(self);

    octaspire_list_node_t *newFirst = octaspire_list_node_new(
        0,
        self->front,
        self->elementSize,
        self->elementIsPointer,
        self->elementReleaseCallback,
        element,
        self->allocator);

    if (!newFirst)
    {
        return false;
    }

    if (self->front)
    {
        octaspire_list_node_set_previous(self->front, newFirst);
    }

    self->front = newFirst;

    if (octaspire_list_get_length(self) == 0)
    {
        self->back = self->front;
    }

    ++(self->numElements);

    return true;
}

bool octaspire_list_push_back(
    octaspire_list_t *self,
    void const * const element)
{
    octaspire_helpers_verify_not_null(self);

    octaspire_list_node_t *newLast = octaspire_list_node_new(
        self->back,
        0,
        self->elementSize,
        self->elementIsPointer,
        self->elementReleaseCallback,
        element,
        self->allocator);

    if (!newLast)
    {
        return false;
    }

    if (self->back)
    {
        octaspire_list_node_set_next(self->back, newLast);
    }

    self->back = newLast;

    if (octaspire_list_get_length(self) == 0)
    {
        self->front = self->back;
    }

    // Sanity checks
    if (self->numElements > 0)
    {
        octaspire_helpers_verify_not_null(octaspire_list_node_get_previous(self->back));
    }
    else
    {
        octaspire_helpers_verify_null(octaspire_list_node_get_previous(self->back));
    }

    ++(self->numElements);

    return true;
}

bool octaspire_list_pop_front(
    octaspire_list_t * const self)
{
    octaspire_helpers_verify_not_null(self);

    if (self->front)
    {
        octaspire_list_node_t *oldFirst = self->front;

        self->front = octaspire_list_node_get_next(self->front);

        if (self->front)
        {
            octaspire_list_node_set_previous(self->front, 0);
        }

        octaspire_list_node_set_next(oldFirst, 0);

        octaspire_helpers_verify_null(octaspire_list_node_get_previous(oldFirst));
        octaspire_helpers_verify_true(self->numElements > 0);

        --(self->numElements);

        if (octaspire_list_get_length(self) == 0)
        {
            self->back = self->front;
        }

        octaspire_list_node_release(oldFirst);
        oldFirst = 0;

        return true;
    }

    return true;
}

bool octaspire_list_pop_back(
    octaspire_list_t * const self)
{
    octaspire_helpers_verify_not_null(self);

    if (self->back)
    {
        octaspire_list_node_t *oldLast = self->back;

        self->back = octaspire_list_node_get_previous(self->back);

        if (self->back)
        {
            octaspire_list_node_set_next(self->back, 0);
        }

        octaspire_list_node_set_previous(oldLast, 0);

        octaspire_helpers_verify_null(octaspire_list_node_get_next(oldLast));
        octaspire_helpers_verify_true(self->numElements > 0);

        --(self->numElements);

        if (octaspire_list_get_length(self) == 0)
        {
            self->front = self->back;
        }

        octaspire_list_node_release(oldLast);
        oldLast = 0;

        return true;
    }

    return true;
}

bool octaspire_list_remove(
    octaspire_list_t * const self,
    octaspire_list_node_t * const node)
{
    octaspire_helpers_verify_not_null(self);

    if (node == octaspire_list_get_front_const(self))
    {
        return octaspire_list_pop_front(self);
    }
    else if (node == octaspire_list_get_back_const(self))
    {
        return octaspire_list_pop_back(self);
    }
    else
    {
        octaspire_list_node_t * const prev =
            octaspire_list_node_get_previous(node);

        octaspire_list_node_t * const next =
            octaspire_list_node_get_next(node);

        if (prev)
        {
            octaspire_list_node_set_next(prev, next);
        }

        if (next)
        {
            octaspire_list_node_set_previous(next, prev);
        }

        octaspire_list_node_set_next(node, 0);
        octaspire_list_node_set_previous(node, 0);

        octaspire_helpers_verify_true(self->numElements > 0);

        --(self->numElements);

        if (octaspire_list_get_length(self) == 0)
        {
            self->front = self->back;
        }

        octaspire_list_node_release(node);
        return true;
    }
}

bool octaspire_list_clear(
    octaspire_list_t * const self)
{
    octaspire_helpers_verify_not_null(self);

    while (!octaspire_list_is_empty(self))
    {
        if (!octaspire_list_pop_front(self))
        {
            return false;
        }

    }

    return true;
}

size_t octaspire_list_get_length(
    octaspire_list_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->numElements;
}

bool octaspire_list_is_empty(
    octaspire_list_t const * const self)
{
    return (self->front == 0);
}

octaspire_list_node_t *octaspire_list_get_at(
    octaspire_list_t * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_helpers_verify_not_null(self);

    if (possiblyNegativeIndex < 0)
    {
        size_t const index = (size_t)(-(possiblyNegativeIndex + 1));
        size_t counter = 0;
        octaspire_list_node_t * node = octaspire_list_get_back(self);

        while (true)
        {
            if (counter == index)
            {
                return node;
            }

            node = octaspire_list_node_get_previous(node);

            if (!node)
            {
                break;
            }

            ++counter;
        }

        return 0;
    }
    else
    {
        size_t const index = (size_t)possiblyNegativeIndex;
        size_t counter = 0;
        octaspire_list_node_t * node = octaspire_list_get_front(self);

        while (true)
        {
            if (counter == index)
            {
                return node;
            }

            node = octaspire_list_node_get_next(node);

            if (!node)
            {
                break;
            }

            ++counter;
        }

        return 0;
    }
}

octaspire_list_node_t const *octaspire_list_get_at_const(
    octaspire_list_t const * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_helpers_verify_not_null(self);

    if (possiblyNegativeIndex < 0)
    {
        size_t const index = (size_t)(-(possiblyNegativeIndex + 1));
        size_t counter = 0;

        octaspire_list_node_t const * node =
            octaspire_list_get_back_const(self);

        while (true)
        {
            if (counter == index)
            {
                return node;
            }

            node = octaspire_list_node_get_previous_const(node);

            if (!node)
            {
                break;
            }

            ++counter;
        }

        return 0;
    }
    else
    {
        size_t const index = (size_t)possiblyNegativeIndex;
        size_t counter = 0;
        octaspire_list_node_t const * node =
            octaspire_list_get_front_const(self);

        while (true)
        {
            if (counter == index)
            {
                return node;
            }

            node = octaspire_list_node_get_next_const(node);

            if (!node)
            {
                break;
            }

            ++counter;
        }

        return 0;
    }
}


octaspire_list_node_iterator_t octaspire_list_node_iterator_init(
    octaspire_list_t * const self)
{
    octaspire_list_node_iterator_t iterator;

    iterator.list = self;
    iterator.currentNode = octaspire_list_get_front(self);

    return iterator;
}

bool octaspire_list_node_iterator_next(
    octaspire_list_node_iterator_t * const self)
{
    if (!self->currentNode)
    {
        return false;
    }

    self->currentNode = octaspire_list_node_get_next(self->currentNode);

    return (self->currentNode != 0);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_list.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_queue.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_queue_t
{
    octaspire_allocator_t      *allocator;
    octaspire_list_t *list;
    size_t                      maxLength;
    bool                        hasMaxLength;
    char                        padding[7];
};

static bool octaspire_queue_private_ensure_max_length(
    octaspire_queue_t * const self)
{
    if (self->hasMaxLength)
    {
        while (octaspire_queue_get_length(self) > self->maxLength)
        {
            if (!octaspire_queue_pop(self))
            {
                return false;
            }
        }
    }

    return true;
}

octaspire_queue_t *octaspire_queue_new(
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_queue_element_callback_t const elementReleaseCallback,
    octaspire_allocator_t *allocator)
{
    octaspire_queue_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_queue_t));

    if (!self)
    {
        return self;
    }

    self->allocator    = allocator;
    self->hasMaxLength = false;
    self->maxLength    = 0;

    self->list = octaspire_list_new(
        elementSize,
        elementIsPointer,
        elementReleaseCallback,
        allocator);

    if (!self->list)
    {
        octaspire_queue_release(self);
        self = 0;
        return self;
    }

    return self;
}

octaspire_queue_t *octaspire_queue_new_with_max_length(
    size_t const maxLength,
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_queue_element_callback_t const elementReleaseCallback,
    octaspire_allocator_t *allocator)
{
    octaspire_queue_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_queue_t));

    if (!self)
    {
        return self;
    }

    self->allocator    = allocator;
    self->hasMaxLength = true;
    self->maxLength    = maxLength;

    self->list = octaspire_list_new(
        elementSize,
        elementIsPointer,
        elementReleaseCallback,
        allocator);

    if (!self->list)
    {
        octaspire_queue_release(self);
        self = 0;
        return self;
    }

    return self;
}

void octaspire_queue_release(octaspire_queue_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_list_release(self->list);
    self->list = 0;

    octaspire_helpers_verify_not_null(self->allocator);
    octaspire_allocator_free(self->allocator, self);
}

void *octaspire_queue_peek(
    octaspire_queue_t * const self)
{
    octaspire_list_node_t * const node = octaspire_list_get_front(self->list);

    if (!node)
    {
        return 0;
    }

    return octaspire_list_node_get_element(node);
}

void const *octaspire_queue_peek_const(
    octaspire_queue_t const * const self)
{
    octaspire_list_node_t const * const node =
        octaspire_list_get_front(self->list);

    if (!node)
    {
        return 0;
    }

    return octaspire_list_node_get_element_const(node);
}

bool octaspire_queue_pop(
    octaspire_queue_t * const self)
{
    return octaspire_list_pop_front(self->list);
}

bool octaspire_queue_push(
    octaspire_queue_t *self,
    void const * const element)
{
    if (!octaspire_list_push_back(self->list, element))
    {
        return false;
    }

    return octaspire_queue_private_ensure_max_length(self);
}

bool octaspire_queue_clear(
    octaspire_queue_t * const self)
{
    return octaspire_list_clear(self->list);
}

size_t octaspire_queue_get_length(
    octaspire_queue_t const * const self)
{
    return octaspire_list_get_length(self->list);
}

bool octaspire_queue_is_empty(
    octaspire_queue_t const * const self)
{
    return octaspire_list_is_empty(self->list);
}

void *octaspire_queue_get_at(
    octaspire_queue_t * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_list_node_t * const node =
        octaspire_list_get_at(self->list, possiblyNegativeIndex);

    if (!node)
    {
        return 0;
    }

    return octaspire_list_node_get_element(node);
}

void const *octaspire_queue_get_at_const(
    octaspire_queue_t const * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_list_node_t const * const node =
        octaspire_list_get_at(self->list, possiblyNegativeIndex);

    if (!node)
    {
        return 0;
    }

    return octaspire_list_node_get_element_const(node);
}

size_t octaspire_queue_get_max_length(
    octaspire_queue_t const * const self)
{
    return self->maxLength;
}

bool octaspire_queue_has_max_length(
    octaspire_queue_t const * const self)
{
    return self->hasMaxLength;
}

bool octaspire_queue_set_max_length(
    octaspire_queue_t * const self,
    size_t maxLength)
{
    self->maxLength = maxLength;
    return octaspire_queue_private_ensure_max_length(self);
}

bool octaspire_queue_set_has_max_length(
    octaspire_queue_t * const self,
    bool hasMaxLength)
{
    self->hasMaxLength = hasMaxLength;
    return octaspire_queue_set_max_length(self, self->maxLength);
}


octaspire_queue_iterator_t octaspire_queue_iterator_init(
    octaspire_queue_t * const self)
{
    octaspire_queue_iterator_t iterator;

    iterator.queue = self;
    iterator.iterator = octaspire_list_node_iterator_init(self->list);

    return iterator;
}

bool octaspire_queue_iterator_next(
    octaspire_queue_iterator_t * const self)
{
    return octaspire_list_node_iterator_next(&(self->iterator));
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_queue.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_string.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_string_t
{
    octaspire_vector_t                   *octets;
    octaspire_vector_t                   *ucsCharacters;
    octaspire_allocator_t                          *allocator;
    size_t                                          errorAtOctet;
    octaspire_string_error_status_t  errorStatus;
};

static char const octaspire_string_private_null_octet = '\0';


// Prototypes for private functions /////////////////////////////////////////
static bool octaspire_string_private_check_substring_match_at(
    octaspire_string_t const * const self,
    size_t const startFromIndex,
    octaspire_string_t const * const substring);

static bool octaspire_string_private_is_string_at_index(
    octaspire_string_t const * const self,
    size_t const selfIndex,
    octaspire_string_t const * const str,
    size_t const strFirstIndex,
    size_t const strLastIndex);

static bool octaspire_string_private_ensure_octets_are_up_to_date(
    octaspire_string_t const * const self);

//////////////////////////////////////////////////////////////////////////////


octaspire_string_t *octaspire_string_new(
    char const * const str,
    octaspire_allocator_t *allocator)
{
    return octaspire_string_new_from_buffer(
        str,
        str ? strlen(str) : 0,
        allocator);
}

octaspire_string_t *octaspire_string_new_from_buffer(
    char const * const buffer,
    size_t const lengthInOctets,
    octaspire_allocator_t *allocator)
{
    octaspire_string_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_string_t));

    if (!self)
    {
        return 0;
    }

    self->allocator        = allocator;

    // We cannot know how many actual UCS characters there are in buffer, because
    // characters can be encoded between one and four octets. To speed up allocation,
    // without allocating too much space, we preallocate lengthInOctets / 4 characters.
    self->ucsCharacters    = octaspire_vector_new_with_preallocated_elements(
        sizeof(uint32_t),
        false,
        lengthInOctets / 4,
        0,
        self->allocator);

    if (!self->ucsCharacters)
    {
        octaspire_string_release(self);
        self = 0;
        return 0;
    }

    self->errorStatus  = OCTASPIRE_STRING_ERROR_STATUS_OK;

    self->octets = octaspire_vector_new(
        sizeof(char),
        false,
        0,
        self->allocator);

    self->errorAtOctet = 0;

    if (buffer && lengthInOctets)
    {
        size_t index = 0;
        uint32_t ucsChar = 0;
        int numOctets = 0;
        while (index < lengthInOctets)
        {
            // TODO XXX is (lengthInOctets - index) correct?
            octaspire_utf8_decode_status_t const status = octaspire_utf8_decode_character(
                buffer + index,
                (lengthInOctets - index),
                &ucsChar,
                &numOctets);

            if (status != OCTASPIRE_UTF8_DECODE_STATUS_OK)
            {
                self->errorStatus  = OCTASPIRE_STRING_ERROR_STATUS_DECODING_ERROR;
                self->errorAtOctet = index;
                break;
            }

            if (numOctets > 0)
            {
                if (!octaspire_vector_push_back_element(self->ucsCharacters, &ucsChar))
                {
                    octaspire_string_release(self);
                    self = 0;
                    return 0;
                }

                index += (size_t)numOctets;
            }
        }
    }

    return self;
}

octaspire_string_t *octaspire_string_new_format(
    octaspire_allocator_t *allocator,
    char const * const fmt,
    ...)
{
    va_list arguments;
    va_start(arguments, fmt);

    octaspire_string_t *result =
        octaspire_string_new_vformat(allocator, fmt, arguments);

    va_end(arguments);

    return result;
}

octaspire_string_t *octaspire_string_new_vformat(
    octaspire_allocator_t *allocator,
    char const * const fmt,
    va_list arguments)
{
    va_list copyOfVarArgs;
    va_copy(copyOfVarArgs, arguments);

    octaspire_string_error_status_t errorStatus =
        OCTASPIRE_STRING_ERROR_STATUS_OK;

    size_t                                         errorAtOctet = 0;

    octaspire_string_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_string_t));

    if (!self)
    {
        va_end(copyOfVarArgs);
        return self;
    }

    self->allocator        = allocator;

    assert(self->allocator);

    self->octets = octaspire_vector_new(
        sizeof(char),
        false,
        0,
        self->allocator);

    self->ucsCharacters     = octaspire_vector_new(sizeof(uint32_t), false, 0, self->allocator);

    octaspire_string_reset_error_status(self);

    size_t buflen = 8;
    char *buffer = octaspire_allocator_malloc(allocator, buflen);
    assert(buffer);

    octaspire_vector_t *vec2 = octaspire_vector_new(
        sizeof(char),
        false,
        0,
        allocator);

    assert(vec2);

    int negativeResultCounter = -1;

    bool firstRound = true;
    while (true)
    {
        if (negativeResultCounter > 1000)
        {
            errorStatus = OCTASPIRE_STRING_ERROR_STATUS_ENCODING_ERROR;
            // TODO XXX what octet index to put here? Negative index, or just unused on this error type?
            errorAtOctet = 0;
            break;
        }

        int n = 0;

        if (firstRound)
        {
            firstRound = false;
        }
        else
        {
            va_copy(copyOfVarArgs, arguments);
        }

#ifdef OCTASPIRE_CLANG_PRAGMAS_ENABLED
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wformat-nonliteral"
#endif

    #ifdef OCTASPIRE_PLAN9_IMPLEMENTATION
        n = vsnprintf(
            buffer,
            buflen - 1,
            fmt,
            copyOfVarArgs);
    #else
        n = vsnprintf(
            buffer,
            buflen,
            fmt,
            copyOfVarArgs);
    #endif

#ifdef OCTASPIRE_CLANG_PRAGMAS_ENABLED
#pragma clang diagnostic pop
#endif

        va_end(copyOfVarArgs);

        if (n < 0)
        {
            // Encoding error in C99 or, on older glibc, the output was truncated.
            // Try again with more space. Because we don't know how much
            // space is required, lets double it (and make sure that the length is not zero).
            // Because we don't know is the reason for failure an encoding error or missing space,
            // we will start counting to prevent looping forever.
            ++negativeResultCounter;

            buflen *= 2;
            char *tmpPtr = octaspire_allocator_realloc(allocator, buffer, buflen);
            //char *tmpPtr = realloc(buffer, buflen);

            if (tmpPtr)
            {
                buffer = tmpPtr;
                memset(buffer, 0, buflen);
            }
            else
            {
                octaspire_allocator_free(allocator, buffer);
                buffer = 0;
                return 0;
            }
        }
        else if ((size_t)n >= buflen)
        {
            // TODO calculate exact size

            buflen *= 2;
            char *tmpPtr = octaspire_allocator_realloc(allocator, buffer, buflen);
            //char *tmpPtr = realloc(buffer, buflen);

            if (tmpPtr)
            {
                buffer = tmpPtr;
                memset(buffer, 0, buflen);
            }
            else
            {
                octaspire_allocator_free(allocator, buffer);
                buffer = 0;
                return 0;
            }
        }
        else if (n > 0)
        {
            assert((size_t)n < buflen);
            // Success
            for (size_t i = 0; i < (size_t)n; ++i)
            {
                char const c = buffer[i];

                octaspire_vector_push_back_element(vec2, &c);
            }

            if (!octaspire_vector_push_back_char(
                    vec2,
                    octaspire_string_private_null_octet))
            {
                abort();
            }

            break;
        }
        else
        {
            // Empty string
            break;
            //assert(false);
        }
    }

    //assert(!octaspire_vector_is_empty(vec2));

    if (!octaspire_vector_push_back_char(vec2, octaspire_string_private_null_octet))
    {
        abort();
    }

    octaspire_string_t *tmpStr = octaspire_string_new(
        octaspire_vector_get_element_at(vec2, 0),
        allocator);

    octaspire_string_release(self);
    self = tmpStr;

    assert(self);

    if (!octaspire_string_is_error(self))
    {
        if (errorStatus != OCTASPIRE_STRING_ERROR_STATUS_OK)
        {
            self->errorStatus  = errorStatus;
            self->errorAtOctet = errorAtOctet;
        }
    }

    octaspire_allocator_free(allocator, buffer);
    buffer = 0;

    octaspire_vector_release(vec2);
    vec2 = 0;

    return self;
}

octaspire_string_t *octaspire_string_new_copy(
    octaspire_string_t const * const other,
    octaspire_allocator_t *allocator)
{
    octaspire_string_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_string_t));

    if (!self)
    {
        return self;
    }

    self->octets            = octaspire_vector_new_shallow_copy(other->octets, allocator);

    self->ucsCharacters     = octaspire_vector_new_shallow_copy(other->ucsCharacters, allocator);
    self->errorStatus       = other->errorStatus;
    self->errorAtOctet      = other->errorAtOctet;
    self->allocator         = allocator;

    return self;
}

octaspire_string_t *octaspire_string_new_substring_from_given_index_and_length(
    octaspire_string_t const * const other,
    octaspire_allocator_t *allocator,
    size_t const ucsCharStartIndex,
    size_t const lengthInUcsChars)
{
    assert(other);
    assert(allocator);

    size_t const endIndex = ucsCharStartIndex + lengthInUcsChars;

    if (endIndex >= octaspire_string_get_length_in_ucs_characters(other))
    {
        return 0;
    }

    octaspire_string_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_string_t));

    if (!self)
    {
        return self;
    }

    self->allocator         = allocator;

    self->octets = octaspire_vector_new(
        sizeof(char),
        false,
        0,
        self->allocator);

    self->ucsCharacters     = octaspire_vector_new_with_preallocated_elements(
        sizeof(uint32_t),
        false,
        lengthInUcsChars,
        0,
        self->allocator);

    if (!self->ucsCharacters)
    {
        octaspire_string_release(self);
        self = 0;
        return 0;
    }

    self->errorStatus   = OCTASPIRE_STRING_ERROR_STATUS_OK;
    self->errorAtOctet  = 0;

    for (size_t i = 0; i < lengthInUcsChars; ++i)
    {
        octaspire_string_push_back_ucs_character(
            self,
            octaspire_string_get_ucs_character_at_index(
                other,
                (ptrdiff_t)(ucsCharStartIndex + i)));
    }

    return self;
}

void octaspire_string_release(octaspire_string_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_vector_release(self->octets);
    octaspire_vector_release(self->ucsCharacters);

    octaspire_allocator_free(self->allocator, self);
}

bool octaspire_string_set_from_c_string(
    octaspire_string_t * const self,
    char const * const str)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(str);

    if (!octaspire_string_clear(self))
    {
        return false;
    }

    if (!octaspire_string_concatenate_c_string(self, str))
    {
        return false;
    }

    return true;
}

bool octaspire_string_is_empty(
    octaspire_string_t const * const self)
{
    return octaspire_string_get_length_in_ucs_characters(self) == 0;
}

size_t octaspire_string_get_length_in_ucs_characters(
    octaspire_string_t const * const self)
{
    assert(self);
    return octaspire_vector_get_length(self->ucsCharacters);
}

size_t octaspire_string_get_length_in_octets(
    octaspire_string_t const * const self)
{
    octaspire_string_private_ensure_octets_are_up_to_date(self);

    if (octaspire_vector_is_empty(self->octets))
    {
        return 0;
    }

    assert(*(char const*)octaspire_vector_peek_back_element_const(self->octets) == '\0');
    // Subtract one because of '\0' at the end
    return octaspire_vector_get_length(self->octets) - 1;
}

typedef struct octaspire_string_private_index_t
{
    size_t index;
    bool   isValid;
    char   padding[7];

} octaspire_string_private_index_t;

static octaspire_string_private_index_t octaspire_string_private_is_index_valid(
    octaspire_string_t const * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_string_private_index_t result = {.isValid=false, .index=0};

    if (possiblyNegativeIndex < 0)
    {
        ptrdiff_t tmpIndex =
            (ptrdiff_t)octaspire_string_get_length_in_ucs_characters(self) +
            possiblyNegativeIndex;

        if (tmpIndex >= 0 &&
            (size_t)tmpIndex < octaspire_string_get_length_in_ucs_characters(self))
        {
            result.index   = (size_t)tmpIndex;
            result.isValid = true;

            return result;
        }
    }

    // To allow to be used with overwrite or push back
    result.index   = (size_t)possiblyNegativeIndex;

    if ((size_t)possiblyNegativeIndex < octaspire_string_get_length_in_ucs_characters(self))
    {
        result.isValid = true;

        return result;
    }

    return result;
}

bool octaspire_string_is_index_valid(
    octaspire_string_t const * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    const octaspire_string_private_index_t index =
        octaspire_string_private_is_index_valid(
            self,
            possiblyNegativeIndex);

    return index.isValid;
}

uint32_t octaspire_string_get_ucs_character_at_index(
    octaspire_string_t const * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_string_private_index_t const realIndex =
        octaspire_string_private_is_index_valid(self, possiblyNegativeIndex);

    if (!realIndex.isValid)
    {
        abort();
    }

    return *(uint32_t*)octaspire_vector_get_element_at(
        self->ucsCharacters,
        (ptrdiff_t)realIndex.index);
}

char const * octaspire_string_get_c_string(
    octaspire_string_t const * const self)
{
    octaspire_string_private_ensure_octets_are_up_to_date(self);

    static char const * const emptyStr = "";
    if (octaspire_vector_is_empty(self->octets))
    {
        return emptyStr;
    }

    octaspire_helpers_verify_true(
        *(char const*)octaspire_vector_peek_back_element_const(self->octets) ==
            '\0');

    return octaspire_vector_peek_front_element_const(self->octets);
}

bool octaspire_string_is_error(
    octaspire_string_t const * const self)
{
    return self->errorStatus != OCTASPIRE_STRING_ERROR_STATUS_OK;
}

octaspire_string_error_status_t octaspire_string_get_error_status(
    octaspire_string_t const * const self)
{
    return self->errorStatus;
}

size_t octaspire_string_get_error_position_in_octets(
    octaspire_string_t const * const self)
{
    return self->errorAtOctet;
}

void octaspire_string_reset_error_status(
    octaspire_string_t * const self)
{
    self->errorStatus   = OCTASPIRE_STRING_ERROR_STATUS_OK;
    self->errorAtOctet  = 0;
}

bool octaspire_string_concatenate(
    octaspire_string_t * const self,
    octaspire_string_t const * const other)
{
    return octaspire_string_concatenate_c_string(
        self,
        octaspire_string_get_c_string(other));
}

bool octaspire_string_concatenate_c_string(
    octaspire_string_t * const self,
    char const * const str)
{
    octaspire_string_reset_error_status(self);

    if (!str || str[0] == '\0')
    {
        return true;
    }

    if (!octaspire_vector_clear(self->octets))
    {
        return false;
    }

    size_t const strLen = strlen(str);

    bool result = true;

    size_t index = 0;
    uint32_t ucsChar = 0;
    int numOctets = 0;
    while (str[index] != '\0')
    {
        octaspire_utf8_decode_status_t status =
            octaspire_utf8_decode_character(str + index, (strLen - index), &ucsChar, &numOctets);

        assert(numOctets >= 0);

        if (status != OCTASPIRE_UTF8_DECODE_STATUS_OK)
        {
            self->errorStatus  = OCTASPIRE_STRING_ERROR_STATUS_DECODING_ERROR;
            self->errorAtOctet = index;
            break;
        }

        if (!octaspire_vector_push_back_element(self->ucsCharacters, &ucsChar))
        {
            result = false;
        }

        index += (size_t)numOctets;
    }

    return result;
}

bool octaspire_string_concatenate_format(
    octaspire_string_t * const self,
    char const * const fmt,
    ...)
{
    va_list arguments;
    va_start(arguments, fmt);

    octaspire_string_t *str =
        octaspire_string_new_vformat(self->allocator, fmt, arguments);

    va_end(arguments);

    if (!str)
    {
        return false;
    }

    if (!octaspire_vector_clear(self->octets))
    {
        return false;
    }

    bool result = octaspire_string_concatenate_c_string(
        self,
        octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    return result;
}

bool octaspire_string_private_check_substring_match_at(
    octaspire_string_t const * const self,
    size_t const startFromIndex,
    octaspire_string_t const * const substring)
{
    size_t const selfLength = octaspire_string_get_length_in_ucs_characters(self);

    size_t const substringLength =
        octaspire_string_get_length_in_ucs_characters(substring);

    for (size_t i = 0; i < substringLength; ++i)
    {
        if ((startFromIndex + i) >= selfLength)
        {
            return false;
        }

        if (octaspire_string_get_ucs_character_at_index(
                self,
                (ptrdiff_t)(startFromIndex + i)) !=
            octaspire_string_get_ucs_character_at_index(
                substring,
                (ptrdiff_t)i))
        {
            return false;
        }
    }

    return true;
}

ptrdiff_t octaspire_string_find_first_substring(
    octaspire_string_t const * const self,
    ptrdiff_t const startFromIndexPossiblyNegative,
    octaspire_string_t const * const substring)
{
    octaspire_string_private_index_t const realIndex =
        octaspire_string_private_is_index_valid(self, startFromIndexPossiblyNegative);

    if (!realIndex.isValid)
    {
        return -1;
    }

    size_t const selfLength = octaspire_string_get_length_in_ucs_characters(self);

    for (size_t i = realIndex.index; i < (realIndex.index + selfLength); ++i)
    {
        if (octaspire_string_private_check_substring_match_at(
                self,
                i,
                substring))
        {
            return (ptrdiff_t)i;
        }
    }

    return -1;
}

bool octaspire_string_remove_character_at(
    octaspire_string_t * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_string_private_index_t const realIndex =
        octaspire_string_private_is_index_valid(self, possiblyNegativeIndex);

    if (!realIndex.isValid)
    {
        return false;
    }

    if (!octaspire_vector_clear(self->octets))
    {
        return false;
    }

    if (!octaspire_vector_remove_element_at(
            self->ucsCharacters,
            (ptrdiff_t)realIndex.index))
    {
        assert(false);
        return false;
    }

    return true;
}

size_t octaspire_string_remove_characters_at(
    octaspire_string_t * const self,
    ptrdiff_t const startFromIndexPossiblyNegative,
    size_t const numCharacters)
{
    if (!numCharacters)
    {
        return numCharacters;
    }

    octaspire_string_private_index_t const realIndex =
        octaspire_string_private_is_index_valid(
            self,
            startFromIndexPossiblyNegative);

    if (!realIndex.isValid)
    {
        return 0;
    }

    if (!octaspire_vector_clear(self->octets))
    {
        return false;
    }

    size_t result = 0;

    for (ptrdiff_t i = (ptrdiff_t)numCharacters - 1; i >= 0; --i)
    {
        if (octaspire_string_remove_character_at(
                self,
                (ptrdiff_t)(realIndex.index + (size_t)i)))
        {
            ++result;
        }
    }

    return result;
}

size_t octaspire_string_remove_all_substrings(
    octaspire_string_t * const self,
    octaspire_string_t const * const substring)
{
    if (!octaspire_vector_clear(self->octets))
    {
        abort();
    }

    size_t result = 0;

    size_t const substringLength =
        octaspire_string_get_length_in_ucs_characters(substring);

    while (true)
    {
        if (octaspire_string_is_empty(self))
        {
            return result;
        }

        ptrdiff_t const substringIndex =
            octaspire_string_find_first_substring(self, 0, substring);

        if (substringIndex < 0)
        {
            return result;
        }

        if (octaspire_string_remove_characters_at(
            self,
            substringIndex,
            substringLength))
        {
            ++result;
        }
    }
}

bool octaspire_string_clear(
    octaspire_string_t * const self)
{
    self->errorStatus       = OCTASPIRE_STRING_ERROR_STATUS_OK;
    self->errorAtOctet      = 0;

    if (!octaspire_vector_clear(self->octets))
    {
        return false;
    }

    return octaspire_vector_clear(self->ucsCharacters);
}

bool octaspire_string_is_equal(
    octaspire_string_t const * const self,
    octaspire_string_t const * const other)
{
    assert(self);
    assert(other);

    size_t const myLen = octaspire_string_get_length_in_ucs_characters(self);

    if (myLen != octaspire_string_get_length_in_ucs_characters(other))
    {
        return false;
    }

    for (size_t i = 0; i < myLen; ++i)
    {
        uint32_t ucsChar1 =
            *(uint32_t const * const)octaspire_vector_get_element_at(
                self->ucsCharacters,
                (ptrdiff_t)i);

        uint32_t ucsChar2 =
            *(uint32_t const * const)octaspire_vector_get_element_at(
                other->ucsCharacters,
                (ptrdiff_t)i);

        if (ucsChar1 != ucsChar2)
        {
            return false;
        }

    }

    return true;
}

bool octaspire_string_is_equal_to_c_string(
    octaspire_string_t const * const self,
    char const * const str)
{
    assert(self);
    assert(str);

    octaspire_string_private_ensure_octets_are_up_to_date(self);

    if (octaspire_vector_is_empty(self->octets))
    {
        return (strlen(str) == 0);
    }

    assert(*(char const*)octaspire_vector_peek_back_element_const(self->octets) == '\0');

    size_t const len = octaspire_string_get_length_in_octets(self);

    if (strlen(str) != len)
    {
        return false;
    }

    return memcmp(octaspire_vector_get_element_at(self->octets,  0), str, len) == 0;
}

int octaspire_string_compare(
    octaspire_string_t const * const self,
    octaspire_string_t const * const other)
{
    assert(self);
    assert(other);

    return octaspire_string_compare_to_c_string(
        self,
        octaspire_string_get_c_string(other));
}

int octaspire_string_compare_to_c_string(
    octaspire_string_t const * const self,
    char const * const str)
{
    assert(self);
    assert(str);

    octaspire_string_private_ensure_octets_are_up_to_date(self);

    if (octaspire_vector_is_empty(self->octets))
    {
        return 0;
    }

    assert(*(char const*)octaspire_vector_peek_back_element_const(self->octets) == '\0');

    return strcmp(octaspire_string_get_c_string(self), str);
}

bool octaspire_string_starts_with(
    octaspire_string_t const * const self,
    octaspire_string_t const * const other)
{
    assert(self && other);

    size_t const myLen = octaspire_string_get_length_in_ucs_characters(self);
    size_t const otherLen = octaspire_string_get_length_in_ucs_characters(other);

    if (myLen < otherLen)
    {
        return false;
    }

    for (size_t i = 0; i < otherLen; ++i)
    {
        if (octaspire_string_get_ucs_character_at_index(
                self,
                (ptrdiff_t)i) !=
            octaspire_string_get_ucs_character_at_index(
                other,
                (ptrdiff_t)i))
        {
            return false;
        }
    }

    return true;
}

bool octaspire_string_ends_with(
    octaspire_string_t const * const self,
    octaspire_string_t const * const other)
{
    assert(self && other);

    size_t const myLen = octaspire_string_get_length_in_ucs_characters(self);
    size_t const otherLen = octaspire_string_get_length_in_ucs_characters(other);

    if (myLen < otherLen)
    {
        return false;
    }

    size_t const myStartIndex = myLen - otherLen;

    for (size_t i = 0; i < otherLen; ++i)
    {
        if (octaspire_string_get_ucs_character_at_index(
                self,
                (ptrdiff_t)(myStartIndex + i)) !=
            octaspire_string_get_ucs_character_at_index(
                other,
                (ptrdiff_t)i))
        {
            return false;
        }
    }

    return true;
}

uint32_t octaspire_string_get_hash(
    octaspire_string_t const * const self)
{
    uint32_t hash = 0;

    octaspire_string_private_ensure_octets_are_up_to_date(self);

    if (octaspire_vector_is_empty(self->octets))
    {
        return 0;
    }

    assert(*(char const*)octaspire_vector_peek_back_element_const(self->octets) == '\0');

    size_t const len = octaspire_vector_get_length(self->octets);

    if (!octaspire_vector_is_empty(self->octets))
    {
        hash = jenkins_one_at_a_time_hash(
            octaspire_vector_get_element_at(self->octets, 0), len);
    }

    return hash;
}

bool octaspire_string_push_back_ucs_character(
    octaspire_string_t *self,
    uint32_t const character)
{
    assert(self);

    if (!octaspire_vector_push_back_element(self->ucsCharacters, &character))
    {
        return false;
    }

    return octaspire_vector_clear(self->octets);
}

bool octaspire_string_pop_front_ucs_character(
    octaspire_string_t *self)
{
    assert(self);

    if (octaspire_string_is_empty(self))
    {
        return false;
    }

    if (!octaspire_vector_clear(self->octets))
    {
        return false;
    }

    return octaspire_string_remove_character_at(self, 0);
}

bool octaspire_string_pop_back_ucs_character(
    octaspire_string_t *self)
{
    assert(self);

    if (octaspire_string_is_empty(self))
    {
        return false;
    }

    if (!octaspire_vector_clear(self->octets))
    {
        return false;
    }

    return octaspire_string_remove_character_at(
        self,
        (ptrdiff_t)
            (octaspire_string_get_length_in_ucs_characters(self) - 1));
}

bool octaspire_string_insert_string_to(
    octaspire_string_t * const self,
    octaspire_string_t const * const str,
    ptrdiff_t const indexToPutFirstCharacterPossiblyNegative)
{
    octaspire_string_private_index_t const realIndex =
        octaspire_string_private_is_index_valid(
            self,
            indexToPutFirstCharacterPossiblyNegative);

    if (!realIndex.isValid)
    {
        return false;
    }

    if (!octaspire_vector_clear(self->octets))
    {
        return false;
    }

    for (size_t i = 0; i < octaspire_string_get_length_in_ucs_characters(str); ++i)
    {
        uint32_t const c =
            octaspire_string_get_ucs_character_at_index(
                str,
                (ptrdiff_t)i);

        if (!octaspire_vector_insert_element_before_the_element_at_index(
            self->ucsCharacters,
            &c,
            (ptrdiff_t)(realIndex.index + i)))
        {
            return false;
        }
    }

    return true;
}

bool octaspire_string_overwrite_with_string_at(
    octaspire_string_t * const self,
    octaspire_string_t const * const str,
    ptrdiff_t const indexToPutFirstCharacterPossiblyNegative)
{
    octaspire_string_private_index_t const realIndex =
        octaspire_string_private_is_index_valid(
            self,
            indexToPutFirstCharacterPossiblyNegative);

    if (!realIndex.isValid)
    {
        // New chars are pushed back if index is too large,
        // so no need to check that.
        if (indexToPutFirstCharacterPossiblyNegative < 0)
        {
            return false;
        }
    }

    if (!octaspire_vector_clear(self->octets))
    {
        return false;
    }

    for (size_t i = 0;
         i < octaspire_string_get_length_in_ucs_characters(str);
         ++i)
    {
        uint32_t const c =
            octaspire_string_get_ucs_character_at_index(
                str,
                (ptrdiff_t)i);

        if (!octaspire_vector_replace_element_at_index_or_push_back(
            self->ucsCharacters,
            &c,
            (ptrdiff_t)(realIndex.index + i)))
        {
            return false;
        }
    }

    return true;
}

octaspire_vector_t *octaspire_string_split(
    octaspire_string_t *self,
    char const * const delimiter)
{
    octaspire_string_t *delimString = octaspire_string_new(
        delimiter,
        self->allocator);

    if (!delimString)
    {
        return 0;
    }

    octaspire_vector_t *result = octaspire_vector_new(
        sizeof(octaspire_string_t*),
        true,
        (octaspire_vector_element_callback_t)octaspire_string_release,
        self->allocator);

    if (!result)
    {
        octaspire_string_release(delimString);
        delimString = 0;
        return 0;
    }

    octaspire_string_t *collectorString = octaspire_string_new(
        "",
        self->allocator);

    if (!collectorString)
    {
        octaspire_string_release(delimString);
        delimString = 0;

        octaspire_vector_release(result);
        result = 0;
        return 0;
    }

    for (size_t i = 0;
         i < octaspire_string_get_length_in_ucs_characters(self);
         ++i)
    {
        octaspire_string_push_back_ucs_character(
            collectorString,
            octaspire_string_get_ucs_character_at_index(
                self,
                (ptrdiff_t)i));

        if (octaspire_string_is_equal(collectorString, delimString))
        {
            octaspire_string_clear(collectorString);
        }
        else if (octaspire_string_ends_with(collectorString, delimString))
        {
            size_t const numUcsCharsToGet =
                octaspire_string_get_length_in_ucs_characters(collectorString) -
                octaspire_string_get_length_in_ucs_characters(delimString);

            octaspire_string_t *token =
                octaspire_string_new_substring_from_given_index_and_length(
                    collectorString,
                    collectorString->allocator,
                    0,
                    numUcsCharsToGet);

            assert(token);

            octaspire_vector_push_back_element(result, &token);

            octaspire_string_clear(collectorString);
        }
    }

    if (!octaspire_string_is_empty(collectorString))
    {
        if (octaspire_string_is_equal(collectorString, delimString))
        {
            octaspire_string_clear(collectorString);
        }
        else if (octaspire_string_ends_with(collectorString, delimString))
        {
            size_t const numUcsCharsToGet =
                octaspire_string_get_length_in_ucs_characters(collectorString) -
                octaspire_string_get_length_in_ucs_characters(delimString);

            octaspire_string_t *token =
                octaspire_string_new_substring_from_given_index_and_length(
                    collectorString,
                    collectorString->allocator,
                    0,
                    numUcsCharsToGet);

            assert(token);

            octaspire_vector_push_back_element(result, &token);

            octaspire_string_clear(collectorString);
        }
        else
        {
            octaspire_string_t *token =
                octaspire_string_new_copy(
                    collectorString,
                    collectorString->allocator);

            assert(token);

            octaspire_vector_push_back_element(result, &token);

            octaspire_string_clear(collectorString);
        }

        octaspire_string_clear(collectorString);
    }

    octaspire_string_release(collectorString);
    collectorString = 0;

    octaspire_string_release(delimString);
    delimString = 0;

    return result;
}

bool octaspire_string_contains_char(
    octaspire_string_t const * const self,
    uint32_t const character)
{
    for (size_t i = 0;
         i < octaspire_string_get_length_in_ucs_characters(self);
         ++i)
    {
        if (octaspire_string_get_ucs_character_at_index(
                self,
                (ptrdiff_t)i) == character)
        {
            return true;
        }
    }

    return false;
}

bool octaspire_string_contains_only_these_chars(
    octaspire_string_t const * const self,
    octaspire_string_t const * const chars)
{
    for (size_t i = 0;
         i < octaspire_string_get_length_in_ucs_characters(self);
         ++i)
    {
        uint32_t const selfChar =
            octaspire_string_get_ucs_character_at_index(
                self,
                (ptrdiff_t)i);

        bool found = false;

        for (size_t j = 0;
             j < octaspire_string_get_length_in_ucs_characters(chars);
             ++j)
        {
            if (octaspire_string_get_ucs_character_at_index(
                chars,
                (ptrdiff_t)j) == selfChar)
            {
                found = true;
                break;
            }
        }

        if (!found)
        {
            return false;
        }
    }

    return true;
}

bool octaspire_string_contains_only_these_chars_c_string(
    octaspire_string_t const * const self,
    char const * const chars)
{
    // TODO maybe a more efficient implementation.

    octaspire_string_t * const str =
        octaspire_string_new(chars, self->allocator);

    octaspire_helpers_verify_not_null(str);

    bool const result =
        octaspire_string_contains_only_these_chars(self, str);

    octaspire_string_release(str);
    return result;
}

octaspire_vector_t *octaspire_string_find_char(
    octaspire_string_t const * const self,
    octaspire_string_t const * const character,
    ptrdiff_t const characterIndexPossiblyNegative)
{
    octaspire_string_private_index_t const realIndex =
        octaspire_string_private_is_index_valid(
            character,
            characterIndexPossiblyNegative);

    if (!realIndex.isValid)
    {
        return 0;
    }

    octaspire_vector_t *result = octaspire_vector_new(
        sizeof(size_t),
        false,
        0,
        self->allocator);

    for (size_t i = 0;
         i < octaspire_string_get_length_in_ucs_characters(self);
         ++i)
    {
        if (octaspire_string_get_ucs_character_at_index(
                self,
                (ptrdiff_t)i) ==
            octaspire_string_get_ucs_character_at_index(
                character,
                (ptrdiff_t)realIndex.index))
        {
            octaspire_vector_push_back_element(result, &i);
        }
    }

    return result;
}

static bool octaspire_string_private_ensure_octets_are_up_to_date(
    octaspire_string_t const * const self)
{
    if (!octaspire_vector_is_empty(self->octets))
    {
        return true;
    }

    for (size_t i = 0; i < octaspire_vector_get_length(self->ucsCharacters); ++i)
    {
        octaspire_utf8_character_t encoded;

        uint32_t const ucsChar = *(uint32_t const * const)
            octaspire_vector_get_element_at_const(
                self->ucsCharacters,
                (ptrdiff_t)i);

        octaspire_utf8_encode_status_t const status = octaspire_utf8_encode_character(
            ucsChar,
            &encoded);

        if (status != OCTASPIRE_UTF8_ENCODE_STATUS_OK)
        {
            return false;
        }

        for (size_t j = 0; j < encoded.numoctets; ++j)
        {
            // Ugly; force into non-const.
            if (!octaspire_vector_push_back_element(
                    (octaspire_vector_t * const)self->octets,
                    encoded.octets + 4 - encoded.numoctets + j))
            {
                return false;
            }
        }
    }

    // Append null byte to allow use with libc
    // Ugly; force into non-const.
    if (!octaspire_vector_push_back_element(
        (octaspire_vector_t * const)self->octets,
        &octaspire_string_private_null_octet))
    {
        return false;
    }

    return true;
}

bool octaspire_string_private_is_string_at_index(
    octaspire_string_t const * const self,
    size_t const selfIndex,
    octaspire_string_t const * const str,
    size_t const strFirstIndex,
    size_t const strLastIndex)
{
    size_t selfIndex2 = selfIndex;
    for (size_t i = strFirstIndex; i <= strLastIndex; ++i)
    {
        if (selfIndex2 >= octaspire_string_get_length_in_ucs_characters(self))
        {
            return false;
        }

        if (octaspire_string_get_ucs_character_at_index(
                self,
                (ptrdiff_t)selfIndex2) !=
            octaspire_string_get_ucs_character_at_index(
                str,
                (ptrdiff_t)i))
        {
            return false;
        }

        ++selfIndex2;
    }

    return true;
}

octaspire_vector_t *octaspire_string_find_string(
    octaspire_string_t const * const self,
    octaspire_string_t const * const str,
    ptrdiff_t const strStartIndexPossiblyNegative,
    size_t const strLength)
{
    if (!strLength)
    {
        return 0;
    }

    octaspire_string_private_index_t const realIndex =
        octaspire_string_private_is_index_valid(str, strStartIndexPossiblyNegative);

    if (!realIndex.isValid)
    {
        return 0;
    }

    size_t const strEndIndex = realIndex.index + (strLength - 1);

    if (strEndIndex >= octaspire_string_get_length_in_ucs_characters(str))
    {
        return 0;
    }

    octaspire_vector_t *result = octaspire_vector_new(
        sizeof(size_t),
        false,
        0,
        self->allocator);

    for (size_t i = 0; i < octaspire_string_get_length_in_ucs_characters(self); ++i)
    {
        if (octaspire_string_private_is_string_at_index(
            self,
            i,
            str,
            realIndex.index,
            strEndIndex))
        {
            octaspire_vector_push_back_element(result, &i);
        }
    }

    return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_string.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_pair.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_pair_t
{
    void   *first;
    void   *second;
    size_t firstSize;
    size_t secondSize;
    octaspire_pair_element_callback_t firstReleaseCallback;
    octaspire_pair_element_callback_t secondReleaseCallback;
    octaspire_allocator_t *allocator;
    bool   firstIsPointer;
    bool   secondIsPointer;
    char   padding[6];
};

size_t octaspire_pair_t_get_sizeof(void)
{
    return sizeof(octaspire_pair_t);
}

octaspire_pair_t *octaspire_pair_new(
    size_t const firstElementSize,
    bool const firstElementIsPointer,
    size_t const secondElementSize,
    bool const secondElementIsPointer,
    octaspire_pair_element_callback_t firstElementReleaseCallback,
    octaspire_pair_element_callback_t secondElementReleaseCallback,
    octaspire_allocator_t *allocator)
{
    octaspire_pair_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_pair_t));

    if (!self)
    {
        return self;
    }

    self->allocator             = allocator;
    self->first                 = 0;
    self->second                = 0;
    self->firstSize             = firstElementSize;
    self->firstIsPointer        = firstElementIsPointer;
    self->secondSize            = secondElementSize;
    self->secondIsPointer       = secondElementIsPointer;
    self->firstReleaseCallback  = firstElementReleaseCallback;
    self->secondReleaseCallback = secondElementReleaseCallback;

    self->first = octaspire_allocator_malloc(self->allocator, self->firstSize);

    if (!self->first)
    {
        octaspire_pair_release(self);
        self = 0;
        return 0;
    }

    self->second = octaspire_allocator_malloc(self->allocator, self->secondSize);

    if (!self->second)
    {
        octaspire_pair_release(self);
        self = 0;
        return 0;
    }

    return self;
}

octaspire_pair_t *octaspire_pair_new_shallow_copy(
    octaspire_pair_t   *other,
    octaspire_allocator_t *allocator)
{
    octaspire_pair_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_pair_t));

    if (!self)
    {
        return self;
    }

    self->allocator = allocator;
    self->first                 = 0;
    self->second                = 0;
    self->firstSize             = other->firstSize;
    self->firstIsPointer        = other->firstIsPointer;
    self->secondSize            = other->secondSize;
    self->secondIsPointer       = other->secondIsPointer;
    self->firstReleaseCallback  = other->firstReleaseCallback;
    self->secondReleaseCallback = other->secondReleaseCallback;

    self->first  = octaspire_allocator_malloc(self->allocator, self->firstSize);

    if (!self->first)
    {
        octaspire_pair_release(self);
        self = 0;
        return 0;
    }

    self->second = octaspire_allocator_malloc(self->allocator, self->secondSize);

    if (!self->second)
    {
        octaspire_pair_release(self);
        self = 0;
        return 0;
    }

    if (self->first != memcpy(self->first,  other->first,  self->firstSize))
    {
        octaspire_pair_release(self);
        self = 0;
        return 0;
    }

    if (self->second != memcpy(self->second, other->second, self->secondSize))
    {
        octaspire_pair_release(self);
        self = 0;
        return 0;
    }

    return self;
}

void octaspire_pair_release(octaspire_pair_t *self)
{
    if (!self)
    {
        return;
    }

    if (self->firstReleaseCallback)
    {
        if (self->firstIsPointer)
        {
            if (self->first)
            {
                (self->firstReleaseCallback)(*(void**)self->first);
            }
        }
        else
        {
            (self->firstReleaseCallback)(self->first);
        }
    }

    if (self->first)
    {
        octaspire_allocator_free(self->allocator, self->first);
        self->first = 0;
    }

    if (self->secondReleaseCallback)
    {
        if (self->secondIsPointer)
        {
            if (self->second)
            {
                (self->secondReleaseCallback)(*(void**)self->second);
            }
        }
        else
        {
            (self->secondReleaseCallback)(self->second);
        }
    }

    if (self->second)
    {
        octaspire_allocator_free(self->allocator, self->second);
        self->second = 0;
    }

    octaspire_allocator_free(self->allocator, self);
}

void *octaspire_pair_get_first(octaspire_pair_t *self)
{
    return self->firstIsPointer ? (*(void**)self->first) : self->first;
}

void const *octaspire_pair_get_first_const(octaspire_pair_t const * const self)
{
    return self->firstIsPointer ? (*(void const **)self->first) : self->first;
}

void *octaspire_pair_get_second(octaspire_pair_t *self)
{
    return self->secondIsPointer ? (*(void**)self->second) : self->second;
}

void const *octaspire_pair_get_second_const(octaspire_pair_t const * const self)
{
    return self->secondIsPointer ? (*(void const **)self->second) : self->second;
}

size_t octaspire_pair_get_size_of_first_element_in_octets(
    octaspire_pair_t const * const self)
{
    return self->firstSize;
}

size_t octaspire_pair_get_size_of_second_element_in_octets(
    octaspire_pair_t const * const self)
{
    return self->secondSize;
}

void octaspire_pair_set(
    octaspire_pair_t *self,
    void const *first,
    void const *second)
{
    octaspire_pair_set_first( self, first);
    octaspire_pair_set_second(self, second);
}

void octaspire_pair_set_first(
    octaspire_pair_t *self,
    void const *first)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(first);
    if (self->first != memcpy(self->first,  first,  self->firstSize))
    {
        abort();
    }
}

void octaspire_pair_set_second(
    octaspire_pair_t *self,
    void const *second)
{
    if (self->second != memcpy(self->second, second, self->secondSize))
    {
        abort();
    }
}

bool octaspire_pair_set_first_to_void_pointer(
    octaspire_pair_t *self,
    void *element)
{
    if (self->firstSize != sizeof(element))
    {
        return false;
    }

    octaspire_pair_set_first(self, &element);

    return true;
}

bool octaspire_pair_set_second_to_void_pointer(
    octaspire_pair_t *self,
    void *element)
{
    if (self->secondSize != sizeof(element))
    {
        return false;
    }

    octaspire_pair_set_second(self, &element);

    return true;
}

void octaspire_pair_clear(
    octaspire_pair_t * const self)
{
    if (self->first != memset(self->first,  0, self->firstSize))
    {
        abort();
    }

    if (self->second != memset(self->second, 0, self->secondSize))
    {
        abort();
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_pair.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_map.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/



struct octaspire_map_element_t
{
    size_t                        keySizeInOctets;
    void                         *key;
    size_t                        valueSizeInOctets;
    octaspire_vector_t *values;
    octaspire_allocator_t        *allocator;
    uint32_t                      hash;
    bool                          keyIsPointer;
    bool                          valueIsPointer;
    char                          padding[2];
};

octaspire_map_element_t *octaspire_map_element_new(
    uint32_t const hash,
    size_t const keySizeInOctets,
    bool const keyIsPointer,
    void const * const key,
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    void const * const value,
    octaspire_allocator_t * const allocator)
{
    octaspire_map_element_t *self = octaspire_allocator_malloc(
        allocator,
        sizeof(octaspire_map_element_t));

    if (!self)
    {
        return self;
    }

    self->allocator = allocator;
    self->hash = hash;
    self->keySizeInOctets = keySizeInOctets;
    self->keyIsPointer    = keyIsPointer;
    self->key = octaspire_allocator_malloc(self->allocator, self->keySizeInOctets);

    if (!self->key)
    {
        octaspire_map_element_release(self);
        self = 0;
        return 0;
    }

    if (self->key != memcpy(self->key, key, self->keySizeInOctets))
    {
        abort();
    }

    self->valueSizeInOctets = valueSizeInOctets;
    self->valueIsPointer    = valueIsPointer;
    //self->value = octaspire_allocator_malloc(self->allocator, self->valueSizeInOctets);

    self->values = octaspire_vector_new(
        valueSizeInOctets,
        valueIsPointer,
        0,
        allocator);

    if (!self->values)
    {
        octaspire_map_element_release(self);
        self = 0;
        return 0;
    }

    if (!octaspire_vector_push_back_element(self->values, value))
    {
        abort();
    }

    return self;
}

void octaspire_map_element_release(octaspire_map_element_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_allocator_free(self->allocator, self->key);
    self->key = 0;

    //octaspire_allocator_free(self->allocator, self->value);
    //self->value= 0;

    octaspire_vector_release(self->values);
    self->values = 0;

    octaspire_allocator_free(self->allocator, self);
}

uint32_t octaspire_map_element_get_hash(
    octaspire_map_element_t const * const self)
{
    assert(self);
    return self->hash;
}

void *octaspire_map_element_get_key(
    octaspire_map_element_t const * const self)
{
    assert(self);
    return self->keyIsPointer ? (*(void**)self->key) : self->key;
}

octaspire_vector_t *octaspire_map_element_get_values(
    octaspire_map_element_t * const self)
{
    return self->values;
}

void *octaspire_map_element_get_value(
    octaspire_map_element_t const * const self)
{
    assert(self);
    assert(octaspire_vector_get_length(self->values) < 2);
    return octaspire_vector_get_element_at(self->values, 0);
    //return self->valueIsPointer ? (*(void**)self->value) : self->value;
}

void const *octaspire_map_element_get_key_const(
    octaspire_map_element_t const * const self)
{
    assert(self);
    return self->keyIsPointer ? (*(void const**)self->key) : self->key;
}

void const *octaspire_map_element_get_value_const(
    octaspire_map_element_t const * const self)
{
    assert(self);
    assert(octaspire_vector_get_length(self->values) < 2);
    return octaspire_vector_get_element_at_const(self->values, 0);
}



struct octaspire_map_t
{
    size_t                                                   keySizeInOctets;
    size_t                                                   valueSizeInOctets;
    octaspire_allocator_t                                   *allocator;
    octaspire_vector_t                            *buckets;
    octaspire_map_key_compare_function_t      keyCompareFunction;
    octaspire_map_key_hash_function_t         keyHashFunction;
    octaspire_map_element_callback_t     keyReleaseCallback;
    octaspire_map_element_callback_t     valueReleaseCallback;
    size_t                                                   numBucketsInUse;
    size_t                                                   numElements;
    bool                                                     keyIsPointer;
    bool                                                     valueIsPointer;
    char                                                     padding[6];
};

static size_t const OCTASPIRE_MAP_SMALLEST_SIZE   = 128;
static float  const OCTASPIRE_MAP_MAX_LOAD_FACTOR = 0.75f;

// Prototypes for static functions
static octaspire_vector_t *octaspire_map_private_build_new_buckets(
    octaspire_map_t *self,
    size_t const numBuckets,
    octaspire_allocator_t *allocator);

static float octaspire_map_private_get_load_factor(
    octaspire_map_t const * const self);

static bool octaspire_map_private_rehash(
    octaspire_map_t * const self);

static void octaspire_map_private_release_given_buckets(
    octaspire_map_t *self,
    octaspire_vector_t **bucketsPtr);


static bool octaspire_map_private_rehash(
    octaspire_map_t * const self)
{
    assert(self);

    size_t const oldBucketCount = octaspire_vector_get_length(self->buckets);
    size_t const newBucketCount = oldBucketCount * 2;

    assert(oldBucketCount && newBucketCount);

    octaspire_vector_t *newBuckets =
        octaspire_map_private_build_new_buckets(self, newBucketCount, self->allocator);

    self->numBucketsInUse = 0;
    self->numElements     = 0;

    if (!newBuckets)
    {
        return false;
    }

    for (size_t i = 0; i < oldBucketCount; ++i)
    {
        octaspire_vector_t *oldBucket =
            (octaspire_vector_t*)octaspire_vector_get_element_at(
                self->buckets,
                (ptrdiff_t)i);

        for (size_t j = 0; j < octaspire_vector_get_length(oldBucket); ++j)
        {
            octaspire_map_element_t *element =
                (octaspire_map_element_t*)octaspire_vector_get_element_at(
                    oldBucket,
                    (ptrdiff_t)j);

            uint32_t hash = octaspire_map_element_get_hash(element);

            size_t const bucketIndex = hash % newBucketCount;

            octaspire_vector_t *bucket =
                (octaspire_vector_t*)octaspire_vector_get_element_at(
                    newBuckets,
                    (ptrdiff_t)bucketIndex);

            assert(bucket);

            if (octaspire_vector_is_empty(bucket))
            {
                ++(self->numBucketsInUse);
            }

            if (!octaspire_vector_push_back_element(bucket, &element))
            {
                return false;
            }

            ++(self->numElements);
        }

        octaspire_vector_release(oldBucket);
        oldBucket = 0;
    }

    octaspire_vector_release(self->buckets);
    self->buckets = 0;

    self->buckets = newBuckets;

    assert(octaspire_map_private_get_load_factor(self) <
        OCTASPIRE_MAP_MAX_LOAD_FACTOR);

    return true;
}

static float octaspire_map_private_get_load_factor(
    octaspire_map_t const * const self)
{
    return (float)self->numBucketsInUse / octaspire_vector_get_length(self->buckets);
}

static void octaspire_map_private_release_given_buckets(
    octaspire_map_t *self,
    octaspire_vector_t **bucketsPtr)
{
    assert(self && bucketsPtr && *bucketsPtr);

    octaspire_vector_t *buckets = *bucketsPtr;

    size_t const numBuckets = octaspire_vector_get_length(buckets);

    for (size_t i = 0; i < numBuckets; ++i)
    {
        octaspire_vector_t *bucket =
            (octaspire_vector_t*)octaspire_vector_get_element_at(
                buckets,
                (ptrdiff_t)i);

        assert(bucket);

        for (size_t j = 0; j < octaspire_vector_get_length(bucket); ++j)
        {
            octaspire_map_element_t *element = (octaspire_map_element_t*)
                octaspire_vector_get_element_at(bucket, (ptrdiff_t)j);

            if (self->valueReleaseCallback)
            {
                for (size_t k = 0; k < octaspire_vector_get_length(element->values); ++k)
                {
                    //self->valueReleaseCallback(*(void**)element->value);
                    self->valueReleaseCallback(
                        octaspire_vector_get_element_at(
                            element->values,
                            (ptrdiff_t)k));
                }
            }

            if (self->keyReleaseCallback)
            {
                if (element->keyIsPointer)
                {
                    self->keyReleaseCallback(*(void**)element->key);
                }
                else
                {
                    self->keyReleaseCallback(element->key);
                }
            }

            octaspire_map_element_release(element);
        }

        //octaspire_vector_clear(bucket);
        octaspire_vector_release(bucket);
        bucket = 0;

    }

    octaspire_vector_release(buckets);
    *bucketsPtr = 0;
}

static octaspire_vector_t *octaspire_map_private_build_new_buckets(
    octaspire_map_t *self,
    size_t const numBuckets,
    octaspire_allocator_t *allocator)
{
    octaspire_vector_t *buckets = octaspire_vector_new_with_preallocated_elements(
        sizeof(octaspire_vector_t*),
        true,
        numBuckets,
        0, //(octaspire_vector_element_callback_t)octaspire_vector_release,
        allocator);

    if (!buckets)
    {
        return 0;
    }

    for (size_t i = 0; i < numBuckets; ++i)
    {
        octaspire_vector_t *bucket = octaspire_vector_new(
            sizeof(octaspire_map_element_t *),
            true,
            0, // (octaspire_vector_element_callback_t)octaspire_map_element_release,
            allocator);

        if (!bucket)
        {
            octaspire_map_private_release_given_buckets(self, &buckets);
            assert(!buckets);
            return 0;
        }

        if (!octaspire_vector_push_back_element(buckets, &bucket))
        {
            // This should never happen, because numBuckets buckets are
            // preallocated on the vector. So assert could be
            // used here, but maybe this is still safer?
            octaspire_map_private_release_given_buckets(self, &buckets);
            assert(!buckets);
            return 0;
        }
    }

    assert(octaspire_vector_get_length(buckets) == numBuckets);

    return buckets;
}

octaspire_map_t *octaspire_map_new(
    size_t const keySizeInOctets,
    bool const keyIsPointer,
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    octaspire_map_key_compare_function_t keyCompareFunction,
    octaspire_map_key_hash_function_t keyHashFunction,
    octaspire_map_element_callback_t keyReleaseCallback,
    octaspire_map_element_callback_t valueReleaseCallback,
    octaspire_allocator_t *allocator)
{
    octaspire_map_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_map_t));

    if (!self)
    {
        return self;
    }

    self->keySizeInOctets      = keySizeInOctets;
    self->keyIsPointer         = keyIsPointer;
    self->valueSizeInOctets    = valueSizeInOctets;
    self->valueIsPointer       = valueIsPointer;
    self->allocator            = allocator;
    self->keyCompareFunction   = keyCompareFunction;
    self->keyHashFunction      = keyHashFunction;
    self->keyReleaseCallback   = keyReleaseCallback;
    self->valueReleaseCallback = valueReleaseCallback;
    self->numBucketsInUse      = 0;
    self->numElements          = 0;

    self->buckets = octaspire_map_private_build_new_buckets(
        self,
        OCTASPIRE_MAP_SMALLEST_SIZE,
        self->allocator);

    if (!self->buckets)
    {
        octaspire_map_release(self);
        self = 0;
        return 0;
    }

    return self;
}

octaspire_map_t *octaspire_map_new_with_octaspire_string_keys(
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    octaspire_map_element_callback_t valueReleaseCallback,
    octaspire_allocator_t *allocator)
{
    return octaspire_map_new(
        sizeof(octaspire_string_t*),
        true,
        valueSizeInOctets,
        valueIsPointer,
        (octaspire_map_key_compare_function_t)octaspire_string_is_equal,
        (octaspire_map_key_hash_function_t)octaspire_string_get_hash,
        (octaspire_map_element_callback_t)octaspire_string_release,
        valueReleaseCallback,
        allocator);
}

static bool octaspire_map_helper_private_size_t_is_equal(
    size_t const * const first,
    size_t const * const second)
{
    return *first == *second;
}

uint32_t octaspire_map_helper_size_t_get_hash(
    size_t const value)
{
    return jenkins_one_at_a_time_hash(&value, sizeof(value));
}

octaspire_map_t *octaspire_map_new_with_size_t_keys(
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    octaspire_map_element_callback_t valueReleaseCallback,
    octaspire_allocator_t *allocator)
{
    return octaspire_map_new(
        sizeof(size_t),
        false,
        valueSizeInOctets,
        valueIsPointer,
        (octaspire_map_key_compare_function_t)
            octaspire_map_helper_private_size_t_is_equal,
        (octaspire_map_key_hash_function_t)octaspire_map_helper_size_t_get_hash,
        (octaspire_map_element_callback_t)0,
        valueReleaseCallback,
        allocator);
}

void octaspire_map_release(octaspire_map_t *self)
{
    if (!self)
    {
        return;
    }

    if (self->buckets)
    {
        octaspire_map_private_release_given_buckets(self, &(self->buckets));
        assert(!(self->buckets));
    }

    self->buckets = 0;

    octaspire_allocator_free(self->allocator, self);
}

bool octaspire_map_remove(
    octaspire_map_t *self,
    uint32_t const hash,
    void const * const key)
{
    size_t const bucketIndex = hash % octaspire_vector_get_length(self->buckets);

    octaspire_vector_t *bucket =
        (octaspire_vector_t*)octaspire_vector_get_element_at(
            self->buckets,
            (ptrdiff_t)bucketIndex);

    if (!bucket)
    {
        return false;
    }

    size_t const numElementsInBucket = octaspire_vector_get_length(bucket);

    for (size_t i = 0; i < numElementsInBucket; ++i)
    {
        octaspire_map_element_t *element =
            (octaspire_map_element_t*)octaspire_vector_get_element_at(
                bucket,
                (ptrdiff_t)i);

        assert(element);

        void const * key2 = octaspire_map_element_get_key(element);

        if (self->keyCompareFunction(element->keyIsPointer ? *(void const * const *)key : key, key2))
        {
            if (self->valueReleaseCallback)
            {
                for (size_t j = 0; j < octaspire_vector_get_length(element->values); ++j)
                {
                    //self->valueReleaseCallback(*(void**)element->value);
                    self->valueReleaseCallback(
                        octaspire_vector_get_element_at(
                            element->values,
                            (ptrdiff_t)j));
                }
            }

            if (self->keyReleaseCallback)
            {
                if (element->keyIsPointer)
                {
                    self->keyReleaseCallback(*(void**)element->key);
                }
                else
                {
                    self->keyReleaseCallback(element->key);
                }
            }

            octaspire_map_element_release(element);
            if (octaspire_vector_remove_element_at(bucket, (ptrdiff_t)i))
            {
                --(self->numElements);
                return true;
            }
            else
            {
                return false;
            }
        }
    }

    return false;
}

bool octaspire_map_clear(
    octaspire_map_t * const self)
{
    // TODO XXX how to this in best way?

    octaspire_vector_t *buckets = octaspire_map_private_build_new_buckets(
        self,
        OCTASPIRE_MAP_SMALLEST_SIZE,
        self->allocator);

    if (!buckets)
    {
        return false;
    }

    if (self->buckets)
    {
        octaspire_map_private_release_given_buckets(self, &(self->buckets));
        assert(!(self->buckets));
    }

    self->buckets = buckets;

    self->numBucketsInUse = 0;
    self->numElements     = 0;

    return true;
}

bool octaspire_map_add_hash_map(
    octaspire_map_t * const self,
    octaspire_map_t * const other)
{
    bool result = true;

    for (size_t i = 0; i < octaspire_map_get_number_of_elements(other); ++i)
    {
        octaspire_map_element_t *otherElement =
            octaspire_map_get_at_index(other, (ptrdiff_t)i);

        for (size_t j = 0; j < octaspire_vector_get_length(otherElement->values); ++j)
        {
            void * const key   = otherElement->key;
            void * const value = octaspire_vector_get_element_at(
                otherElement->values,
                (ptrdiff_t)j);

            if (!octaspire_map_put(
                self,
                otherElement->hash,
                key,
                &value))
            {
                result = false;
            }
        }
    }

    return result;
}

bool octaspire_map_put(
    octaspire_map_t *self,
    uint32_t const hash,
    void const * const key,
    void const * const value)
{
    assert(self);
    assert(octaspire_vector_get_length(self->buckets));

    octaspire_map_element_t *element =
        octaspire_map_get(self, hash, key);

    if (element)
    {
        return octaspire_vector_push_back_element(element->values, value);
    }
    else
    {
        //octaspire_map_remove(self, hash, key);

        size_t const bucketIndex = hash % octaspire_vector_get_length(self->buckets);

        octaspire_vector_t *bucket =
            (octaspire_vector_t*)octaspire_vector_get_element_at(
                self->buckets,
                (ptrdiff_t)bucketIndex);

        assert(bucket);

        if (octaspire_vector_is_empty(bucket))
        {
            ++(self->numBucketsInUse);
        }

        element = octaspire_map_element_new(
            hash,
            self->keySizeInOctets,
            self->keyIsPointer,
            key,
            self->valueSizeInOctets,
            self->valueIsPointer,
            value,
            self->allocator);

        if (!octaspire_vector_push_back_element(bucket, &element))
        {
            return false;
        }

        ++(self->numElements);

        if (octaspire_map_private_get_load_factor(self) >=
                OCTASPIRE_MAP_MAX_LOAD_FACTOR)
        {
            if (!octaspire_map_private_rehash(self))
            {
                return false;
            }
        }

        return true;
    }
}

octaspire_map_element_t const * octaspire_map_get_const(
    octaspire_map_t const * const self,
    uint32_t const hash,
    void const * const key)
{
    size_t const bucketIndex = hash % octaspire_vector_get_length(self->buckets);

    octaspire_vector_t *bucket =
        (octaspire_vector_t*)octaspire_vector_get_element_at(
            self->buckets,
            (ptrdiff_t)bucketIndex);

    assert(bucket);

    size_t const numElementsInBucket = octaspire_vector_get_length(bucket);

    if (numElementsInBucket == 1)
    {
        octaspire_map_element_t *element = (octaspire_map_element_t*)
            octaspire_vector_peek_front_element(bucket);

        assert(element);

        void const * const key2 = octaspire_map_element_get_key(element);

        if (self->keyCompareFunction(element->keyIsPointer ? *(void const * const *)key : key, key2))
        {
            return element;
        }

        return 0;
    }

    for (size_t i = 0; i < numElementsInBucket; ++i)
    {
        octaspire_map_element_t *element =
            (octaspire_map_element_t*)octaspire_vector_get_element_at(
                bucket,
                (ptrdiff_t)i);

        assert(element);

        void const * const key2 = octaspire_map_element_get_key(element);

        if (self->keyCompareFunction(element->keyIsPointer ? *(void const * const *)key : key, key2))
        {
            return element;
        }
    }

    return 0;
}

octaspire_map_element_t *octaspire_map_get(
    octaspire_map_t *self, uint32_t const hash, void const * const key)
{
    size_t const bucketIndex = hash % octaspire_vector_get_length(self->buckets);

    octaspire_vector_t *bucket =
        (octaspire_vector_t*)octaspire_vector_get_element_at(
            self->buckets,
            (ptrdiff_t)bucketIndex);

    assert(bucket);

    size_t const numElementsInBucket = octaspire_vector_get_length(bucket);

    if (numElementsInBucket == 1)
    {
        octaspire_map_element_t *element = (octaspire_map_element_t*)
            octaspire_vector_peek_front_element(bucket);

        assert(element);

        void const * key2 = octaspire_map_element_get_key(element);

        if (self->keyCompareFunction(element->keyIsPointer ? *(void const * const *)key : key, key2))
        {
            return element;
        }

        return 0;
    }

    for (size_t i = 0; i < numElementsInBucket; ++i)
    {
        octaspire_map_element_t *element =
            (octaspire_map_element_t*)octaspire_vector_get_element_at(
                bucket,
                (ptrdiff_t)i);

        assert(element);

        void const * key2 = octaspire_map_element_get_key(element);

        if (self->keyCompareFunction(element->keyIsPointer ? *(void const * const *)key : key, key2))
        {
            return element;
        }
    }

    return 0;
}

bool octaspire_map_is_empty(octaspire_map_t const * const self)
{
    return (octaspire_map_get_number_of_elements(self) == 0);
}

size_t octaspire_map_get_number_of_elements(octaspire_map_t const * const self)
{
    assert(self);
    return self->numElements;
}

octaspire_map_element_t *octaspire_map_get_at_index(
    octaspire_map_t * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    if (possiblyNegativeIndex < 0)
    {
        if (octaspire_vector_is_empty(self->buckets))
        {
            return 0;
        }

        size_t index   = (size_t)(-(possiblyNegativeIndex+1));
        size_t counter = 0;
        for (ptrdiff_t i = (ptrdiff_t)octaspire_vector_get_length(self->buckets) - 1; i >= 0; --i)
        {
            octaspire_vector_t * const bucket = (octaspire_vector_t*)
                octaspire_vector_get_element_at(
                    self->buckets,
                    i);

            size_t const bucketSize = octaspire_vector_get_length(bucket);

            if (bucketSize)
            {
                if (index <= (counter + bucketSize - 1))
                {
                    return (octaspire_map_element_t*)
                        octaspire_vector_get_element_at(
                            bucket,
                            -((ptrdiff_t)(index - counter)));
                }

                counter += bucketSize;
            }
        }

        return 0;
    }
    else
    {
        size_t counter = 0;
        for (size_t i = 0; i < octaspire_vector_get_length(self->buckets); ++i)
        {
            octaspire_vector_t * const bucket = (octaspire_vector_t*)
                octaspire_vector_get_element_at(
                    self->buckets,
                    (ptrdiff_t)i);

            size_t const bucketSize = octaspire_vector_get_length(bucket);

            if (bucketSize)
            {
                if ((size_t)possiblyNegativeIndex <= (counter + bucketSize - 1))
                {
                    return (octaspire_map_element_t*)
                        octaspire_vector_get_element_at(
                            bucket,
                            possiblyNegativeIndex - (ptrdiff_t)counter);
                }

                counter += bucketSize;
            }
        }

        return 0;
    }
}

octaspire_map_element_iterator_t
octaspire_map_element_iterator_init(
    octaspire_map_t * const self)
{
    octaspire_map_element_iterator_t iterator;

    iterator.hashMap = self;
    iterator.bucketIndex = 0;
    iterator.elementInsideBucketIndex = 0;
    iterator.element = 0;

    while (!(iterator.element))
    {
        if (iterator.bucketIndex < octaspire_vector_get_length(self->buckets))
        {
            octaspire_vector_t * const bucket = (octaspire_vector_t*)
                octaspire_vector_get_element_at(
                    self->buckets,
                    (ptrdiff_t)(iterator.bucketIndex));

            size_t const bucketSize = octaspire_vector_get_length(bucket);

            for (; iterator.elementInsideBucketIndex < bucketSize; ++(iterator.elementInsideBucketIndex))
            {
                iterator.element = (octaspire_map_element_t*)
                    octaspire_vector_get_element_at(
                        bucket,
                        (ptrdiff_t)(iterator.elementInsideBucketIndex));

                if (iterator.element)
                {
                    break;
                }
            }
        }
        else
        {
            break;
        }

        if (iterator.element)
        {
            return iterator;
        }

        ++(iterator.bucketIndex);
        iterator.elementInsideBucketIndex = 0;
    }

    return iterator;
}

bool octaspire_map_element_iterator_next(
    octaspire_map_element_iterator_t * const self)
{
    self->element = 0;
    ++(self->elementInsideBucketIndex);

    while (!(self->element))
    {
        if (self->bucketIndex < octaspire_vector_get_length(self->hashMap->buckets))
        {
            octaspire_vector_t * const bucket = (octaspire_vector_t*)
                octaspire_vector_get_element_at(
                    self->hashMap->buckets,
                    (ptrdiff_t)(self->bucketIndex));

            size_t const bucketSize = octaspire_vector_get_length(bucket);

            for (; self->elementInsideBucketIndex < bucketSize; ++(self->elementInsideBucketIndex))
            {
                self->element = (octaspire_map_element_t*)
                    octaspire_vector_get_element_at(
                        bucket,
                        (ptrdiff_t)(self->elementInsideBucketIndex));

                if (self->element)
                {
                    break;
                }
            }
        }
        else
        {
            break;
        }

        if (self->element)
        {
            return self->element != 0;
        }

        ++(self->bucketIndex);
        self->elementInsideBucketIndex = 0;
    }

    return self->element != 0;
}


octaspire_map_element_const_iterator_t
octaspire_map_element_const_iterator_init(
    octaspire_map_t const * const self)
{
    octaspire_map_element_const_iterator_t iterator;

    iterator.hashMap = self;
    iterator.bucketIndex = 0;
    iterator.elementInsideBucketIndex = 0;
    iterator.element = 0;

    while (!(iterator.element))
    {
        if (iterator.bucketIndex < octaspire_vector_get_length(self->buckets))
        {
            octaspire_vector_t const * const bucket =
                (octaspire_vector_t const *)
                octaspire_vector_get_element_at_const(
                    self->buckets,
                    (ptrdiff_t)(iterator.bucketIndex));

            size_t const bucketSize = octaspire_vector_get_length(bucket);

            for (; iterator.elementInsideBucketIndex < bucketSize; ++(iterator.elementInsideBucketIndex))
            {
                iterator.element = (octaspire_map_element_t const *)
                    octaspire_vector_get_element_at_const(
                        bucket,
                        (ptrdiff_t)(iterator.elementInsideBucketIndex));

                if (iterator.element)
                {
                    break;
                }
            }
        }
        else
        {
            break;
        }

        if (iterator.element)
        {
            return iterator;
        }

        ++(iterator.bucketIndex);
        iterator.elementInsideBucketIndex = 0;
    }

    return iterator;
}

bool octaspire_map_element_const_iterator_next(
    octaspire_map_element_const_iterator_t * const self)
{
    self->element = 0;
    ++(self->elementInsideBucketIndex);

    while (!(self->element))
    {
        if (self->bucketIndex < octaspire_vector_get_length(self->hashMap->buckets))
        {
            octaspire_vector_t const * const bucket =
                (octaspire_vector_t const *)
                octaspire_vector_get_element_at_const(
                    self->hashMap->buckets,
                    (ptrdiff_t)(self->bucketIndex));

            size_t const bucketSize = octaspire_vector_get_length(bucket);

            for (; self->elementInsideBucketIndex < bucketSize; ++(self->elementInsideBucketIndex))
            {
                self->element = (octaspire_map_element_t const *)
                    octaspire_vector_get_element_at_const(
                        bucket,
                        (ptrdiff_t)(self->elementInsideBucketIndex));

                if (self->element)
                {
                    break;
                }
            }
        }
        else
        {
            break;
        }

        if (self->element)
        {
            return self->element != 0;
        }

        ++(self->bucketIndex);
        self->elementInsideBucketIndex = 0;
    }

    return self->element != 0;
}


//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_map.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_input.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_input_t
{
    octaspire_string_t *text;
    size_t                             index;
    size_t                             line;
    size_t                             column;
    octaspire_allocator_t             *allocator;
};

bool octaspire_input_private_is_ucs_character_index_valid(
    octaspire_input_t const * const self,
    size_t index);

octaspire_input_t *octaspire_input_new_from_c_string(
    char const * const str,
    octaspire_allocator_t *allocator)
{
    return octaspire_input_new_from_buffer(str, str ? strlen(str) : 0, allocator);
}

octaspire_input_t *octaspire_input_new_from_buffer(
    char const * const buffer,
    size_t const lengthInOctets,
    octaspire_allocator_t *allocator)
{
    octaspire_input_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_input_t));

    if (!self)
    {
        return self;
    }

    self->allocator = allocator;

    self->index  = 0;
    self->line   = 1;
    self->column = 1;

    self->text   = octaspire_string_new_from_buffer(buffer, lengthInOctets, self->allocator);

    if (!self->text)
    {
        octaspire_input_release(self);
        self = 0;
        return 0;
    }

    return self;
}

octaspire_input_t *octaspire_input_new_from_path(
    char const * const path,
    octaspire_allocator_t *octaspireAllocator,
    octaspire_stdio_t *octaspireStdio)
{
    size_t octetsAllocated = 0;

    char *buffer = octaspire_helpers_path_to_buffer(
        path,
        &octetsAllocated,
        octaspireAllocator,
        octaspireStdio);

    if (!buffer)
    {
        return 0;
    }

    octaspire_input_t *self = octaspire_input_new_from_buffer(buffer, octetsAllocated, octaspireAllocator);

    octaspire_allocator_free(octaspireAllocator, buffer);
    buffer = 0;

    return self;
}

void octaspire_input_release(octaspire_input_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_string_release(self->text);
    octaspire_allocator_free(self->allocator, self);
}

size_t octaspire_input_get_length_in_ucs_characters(octaspire_input_t const * const self)
{
    return octaspire_string_get_length_in_ucs_characters(self->text);
}

void   octaspire_input_clear(octaspire_input_t *self)
{
    octaspire_string_clear(self->text);
    self->index  = 0;
    self->line   = 1;
    self->column = 1;
}

void   octaspire_input_rewind(octaspire_input_t *self)
{
    self->index  = 0;
    self->line   = 1;
    self->column = 1;
}

uint32_t octaspire_input_peek_next_ucs_character(octaspire_input_t *self)
{
    if (self->index >= octaspire_string_get_length_in_ucs_characters(self->text))
    {
        return 0;
    }

    return octaspire_string_get_ucs_character_at_index(
        self->text,
        (ptrdiff_t)(self->index));
}

uint32_t octaspire_input_peek_next_next_ucs_character(octaspire_input_t *self)
{
    if ((self->index + 1) >= octaspire_string_get_length_in_ucs_characters(self->text))
    {
        return 0;
    }

    return octaspire_string_get_ucs_character_at_index(
        self->text,
        (ptrdiff_t)(self->index + 1));
}

bool octaspire_input_pop_next_ucs_character(octaspire_input_t *self)
{
    if (!octaspire_input_private_is_ucs_character_index_valid(self, self->index))
    {
        return false;
    }

    uint32_t const result =
        octaspire_string_get_ucs_character_at_index(
            self->text,
            (ptrdiff_t)(self->index));

    ++(self->index);

    if (octaspire_input_private_is_ucs_character_index_valid(self, self->index))
    {
        if (result == '\n')
        {
            self->column = 1;
            ++(self->line);
        }
        else
        {
            ++(self->column);
        }
    }

    return true;
}

bool octaspire_input_is_good(octaspire_input_t const * const self)
{
    return self->index < octaspire_string_get_length_in_ucs_characters(self->text);
}

bool octaspire_input_private_is_ucs_character_index_valid(
    octaspire_input_t const * const self,
    size_t index)
{
    return index < octaspire_string_get_length_in_ucs_characters(self->text);
}

bool octaspire_input_push_back_from_string(
    octaspire_input_t * const self,
    octaspire_string_t const * const str)
{
    return octaspire_input_push_back_from_c_string(
        self,
        octaspire_string_get_c_string(str));
}

bool octaspire_input_push_back_from_c_string(octaspire_input_t * const self, char const * const str)
{
    assert(self);
    return octaspire_string_concatenate_c_string(self->text, str);
}

size_t octaspire_input_get_line_number(octaspire_input_t const * const self)
{
    return self->line;
}

size_t octaspire_input_get_column_number(octaspire_input_t const * const self)
{
    return self->column;
}

size_t octaspire_input_get_ucs_character_index(octaspire_input_t const * const self)
{
    return self->index;
}

void octaspire_input_print(octaspire_input_t const * const self)
{
    printf("\n-------------------------- octaspire input --------------------------\n");
    printf("%s", octaspire_string_get_c_string(self->text));
    printf("---------------------------------------------------------------------\n");
}


//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_input.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_stdio.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_stdio_t
{
    octaspire_allocator_t *allocator;
    size_t   numberOfFutureReadsToBeRigged;
    size_t   bitIndex;
    uint32_t bitQueue;
    char     padding[4];
};

octaspire_stdio_t *octaspire_stdio_new(octaspire_allocator_t *allocator)
{
    size_t const size = sizeof(octaspire_stdio_t);

    octaspire_stdio_t *self = octaspire_allocator_malloc(allocator, size);

    if (!self)
    {
        return self;
    }

    memset(self, 0, size);

    self->allocator = allocator;

    return self;
}

void octaspire_stdio_release(octaspire_stdio_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_allocator_free(self->allocator, self);
}

size_t octaspire_stdio_fread(
    octaspire_stdio_t *self,
    void *ptr,
    size_t const size,
    size_t const nmemb,
    FILE *stream)
{
    if (self->numberOfFutureReadsToBeRigged)
    {
        --(self->numberOfFutureReadsToBeRigged);

        if (!octaspire_helpers_test_bit(self->bitQueue, self->bitIndex))
        {
            ++(self->bitIndex);
            return 0;
        }

        ++(self->bitIndex);
    }

    return fread(ptr, size, nmemb, stream);
}

void octaspire_stdio_set_number_and_type_of_future_reads_to_be_rigged(
    octaspire_stdio_t *self,
    size_t const count,
    uint32_t const bitQueue)
{
    self->numberOfFutureReadsToBeRigged = count;
    self->bitIndex = 0;
    self->bitQueue = bitQueue;
}

size_t octaspire_stdio_get_number_of_future_reads_to_be_rigged(
    octaspire_stdio_t const * const self)
{
    return self->numberOfFutureReadsToBeRigged;
}

octaspire_string_t *octaspire_stdio_read_line(octaspire_stdio_t *self, FILE *stream)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(char),
        false,
        0,
        self->allocator);

    while (true)
    {
        int c = fgetc(stream);
        char const ch = (char)c;

        if (c == EOF)
        {
            octaspire_vector_release(vec);
            return 0;
        }
        else if (c == '\n')
        {
            octaspire_vector_push_back_element(vec, &ch);
            break;
        }

        octaspire_vector_push_back_element(vec, &ch);
    }

    octaspire_string_t* result = octaspire_string_new_from_buffer(
        octaspire_vector_get_element_at_const(vec, 0),
        octaspire_vector_get_length_in_octets(vec),
        self->allocator);

    octaspire_vector_release(vec);
    vec = 0;
    return result;
}


//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_stdio.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_semver.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

typedef struct octaspire_semver_pre_release_elem_t
{
    octaspire_semver_pre_release_elem_type_t  type;
    octaspire_allocator_t                    *allocator;

    union
    {
        size_t               numerical;
        octaspire_string_t * lexical;
    } value;
}
octaspire_semver_pre_release_elem_t;

void octaspire_semver_pre_release_elem_release(octaspire_semver_pre_release_elem_t *self)
{
    if (!self)
    {
        return;
    }

    switch (self->type)
    {
        case OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_LEXICAL:
        {
            octaspire_string_release(self->value.lexical);
        }
        break;

        case OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_NUMERICAL:
        {
            // NOP
        }
        break;

        case OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_UNKNOWN:
        {
            abort();
        }
        break;
    }

    octaspire_allocator_free(self->allocator, self);
}

octaspire_semver_pre_release_elem_t *octaspire_semver_pre_release_elem_new(
    octaspire_string_t      const * const str,
    octaspire_allocator_t * const allocator)
{
    octaspire_helpers_verify_not_null(str);
    octaspire_helpers_verify_not_null(allocator);

    octaspire_semver_pre_release_elem_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_semver_pre_release_elem_t));

    if (!self)
    {
        return 0;
    }

    self->allocator = allocator;

    if (octaspire_string_contains_only_these_chars_c_string(
            str,
            "0123456789"))
    {
        self->type            = OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_NUMERICAL;
        self->value.numerical = atoi(octaspire_string_get_c_string(str));
    }
    else
    {
        octaspire_string_t * copyStr =
            octaspire_string_new_copy(str, self->allocator);

        if (!copyStr)
        {
            octaspire_semver_pre_release_elem_release(self);
            self = 0;
            return 0;
        }

        self->type          = OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_LEXICAL;
        self->value.lexical = copyStr;
    }

    return self;
}

octaspire_semver_pre_release_elem_t *octaspire_semver_pre_release_elem_numerical_new(
    size_t                  const value,
    octaspire_allocator_t * const allocator)
{
    octaspire_helpers_verify_not_null(allocator);

    octaspire_semver_pre_release_elem_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_semver_pre_release_elem_t));

    if (!self)
    {
        return 0;
    }

    self->allocator = allocator;

    self->type            = OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_NUMERICAL;
    self->value.numerical = value;

    return self;
}

struct octaspire_semver_t
{
    size_t                 major;
    size_t                 minor;
    size_t                 patch;
    octaspire_vector_t    *preRelease;
    octaspire_vector_t    *buildMetadata;
    octaspire_allocator_t *allocator;
};

octaspire_semver_t *octaspire_semver_new(
    size_t                const         major,
    size_t                const         minor,
    size_t                const         patch,
    octaspire_vector_t    const * const preRelease,
    octaspire_vector_t    const * const buildMetadata,
    octaspire_allocator_t       * const allocator)
{
    if (!allocator)
    {
        return 0;
    }

    octaspire_semver_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_semver_t));

    if (!self)
    {
        return 0;
    }

    self->allocator = allocator;
    self->major     = major;
    self->minor     = minor;
    self->patch     = patch;

    self->preRelease = octaspire_vector_new(
        sizeof(octaspire_semver_pre_release_elem_t*),
        true,
        (octaspire_vector_element_callback_t)octaspire_semver_pre_release_elem_release,
        self->allocator);

    if (!self->preRelease)
    {
        octaspire_semver_release(self);
        self = 0;
        return 0;
    }

    self->buildMetadata = octaspire_vector_new(
        sizeof(octaspire_string_t*),
        true,
        (octaspire_vector_element_callback_t)octaspire_string_release,
        self->allocator);

    if (!self->buildMetadata)
    {
        octaspire_semver_release(self);
        self = 0;
        return 0;
    }

    if (preRelease)
    {
        for (size_t i = 0; i < octaspire_vector_get_length(preRelease); ++i)
        {
            octaspire_string_t const * const str =
                octaspire_vector_get_element_at_const(preRelease, i);

            octaspire_helpers_verify_not_null(str);

            octaspire_semver_pre_release_elem_t * preReleaseElem =
                octaspire_semver_pre_release_elem_new(str, self->allocator);

            if (!preReleaseElem)
            {
                octaspire_semver_release(self);
                self = 0;
                return 0;
            }

            if (!octaspire_vector_push_back_element(
                    self->preRelease,
                    &preReleaseElem))
            {
                octaspire_semver_pre_release_elem_release(preReleaseElem);

                octaspire_semver_release(self);
                self = 0;
                return 0;
            }
        }
    }

    if (buildMetadata)
    {
        for (size_t i = 0; i < octaspire_vector_get_length(buildMetadata); ++i)
        {
            octaspire_string_t * str =
                octaspire_string_new_copy(
                    octaspire_vector_get_element_at_const(buildMetadata, i),
                    self->allocator);

            if (!str)
            {
                octaspire_semver_release(self);
                self = 0;
                return 0;
            }

            if (!octaspire_vector_push_back_element(self->buildMetadata, &str))
            {
                octaspire_string_release(str);
                str  = 0;
                octaspire_semver_release(self);
                self = 0;
                return 0;
            }
        }
    }

    return self;
}

octaspire_semver_t *octaspire_semver_new_prerelease(
    size_t                const         major,
    size_t                const         minor,
    size_t                const         patch,
    octaspire_allocator_t       * const allocator,
    ...)
{
    va_list arguments;
    va_start(arguments, allocator);

    octaspire_semver_t * result = octaspire_semver_new_prerelease_va(
        major,
        minor,
        patch,
        allocator,
        arguments);

    va_end(arguments);
    return result;
}

octaspire_semver_t *octaspire_semver_new_prerelease_va(
    size_t                const         major,
    size_t                const         minor,
    size_t                const         patch,
    octaspire_allocator_t       * const allocator,
    va_list                             preRelease)
{
    octaspire_vector_t * const preReleaseVec = octaspire_vector_new(
        sizeof(octaspire_string_t*),
        true,
        (octaspire_vector_element_callback_t)octaspire_string_release,
        allocator);

    if (!preReleaseVec)
    {
        return 0;
    }

    while (true)
    {
        char const * const arg = va_arg(preRelease, char*);

        if (!arg || !strlen(arg))
        {
            break;
        }

        octaspire_string_t * const str =
            octaspire_string_new(arg, allocator);

        if (!arg)
        {
            octaspire_vector_release(preReleaseVec);
            return 0;
        }

        if (!octaspire_vector_push_back_element(
            preReleaseVec,
            &str))
        {
            octaspire_vector_release(preReleaseVec);
            return 0;
        }
    }

    octaspire_semver_t * const result =
        octaspire_semver_new(major, minor, patch, preReleaseVec, 0, allocator);

    octaspire_vector_release(preReleaseVec);
    return result;
}

void octaspire_semver_release(octaspire_semver_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_vector_release(self->preRelease);
    octaspire_vector_release(self->buildMetadata);

    octaspire_allocator_free(self->allocator, self);
}

bool octaspire_semver_add_prerelease(
    octaspire_semver_t * const self,
    char const * const preRelease)
{
    octaspire_string_t * str =
        octaspire_string_new(preRelease, self->allocator);

    if (!str)
    {
        return false;
    }

    octaspire_semver_pre_release_elem_t * preReleaseElem =
        octaspire_semver_pre_release_elem_new(str, self->allocator);

    octaspire_string_release(str);
    str = 0;

    if (!preReleaseElem)
    {
        return false;
    }

    if (!octaspire_vector_push_back_element(
            self->preRelease,
            &preReleaseElem))
    {
        octaspire_semver_pre_release_elem_release(preReleaseElem);
        preReleaseElem = 0;
        return false;
    }

    return true;
}

bool octaspire_semver_add_prerelease_numerical(
    octaspire_semver_t * const self,
    size_t const preRelease)
{
    octaspire_semver_pre_release_elem_t * preReleaseElem =
        octaspire_semver_pre_release_elem_numerical_new(preRelease, self->allocator);

    if (!preReleaseElem)
    {
        return false;
    }

    if (!octaspire_vector_push_back_element(
            self->preRelease,
            &preReleaseElem))
    {
        octaspire_semver_pre_release_elem_release(preReleaseElem);
        preReleaseElem = 0;
        return false;
    }

    return true;
}

bool octaspire_semver_remove_prerelease(
    octaspire_semver_t * const self,
    char const * const prerelease)
{
    for (size_t i = 0;
         i < octaspire_semver_get_num_pre_release_identifiers(self);
         ++i)
    {
        octaspire_semver_pre_release_elem_t const * const elem =
            octaspire_vector_get_element_at_const(self->preRelease, i);

        octaspire_helpers_verify_not_null(elem);

        if (elem->type == OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_LEXICAL)
        {
            if (octaspire_string_is_equal_to_c_string(
                    elem->value.lexical,
                    prerelease))
            {
                if (!octaspire_vector_remove_element_at(self->preRelease, i))
                {
                    return false;
                }
                return true;
            }
        }
    }

    return false;
}

bool octaspire_semver_remove_prerelease_numerical(
    octaspire_semver_t * const self,
    size_t const prerelease)
{
    for (size_t i = 0;
         i < octaspire_semver_get_num_pre_release_identifiers(self);
         ++i)
    {
        octaspire_semver_pre_release_elem_t const * const elem =
            octaspire_vector_get_element_at_const(self->preRelease, i);

        octaspire_helpers_verify_not_null(elem);

        if (elem->type == OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_NUMERICAL)
        {
            if (elem->value.numerical == prerelease)
            {
                if (!octaspire_vector_remove_element_at(self->preRelease, i))
                {
                    return false;
                }
                return true;
            }
        }
    }

    return false;
}

bool octaspire_semver_add_buildmetadata(
    octaspire_semver_t * const self,
    char const * const buildMetaData)
{
    octaspire_string_t * str =
        octaspire_string_new(buildMetaData, self->allocator);

    if (!str)
    {
        return false;
    }

    if (!octaspire_vector_push_back_element(self->buildMetadata, &str))
    {
        return false;
    }

    return true;
}

octaspire_semver_pre_release_elem_type_t octaspire_semver_get_prerelease_at(
    octaspire_semver_t const * const self,
    size_t const index,
    size_t * outNumerical,
    char const ** outLexical)
{
    if (index >= octaspire_semver_get_num_pre_release_identifiers(self))
    {
        return OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_UNKNOWN;
    }

    octaspire_semver_pre_release_elem_t const * const elem =
        octaspire_vector_get_element_at_const(self->preRelease, index);

    octaspire_helpers_verify_not_null(elem);

    if (elem->type == OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_LEXICAL)
    {
        *outLexical = octaspire_string_get_c_string(elem->value.lexical);
        return OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_LEXICAL;
    }

    *outNumerical = elem->value.numerical;
    return OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_NUMERICAL;
}

octaspire_string_t * octaspire_semver_to_string(
    octaspire_semver_t const * const self)
{
    octaspire_helpers_verify_not_null(self);

    octaspire_string_t * const result =
        octaspire_string_new_format(
            self->allocator,
            "%zu.%zu.%zu",
            self->major,
            self->minor,
            self->patch);

    for (size_t i = 0; i < octaspire_vector_get_length(self->preRelease); ++i)
    {
        if (i == 0)
        {
            if (!octaspire_string_concatenate_c_string(result, "-"))
            {
                octaspire_string_release(result);
                return 0;
            }
        }

        octaspire_semver_pre_release_elem_t const * const elem =
            octaspire_vector_get_element_at_const(self->preRelease, i);

        octaspire_helpers_verify_not_null(elem);

        switch (elem->type)
        {
            case OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_LEXICAL:
            {
                octaspire_helpers_verify_not_null(elem->value.lexical);

                if (!octaspire_string_concatenate_format(
                        result,
                        "%s%s",
                        octaspire_string_get_c_string(elem->value.lexical),
                        ((i+1) < octaspire_vector_get_length(self->preRelease))
                        ? "." : ""))
                {
                    octaspire_string_release(result);
                    return 0;
                }
            }
            break;

            case OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_NUMERICAL:
            {
                if (!octaspire_string_concatenate_format(
                        result,
                        "%zu%s",
                        elem->value.numerical,
                        ((i+1) < octaspire_vector_get_length(self->preRelease))
                        ? "." : ""))
                {
                    octaspire_string_release(result);
                    return 0;
                }
            }
            break;

            case OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_UNKNOWN:
            {
                abort();
            }
            break;
        }
    }

    for (size_t i = 0;
         i < octaspire_vector_get_length(self->buildMetadata);
         ++i)
    {
        if (i == 0)
        {
            if (!octaspire_string_concatenate_c_string(result, "+"))
            {
                octaspire_string_release(result);
                return 0;
            }
        }

        octaspire_string_t const * const elem =
            octaspire_vector_get_element_at_const(self->buildMetadata, i);

        octaspire_helpers_verify_not_null(elem);

        if (!octaspire_string_concatenate_format(
                result,
                "%s%s",
                octaspire_string_get_c_string(elem),
                ((i+1) < octaspire_vector_get_length(self->preRelease))
                ? "." : ""))
        {
            octaspire_string_release(result);
            return 0;
        }
    }

    return result;
}

int octaspire_semver_compare(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    int diff = self->major - other->major;

    if (diff)
    {
        return (diff < 0) ? -1 : 1;
    }

    diff = self->minor - other->minor;

    if (diff)
    {
        return (diff < 0) ? -1 : 1;
    }

    diff = self->patch - other->patch;

    if (diff)
    {
        return (diff < 0) ? -1 : 1;
    }

    size_t const selfLen =
        octaspire_vector_get_length(self->preRelease);

    size_t const otherLen =
        octaspire_vector_get_length(other->preRelease);

    if (!selfLen)
    {
        if (!otherLen)
        {
            return 0;
        }

        return 1;
    }

    if (!otherLen)
    {
        return -1;
    }

    for (size_t i = 0; i < octaspire_helpers_min_size_t(selfLen, otherLen); ++i)
    {
        octaspire_semver_pre_release_elem_t const * const selfElem =
            octaspire_vector_get_element_at_const(self->preRelease, i);

        octaspire_semver_pre_release_elem_t const * const otherElem =
            octaspire_vector_get_element_at_const(other->preRelease, i);

        if (selfElem->type != otherElem->type)
        {
            return (selfElem->type == OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_NUMERICAL)
                ? -1
                :  1;
        }

        switch (selfElem->type)
        {
            case OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_LEXICAL:
            {
                int const diff = octaspire_string_compare(
                    selfElem->value.lexical,
                    otherElem->value.lexical);

                if (diff)
                {
                    return (diff < 0) ? -1 : 1;
                }
            }
            break;

            case OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_NUMERICAL:
            {
                int const diff =
                    selfElem->value.numerical - otherElem->value.numerical;

                if (diff)
                {
                    return (diff < 0) ? -1 : 1;
                }
            }
            break;

            case OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_UNKNOWN:
            {
                abort();
            }
            break;
        }
    }

    if (selfLen == otherLen)
    {
        return 0;
    }

    diff = selfLen - otherLen;
    return (diff < 0) ? -1 : 1;
}

bool octaspire_semver_is_smaller_than(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other)
{
    return (octaspire_semver_compare(self, other) == -1);
}

bool octaspire_semver_is_smaller_or_equal_to(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other)
{
    return (octaspire_semver_compare(self, other) <= 0);
}

bool octaspire_semver_is_greater_than(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other)
{
    return (octaspire_semver_compare(self, other) == 1);
}

bool octaspire_semver_is_greater_or_equal_to(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other)
{
    return (octaspire_semver_compare(self, other) >= 0);
}

bool octaspire_semver_is_equal_to(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other)
{
    return (octaspire_semver_compare(self, other) == 0);
}

bool octaspire_semver_is_unequal_to(
    octaspire_semver_t const * const self,
    octaspire_semver_t const * const other)
{
    return (!octaspire_semver_is_equal_to(self, other));
}

size_t octaspire_semver_get_num_pre_release_identifiers(
    octaspire_semver_t const * const self)
{
    return octaspire_vector_get_length(self->preRelease);
}

size_t octaspire_semver_get_num_build_metadata_identifiers(
    octaspire_semver_t const * const self)
{
    return octaspire_vector_get_length(self->buildMetadata);
}

bool octaspire_semver_add_or_subtract(
    octaspire_semver_t       * const self,
    octaspire_semver_t const * const other,
    bool                       const add)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    if (other->major)
    {
        if (other->minor || other->patch)
        {
            return false;
        }

        if (add)
        {
            self->major += other->major;
            self->minor = 0;
            self->patch = 0;
        }
        else
        {
            if (self->major < other->major)
            {
                return false;
            }

            self->major -= other->major;
        }
    }

    if (other->minor)
    {
        if (other->major || other->patch)
        {
            return false;
        }

        if (add)
        {
            self->minor += other->minor;
            self->patch = 0;
        }
        else
        {
            if (self->minor < other->minor)
            {
                return false;
            }

            self->minor -= other->minor;
        }
    }

    if (other->patch)
    {
        if (other->major || other->minor)
        {
            return false;
        }

        if (add)
        {
            self->patch += other->patch;
        }
        else
        {
            if (self->patch < other->patch)
            {
                return false;
            }

            self->patch -= other->patch;
        }
    }

    for (size_t i = 0;
         i < octaspire_semver_get_num_pre_release_identifiers(other);
         ++i)
    {
        size_t outNumerical     = 0;
        char const * outLexical = 0;
        octaspire_semver_pre_release_elem_type_t const type =
            octaspire_semver_get_prerelease_at(other, i, &outNumerical, &outLexical);

        octaspire_helpers_verify_true(type != OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_UNKNOWN);

        switch (type)
        {
        case OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_LEXICAL:
        {
            if (add)
            {
                if (!octaspire_semver_add_prerelease(self, outLexical))
                {
                    return false;
                }
            }
            else
            {
                if (!octaspire_semver_remove_prerelease(self, outLexical))
                {
                    return false;
                }
            }
        }
        break;

        case OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_NUMERICAL:
        {
            if (add)
            {
                if (!octaspire_semver_add_prerelease_numerical(self, outNumerical))
                {
                    return false;
                }
            }
            else
            {
                if (!octaspire_semver_remove_prerelease_numerical(self, outNumerical))
                {
                    return false;
                }
            }
        }
        break;

        case OCTASPIRE_SEMVER_PRE_RELEASE_ELEM_TYPE_UNKNOWN:
        {
            abort();
        }
        break;
        }
    }

    return true;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_semver.c
//////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif

#endif // OCTASPIRE_CORE_AMALGAMATED_IMPLEMENTATION

#ifdef OCTASPIRE_CORE_AMALGAMATED_UNIT_TEST_IMPLEMENTATION
// This file is modified by www.octaspire.com. The original copyright is:

/*
 * Copyright (c) 2011-2016 Scott Vokes <vokes.s@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

// Modifications are released under similar license:

/*
 * Copyright (c) 2017 www.octaspire.com
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef GREATEST_H
#define GREATEST_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef GREATEST_ENABLE_ANSI_COLORS
#define GREATEST_ANSI_COLOR_RED    "\x1B[31m"
#define GREATEST_ANSI_COLOR_GREEN  "\x1B[32m"
#define GREATEST_ANSI_COLOR_YELLOW "\x1B[33m"
#define GREATEST_ANSI_COLOR_DGRAY  "\x1B[1;30m"
#define GREATEST_ANSI_COLOR_RESET  "\x1B[0m"
#else
#define GREATEST_ANSI_COLOR_RED    ""
#define GREATEST_ANSI_COLOR_GREEN  ""
#define GREATEST_ANSI_COLOR_YELLOW ""
#define GREATEST_ANSI_COLOR_DGRAY  ""
#define GREATEST_ANSI_COLOR_RESET  ""
#endif

/* 1.2.2 */
#define GREATEST_VERSION_MAJOR 1
#define GREATEST_VERSION_MINOR 2
#define GREATEST_VERSION_PATCH 2

/* A unit testing system for C, contained in 1 file.
 * It doesn't use dynamic allocation or depend on anything
 * beyond ANSI C89.
 *
 * An up-to-date version can be found at:
 *     https://github.com/silentbicycle/greatest/
 */


/***********
 * Options *
 ***********/

/* Default column width for non-verbose output. */
#ifndef GREATEST_DEFAULT_WIDTH
#define GREATEST_DEFAULT_WIDTH 72
#endif

/* FILE *, for test logging. */
#ifndef GREATEST_STDOUT
#define GREATEST_STDOUT stdout
#endif

/* Remove GREATEST_ prefix from most commonly used symbols? */
#ifndef GREATEST_USE_ABBREVS
#define GREATEST_USE_ABBREVS 1
#endif

/* Set to 0 to disable all use of setjmp/longjmp. */
#ifndef GREATEST_USE_LONGJMP
#define GREATEST_USE_LONGJMP 1
#endif

#ifdef GREATEST_USE_LONGJMP
#endif

/* Set to 0 to disable all use of time.h / clock(). */
#ifndef GREATEST_USE_TIME
#define GREATEST_USE_TIME 1
#endif

#ifdef GREATEST_USE_TIME
#endif

/* Floating point type, for ASSERT_IN_RANGE. */
#ifndef GREATEST_FLOAT
#define GREATEST_FLOAT double
#define GREATEST_FLOAT_FMT "%g"
#endif

/*********
 * Types *
 *********/

/* Info for the current running suite. */
typedef struct greatest_suite_info {
    unsigned int tests_run;
    unsigned int passed;
    unsigned int failed;
    unsigned int skipped;

#ifdef GREATEST_USE_TIME
    /* timers, pre/post running suite and individual tests */
    clock_t pre_suite;
    clock_t post_suite;
    clock_t pre_test;
    clock_t post_test;
#endif
} greatest_suite_info;

/* Type for a suite function. */
typedef void (greatest_suite_cb)(void);

/* Types for setup/teardown callbacks. If non-NULL, these will be run
 * and passed the pointer to their additional data. */
typedef void (greatest_setup_cb)(void *udata);
typedef void (greatest_teardown_cb)(void *udata);

/* Type for an equality comparison between two pointers of the same type.
 * Should return non-0 if equal, otherwise 0.
 * UDATA is a closure value, passed through from ASSERT_EQUAL_T[m]. */
typedef int greatest_equal_cb(const void *exp, const void *got, void *udata);

/* Type for a callback that prints a value pointed to by T.
 * Return value has the same meaning as printf's.
 * UDATA is a closure value, passed through from ASSERT_EQUAL_T[m]. */
typedef int greatest_printf_cb(const void *t, void *udata);

/* Callbacks for an arbitrary type; needed for type-specific
 * comparisons via GREATEST_ASSERT_EQUAL_T[m].*/
typedef struct greatest_type_info {
    greatest_equal_cb *equal;
    greatest_printf_cb *print;
} greatest_type_info;

typedef struct greatest_memory_cmp_env {
    const unsigned char *exp;
    const unsigned char *got;
    size_t size;
} greatest_memory_cmp_env;

/* Callbacks for string and raw memory types. */
extern greatest_type_info greatest_type_info_string;
extern greatest_type_info greatest_type_info_memory;

typedef enum {
    GREATEST_FLAG_FIRST_FAIL = 0x01,
    GREATEST_FLAG_LIST_ONLY = 0x02
} greatest_flag_t;

/* Struct containing all test runner state. */
typedef struct greatest_run_info {
    unsigned char flags;
    unsigned char verbosity;
    unsigned char pad_0[2];

    unsigned int tests_run;     /* total test count */

    /* currently running test suite */
    greatest_suite_info suite;

    /* overall pass/fail/skip counts */
    unsigned int passed;
    unsigned int failed;
    unsigned int skipped;
    unsigned int assertions;

    /* info to print about the most recent failure */
    unsigned int fail_line;
    unsigned int pad_1;
    const char *fail_file;
    const char *msg;

    /* current setup/teardown hooks and userdata */
    greatest_setup_cb *setup;
    void *setup_udata;
    greatest_teardown_cb *teardown;
    void *teardown_udata;

    /* formatting info for ".....s...F"-style output */
    unsigned int col;
    unsigned int width;

    /* only run a specific suite or test */
    const char *suite_filter;
    const char *test_filter;

#ifdef GREATEST_USE_TIME
    /* overall timers */
    clock_t begin;
    clock_t end;
#endif

#ifdef GREATEST_USE_LONGJMP
    int pad_jmp_buf;
    char octaspire_padding[4];
    jmp_buf jump_dest;
#endif
} greatest_run_info;

struct greatest_report_t {
    /* overall pass/fail/skip counts */
    unsigned int passed;
    unsigned int failed;
    unsigned int skipped;
    unsigned int assertions;
};

/* Global var for the current testing context.
 * Initialized by GREATEST_MAIN_DEFS(). */
extern greatest_run_info greatest_info;

/* Type for ASSERT_ENUM_EQ's ENUM_STR argument. */
typedef const char *greatest_enum_str_fun(int value);

/**********************
 * Exported functions *
 **********************/

/* These are used internally by greatest. */
void greatest_do_pass(const char *name);
void greatest_do_fail(const char *name);
void greatest_do_skip(const char *name);
int greatest_pre_test(const char *name);
void greatest_post_test(const char *name, int res);
void greatest_usage(const char *name);
int greatest_do_assert_equal_t(const void *exp, const void *got,
    greatest_type_info *type_info, void *udata);

/* These are part of the public greatest API. */
void GREATEST_SET_SETUP_CB(greatest_setup_cb *cb, void *udata);
void GREATEST_SET_TEARDOWN_CB(greatest_teardown_cb *cb, void *udata);
int greatest_all_passed(void);
void greatest_set_test_filter(const char *name);
void greatest_set_suite_filter(const char *name);
void greatest_get_report(struct greatest_report_t *report);
unsigned int greatest_get_verbosity(void);
void greatest_set_verbosity(unsigned int verbosity);
void greatest_set_flag(greatest_flag_t flag);


/********************
* Language Support *
********************/

/**********
 * Macros *
 **********/

/* Define a suite. */
#define GREATEST_SUITE(NAME) void NAME(void); void NAME(void)

/* Declare a suite, provided by another compilation unit. */
#define GREATEST_SUITE_EXTERN(NAME) void NAME(void)

/* Start defining a test function.
 * The arguments are not included, to allow parametric testing. */
#define GREATEST_TEST static enum greatest_test_res

/* PASS/FAIL/SKIP result from a test. Used internally. */
typedef enum greatest_test_res {
    GREATEST_TEST_RES_PASS = 0,
    GREATEST_TEST_RES_FAIL = -1,
    GREATEST_TEST_RES_SKIP = 1
} greatest_test_res;

/* Run a suite. */
#define GREATEST_RUN_SUITE(S_NAME) greatest_run_suite(S_NAME, #S_NAME)

/* Run a test in the current suite. */
#define GREATEST_RUN_TEST(TEST)                                         \
    do {                                                                \
        if (greatest_pre_test(#TEST) == 1) {                            \
            enum greatest_test_res res = GREATEST_SAVE_CONTEXT();       \
            if (res == GREATEST_TEST_RES_PASS) {                        \
                res = TEST();                                           \
            }                                                           \
            greatest_post_test(#TEST, res);                             \
        } else if (GREATEST_LIST_ONLY()) {                              \
            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
        }                                                               \
    } while (0)

/* Ignore a test, don't warn about it being unused. */
#define GREATEST_IGNORE_TEST(TEST) (void)TEST

/* Run a test in the current suite with one void * argument,
 * which can be a pointer to a struct with multiple arguments. */
#define GREATEST_RUN_TEST1(TEST, ENV)                                   \
    do {                                                                \
        if (greatest_pre_test(#TEST) == 1) {                            \
            int res = TEST(ENV);                                        \
            greatest_post_test(#TEST, res);                             \
        } else if (GREATEST_LIST_ONLY()) {                              \
            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
        }                                                               \
    } while (0)

#ifdef GREATEST_VA_ARGS
#define GREATEST_RUN_TESTp(TEST, ...)                                   \
    do {                                                                \
        if (greatest_pre_test(#TEST) == 1) {                            \
            int res = TEST(__VA_ARGS__);                                \
            greatest_post_test(#TEST, res);                             \
        } else if (GREATEST_LIST_ONLY()) {                              \
            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
        }                                                               \
    } while (0)
#endif


/* Check if the test runner is in verbose mode. */
#define GREATEST_IS_VERBOSE() ((greatest_info.verbosity) > 0)
#define GREATEST_LIST_ONLY()                                            \
    (greatest_info.flags & GREATEST_FLAG_LIST_ONLY)
#define GREATEST_FIRST_FAIL()                                           \
    (greatest_info.flags & GREATEST_FLAG_FIRST_FAIL)
#define GREATEST_FAILURE_ABORT()                                        \
    (greatest_info.suite.failed > 0 && GREATEST_FIRST_FAIL())

/* Message-less forms of tests defined below. */
#define GREATEST_PASS() GREATEST_PASSm(NULL)
#define GREATEST_FAIL() GREATEST_FAILm(NULL)
#define GREATEST_SKIP() GREATEST_SKIPm(NULL)
#define GREATEST_ASSERT(COND)                                           \
    GREATEST_ASSERTm(#COND, COND)
#define GREATEST_ASSERT_OR_LONGJMP(COND)                                \
    GREATEST_ASSERT_OR_LONGJMPm(#COND, COND)
#define GREATEST_ASSERT_FALSE(COND)                                     \
    GREATEST_ASSERT_FALSEm(#COND, COND)
#define GREATEST_ASSERT_EQ(EXP, GOT)                                    \
    GREATEST_ASSERT_EQm(#EXP " != " #GOT, EXP, GOT)
#define GREATEST_ASSERT_EQ_FMT(EXP, GOT, FMT)                           \
    GREATEST_ASSERT_EQ_FMTm(#EXP " != " #GOT, EXP, GOT, FMT)
#define GREATEST_ASSERT_IN_RANGE(EXP, GOT, TOL)                         \
    GREATEST_ASSERT_IN_RANGEm(#EXP " != " #GOT " +/- " #TOL, EXP, GOT, TOL)
#define GREATEST_ASSERT_EQUAL_T(EXP, GOT, TYPE_INFO, UDATA)             \
    GREATEST_ASSERT_EQUAL_Tm(#EXP " != " #GOT, EXP, GOT, TYPE_INFO, UDATA)
#define GREATEST_ASSERT_STR_EQ(EXP, GOT)                                \
    GREATEST_ASSERT_STR_EQm(#EXP " != " #GOT, EXP, GOT)
#define GREATEST_ASSERT_STRN_EQ(EXP, GOT, SIZE)                         \
    GREATEST_ASSERT_STRN_EQm(#EXP " != " #GOT, EXP, GOT, SIZE)
#define GREATEST_ASSERT_MEM_EQ(EXP, GOT, SIZE)                          \
    GREATEST_ASSERT_MEM_EQm(#EXP " != " #GOT, EXP, GOT, SIZE)
#define GREATEST_ASSERT_ENUM_EQ(EXP, GOT, ENUM_STR)                     \
    GREATEST_ASSERT_ENUM_EQm(#EXP " != " #GOT, EXP, GOT, ENUM_STR)

/* The following forms take an additional message argument first,
 * to be displayed by the test runner. */

/* Fail if a condition is not true, with message. */
#define GREATEST_ASSERTm(MSG, COND)                                     \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if (!(COND)) { GREATEST_FAILm(MSG); }                           \
    } while (0)

/* Fail if a condition is not true, longjmping out of test. */
#define GREATEST_ASSERT_OR_LONGJMPm(MSG, COND)                          \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if (!(COND)) { GREATEST_FAIL_WITH_LONGJMPm(MSG); }              \
    } while (0)

/* Fail if a condition is not false, with message. */
#define GREATEST_ASSERT_FALSEm(MSG, COND)                               \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if ((COND)) { GREATEST_FAILm(MSG); }                            \
    } while (0)

/* Fail if EXP != GOT (equality comparison by ==). */
#define GREATEST_ASSERT_EQm(MSG, EXP, GOT)                              \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if ((EXP) != (GOT)) { GREATEST_FAILm(MSG); }                    \
    } while (0)

/* Fail if EXP != GOT (equality comparison by ==).
 * Warning: FMT, EXP, and GOT will be evaluated more
 * than once on failure. */
#define GREATEST_ASSERT_EQ_FMTm(MSG, EXP, GOT, FMT)                     \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if ((EXP) != (GOT)) {                                           \
            fprintf(GREATEST_STDOUT, "\nExpected: ");                   \
            fprintf(GREATEST_STDOUT, FMT, EXP);                         \
            fprintf(GREATEST_STDOUT, "\n     Got: ");                   \
            fprintf(GREATEST_STDOUT, FMT, GOT);                         \
            fprintf(GREATEST_STDOUT, "\n");                             \
            GREATEST_FAILm(MSG);                                        \
        }                                                               \
    } while (0)

/* Fail if EXP is not equal to GOT, printing enum IDs. */
#define GREATEST_ASSERT_ENUM_EQm(MSG, EXP, GOT, ENUM_STR)               \
    do {                                                                \
        int greatest_EXP = (int)(EXP);                                  \
        int greatest_GOT = (int)(GOT);                                  \
        greatest_enum_str_fun *greatest_ENUM_STR = ENUM_STR;            \
        if (greatest_EXP != greatest_GOT) {                             \
            fprintf(GREATEST_STDOUT, "\nExpected: %s",                  \
                greatest_ENUM_STR(greatest_EXP));                       \
            fprintf(GREATEST_STDOUT, "\n     Got: %s\n",                \
                greatest_ENUM_STR(greatest_GOT));                       \
            GREATEST_FAILm(MSG);                                        \
        }                                                               \
    } while (0)                                                         \

/* Fail if GOT not in range of EXP +|- TOL. */
#define GREATEST_ASSERT_IN_RANGEm(MSG, EXP, GOT, TOL)                   \
    do {                                                                \
        GREATEST_FLOAT greatest_EXP = (EXP);                            \
        GREATEST_FLOAT greatest_GOT = (GOT);                            \
        GREATEST_FLOAT greatest_TOL = (TOL);                            \
        greatest_info.assertions++;                                     \
        if ((greatest_EXP > greatest_GOT &&                             \
                greatest_EXP - greatest_GOT > greatest_TOL) ||          \
            (greatest_EXP < greatest_GOT &&                             \
                greatest_GOT - greatest_EXP > greatest_TOL)) {          \
            fprintf(GREATEST_STDOUT,                                    \
                "\nExpected: " GREATEST_FLOAT_FMT                       \
                " +/- " GREATEST_FLOAT_FMT                              \
                "\n     Got: " GREATEST_FLOAT_FMT                       \
                "\n",                                                   \
                greatest_EXP, greatest_TOL, greatest_GOT);              \
            GREATEST_FAILm(MSG);                                        \
        }                                                               \
    } while (0)

/* Fail if EXP is not equal to GOT, according to strcmp. */
#define GREATEST_ASSERT_STR_EQm(MSG, EXP, GOT)                          \
    do {                                                                \
        GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT,                         \
            &greatest_type_info_string, NULL);                          \
    } while (0)                                                         \

/* Fail if EXP is not equal to GOT, according to strcmp. */
#define GREATEST_ASSERT_STRN_EQm(MSG, EXP, GOT, SIZE)                   \
    do {                                                                \
        size_t size = SIZE;                                             \
        GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT,                         \
            &greatest_type_info_string, &size);                         \
    } while (0)                                                         \

/* Fail if EXP is not equal to GOT, according to memcmp. */
#define GREATEST_ASSERT_MEM_EQm(MSG, EXP, GOT, SIZE)                    \
    do {                                                                \
        greatest_memory_cmp_env env;                                    \
        env.exp = (const unsigned char *)EXP;                           \
        env.got = (const unsigned char *)GOT;                           \
        env.size = SIZE;                                                \
        GREATEST_ASSERT_EQUAL_Tm(MSG, env.exp, env.got,                 \
            &greatest_type_info_memory, &env);                          \
    } while (0)                                                         \

/* Fail if EXP is not equal to GOT, according to a comparison
 * callback in TYPE_INFO. If they are not equal, optionally use a
 * print callback in TYPE_INFO to print them. */
#define GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT, TYPE_INFO, UDATA)       \
    do {                                                                \
        greatest_type_info *type_info = (TYPE_INFO);                    \
        greatest_info.assertions++;                                     \
        if (!greatest_do_assert_equal_t(EXP, GOT,                       \
                type_info, UDATA)) {                                    \
            if (type_info == NULL || type_info->equal == NULL) {        \
                GREATEST_FAILm("type_info->equal callback missing!");   \
            } else {                                                    \
                GREATEST_FAILm(MSG);                                    \
            }                                                           \
        }                                                               \
    } while (0)                                                         \

/* Pass. */
#define GREATEST_PASSm(MSG)                                             \
    do {                                                                \
        greatest_info.msg = MSG;                                        \
        return GREATEST_TEST_RES_PASS;                                  \
    } while (0)

/* Fail. */
#define GREATEST_FAILm(MSG)                                             \
    do {                                                                \
        greatest_info.fail_file = __FILE__;                             \
        greatest_info.fail_line = __LINE__;                             \
        greatest_info.msg = MSG;                                        \
        return GREATEST_TEST_RES_FAIL;                                  \
    } while (0)

/* Optional GREATEST_FAILm variant that longjmps. */
#ifdef GREATEST_USE_LONGJMP
#define GREATEST_FAIL_WITH_LONGJMP() GREATEST_FAIL_WITH_LONGJMPm(NULL)
#define GREATEST_FAIL_WITH_LONGJMPm(MSG)                                \
    do {                                                                \
        greatest_info.fail_file = __FILE__;                             \
        greatest_info.fail_line = __LINE__;                             \
        greatest_info.msg = MSG;                                        \
        longjmp(greatest_info.jump_dest, GREATEST_TEST_RES_FAIL);       \
    } while (0)
#endif

/* Skip the current test. */
#define GREATEST_SKIPm(MSG)                                             \
    do {                                                                \
        greatest_info.msg = MSG;                                        \
        return GREATEST_TEST_RES_SKIP;                                  \
    } while (0)

/* Check the result of a subfunction using ASSERT, etc. */
#define GREATEST_CHECK_CALL(RES)                                        \
    do {                                                                \
        enum greatest_test_res greatest_RES = RES;                      \
        if (greatest_RES != GREATEST_TEST_RES_PASS) {                   \
            return greatest_RES;                                        \
        }                                                               \
    } while (0)                                                         \

#ifdef GREATEST_USE_TIME
#define GREATEST_SET_TIME(NAME)                                         \
    NAME = clock();                                                     \
    if (NAME == (clock_t) -1) {                                         \
        fprintf(GREATEST_STDOUT,                                        \
            "clock error: %s\n", #NAME);                                \
        exit(EXIT_FAILURE);                                             \
    }

#define GREATEST_CLOCK_DIFF(C1, C2)                                     \
    fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_DGRAY " (%lu ticks, %.3f sec)" GREATEST_ANSI_COLOR_RESET, \
        (long unsigned int) (C2) - (long unsigned int)(C1),             \
        (double)((C2) - (C1)) / (1.0 * (double)CLOCKS_PER_SEC))
#else
#define GREATEST_SET_TIME(UNUSED)
#define GREATEST_CLOCK_DIFF(UNUSED1, UNUSED2)
#endif

#ifdef GREATEST_USE_LONGJMP
#define GREATEST_SAVE_CONTEXT()                                         \
        /* setjmp returns 0 (GREATEST_TEST_RES_PASS) on first call */   \
        /* so the test runs, then RES_FAIL from FAIL_WITH_LONGJMP. */   \
        ((enum greatest_test_res)(setjmp(greatest_info.jump_dest)))
#else
#define GREATEST_SAVE_CONTEXT()                                         \
    /*a no-op, since setjmp/longjmp aren't being used */                \
    GREATEST_TEST_RES_PASS
#endif

/* Include several function definitions in the main test file. */
#define GREATEST_MAIN_DEFS()                                            \
                                                                        \
/* Is FILTER a subset of NAME? */                                       \
static int greatest_name_match(const char *name,                        \
    const char *filter) {                                               \
    size_t offset = 0;                                                  \
    size_t filter_len = strlen(filter);                                 \
    while (name[offset] != '\0') {                                      \
        if (name[offset] == filter[0]) {                                \
            if (0 == strncmp(&name[offset], filter, filter_len)) {      \
                return 1;                                               \
            }                                                           \
        }                                                               \
        offset++;                                                       \
    }                                                                   \
                                                                        \
    return 0;                                                           \
}                                                                       \
                                                                        \
int greatest_pre_test(const char *name) {                               \
    if (!GREATEST_LIST_ONLY()                                           \
        && (!GREATEST_FIRST_FAIL() || greatest_info.suite.failed == 0)  \
        && (greatest_info.test_filter == NULL ||                        \
            greatest_name_match(name, greatest_info.test_filter))) {    \
        GREATEST_SET_TIME(greatest_info.suite.pre_test);                \
        if (greatest_info.setup) {                                      \
            greatest_info.setup(greatest_info.setup_udata);             \
        }                                                               \
        return 1;               /* test should be run */                \
    } else {                                                            \
        return 0;               /* skipped */                           \
    }                                                                   \
}                                                                       \
                                                                        \
void greatest_post_test(const char *name, int res) {                    \
    GREATEST_SET_TIME(greatest_info.suite.post_test);                   \
    if (greatest_info.teardown) {                                       \
        void *udata = greatest_info.teardown_udata;                     \
        greatest_info.teardown(udata);                                  \
    }                                                                   \
                                                                        \
    if (res <= GREATEST_TEST_RES_FAIL) {                                \
        greatest_do_fail(name);                                         \
    } else if (res >= GREATEST_TEST_RES_SKIP) {                         \
        greatest_do_skip(name);                                         \
    } else if (res == GREATEST_TEST_RES_PASS) {                         \
        greatest_do_pass(name);                                         \
    }                                                                   \
    greatest_info.suite.tests_run++;                                    \
    greatest_info.col++;                                                \
    if (GREATEST_IS_VERBOSE()) {                                        \
        GREATEST_CLOCK_DIFF(greatest_info.suite.pre_test,               \
            greatest_info.suite.post_test);                             \
        fprintf(GREATEST_STDOUT, "\n");                                 \
    } else if (greatest_info.col % greatest_info.width == 0) {          \
        fprintf(GREATEST_STDOUT, "\n");                                 \
        greatest_info.col = 0;                                          \
    }                                                                   \
    fflush(GREATEST_STDOUT);                                            \
}                                                                       \
                                                                        \
static void report_suite(void) {                                        \
    if (greatest_info.suite.tests_run > 0) {                            \
        fprintf(GREATEST_STDOUT,                                        \
            "\n%u test%s - %u passed, %u failed, %u skipped",           \
            greatest_info.suite.tests_run,                              \
            greatest_info.suite.tests_run == 1 ? "" : "s",              \
            greatest_info.suite.passed,                                 \
            greatest_info.suite.failed,                                 \
            greatest_info.suite.skipped);                               \
        GREATEST_CLOCK_DIFF(greatest_info.suite.pre_suite,              \
            greatest_info.suite.post_suite);                            \
        fprintf(GREATEST_STDOUT, "\n");                                 \
    }                                                                   \
}                                                                       \
                                                                        \
static void update_counts_and_reset_suite(void) {                       \
    greatest_info.setup = NULL;                                         \
    greatest_info.setup_udata = NULL;                                   \
    greatest_info.teardown = NULL;                                      \
    greatest_info.teardown_udata = NULL;                                \
    greatest_info.passed += greatest_info.suite.passed;                 \
    greatest_info.failed += greatest_info.suite.failed;                 \
    greatest_info.skipped += greatest_info.suite.skipped;               \
    greatest_info.tests_run += greatest_info.suite.tests_run;           \
    memset(&greatest_info.suite, 0, sizeof(greatest_info.suite));       \
    greatest_info.col = 0;                                              \
}                                                                       \
                                                                        \
static void greatest_run_suite(greatest_suite_cb *suite_cb,             \
                               const char *suite_name) {                \
    if (greatest_info.suite_filter &&                                   \
        !greatest_name_match(suite_name, greatest_info.suite_filter)) { \
        return;                                                         \
    }                                                                   \
    update_counts_and_reset_suite();                                    \
    if (GREATEST_FIRST_FAIL() && greatest_info.failed > 0) { return; }  \
    fprintf(GREATEST_STDOUT, "\n" GREATEST_ANSI_COLOR_YELLOW "* Suite %s:" GREATEST_ANSI_COLOR_RESET "\n", suite_name);  \
    GREATEST_SET_TIME(greatest_info.suite.pre_suite);                   \
    suite_cb();                                                         \
    GREATEST_SET_TIME(greatest_info.suite.post_suite);                  \
    report_suite();                                                     \
}                                                                       \
                                                                        \
void greatest_do_pass(const char *name) {                               \
    if (GREATEST_IS_VERBOSE()) {                                        \
        fprintf(GREATEST_STDOUT, "PASS %s: %s",                         \
            name, greatest_info.msg ? greatest_info.msg : "");          \
    } else {                                                            \
        fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_GREEN "." GREATEST_ANSI_COLOR_RESET);  \
    }                                                                   \
    greatest_info.suite.passed++;                                       \
}                                                                       \
                                                                        \
void greatest_do_fail(const char *name) {                               \
    if (GREATEST_IS_VERBOSE()) {                                        \
        fprintf(GREATEST_STDOUT,                                        \
            "FAIL %s: %s (%s:%u)",                                      \
            name, greatest_info.msg ? greatest_info.msg : "",           \
            greatest_info.fail_file, greatest_info.fail_line);          \
    } else {                                                            \
        fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_RED "F" GREATEST_ANSI_COLOR_RESET);    \
        greatest_info.col++;                                            \
        /* add linebreak if in line of '.'s */                          \
        if (greatest_info.col != 0) {                                   \
            fprintf(GREATEST_STDOUT, "\n");                             \
            greatest_info.col = 0;                                      \
        }                                                               \
        fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_RED "FAIL" GREATEST_ANSI_COLOR_RESET " %s: %s (%s:%u)\n",  \
            name,                                                       \
            greatest_info.msg ? greatest_info.msg : "",                 \
            greatest_info.fail_file, greatest_info.fail_line);          \
    }                                                                   \
    greatest_info.suite.failed++;                                       \
}                                                                       \
                                                                        \
void greatest_do_skip(const char *name) {                               \
    if (GREATEST_IS_VERBOSE()) {                                        \
        fprintf(GREATEST_STDOUT, "SKIP %s: %s",                         \
            name,                                                       \
            greatest_info.msg ?                                         \
            greatest_info.msg : "" );                                   \
    } else {                                                            \
        fprintf(GREATEST_STDOUT, "s");                                  \
    }                                                                   \
    greatest_info.suite.skipped++;                                      \
}                                                                       \
                                                                        \
int greatest_do_assert_equal_t(const void *exp, const void *got,        \
        greatest_type_info *type_info, void *udata) {                   \
    int eq = 0;                                                         \
    if (type_info == NULL || type_info->equal == NULL) {                \
        return 0;                                                       \
    }                                                                   \
    eq = type_info->equal(exp, got, udata);                             \
    if (!eq) {                                                          \
        if (type_info->print != NULL) {                                 \
            fprintf(GREATEST_STDOUT, "\nExpected: ");                   \
            (void)type_info->print(exp, udata);                         \
            fprintf(GREATEST_STDOUT, "\n     Got: ");                   \
            (void)type_info->print(got, udata);                         \
            fprintf(GREATEST_STDOUT, "\n");                             \
        } else {                                                        \
            fprintf(GREATEST_STDOUT,                                    \
                "GREATEST_ASSERT_EQUAL_T failure at %s:%u\n",           \
                greatest_info.fail_file,                                \
                greatest_info.fail_line);                               \
        }                                                               \
    }                                                                   \
    return eq;                                                          \
}                                                                       \
                                                                        \
void greatest_usage(const char *name) {                                 \
    fprintf(GREATEST_STDOUT,                                            \
        "Usage: %s [-hlfv] [-s SUITE] [-t TEST]\n"                      \
        "  -h, --help  print this Help\n"                               \
        "  -l          List suites and their tests, then exit\n"        \
        "  -f          Stop runner after first failure\n"               \
        "  -v          Verbose output\n"                                \
        "  -s SUITE    only run suites containing string SUITE\n"       \
        "  -t TEST     only run tests containing string TEST\n",        \
        name);                                                          \
}                                                                       \
                                                                        \
static void greatest_parse_args(int argc, char **argv) {                \
    int i = 0;                                                          \
    for (i = 1; i < argc; i++) {                                        \
        if (0 == strncmp("-t", argv[i], 2)) {                           \
            if (argc <= i + 1) {                                        \
                greatest_usage(argv[0]);                                \
                exit(EXIT_FAILURE);                                     \
            }                                                           \
            greatest_info.test_filter = argv[i+1];                      \
            i++;                                                        \
        } else if (0 == strncmp("-s", argv[i], 2)) {                    \
            if (argc <= i + 1) {                                        \
                greatest_usage(argv[0]);                                \
                exit(EXIT_FAILURE);                                     \
            }                                                           \
            greatest_info.suite_filter = argv[i+1];                     \
            i++;                                                        \
        } else if (0 == strncmp("-f", argv[i], 2)) {                    \
            greatest_info.flags |= GREATEST_FLAG_FIRST_FAIL;            \
        } else if (0 == strncmp("-v", argv[i], 2)) {                    \
            greatest_info.verbosity++;                                  \
        } else if (0 == strncmp("-l", argv[i], 2)) {                    \
            greatest_info.flags |= GREATEST_FLAG_LIST_ONLY;             \
        } else if (0 == strncmp("-h", argv[i], 2) ||                    \
                   0 == strncmp("--help", argv[i], 6)) {                \
            greatest_usage(argv[0]);                                    \
            exit(EXIT_SUCCESS);                                         \
        } else if (0 == strncmp("--", argv[i], 2)) {                    \
            break;                                                      \
        } else {                                                        \
            fprintf(GREATEST_STDOUT,                                    \
                "Unknown argument '%s'\n", argv[i]);                    \
            greatest_usage(argv[0]);                                    \
            exit(EXIT_FAILURE);                                         \
        }                                                               \
    }                                                                   \
}                                                                       \
                                                                        \
int greatest_all_passed(void) { return (greatest_info.failed == 0); }   \
                                                                        \
void greatest_set_test_filter(const char *name) {                       \
    greatest_info.test_filter = name;                                   \
}                                                                       \
                                                                        \
void greatest_set_suite_filter(const char *name) {                      \
    greatest_info.suite_filter = name;                                  \
}                                                                       \
                                                                        \
void greatest_get_report(struct greatest_report_t *report) {            \
    if (report) {                                                       \
        report->passed = greatest_info.passed;                          \
        report->failed = greatest_info.failed;                          \
        report->skipped = greatest_info.skipped;                        \
        report->assertions = greatest_info.assertions;                  \
    }                                                                   \
}                                                                       \
                                                                        \
unsigned int greatest_get_verbosity(void) {                             \
    return greatest_info.verbosity;                                     \
}                                                                       \
                                                                        \
void greatest_set_verbosity(unsigned int verbosity) {                   \
    greatest_info.verbosity = (unsigned char)verbosity;                 \
}                                                                       \
                                                                        \
void greatest_set_flag(greatest_flag_t flag) {                          \
    greatest_info.flags |= flag;                                        \
}                                                                       \
                                                                        \
void GREATEST_SET_SETUP_CB(greatest_setup_cb *cb, void *udata) {        \
    greatest_info.setup = cb;                                           \
    greatest_info.setup_udata = udata;                                  \
}                                                                       \
                                                                        \
void GREATEST_SET_TEARDOWN_CB(greatest_teardown_cb *cb,                 \
                                    void *udata) {                      \
    greatest_info.teardown = cb;                                        \
    greatest_info.teardown_udata = udata;                               \
}                                                                       \
                                                                        \
static int greatest_string_equal_cb(const void *exp, const void *got,   \
    void *udata) {                                                      \
    size_t *size = (size_t *)udata;                                     \
    return (size != NULL                                                \
        ? (0 == strncmp((const char *)exp, (const char *)got, *size))   \
        : (0 == strcmp((const char *)exp, (const char *)got)));         \
}                                                                       \
                                                                        \
static int greatest_string_printf_cb(const void *t, void *udata) {      \
    (void)udata; /* note: does not check \0 termination. */             \
    return fprintf(GREATEST_STDOUT, "%s", (const char *)t);             \
}                                                                       \
                                                                        \
greatest_type_info greatest_type_info_string = {                        \
    greatest_string_equal_cb,                                           \
    greatest_string_printf_cb,                                          \
};                                                                      \
                                                                        \
static int greatest_memory_equal_cb(const void *exp, const void *got,   \
    void *udata) {                                                      \
    greatest_memory_cmp_env *env = (greatest_memory_cmp_env *)udata;    \
    return (0 == memcmp(exp, got, env->size));                          \
}                                                                       \
                                                                        \
static int greatest_memory_printf_cb(const void *t, void *udata) {      \
    greatest_memory_cmp_env *env = (greatest_memory_cmp_env *)udata;    \
    const unsigned char *buf = (const unsigned char *)t;                \
    unsigned char diff_mark = ' ';                                      \
    FILE *out = GREATEST_STDOUT;                                        \
    size_t i, line_i, line_len = 0;                                     \
    int len = 0;   /* format hexdump with differences highlighted */    \
    for (i = 0; i < env->size; i+= line_len) {                          \
        diff_mark = ' ';                                                \
        line_len = env->size - i;                                       \
        if (line_len > 16) { line_len = 16; }                           \
        for (line_i = i; line_i < i + line_len; line_i++) {             \
            if (env->exp[line_i] != env->got[line_i]) diff_mark = 'X';  \
        }                                                               \
        len += fprintf(out, "\n%04x %c ", (unsigned int)i, diff_mark);  \
        for (line_i = i; line_i < i + line_len; line_i++) {             \
            int m = env->exp[line_i] == env->got[line_i]; /* match? */  \
            len += fprintf(out, "%02x%c", buf[line_i], m ? ' ' : '<');  \
        }                                                               \
        for (line_i = 0; line_i < 16 - line_len; line_i++) {            \
            len += fprintf(out, "   ");                                 \
        }                                                               \
        fprintf(out, " ");                                              \
        for (line_i = i; line_i < i + line_len; line_i++) {             \
            unsigned char c = buf[line_i];                              \
            len += fprintf(out, "%c", isprint(c) ? c : '.');            \
        }                                                               \
    }                                                                   \
    len += fprintf(out, "\n");                                          \
    return len;                                                         \
}                                                                       \
                                                                        \
greatest_type_info greatest_type_info_memory = {                        \
    greatest_memory_equal_cb,                                           \
    greatest_memory_printf_cb,                                          \
};                                                                      \
                                                                        \
greatest_run_info greatest_info

/* Init internals. */
#define GREATEST_INIT()                                                 \
    do {                                                                \
        /* Suppress unused function warning if features aren't used */  \
        (void)greatest_run_suite;                                       \
        (void)greatest_parse_args;                                      \
                                                                        \
        memset(&greatest_info, 0, sizeof(greatest_info));               \
        greatest_info.width = GREATEST_DEFAULT_WIDTH;                   \
        GREATEST_SET_TIME(greatest_info.begin);                         \
    } while (0)                                                         \

/* Handle command-line arguments, etc. */
#define GREATEST_MAIN_BEGIN()                                           \
    do {                                                                \
        GREATEST_INIT();                                                \
        greatest_parse_args(argc, argv);                                \
    } while (0)

/* Report passes, failures, skipped tests, the number of
 * assertions, and the overall run time. */
#define GREATEST_PRINT_REPORT()                                         \
    do {                                                                \
        if (!GREATEST_LIST_ONLY()) {                                    \
            update_counts_and_reset_suite();                            \
            GREATEST_SET_TIME(greatest_info.end);                       \
            fprintf(GREATEST_STDOUT,                                    \
                "\nTotal: %u test%s",                                   \
                greatest_info.tests_run,                                \
                greatest_info.tests_run == 1 ? "" : "s");               \
            GREATEST_CLOCK_DIFF(greatest_info.begin,                    \
                greatest_info.end);                                     \
            fprintf(GREATEST_STDOUT, ", %u assertion%s\n",              \
                greatest_info.assertions,                               \
                greatest_info.assertions == 1 ? "" : "s");              \
            fprintf(GREATEST_STDOUT,                                    \
                GREATEST_ANSI_COLOR_GREEN "Pass: %u, fail: %u, skip: %u.\n" GREATEST_ANSI_COLOR_RESET,  \
                greatest_info.passed,                                   \
                greatest_info.failed, greatest_info.skipped);           \
        }                                                               \
    } while (0)

/* Report results, exit with exit status based on results. */
#define GREATEST_MAIN_END()                                             \
    do {                                                                \
        GREATEST_PRINT_REPORT();                                        \
        return (greatest_all_passed() ? EXIT_SUCCESS : EXIT_FAILURE);   \
    } while (0)

/* Make abbreviations without the GREATEST_ prefix for the
 * most commonly used symbols. */
#ifdef GREATEST_USE_ABBREVS
#define TEST           GREATEST_TEST
#define SUITE          GREATEST_SUITE
#define SUITE_EXTERN   GREATEST_SUITE_EXTERN
#define RUN_TEST       GREATEST_RUN_TEST
#define RUN_TEST1      GREATEST_RUN_TEST1
#define RUN_SUITE      GREATEST_RUN_SUITE
#define IGNORE_TEST    GREATEST_IGNORE_TEST
#define ASSERT         GREATEST_ASSERT
#define ASSERTm        GREATEST_ASSERTm
#define ASSERT_FALSE   GREATEST_ASSERT_FALSE
#define ASSERT_EQ      GREATEST_ASSERT_EQ
#define ASSERT_EQ_FMT  GREATEST_ASSERT_EQ_FMT
#define ASSERT_IN_RANGE GREATEST_ASSERT_IN_RANGE
#define ASSERT_EQUAL_T GREATEST_ASSERT_EQUAL_T
#define ASSERT_STR_EQ  GREATEST_ASSERT_STR_EQ
#define ASSERT_STRN_EQ GREATEST_ASSERT_STRN_EQ
#define ASSERT_MEM_EQ  GREATEST_ASSERT_MEM_EQ
#define ASSERT_ENUM_EQ GREATEST_ASSERT_ENUM_EQ
#define ASSERT_FALSEm  GREATEST_ASSERT_FALSEm
#define ASSERT_EQm     GREATEST_ASSERT_EQm
#define ASSERT_EQ_FMTm GREATEST_ASSERT_EQ_FMTm
#define ASSERT_IN_RANGEm GREATEST_ASSERT_IN_RANGEm
#define ASSERT_EQUAL_Tm GREATEST_ASSERT_EQUAL_Tm
#define ASSERT_STR_EQm GREATEST_ASSERT_STR_EQm
#define ASSERT_STRN_EQm GREATEST_ASSERT_STRN_EQm
#define ASSERT_MEM_EQm GREATEST_ASSERT_MEM_EQm
#define ASSERT_ENUM_EQm GREATEST_ASSERT_ENUM_EQm
#define PASS           GREATEST_PASS
#define FAIL           GREATEST_FAIL
#define SKIP           GREATEST_SKIP
#define PASSm          GREATEST_PASSm
#define FAILm          GREATEST_FAILm
#define SKIPm          GREATEST_SKIPm
#define SET_SETUP      GREATEST_SET_SETUP_CB
#define SET_TEARDOWN   GREATEST_SET_TEARDOWN_CB
#define CHECK_CALL     GREATEST_CHECK_CALL

#ifdef GREATEST_VA_ARGS
#define RUN_TESTp      GREATEST_RUN_TESTp
#endif

#ifdef GREATEST_USE_LONGJMP
#define ASSERT_OR_LONGJMP  GREATEST_ASSERT_OR_LONGJMP
#define ASSERT_OR_LONGJMPm GREATEST_ASSERT_OR_LONGJMPm
#define FAIL_WITH_LONGJMP  GREATEST_FAIL_WITH_LONGJMP
#define FAIL_WITH_LONGJMPm GREATEST_FAIL_WITH_LONGJMPm
#endif

#endif /* USE_ABBREVS */

#ifdef __cplusplus
}
#endif

#endif
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_helpers.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireHelpersTestAllocator = 0;
static octaspire_stdio_t     *octaspireHelpersTestStdio = 0;

TEST octaspire_helpers_test_bit_when_only_highest_order_bit_is_set_test(void)
{
    uint32_t const bitSet = 0x80000000;

    for (size_t i = 0; i < 31; ++i)
    {
        ASSERT_FALSE(octaspire_helpers_test_bit(bitSet, i));
    }

    ASSERT(octaspire_helpers_test_bit(bitSet, 31));

    PASS();
}

TEST octaspire_helpers_test_bit_when_only_lowest_order_bit_is_set_test(void)
{
    uint32_t const bitSet = 0x00000001;

    ASSERT(octaspire_helpers_test_bit(bitSet, 0));

    for (size_t i = 1; i < 32; ++i)
    {
        ASSERT_FALSE(octaspire_helpers_test_bit(bitSet, i));
    }

    PASS();
}

TEST octaspire_helpers_test_bit_when_all_bits_are_set_test(void)
{
    uint32_t const bitSet = 0xFFFFFFFF;

    for (size_t i = 0; i < 32; ++i)
    {
        ASSERT(octaspire_helpers_test_bit(bitSet, i));
    }

    PASS();
}

TEST octaspire_helpers_test_bit_when_no_bits_are_set_test(void)
{
    uint32_t const bitSet = 0x00000000;

    for (size_t i = 0; i < 32; ++i)
    {
        ASSERT_FALSE(octaspire_helpers_test_bit(bitSet, i));
    }

    PASS();
}

TEST octaspire_helpers_test_bit_when_every_bit_at_even_index_is_set_test(void)
{
    uint32_t const bitSet = 0x55555555;

    for (size_t i = 0; i < 32; ++i)
    {
        if (i % 2 == 0)
        {
            ASSERT(octaspire_helpers_test_bit(bitSet, i));
        }
        else
        {
            ASSERT_FALSE(octaspire_helpers_test_bit(bitSet, i));
        }
    }

    PASS();
}

TEST octaspire_helpers_test_bit_when_every_bit_at_odd_index_is_set_test(void)
{
    uint32_t const bitSet = 0xAAAAAAAA;

    for (size_t i = 0; i < 32; ++i)
    {
        if (i % 2 != 0)
        {
            ASSERT(octaspire_helpers_test_bit(bitSet, i));
        }
        else
        {
            ASSERT_FALSE(octaspire_helpers_test_bit(bitSet, i));
        }
    }

    PASS();
}

TEST octaspire_helpers_path_to_buffer_test(void)
{
    size_t octetsAllocated = 0;

    char * buffer = octaspire_helpers_path_to_buffer(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_helpers_path_to_buffer_test",
        &octetsAllocated,
        octaspireHelpersTestAllocator,
        octaspireHelpersTestStdio);

    ASSERT(buffer);
    ASSERT_EQ(2 + 3 + 4, octetsAllocated);

    // Copyright sign 0xa9               2 octet
    // Equal sign     0x2260             3 octets
    // Linear b syllable b008 a 0x10000  4 octets
    char const * const expected = "\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    ASSERT_EQ(octetsAllocated, strlen(expected));

    ASSERT_MEM_EQ(expected, buffer, octetsAllocated);

    octaspire_allocator_free(octaspireHelpersTestAllocator, buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_helpers_path_to_buffer_failure_on_nonexisting_file_test(void)
{
    size_t octetsAllocated = 0;

    char * buffer = octaspire_helpers_path_to_buffer(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_helpers_path_to_buffer_failure_on_nonexisting_file_test",
        &octetsAllocated,
        octaspireHelpersTestAllocator,
        octaspireHelpersTestStdio);

    ASSERT_FALSE(buffer);
    ASSERT_EQ(0, octetsAllocated);

    octaspire_allocator_free(octaspireHelpersTestAllocator, buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_helpers_path_to_buffer_failure_on_empty_file_test(void)
{
    size_t octetsAllocated = 0;

    char * buffer = octaspire_helpers_path_to_buffer(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_helpers_path_to_buffer_failure_on_empty_file_test",
        &octetsAllocated,
        octaspireHelpersTestAllocator,
        octaspireHelpersTestStdio);

    ASSERT_FALSE(buffer);
    ASSERT_EQ(0, octetsAllocated);

    octaspire_allocator_free(octaspireHelpersTestAllocator, buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_helpers_path_to_buffer_allocation_failure_test(void)
{
    size_t octetsAllocated = 0;

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireHelpersTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireHelpersTestAllocator));

    char * buffer = octaspire_helpers_path_to_buffer(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_helpers_path_to_buffer_test",
        &octetsAllocated,
        octaspireHelpersTestAllocator,
        octaspireHelpersTestStdio);

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireHelpersTestAllocator));

    ASSERT_FALSE(buffer);
    ASSERT_EQ(0, octetsAllocated);

    octaspire_allocator_free(octaspireHelpersTestAllocator, buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_helpers_path_to_buffer_read_failure_test(void)
{
    size_t octetsAllocated = 0;

    octaspire_stdio_set_number_and_type_of_future_reads_to_be_rigged(octaspireHelpersTestStdio, 1, 0);
    ASSERT_EQ(1, octaspire_stdio_get_number_of_future_reads_to_be_rigged(octaspireHelpersTestStdio));

    char * buffer = octaspire_helpers_path_to_buffer(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_helpers_path_to_buffer_test",
        &octetsAllocated,
        octaspireHelpersTestAllocator,
        octaspireHelpersTestStdio);

    ASSERT_EQ(0, octaspire_stdio_get_number_of_future_reads_to_be_rigged(octaspireHelpersTestStdio));

    ASSERT_FALSE(buffer);
    ASSERT_EQ(0, octetsAllocated);

    octaspire_allocator_free(octaspireHelpersTestAllocator, buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_helpers_is_even_size_t_test(void)
{
    ASSERT(octaspire_helpers_is_even_size_t(0));

    for (size_t i = 2; i < 1024; i += 2)
    {
        ASSERT(octaspire_helpers_is_even_size_t(i));
    }

    ASSERT_FALSE(octaspire_helpers_is_even_size_t(1));

    for (size_t i = 3; i < 1024; i += 2)
    {
        ASSERT_FALSE(octaspire_helpers_is_even_size_t(i));
    }

    PASS();
}

TEST octaspire_helpers_is_odd_size_t_test(void)
{
    ASSERT_FALSE(octaspire_helpers_is_odd_size_t(0));

    for (size_t i = 1; i < 1024; i += 2)
    {
        ASSERT(octaspire_helpers_is_odd_size_t(i));
    }

    ASSERT_FALSE(octaspire_helpers_is_odd_size_t(2));

    for (size_t i = 4; i < 1024; i += 2)
    {
        ASSERT_FALSE(octaspire_helpers_is_odd_size_t(i));
    }

    PASS();
}

TEST octaspire_helpers_calculate_hash_for_memory_buffer_argument_test(void)
{
    char const buffer[] = {'a', 'b', 'c'};

    ASSERT_EQ(
        3977453403,
        octaspire_helpers_calculate_hash_for_memory_buffer_argument(
            buffer,
            sizeof(buffer)));

    char const * const buffer2 = "123456789=?qwertyuiop#_.:,!++?";

    ASSERT_EQ(
        3026418028,
        octaspire_helpers_calculate_hash_for_memory_buffer_argument(
            buffer2,
            strlen(buffer2)));

    PASS();
}

TEST octaspire_helpers_base64_encode_qwerty1_line_len_0_test(void)
{
    char const * const input = "qwerty1";

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        input,
        strlen(input),
        0,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    ASSERT_STR_EQ("cXdlcnR5MQ==", octaspire_string_get_c_string(encoded));

    octaspire_string_release(encoded);
    encoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_encode_qwerty1_line_len_10_test(void)
{
    char const * const input = "qwerty1";

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        input,
        strlen(input),
        10,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    ASSERT_STR_EQ("cXdlcnR5MQ\n==", octaspire_string_get_c_string(encoded));

    octaspire_string_release(encoded);
    encoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_decode_encoded_qwerty1_test(void)
{
    char const * const input = "cXdlcnR5MQ==";

    octaspire_vector_t * decoded = octaspire_helpers_base64_decode(
        input,
        (int32_t)strlen(input),
        octaspireHelpersTestAllocator);

    ASSERT(decoded);

    char const * const expected = "qwerty1";

    ASSERT_EQ(strlen(expected), octaspire_vector_get_length(decoded));

    for (size_t i = 0; i < strlen(expected); ++i)
    {
        ASSERT_EQ(
            expected[i],
            *(char const * const)octaspire_vector_get_element_at_const(
                decoded,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(decoded);
    decoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_decode_encoded_qwerty1_with_embedded_whitespace_test(void)
{
    char const * const input = "\ncX\nd l\ncnR5\nM Q= \n= \n ";

    octaspire_vector_t * decoded = octaspire_helpers_base64_decode(
        input,
        (int32_t)strlen(input),
        octaspireHelpersTestAllocator);

    ASSERT(decoded);

    char const * const expected = "qwerty1";

    ASSERT_EQ(strlen(expected), octaspire_vector_get_length(decoded));

    for (size_t i = 0; i < strlen(expected); ++i)
    {
        ASSERT_EQ(
            expected[i],
            *(char const * const)octaspire_vector_get_element_at_const(
                decoded,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(decoded);
    decoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_encode_a_line_len_0_test(void)
{
    char const * const input = "a";

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        input,
        strlen(input),
        0,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    ASSERT_STR_EQ("YQ==", octaspire_string_get_c_string(encoded));

    octaspire_string_release(encoded);
    encoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_encode_a_line_len_1_test(void)
{
    char const * const input = "a";

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        input,
        strlen(input),
        1,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    ASSERT_STR_EQ("Y\nQ\n=\n=", octaspire_string_get_c_string(encoded));

    octaspire_string_release(encoded);
    encoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_decode_encoded_a_test(void)
{
    char const * const input = "YQ==";

    octaspire_vector_t * decoded = octaspire_helpers_base64_decode(
        input,
        (int32_t)strlen(input),
        octaspireHelpersTestAllocator);

    ASSERT(decoded);

    char const * const expected = "a";

    ASSERT_EQ(strlen(expected), octaspire_vector_get_length(decoded));

    for (size_t i = 0; i < strlen(expected); ++i)
    {
        ASSERT_EQ(
            expected[i],
            *(char const * const)octaspire_vector_get_element_at_const(
                decoded,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(decoded);
    decoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_decode_encoded_a_with_embedded_whitespace_test(void)
{
    char const * const input = " Y\t \t \t\t Q  = =  \t \n";

    octaspire_vector_t * decoded = octaspire_helpers_base64_decode(
        input,
        (int32_t)strlen(input),
        octaspireHelpersTestAllocator);

    ASSERT(decoded);

    char const * const expected = "a";

    ASSERT_EQ(strlen(expected), octaspire_vector_get_length(decoded));

    for (size_t i = 0; i < strlen(expected); ++i)
    {
        ASSERT_EQ(
            expected[i],
            *(char const * const)octaspire_vector_get_element_at_const(
                decoded,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(decoded);
    decoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_encode_empty_string_line_length_0_test(void)
{
    char const * const input = "";

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        input,
        strlen(input),
        0,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    ASSERT_STR_EQ("", octaspire_string_get_c_string(encoded));

    octaspire_string_release(encoded);
    encoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_encode_empty_string_line_length_20_test(void)
{
    char const * const input = "";

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        input,
        strlen(input),
        20,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    ASSERT_STR_EQ("", octaspire_string_get_c_string(encoded));

    octaspire_string_release(encoded);
    encoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_decode_encoded_empty_string_test(void)
{
    char const * const input = "";

    octaspire_vector_t * decoded = octaspire_helpers_base64_decode(
        input,
        (int32_t)strlen(input),
        octaspireHelpersTestAllocator);

    ASSERT_EQ(0, decoded);

    octaspire_vector_release(decoded);
    decoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_decode_encoded_empty_string_with_whitespace_test(void)
{
    char const * const input = " \t \n ";

    octaspire_vector_t * decoded = octaspire_helpers_base64_decode(
        input,
        (int32_t)strlen(input),
        octaspireHelpersTestAllocator);

    ASSERT_EQ(0, decoded);

    octaspire_vector_release(decoded);
    decoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_encode_base64_characters_line_length_0_test(void)
{
    char const * const input =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        input,
        strlen(input),
        0,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    ASSERT_STR_EQ(
        "QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5e"
        "jAxMjM0NTY3ODkrLw==",
        octaspire_string_get_c_string(encoded));

    octaspire_string_release(encoded);
    encoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_encode_base64_characters_line_length_64_test(void)
{
    char const * const input =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        input,
        strlen(input),
        64,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    ASSERT_STR_EQ(
        "QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2\nd3h5e"
        "jAxMjM0NTY3ODkrLw==",
        octaspire_string_get_c_string(encoded));

    octaspire_string_release(encoded);
    encoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_decode_encoded_base64_characters_test(void)
{
    char const * const input =
        "QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5e"
        "jAxMjM0NTY3ODkrLw==";

    octaspire_vector_t * decoded = octaspire_helpers_base64_decode(
        input,
        (int32_t)strlen(input),
        octaspireHelpersTestAllocator);

    ASSERT(decoded);

    char const * const expected =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    ASSERT_EQ(strlen(expected), octaspire_vector_get_length(decoded));

    for (size_t i = 0; i < strlen(expected); ++i)
    {
        ASSERT_EQ(
            expected[i],
            *(char const * const)octaspire_vector_get_element_at_const(
                decoded,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(decoded);
    decoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_decode_encoded_base64_characters_with_whitespace_test(void)
{
    char const * const input =
        " QU JD   RE\tVGR0hJ\nSktMTU5PUFFSU\n1RVVl  dYW VphYmNkZWZna\tGlqa2xtbm9wcXJzdHV2d 3h5e"
        "jAx M j M 0NTY\t\t\n 3ODkr Lw= =";

    octaspire_vector_t * decoded = octaspire_helpers_base64_decode(
        input,
        (int32_t)strlen(input),
        octaspireHelpersTestAllocator);

    ASSERT(decoded);

    char const * const expected =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    ASSERT_EQ(strlen(expected), octaspire_vector_get_length(decoded));

    for (size_t i = 0; i < strlen(expected); ++i)
    {
        ASSERT_EQ(
            expected[i],
            *(char const * const)octaspire_vector_get_element_at_const(
                decoded,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(decoded);
    decoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_encode_printable_ascii_characters_line_len_0_test(void)
{
    char const * const input =
        " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abc"
        "defghijklmnopqrstuvwxyz{|}~";

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        input,
        strlen(input),
        0,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    ASSERT_STR_EQ(
        "ICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1R"
        "VVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX4=",
        octaspire_string_get_c_string(encoded));

    octaspire_string_release(encoded);
    encoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_encode_printable_ascii_characters_line_len_10_test(void)
{
    char const * const input =
        " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abc"
        "defghijklmnopqrstuvwxyz{|}~";

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        input,
        strlen(input),
        10,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    ASSERT_STR_EQ(
        "ICEiIyQlJi\ncoKSorLC0u\nLzAxMjM0NT\nY3ODk6Ozw9\nPj9AQUJDRE\nVGR0hJSktM\nTU5PUFFSU1\nR"
        "VVldYWVpb\nXF1eX2BhYm\nNkZWZnaGlq\na2xtbm9wcX\nJzdHV2d3h5\nent8fX4=",
        octaspire_string_get_c_string(encoded));

    octaspire_string_release(encoded);
    encoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_decode_encoded_printable_ascii_characters_test(void)
{
    char const * const input =
        "ICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1R"
        "VVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX4=";

    octaspire_vector_t * decoded = octaspire_helpers_base64_decode(
        input,
        (int32_t)strlen(input),
        octaspireHelpersTestAllocator);

    ASSERT(decoded);

    char const * const expected =
        " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abc"
        "defghijklmnopqrstuvwxyz{|}~";

    ASSERT_EQ(strlen(expected), octaspire_vector_get_length(decoded));

    for (size_t i = 0; i < strlen(expected); ++i)
    {
        ASSERT_EQ(
            expected[i],
            *(char const * const)octaspire_vector_get_element_at_const(
                decoded,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(decoded);
    decoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_decode_encoded_printable_ascii_characters_with_whitespace_test(void)
{
    char const * const input =
        " I C EiI yQ  lJ  icoK\tSorLC0uLzAx\n\nMjM0NTY3O Dk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1R"
        " V V l  d  Y  W    Vpb\nXF1eX\n\t 2B hYmN k  ZWZnaGlqa2xtbm9wcXJzdHV2d3 h 5ent8fX4=  ";

    octaspire_vector_t * decoded = octaspire_helpers_base64_decode(
        input,
        (int32_t)strlen(input),
        octaspireHelpersTestAllocator);

    ASSERT(decoded);

    char const * const expected =
        " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abc"
        "defghijklmnopqrstuvwxyz{|}~";

    ASSERT_EQ(strlen(expected), octaspire_vector_get_length(decoded));

    for (size_t i = 0; i < strlen(expected); ++i)
    {
        ASSERT_EQ(
            expected[i],
            *(char const * const)octaspire_vector_get_element_at_const(
                decoded,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(decoded);
    decoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_encode_all_octets_one_by_one_line_len_0_test(void)
{
    unsigned char input[0xFF + 1];

    for (size_t i = 0; i <= 0xFF; ++i)
        input[i] = (unsigned char)i;

    char const * const expected[] =
    {
        "AA==","AQ==","Ag==","Aw==","BA==","BQ==","Bg==","Bw==","CA==","CQ==",
        "Cg==","Cw==","DA==","DQ==","Dg==","Dw==","EA==","EQ==","Eg==","Ew==",
        "FA==","FQ==","Fg==","Fw==","GA==","GQ==","Gg==","Gw==","HA==","HQ==",
        "Hg==","Hw==","IA==","IQ==","Ig==","Iw==","JA==","JQ==","Jg==","Jw==",
        "KA==","KQ==","Kg==","Kw==","LA==","LQ==","Lg==","Lw==","MA==","MQ==",
        "Mg==","Mw==","NA==","NQ==","Ng==","Nw==","OA==","OQ==","Og==","Ow==",
        "PA==","PQ==","Pg==","Pw==","QA==","QQ==","Qg==","Qw==","RA==","RQ==",
        "Rg==","Rw==","SA==","SQ==","Sg==","Sw==","TA==","TQ==","Tg==","Tw==",
        "UA==","UQ==","Ug==","Uw==","VA==","VQ==","Vg==","Vw==","WA==","WQ==",
        "Wg==","Ww==","XA==","XQ==","Xg==","Xw==","YA==","YQ==","Yg==","Yw==",
        "ZA==","ZQ==","Zg==","Zw==","aA==","aQ==","ag==","aw==","bA==","bQ==",
        "bg==","bw==","cA==","cQ==","cg==","cw==","dA==","dQ==","dg==","dw==",
        "eA==","eQ==","eg==","ew==","fA==","fQ==","fg==","fw==","gA==","gQ==",
        "gg==","gw==","hA==","hQ==","hg==","hw==","iA==","iQ==","ig==","iw==",
        "jA==","jQ==","jg==","jw==","kA==","kQ==","kg==","kw==","lA==","lQ==",
        "lg==","lw==","mA==","mQ==","mg==","mw==","nA==","nQ==","ng==","nw==",
        "oA==","oQ==","og==","ow==","pA==","pQ==","pg==","pw==","qA==","qQ==",
        "qg==","qw==","rA==","rQ==","rg==","rw==","sA==","sQ==","sg==","sw==",
        "tA==","tQ==","tg==","tw==","uA==","uQ==","ug==","uw==","vA==","vQ==",
        "vg==","vw==","wA==","wQ==","wg==","ww==","xA==","xQ==","xg==","xw==",
        "yA==","yQ==","yg==","yw==","zA==","zQ==","zg==","zw==","0A==","0Q==",
        "0g==","0w==","1A==","1Q==","1g==","1w==","2A==","2Q==","2g==","2w==",
        "3A==","3Q==","3g==","3w==","4A==","4Q==","4g==","4w==","5A==","5Q==",
        "5g==","5w==","6A==","6Q==","6g==","6w==","7A==","7Q==","7g==","7w==",
        "8A==","8Q==","8g==","8w==","9A==","9Q==","9g==","9w==","+A==","+Q==",
        "+g==","+w==","/A==","/Q==","/g==","/w==",
    };

    size_t const inputLen = sizeof(input) / sizeof(input[0]);
    ASSERT_EQ(inputLen, sizeof(expected) / sizeof(expected[0]));

    for (size_t i = 0; i < inputLen; ++i)
    {
        octaspire_string_t * encoded = octaspire_helpers_base64_encode(
            (char const * const)(input + i),
            1,
            0,
            octaspireHelpersTestAllocator);

        ASSERT(encoded);

        ASSERT_STR_EQ(
            expected[i],
            octaspire_string_get_c_string(encoded));

        octaspire_string_release(encoded);
        encoded = 0;
    }

    PASS();
}

TEST octaspire_helpers_base64_encode_all_octets_line_len_0_test(void)
{
    unsigned char input[0xFF + 1];

    for (size_t i = 0; i <= 0xFF; ++i)
        input[i] = (unsigned char)i;

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        (char const * const)input,
        sizeof(input) / sizeof(input[0]),
        0,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    char const * const expected =
        "AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyM"
        "zQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZm"
        "doaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZq"
        "bnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3O"
        "z9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/w==";

    ASSERT_EQ(strlen(expected), octaspire_string_get_length_in_octets(encoded));

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(encoded));

    octaspire_string_release(encoded);
    encoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_encode_all_octets_line_len_69_test(void)
{
    unsigned char input[0xFF + 1];

    for (size_t i = 0; i <= 0xFF; ++i)
        input[i] = (unsigned char)i;

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        (char const * const)input,
        sizeof(input) / sizeof(input[0]),
        69,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    char const * const expected =
        "AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyM\n"
        "zQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZm\n"
        "doaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZq\n"
        "bnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3O\n"
        "z9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/w==";

    ASSERT_EQ(strlen(expected), octaspire_string_get_length_in_octets(encoded));

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(encoded));

    octaspire_string_release(encoded);
    encoded = 0;

    PASS();
}

TEST octaspire_helpers_base64_encode_and_then_decode_all_octets_line_len_69_test(void)
{
    unsigned char input[0xFF + 1];

    for (size_t i = 0; i <= 0xFF; ++i)
        input[i] = (unsigned char)i;

    octaspire_string_t * encoded = octaspire_helpers_base64_encode(
        (char const * const)input,
        sizeof(input) / sizeof(input[0]),
        69,
        octaspireHelpersTestAllocator);

    ASSERT(encoded);

    octaspire_vector_t * decoded = octaspire_helpers_base64_decode(
        octaspire_string_get_c_string(encoded),
        (int32_t)octaspire_string_get_length_in_octets(encoded),
        octaspireHelpersTestAllocator);

    ASSERT_EQ(0xFF + 1, octaspire_vector_get_length(decoded));

    for (size_t i = 0; i < octaspire_vector_get_length(decoded); ++i)
    {
        ASSERT_EQ(
            input[i],
            *(unsigned char const * const)
                octaspire_vector_get_element_at_const(decoded, (ptrdiff_t)i));
    }

    octaspire_string_release(encoded);
    encoded = 0;

    octaspire_vector_release(decoded);
    decoded = 0;

    PASS();
}

GREATEST_SUITE(octaspire_helpers_suite)
{
    octaspireHelpersTestAllocator = octaspire_allocator_new(0);
    octaspireHelpersTestStdio     = octaspire_stdio_new(octaspireHelpersTestAllocator);

    assert(octaspireHelpersTestAllocator);
    assert(octaspireHelpersTestStdio);

    RUN_TEST(octaspire_helpers_test_bit_when_only_highest_order_bit_is_set_test);
    RUN_TEST(octaspire_helpers_test_bit_when_only_lowest_order_bit_is_set_test);
    RUN_TEST(octaspire_helpers_test_bit_when_all_bits_are_set_test);
    RUN_TEST(octaspire_helpers_test_bit_when_no_bits_are_set_test);
    RUN_TEST(octaspire_helpers_test_bit_when_every_bit_at_even_index_is_set_test);
    RUN_TEST(octaspire_helpers_test_bit_when_every_bit_at_odd_index_is_set_test);
    RUN_TEST(octaspire_helpers_path_to_buffer_test);
    RUN_TEST(octaspire_helpers_path_to_buffer_failure_on_nonexisting_file_test);
    RUN_TEST(octaspire_helpers_path_to_buffer_failure_on_empty_file_test);
    RUN_TEST(octaspire_helpers_path_to_buffer_allocation_failure_test);
    RUN_TEST(octaspire_helpers_path_to_buffer_read_failure_test);

    RUN_TEST(octaspire_helpers_is_even_size_t_test);
    RUN_TEST(octaspire_helpers_is_odd_size_t_test);

    RUN_TEST(octaspire_helpers_calculate_hash_for_memory_buffer_argument_test);

    RUN_TEST(octaspire_helpers_base64_encode_qwerty1_line_len_0_test);
    RUN_TEST(octaspire_helpers_base64_encode_qwerty1_line_len_10_test);
    RUN_TEST(octaspire_helpers_base64_decode_encoded_qwerty1_test);
    RUN_TEST(octaspire_helpers_base64_decode_encoded_qwerty1_with_embedded_whitespace_test);
    RUN_TEST(octaspire_helpers_base64_encode_a_line_len_0_test);
    RUN_TEST(octaspire_helpers_base64_encode_a_line_len_1_test);
    RUN_TEST(octaspire_helpers_base64_decode_encoded_a_test);
    RUN_TEST(octaspire_helpers_base64_decode_encoded_a_with_embedded_whitespace_test);
    RUN_TEST(octaspire_helpers_base64_encode_empty_string_line_length_0_test);
    RUN_TEST(octaspire_helpers_base64_encode_empty_string_line_length_20_test);
    RUN_TEST(octaspire_helpers_base64_decode_encoded_empty_string_test);
    RUN_TEST(octaspire_helpers_base64_decode_encoded_empty_string_with_whitespace_test);
    RUN_TEST(octaspire_helpers_base64_encode_base64_characters_line_length_0_test);
    RUN_TEST(octaspire_helpers_base64_encode_base64_characters_line_length_64_test);
    RUN_TEST(octaspire_helpers_base64_decode_encoded_base64_characters_test);
    RUN_TEST(octaspire_helpers_base64_decode_encoded_base64_characters_with_whitespace_test);
    RUN_TEST(octaspire_helpers_base64_encode_printable_ascii_characters_line_len_0_test);
    RUN_TEST(octaspire_helpers_base64_encode_printable_ascii_characters_line_len_10_test);
    RUN_TEST(octaspire_helpers_base64_decode_encoded_printable_ascii_characters_test);
    RUN_TEST(octaspire_helpers_base64_decode_encoded_printable_ascii_characters_with_whitespace_test);
    RUN_TEST(octaspire_helpers_base64_encode_all_octets_one_by_one_line_len_0_test);
    RUN_TEST(octaspire_helpers_base64_encode_all_octets_line_len_0_test);
    RUN_TEST(octaspire_helpers_base64_encode_all_octets_line_len_69_test);
    RUN_TEST(octaspire_helpers_base64_encode_and_then_decode_all_octets_line_len_69_test);

    octaspire_stdio_release(octaspireHelpersTestStdio);
    octaspireHelpersTestStdio = 0;

    octaspire_allocator_release(octaspireHelpersTestAllocator);
    octaspireHelpersTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_helpers.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_utf8.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireUtf8TestAllocator = 0;

TEST octaspire_utf8_private_rangeof_test(void)
{
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST, octaspire_utf8_private_rangeof(0));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST, octaspire_utf8_private_rangeof(1));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST, octaspire_utf8_private_rangeof(126));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST, octaspire_utf8_private_rangeof(127));

    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND, octaspire_utf8_private_rangeof(128));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND, octaspire_utf8_private_rangeof(129));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND, octaspire_utf8_private_rangeof(1000));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND, octaspire_utf8_private_rangeof(2047));

    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD, octaspire_utf8_private_rangeof(2048));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD, octaspire_utf8_private_rangeof(2049));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD, octaspire_utf8_private_rangeof(32000));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD, octaspire_utf8_private_rangeof(65535));

    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH, octaspire_utf8_private_rangeof(65536));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH, octaspire_utf8_private_rangeof(65537));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH, octaspire_utf8_private_rangeof(100000));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH, octaspire_utf8_private_rangeof(1114111));

    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_ILLEGAL, octaspire_utf8_private_rangeof(1114112));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_ILLEGAL, octaspire_utf8_private_rangeof(1114113));

    PASS();
}

TEST octaspire_utf8_private_high_order_bits_test(void)
{
    ASSERT_EQ(((uint32_t)0x0),        octaspire_utf8_private_high_order_bits(OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST));
    ASSERT_EQ(((uint32_t)0xC080),     octaspire_utf8_private_high_order_bits(OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND));
    ASSERT_EQ(((uint32_t)0xE08080),   octaspire_utf8_private_high_order_bits(OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD));
    ASSERT_EQ(((uint32_t)0xF0808080), octaspire_utf8_private_high_order_bits(OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH));
    ASSERT_EQ(((uint32_t)0xFFFFFFFF), octaspire_utf8_private_high_order_bits(OCTASPIRE_UTF8_CHARACTER_RANGE_ILLEGAL));

    PASS();
}

TEST octaspire_utf8_encode_character_NUL_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character('\0', &encoded));

    ASSERT_EQ(1, encoded.numoctets);

    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(0, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_SOH_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(1, &encoded));

    ASSERT_EQ(1, encoded.numoctets);

    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(1, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_space_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(' ', &encoded));

    ASSERT_EQ(1, encoded.numoctets);

    ASSERT_EQ(0,  encoded.octets[0]);
    ASSERT_EQ(0,  encoded.octets[1]);
    ASSERT_EQ(0,  encoded.octets[2]);
    ASSERT_EQ(32, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_A_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character('A', &encoded));

    ASSERT_EQ(1, encoded.numoctets);

    ASSERT_EQ(0,  encoded.octets[0]);
    ASSERT_EQ(0,  encoded.octets[1]);
    ASSERT_EQ(0,  encoded.octets[2]);
    ASSERT_EQ(65, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_control_U_PLUS_0080_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0x80, &encoded));

    ASSERT_EQ(2, encoded.numoctets);

    ASSERT_EQ(0,    encoded.octets[0]);
    ASSERT_EQ(0,    encoded.octets[1]);
    ASSERT_EQ(0xc2, encoded.octets[2]);
    ASSERT_EQ(0x80, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_latin_small_letter_a_with_diaeresis_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0xE4, &encoded));

    ASSERT_EQ(2, encoded.numoctets);

    ASSERT_EQ(0,    encoded.octets[0]);
    ASSERT_EQ(0,    encoded.octets[1]);
    ASSERT_EQ(0xc3, encoded.octets[2]);
    ASSERT_EQ(0xa4, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_latin_small_letter_y_with_diaeresis_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0xFF, &encoded));

    ASSERT_EQ(2, encoded.numoctets);

    ASSERT_EQ(0,    encoded.octets[0]);
    ASSERT_EQ(0,    encoded.octets[1]);
    ASSERT_EQ(0xc3, encoded.octets[2]);
    ASSERT_EQ(0xbf, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_copyright_sign_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0xA9, &encoded));

    ASSERT_EQ(2, encoded.numoctets);

    ASSERT_EQ(0,    encoded.octets[0]);
    ASSERT_EQ(0,    encoded.octets[1]);
    ASSERT_EQ(0xc2, encoded.octets[2]);
    ASSERT_EQ(0xa9, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_not_equal_symbol_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0x2260, &encoded));

    ASSERT_EQ(3, encoded.numoctets);

    ASSERT_EQ(0x0,  encoded.octets[0]);
    ASSERT_EQ(0xe2, encoded.octets[1]);
    ASSERT_EQ(0x89, encoded.octets[2]);
    ASSERT_EQ(0xa0, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_linear_b_syllable_b008_a_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0x10000, &encoded));

    ASSERT_EQ(4, encoded.numoctets);

    ASSERT_EQ(0xf0, encoded.octets[0]);
    ASSERT_EQ(0x90, encoded.octets[1]);
    ASSERT_EQ(0x80, encoded.octets[2]);
    ASSERT_EQ(0x80, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_of_illegal_range_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER, octaspire_utf8_encode_character(0xFFFFFFFF, &encoded));

    ASSERT_EQ(0, encoded.numoctets);

    ASSERT_EQ(0x0, encoded.octets[0]);
    ASSERT_EQ(0x0, encoded.octets[1]);
    ASSERT_EQ(0x0, encoded.octets[2]);
    ASSERT_EQ(0x0, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_illegal_range_from_U_PLUS_D800_to_U_PLUS_DFFF_test(void)
{
    octaspire_utf8_character_t encoded;

    // Lower limit minus one
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0xD7ff, &encoded));
    ASSERT_EQ(3,    encoded.numoctets);
    ASSERT_EQ(0,    encoded.octets[0]);
    ASSERT_EQ(0xed, encoded.octets[1]);
    ASSERT_EQ(0x9f, encoded.octets[2]);
    ASSERT_EQ(0xbf, encoded.octets[3]);

    // Lower limit
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER, octaspire_utf8_encode_character(0xD800, &encoded));
    ASSERT_EQ(0, encoded.numoctets);
    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(0, encoded.octets[3]);

    // Lower limit plus one
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER, octaspire_utf8_encode_character(0xD801, &encoded));
    ASSERT_EQ(0, encoded.numoctets);
    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(0, encoded.octets[3]);

    // In the middle between lower and upper limit
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER, octaspire_utf8_encode_character(0xdbff, &encoded));
    ASSERT_EQ(0, encoded.numoctets);
    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(0, encoded.octets[3]);

    // Upper limit minus one
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER, octaspire_utf8_encode_character(0xDFFE, &encoded));
    ASSERT_EQ(0, encoded.numoctets);
    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(0, encoded.octets[3]);

    // Upper limit
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER, octaspire_utf8_encode_character(0xDFFF, &encoded));
    ASSERT_EQ(0, encoded.numoctets);
    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(0, encoded.octets[3]);

    // Upper limit plus one
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0xE000, &encoded));
    ASSERT_EQ(3,    encoded.numoctets);
    ASSERT_EQ(0,    encoded.octets[0]);
    ASSERT_EQ(0xee, encoded.octets[1]);
    ASSERT_EQ(0x80, encoded.octets[2]);
    ASSERT_EQ(0x80, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_is_empty_string_test(void)
{
    char const *text = "";
    ASSERT_EQ(0,  strlen(text));
    ASSERT_EQ(0, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_is_null_test(void)
{
    char const *text = 0;
    ASSERT_EQ(0, octaspire_utf8_private_octets_in_next(text, 0));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_one_octet_0x80_test(void)
{
    char const *text = "\x80";
    ASSERT_EQ(1,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_two_octets_0xC0FF_test(void)
{
    char const *text = "\xC0\xFF";
    ASSERT_EQ(2,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_three_octets_0xE080FF_test(void)
{
    char const *text = "\xE0\x80\xFF";
    ASSERT_EQ(3,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_four_octets_0xF08080FF_test(void)
{
    char const *text = "\xF0\x80\x80\xFF";
    ASSERT_EQ(4,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_one_octet_0x01_test(void)
{
    char const *text = "\x01";
    ASSERT_EQ(1,  strlen(text));
    ASSERT_EQ(1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_two_octets_0xC080_test(void)
{
    char const *text = "\xC0\x80";
    ASSERT_EQ(2,  strlen(text));
    ASSERT_EQ(2, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_two_octets_with_error_0xC000_test(void)
{
    char const *text = "\xC0\x00";
    ASSERT_EQ(1,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_two_octets_with_error_0xC070_test(void)
{
    char const *text = "\xC0\x70";
    ASSERT_EQ(2,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_0xE08080_test(void)
{
    char const *text = "\xE0\x80\x80";
    ASSERT_EQ(3,  strlen(text));
    ASSERT_EQ(3, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_with_error_0xE00080_test(void)
{
    char const *text = "\xE0\x00\x80";
    ASSERT_EQ(1,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_with_error_0xE08000_test(void)
{
    char const *text = "\xE0\x80\x00";
    ASSERT_EQ(2,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_with_error_0xE08070_test(void)
{
    char const *text = "\xE0\x80\x70";
    ASSERT_EQ(3,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_0xF0808080_test(void)
{
    char const *text = "\xF0\x80\x80\x80";
    ASSERT_EQ(4,  strlen(text));
    ASSERT_EQ(4, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0008080_test(void)
{
    char const *text = "\xF0\x00\x80\x80";
    ASSERT_EQ(1,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0800080_test(void)
{
    char const *text = "\xF0\x80\x00\x80";
    ASSERT_EQ(2,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0808000_test(void)
{
    char const *text = "\xF0\x80\x80\x00";
    ASSERT_EQ(3,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0808070_test(void)
{
    char const *text = "\xF0\x80\x80\x70";
    ASSERT_EQ(4,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_one_of_five_octets_0x01F0808080_test(void)
{
    char const *text = "\x01\xF0\x80\x80\x80";
    ASSERT_EQ(5,  strlen(text));
    ASSERT_EQ(1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_two_of_six_octets_0xC080F0808080_test(void)
{
    char const *text = "\xC0\x80\xF0\x80\x80\x80";
    ASSERT_EQ(6,  strlen(text));
    ASSERT_EQ(2, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_three_of_seven_octets_0xE08080F0808080_test(void)
{
    char const *text = "\xE0\x80\x80\xF0\x80\x80\x80";
    ASSERT_EQ(7,  strlen(text));
    ASSERT_EQ(3, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_four_of_eight_octets_0xF0808080F0808080_test(void)
{
    char const *text = "\xF0\x80\x80\x80\xF0\x80\x80\x80";
    ASSERT_EQ(8,  strlen(text));
    ASSERT_EQ(4, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_decode_helper_error_with_more_octets_being_needed_than_available_test(void)
{
    char const *buffer = 0;
    uint32_t    result = 0;

    octaspire_utf8_decode_status_t const expected =
        OCTASPIRE_UTF8_DECODE_STATUS_INPUT_NOT_ENOUGH_OCTETS_AVAILABLE;

    for (size_t numOctetsNeeded = 1; numOctetsNeeded < 5; ++numOctetsNeeded)
    {
        ASSERT_EQ(
            expected,
            octaspire_utf8_private_decode_helper(buffer, numOctetsNeeded, 0, &result));
    }

    for (size_t numOctetsNeeded = 2; numOctetsNeeded < 5; ++numOctetsNeeded)
    {
        ASSERT_EQ(
            expected,
            octaspire_utf8_private_decode_helper(buffer, numOctetsNeeded, 1, &result));
    }

    for (size_t numOctetsNeeded = 3; numOctetsNeeded < 5; ++numOctetsNeeded)
    {
        ASSERT_EQ(
            expected,
            octaspire_utf8_private_decode_helper(buffer, numOctetsNeeded, 2, &result));
    }

    ASSERT_EQ(expected, octaspire_utf8_private_decode_helper(buffer, 4, 3, &result));

    PASS();
}

TEST octaspire_utf8_decode_character_null_string_test(void)
{
    char const *text = 0;
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL, octaspire_utf8_decode_character(text, 0, &result, &numoctets));
    ASSERT_EQ(0, result);
    ASSERT_EQ(0, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_from_buffer_null_string_test(void)
{
    size_t const currentIndex = 0;
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL,
        octaspire_utf8_decode_character_from_buffer(
            0,
            0,
            currentIndex,
            &result,
            &numoctets));

    ASSERT_EQ(0, result);
    ASSERT_EQ(0, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_empty_string_test(void)
{
    char const *text = "";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0, result);
    ASSERT_EQ(0, numoctets);

    PASS();
}

// TODO XXX Should this case be exactly the same as the above case with c-string?
// Now return value is different when decoded from c-string and buffer.
TEST octaspire_utf8_decode_character_from_buffer_empty_string_test(void)
{
    octaspire_vector_t *buffer =
        octaspire_vector_new(sizeof(char), false, 0, octaspireUtf8TestAllocator);

    size_t const currentIndex = 0;
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL,
        octaspire_utf8_decode_character_from_buffer(
            octaspire_vector_get_element_at(buffer, 0),
            octaspire_vector_get_length_in_octets(buffer),
            currentIndex,
            &result,
            &numoctets));

    ASSERT_EQ(0, result);
    ASSERT_EQ(0, numoctets);

    octaspire_vector_release(buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_utf8_decode_character_a_test(void)
{
    char const *text = "a";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OK,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(97, result);
    ASSERT_EQ(1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_from_buffer_a_test(void)
{
    octaspire_vector_t *buffer =
        octaspire_vector_new(sizeof(char), false, 0, octaspireUtf8TestAllocator);

    octaspire_vector_push_back_char(buffer, 'a');
    size_t const currentIndex = 0;
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OK,
        octaspire_utf8_decode_character_from_buffer(
            octaspire_vector_get_element_at(buffer, 0),
            octaspire_vector_get_length_in_octets(buffer),
            currentIndex,
            &result,
            &numoctets));

    ASSERT_EQ(97, result);
    ASSERT_EQ(1, numoctets);

    octaspire_vector_release(buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_utf8_decode_character_the_copyright_sign_test(void)
{
    char const *text = "";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OK,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0xa9, result);
    ASSERT_EQ(2,    numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_not_equal_sign_test(void)
{
    char const *text = "";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OK,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0x2260, result);
    ASSERT_EQ(3,      numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_linear_b_syllable_b008_a_test(void)
{
    char const *text = "";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OK,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0x10000, result);
    ASSERT_EQ(4,       numoctets);

    PASS();
}

TEST octaspire_utf8_decode_a_short_string_test(void)
{
    char const *text = "A.";
    uint32_t result = 0;
    int numoctets = 0;

    uint32_t expectedResults[11]   =
    {
        0x0041,
        0x2262,
        0x0391,
        0x002E,
        0xD55C,
        0xAD6D,
        0xC5B4,
        0x65E5,
        0x672C,
        0x8A9E,
        0x233B4
    };

    int      expectedNumOctets[11] =
    {
        1,
        3,
        2,
        1,
        3,
        3,
        3,
        3,
        3,
        3,
        4
    };

    for (size_t i = 0; i < 11; ++i)
    {
        ASSERT_EQ(
            OCTASPIRE_UTF8_DECODE_STATUS_OK,
            octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

        ASSERT_EQ(expectedResults[i],   result);
        ASSERT_EQ(expectedNumOctets[i], numoctets);

        text += numoctets;
    }

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,     result);
    ASSERT_EQ(0,     numoctets);

    PASS();
}

// Is this good test? Is there potential out of bounds read possibility
// in the decoding part (from the encoded.octets) if the counting
// has error.
TEST octaspire_utf8_encode_and_then_decode_a_short_string_test(void)
{
    uint32_t result = 0;
    int numoctets = 0;

    uint32_t expectedResults[11]   =
    {
        0x0041,
        0x2262,
        0x0391,
        0x002E,
        0xD55C,
        0xAD6D,
        0xC5B4,
        0x65E5,
        0x672C,
        0x8A9E,
        0x233B4
    };

    size_t expectedNumOctets[11] =
    {
        1,
        3,
        2,
        1,
        3,
        3,
        3,
        3,
        3,
        3,
        4
    };

    octaspire_utf8_character_t encoded;


    for (size_t i = 0; i < 11; ++i)
    {
        ASSERT_EQ(
            OCTASPIRE_UTF8_ENCODE_STATUS_OK,
            octaspire_utf8_encode_character(expectedResults[i], &encoded));

        ASSERT_EQ(
            OCTASPIRE_UTF8_DECODE_STATUS_OK,
            octaspire_utf8_decode_character(
                (char const * const)(encoded.octets + (4 - expectedNumOctets[i])),
                expectedNumOctets[i],
                &result,
                &numoctets));

        ASSERT_EQ(expectedResults[i],   result);
        ASSERT_EQ(((int)expectedNumOctets[i]), numoctets);
    }

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_overlong_representations_of_the_null_character_test(void)
{
    // C0 80
    char const *text = "\xC0\x80";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0, result);
    ASSERT_EQ(2, numoctets);

    // E0 80 80
    text = "\xE0\x80\x80";
    result = 0;
    numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0, result);
    ASSERT_EQ(3, numoctets);

    // F0 80 80 80
    text = "\xF0\x80\x80\x80";
    result = 0;
    numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0, result);
    ASSERT_EQ(4, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_0x80_test(void)
{
    char const *text = "\x80";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_from_buffer_illegal_octet_0x80_test(void)
{
    octaspire_vector_t *buffer =
        octaspire_vector_new(sizeof(char), false, 0, octaspireUtf8TestAllocator);

    octaspire_vector_push_back_char(buffer, '\x80');
    size_t const currentIndex = 0;
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character_from_buffer(
            octaspire_vector_get_element_at(buffer, 0),
            octaspire_vector_get_length_in_octets(buffer),
            currentIndex,
            &result,
            &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    octaspire_vector_release(buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_0x01_test(void)
{
    char const *text = "\xC0\x01";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_test(void)
{
    char const *text = "\xC0";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0x80_0x01_test(void)
{
    char const *text = "\xE0\x80\x01";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0x80_test(void)
{
    char const *text = "\xE0\x80";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_test(void)
{
    char const *text = "\xE0";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_0x80_0x01_test(void)
{
    char const *text = "\xF0\x80\x80\x01";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_0x80_test(void)
{
    char const *text = "\xF0\x80\x80";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_test(void)
{
    char const *text = "\xF0\x80";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_test(void)
{
    char const *text = "\xF0";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0xC0_0xC0_0xC0_test(void)
{
    char const *text = "\xF0\xC0\xC0\xC0";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0xC0_0xC0_test(void)
{
    char const *text = "\xE0\xC0\xC0";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_0xC0_test(void)
{
    char const *text = "\xC0\xC0";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_0xFF_test(void)
{
    char const *text = "\xFF";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_0xFE_test(void)
{
    char const *text = "\xFE";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xFE_0xFE_0xFF_0xFF_test(void)
{
    char const *text = "\xFE\xFE\xFF\xFF";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_0xAF_test(void)
{
    char const *text = "\xC0\xAF";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0x2F, result);
    ASSERT_EQ(2,    numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0x80_0xAF_test(void)
{
    char const *text = "\xE0\x80\xAF";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0x2F, result);
    ASSERT_EQ(3,    numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_0x80_0xAF_test(void)
{
    char const *text = "\xF0\x80\x80\xAF";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0x2F, result);
    ASSERT_EQ(4,    numoctets);

    PASS();
}

GREATEST_SUITE(octaspire_utf8_suite)
{
    octaspireUtf8TestAllocator = octaspire_allocator_new(0);
    assert(octaspireUtf8TestAllocator);

    RUN_TEST(octaspire_utf8_private_rangeof_test);
    RUN_TEST(octaspire_utf8_private_high_order_bits_test);
    RUN_TEST(octaspire_utf8_encode_character_NUL_test);
    RUN_TEST(octaspire_utf8_encode_character_SOH_test);
    RUN_TEST(octaspire_utf8_encode_character_space_test);
    RUN_TEST(octaspire_utf8_encode_character_A_test);
    RUN_TEST(octaspire_utf8_encode_character_control_U_PLUS_0080_test);
    RUN_TEST(octaspire_utf8_encode_character_latin_small_letter_a_with_diaeresis_test);
    RUN_TEST(octaspire_utf8_encode_character_latin_small_letter_y_with_diaeresis_test);
    RUN_TEST(octaspire_utf8_encode_character_copyright_sign_test);
    RUN_TEST(octaspire_utf8_encode_character_not_equal_symbol_test);
    RUN_TEST(octaspire_utf8_encode_character_linear_b_syllable_b008_a_test);
    RUN_TEST(octaspire_utf8_encode_character_of_illegal_range_test);
    RUN_TEST(octaspire_utf8_encode_character_illegal_range_from_U_PLUS_D800_to_U_PLUS_DFFF_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_is_empty_string_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_is_null_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_one_octet_0x80_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_two_octets_0xC0FF_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_three_octets_0xE080FF_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_four_octets_0xF08080FF_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_one_octet_0x01_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_two_octets_0xC080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_two_octets_with_error_0xC000_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_two_octets_with_error_0xC070_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_0xE08080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_with_error_0xE00080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_with_error_0xE08000_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_with_error_0xE08070_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_0xF0808080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0008080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0800080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0808000_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0808070_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_one_of_five_octets_0x01F0808080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_two_of_six_octets_0xC080F0808080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_three_of_seven_octets_0xE08080F0808080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_four_of_eight_octets_0xF0808080F0808080_test);
    RUN_TEST(octaspire_utf8_private_decode_helper_error_with_more_octets_being_needed_than_available_test);
    RUN_TEST(octaspire_utf8_decode_character_null_string_test);
    RUN_TEST(octaspire_utf8_decode_character_from_buffer_null_string_test);
    RUN_TEST(octaspire_utf8_decode_character_empty_string_test);
    RUN_TEST(octaspire_utf8_decode_character_from_buffer_empty_string_test);
    RUN_TEST(octaspire_utf8_decode_character_a_test);
    RUN_TEST(octaspire_utf8_decode_character_from_buffer_a_test);
    RUN_TEST(octaspire_utf8_decode_character_the_copyright_sign_test);
    RUN_TEST(octaspire_utf8_decode_character_not_equal_sign_test);
    RUN_TEST(octaspire_utf8_decode_character_linear_b_syllable_b008_a_test);
    RUN_TEST(octaspire_utf8_decode_a_short_string_test);
    RUN_TEST(octaspire_utf8_encode_and_then_decode_a_short_string_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_overlong_representations_of_the_null_character_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_0x80_test);
    RUN_TEST(octaspire_utf8_decode_character_from_buffer_illegal_octet_0x80_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_0x01_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0x80_0x01_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0x80_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_0x80_0x01_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_0x80_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0xC0_0xC0_0xC0_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0xC0_0xC0_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_0xC0_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_0xFF_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_0xFE_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xFE_0xFE_0xFF_0xFF_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_0xAF_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0x80_0xAF_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_0x80_0xAF_test);

    octaspire_allocator_release(octaspireUtf8TestAllocator);
    octaspireUtf8TestAllocator = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_utf8.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_memory.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

TEST octaspire_allocator_new_test(void)
{
    octaspire_allocator_t *allocator = octaspire_allocator_new(0);

    ASSERT(allocator);

    ASSERT_EQ(0, allocator->numberOfFutureAllocationsToBeRigged);
    ASSERT_EQ(0, allocator->bitIndex);

    size_t const bitQueueLen = sizeof(allocator->bitQueue) / sizeof(allocator->bitQueue[0]);
    ASSERT_EQ(20, bitQueueLen);

    for (size_t i = 0; i < bitQueueLen; ++i)
    {
        ASSERT_EQ(0, allocator->bitQueue[i]);
    }


    octaspire_allocator_release(allocator);
    allocator = 0;

    PASS();
}

// How to test this efficiently, etc.?
/*
TEST octaspire_allocator_new_failure_test(void)
{
    octaspire_allocator_t *allocator = octaspire_allocator_new();

    ASSERT_FALSE(allocator);

    octaspire_allocator_release(allocator);
    allocator = 0;

    PASS();
}
*/

TEST octaspire_allocator_malloc_test(void)
{
    octaspire_allocator_t *allocator = octaspire_allocator_new(0);

    size_t *ptrs[100];

    size_t const elemsize = sizeof(ptrs[0]);
    size_t const nelems   = sizeof(ptrs) / elemsize;

    for (size_t i = 0; i < nelems; ++i)
    {
        ptrs[i] = octaspire_allocator_malloc(allocator, elemsize);
        ASSERT(ptrs[i]);
        ASSERT_EQ(0, *(ptrs[i]));
        *(ptrs[i]) = i;
    }

    for (size_t i = 0; i < nelems; ++i)
    {
        ASSERT_EQ(i, *(ptrs[i]));
    }

    for (size_t i = 0; i < nelems; ++i)
    {
        octaspire_allocator_free(allocator, ptrs[i]);
        ptrs[i] = 0;
    }

    octaspire_allocator_release(allocator);
    allocator = 0;

    PASS();
}

TEST octaspire_allocator_free_test(void)
{
    octaspire_allocator_t *allocator = octaspire_allocator_new(0);

    octaspire_allocator_free(allocator, 0);
    octaspire_allocator_free(allocator, octaspire_allocator_malloc(allocator, 10));

    octaspire_allocator_release(allocator);
    allocator = 0;

    PASS();
}

TEST octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged_when_larger_than_32_test(void)
{
    octaspire_allocator_t *allocator = octaspire_allocator_new(0);

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    size_t const count = 640;

    uint32_t const bitPattern = 0x55; // 0101 0101

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged_when_larger_than_32(
        allocator,
        count,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern);

   ASSERT_EQ(count, allocator->numberOfFutureAllocationsToBeRigged);
   ASSERT_EQ(0,     allocator->bitIndex);

   for (size_t i = 0; i < (sizeof(allocator->bitQueue) / sizeof(allocator->bitQueue[0])); ++i)
   {
       ASSERT_EQ(bitPattern, allocator->bitQueue[i]);
   }

   ASSERT_EQ(count, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

   for (size_t i = 0; i < count; ++i)
   {
       if (i % 2 == 0)
       {
           ASSERT(octaspire_allocator_private_test_bit(allocator));
       }
       else
       {
           ASSERT_FALSE(octaspire_allocator_private_test_bit(allocator));
       }

       ++(allocator->bitIndex);
   }

   ASSERT_EQ(count, allocator->bitIndex);

   octaspire_allocator_release(allocator);
   allocator = 0;

   PASS();
}

TEST octaspire_allocator_setting_and_getting_future_allocations_to_fail_and_using_with_malloc_test(void)
{
    octaspire_allocator_t *allocator = octaspire_allocator_new(0);

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    size_t count = 32;

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(allocator, count, 0);

    ASSERT_EQ(count, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    for (size_t i = count; i > 0; --i)
    {
        ASSERT_FALSE(octaspire_allocator_malloc(allocator, 1));
        ASSERT_EQ(i - 1, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(allocator));
    }

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    void *ptr = octaspire_allocator_malloc(allocator, 1);
    ASSERT(ptr);
    octaspire_allocator_free(allocator, ptr);
    ptr = 0;

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    octaspire_allocator_release(allocator);
    allocator = 0;

    PASS();
}

TEST octaspire_allocator_setting_and_getting_future_allocations_to_fail_and_using_with_realloc_test(void)
{
    octaspire_allocator_t *allocator = octaspire_allocator_new(0);

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    void *buffer = octaspire_allocator_malloc(allocator, 1);

    ASSERT(buffer);

    size_t count = 32;

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(allocator, count, 0);

    ASSERT_EQ(count, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    for (size_t i = count; i > 0; --i)
    {
        ASSERT_FALSE(octaspire_allocator_realloc(allocator, buffer, 2));
        ASSERT_EQ(i - 1, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(allocator));
    }

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    void *ptr = octaspire_allocator_realloc(allocator, buffer, 2);
    ASSERT(ptr);
    octaspire_allocator_free(allocator, ptr);
    ptr = 0;

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    octaspire_allocator_release(allocator);
    allocator = 0;

    PASS();
}

GREATEST_SUITE(octaspire_memory_suite)
{
    RUN_TEST(octaspire_allocator_new_test);
    //RUN_TEST(octaspire_allocator_new_failure_test);
    RUN_TEST(octaspire_allocator_malloc_test);
    RUN_TEST(octaspire_allocator_free_test);
    RUN_TEST(octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged_when_larger_than_32_test);
    RUN_TEST(octaspire_allocator_setting_and_getting_future_allocations_to_fail_and_using_with_malloc_test);
    RUN_TEST(octaspire_allocator_setting_and_getting_future_allocations_to_fail_and_using_with_realloc_test);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_memory.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_stdio.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireStdioTestAllocator = 0;

TEST octaspire_stdio_new_test(void)
{
    octaspire_stdio_t *stdio = octaspire_stdio_new(octaspireStdioTestAllocator);

    ASSERT(stdio);

    ASSERT_EQ(0, stdio->numberOfFutureReadsToBeRigged);
    ASSERT_EQ(0, stdio->bitIndex);
    ASSERT_EQ(0, stdio->bitQueue);
    ASSERT_EQ(octaspireStdioTestAllocator, stdio->allocator);

    octaspire_stdio_release(stdio);
    stdio = 0;

    PASS();
}

TEST octaspire_stdio_new_allocation_failure_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireStdioTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireStdioTestAllocator));

    octaspire_stdio_t *stdio = octaspire_stdio_new(octaspireStdioTestAllocator);

    ASSERT_FALSE(stdio);

    ASSERT_EQ(
        0,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireStdioTestAllocator));

    octaspire_stdio_release(stdio);
    stdio = 0;

    PASS();
}

TEST octaspire_stdio_fread_test(void)
{
    octaspire_stdio_t *stdio = octaspire_stdio_new(octaspireStdioTestAllocator);

    ASSERT(stdio);

    FILE *f = fopen(OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_stdio_fread_test", "rb");

    ASSERT(f);

    char octet = 0;
    char const * const expected = "0123456789qwertyuiop";

    for (size_t i = 0; i < strlen(expected); ++i)
    {
        ASSERT_EQ(1, octaspire_stdio_fread(stdio, &octet, sizeof(octet), 1, f));
        ASSERT_EQ(expected[i], octet);
    }

    fclose(f);
    f = 0;

    octaspire_stdio_release(stdio);
    stdio = 0;

    PASS();
}

TEST octaspire_stdio_fread_rigging_and_failure_test(void)
{
    octaspire_stdio_t *stdio = octaspire_stdio_new(octaspireStdioTestAllocator);

    ASSERT(stdio);

    FILE *f = fopen(OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_stdio_fread_test", "rb");

    ASSERT(f);

    char octet = 0;
    char const * const expected = "0123456789qwertyuiop";

    // 0101 0101 0101 0101 0101
    //    5    5    5    5    5
    octaspire_stdio_set_number_and_type_of_future_reads_to_be_rigged(stdio, 20, 0x55555);

    ASSERT_EQ(20, octaspire_stdio_get_number_of_future_reads_to_be_rigged(stdio));

    size_t index = 0;
    for (size_t i = 0; i < strlen(expected); ++i)
    {
        if (i % 2)
        {
            ASSERT_EQ(0, octaspire_stdio_fread(stdio, &octet, sizeof(octet), 1, f));
        }
        else
        {
            ASSERT_EQ(1, octaspire_stdio_fread(stdio, &octet, sizeof(octet), 1, f));
            ASSERT_EQ(expected[index], octet);
            ++index;
        }
    }

    ASSERT_EQ(0, octaspire_stdio_get_number_of_future_reads_to_be_rigged(stdio));

    fclose(f);
    f = 0;

    octaspire_stdio_release(stdio);
    stdio = 0;

    PASS();
}

GREATEST_SUITE(octaspire_stdio_suite)
{
    octaspireStdioTestAllocator = octaspire_allocator_new(0);

    assert(octaspireStdioTestAllocator);

    RUN_TEST(octaspire_stdio_new_test);
    RUN_TEST(octaspire_stdio_new_allocation_failure_test);
    RUN_TEST(octaspire_stdio_fread_test);
    RUN_TEST(octaspire_stdio_fread_rigging_and_failure_test);

    octaspire_allocator_release(octaspireStdioTestAllocator);
    octaspireStdioTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_stdio.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_input.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireInputTestAllocator = 0;
static octaspire_stdio_t     *octaspireInputTestStdio = 0;

TEST octaspire_input_new_from_c_string_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    ASSERT(input->text);

    size_t const numUcsChars =
        octaspire_string_get_length_in_ucs_characters(input->text);

    ASSERT_EQ(6, numUcsChars);

    ASSERT_EQ(0x61,    octaspire_string_get_ucs_character_at_index(input->text, 0));
    ASSERT_EQ(0x62,    octaspire_string_get_ucs_character_at_index(input->text, 1));
    ASSERT_EQ(0x63,    octaspire_string_get_ucs_character_at_index(input->text, 2));
    ASSERT_EQ(0xa9,    octaspire_string_get_ucs_character_at_index(input->text, 3));
    ASSERT_EQ(0x2260,  octaspire_string_get_ucs_character_at_index(input->text, 4));
    ASSERT_EQ(0x10000, octaspire_string_get_ucs_character_at_index(input->text, 5));

    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(6, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_c_string_called_with_null_string_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(0, octaspireInputTestAllocator);

    ASSERT(input);

    ASSERT(input->text);

    ASSERT_EQ(0,         octaspire_string_get_length_in_ucs_characters(input->text));
    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(0, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_c_string_with_allocation_failure_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireInputTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT_EQ(
        0,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    ASSERT_FALSE(input);

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_buffer_test(void)
{
    char const buffer[] =
    {
        'a',
        'b',
        'c',
        '\xC2',
        '\xA9',
        '\xE2',
        '\x89',
        '\xA0',
        '\xF0',
        '\x90',
        '\x80',
        '\x80'
    };

    octaspire_input_t *input = octaspire_input_new_from_buffer(
        buffer, sizeof(buffer) / sizeof(buffer[0]),
        octaspireInputTestAllocator);

    ASSERT(input);

    ASSERT(input->text);

    size_t const numUcsChars =
        octaspire_string_get_length_in_ucs_characters(input->text);

    ASSERT_EQ(6, numUcsChars);

    ASSERT_EQ(0x61,    octaspire_string_get_ucs_character_at_index(input->text, 0));
    ASSERT_EQ(0x62,    octaspire_string_get_ucs_character_at_index(input->text, 1));
    ASSERT_EQ(0x63,    octaspire_string_get_ucs_character_at_index(input->text, 2));
    ASSERT_EQ(0xa9,    octaspire_string_get_ucs_character_at_index(input->text, 3));
    ASSERT_EQ(0x2260,  octaspire_string_get_ucs_character_at_index(input->text, 4));
    ASSERT_EQ(0x10000, octaspire_string_get_ucs_character_at_index(input->text, 5));

    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(6, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_buffer_with_allocation_failure_0x00_test(void)
{
    char const buffer[] =
    {
        'a',
        'b',
        'c',
        '\xC2',
        '\xA9',
        '\xE2',
        '\x89',
        '\xA0',
        '\xF0',
        '\x90',
        '\x80',
        '\x80'
    };

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireInputTestAllocator,
        1,
        0x00);

    ASSERT_EQ(
        1,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    octaspire_input_t *input = octaspire_input_new_from_buffer(
        buffer, sizeof(buffer) / sizeof(buffer[0]),
        octaspireInputTestAllocator);

    ASSERT_EQ(
        0,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    ASSERT_FALSE(input);

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_buffer_with_allocation_failure_0x01_test(void)
{
    char const buffer[] =
    {
        'a',
        'b',
        'c',
        '\xC2',
        '\xA9',
        '\xE2',
        '\x89',
        '\xA0',
        '\xF0',
        '\x90',
        '\x80',
        '\x80'
    };

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireInputTestAllocator,
        2,
        0x01);

    ASSERT_EQ(
        2,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    octaspire_input_t *input = octaspire_input_new_from_buffer(
        buffer, sizeof(buffer) / sizeof(buffer[0]),
        octaspireInputTestAllocator);

    ASSERT_EQ(
        0,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    ASSERT_FALSE(input);

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_path_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_path(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_input_new_from_path_test",
        octaspireInputTestAllocator,
        octaspireInputTestStdio);

    ASSERT(input);

    ASSERT(input->text);

    size_t const numUcsChars =
        octaspire_string_get_length_in_ucs_characters(input->text);

    ASSERT_EQ(6, numUcsChars);

    ASSERT_EQ(0x61,    octaspire_string_get_ucs_character_at_index(input->text, 0));
    ASSERT_EQ(0x62,    octaspire_string_get_ucs_character_at_index(input->text, 1));
    ASSERT_EQ(0x63,    octaspire_string_get_ucs_character_at_index(input->text, 2));
    ASSERT_EQ(0xa9,    octaspire_string_get_ucs_character_at_index(input->text, 3));
    ASSERT_EQ(0x2260,  octaspire_string_get_ucs_character_at_index(input->text, 4));
    ASSERT_EQ(0x10000, octaspire_string_get_ucs_character_at_index(input->text, 5));

    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(6, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_path_failure_on_nonexisting_file_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_path(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_input_new_from_path_failure_on_nonexisting_file_test",
        octaspireInputTestAllocator,
        octaspireInputTestStdio);

    ASSERT_FALSE(input);

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_path_allocation_failure_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireInputTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    octaspire_input_t *input = octaspire_input_new_from_path(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_input_new_from_path_test",
        octaspireInputTestAllocator,
        octaspireInputTestStdio);

    ASSERT_EQ(
        0,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    ASSERT_FALSE(input);

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_get_length_in_ucs_characters_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    ASSERT_EQ(6, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_clear_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    ASSERT(input->text);

    size_t const numUcsChars =
        octaspire_string_get_length_in_ucs_characters(input->text);

    ASSERT_EQ(6, numUcsChars);

    ASSERT_EQ(0x61,    octaspire_string_get_ucs_character_at_index(input->text, 0));
    ASSERT_EQ(0x62,    octaspire_string_get_ucs_character_at_index(input->text, 1));
    ASSERT_EQ(0x63,    octaspire_string_get_ucs_character_at_index(input->text, 2));
    ASSERT_EQ(0xa9,    octaspire_string_get_ucs_character_at_index(input->text, 3));
    ASSERT_EQ(0x2260,  octaspire_string_get_ucs_character_at_index(input->text, 4));
    ASSERT_EQ(0x10000, octaspire_string_get_ucs_character_at_index(input->text, 5));

    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(6, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_clear(input);

    ASSERT(input->text);

    ASSERT_EQ(0, octaspire_string_get_length_in_ucs_characters(input->text));

    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(0, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_rewind_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(6, octaspire_input_get_length_in_ucs_characters(input));

    while (octaspire_input_is_good(input))
    {
        ASSERT(octaspire_input_pop_next_ucs_character(input));
    }

    ASSERT_FALSE(octaspire_input_is_good(input));

    octaspire_input_rewind(input);
    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);
    ASSERT(octaspire_input_is_good(input));

    uint32_t expected[] = {0x61, 0x62, 0x63, 0xa9, 0x2260, 0x10000};

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT(octaspire_input_is_good(input));
        ASSERT_EQ(expected[i], octaspire_input_peek_next_ucs_character(input));
        ASSERT(octaspire_input_pop_next_ucs_character(input));
    }

    ASSERT_FALSE(octaspire_input_is_good(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_peek_next_ucs_character_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    uint32_t expected[] = {0x61, 0x62, 0x63, 0xa9, 0x2260, 0x10000};

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT(octaspire_input_is_good(input));
        ASSERT_EQ(expected[i], octaspire_input_peek_next_ucs_character(input));
        ASSERT(octaspire_input_pop_next_ucs_character(input));
    }

    ASSERT_FALSE(octaspire_input_is_good(input));

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT_FALSE(octaspire_input_is_good(input));
        ASSERT_EQ(0, octaspire_input_peek_next_ucs_character(input));
    }

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_pop_next_ucs_character_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    uint32_t expected[] = {0x61, 0x62, 0x63, 0xa9, 0x2260, 0x10000};

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT(octaspire_input_is_good(input));
        ASSERT_EQ(expected[i], octaspire_input_peek_next_ucs_character(input));
        ASSERT(octaspire_input_pop_next_ucs_character(input));
    }

    ASSERT_FALSE(octaspire_input_is_good(input));

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT_FALSE(octaspire_input_is_good(input));
        ASSERT_EQ(0, octaspire_input_peek_next_ucs_character(input));
        ASSERT_FALSE(octaspire_input_pop_next_ucs_character(input));
    }

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_pop_next_ucs_character_current_line_and_column_are_calculated_correctly_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80\ndef\nghi";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    size_t expected_line[]   = {1, 1, 1, 1, 1, 1, 1,      2, 2, 2, 2,    3, 3, 3};
    size_t expected_column[] = {1, 2, 3, 4, 5, 6, 7,      1, 2, 3, 4,    1, 2, 3};

    ASSERT_EQ(
        sizeof(expected_line) / sizeof(expected_line[0]),
        octaspire_input_get_length_in_ucs_characters(input));

    ASSERT_EQ(
        sizeof(expected_column) / sizeof(expected_column[0]),
        octaspire_input_get_length_in_ucs_characters(input));

    for (size_t i = 0; i < octaspire_input_get_length_in_ucs_characters(input); ++i)
    {
        ASSERT(octaspire_input_is_good(input));

        ASSERT_EQ(expected_line[i],   input->line);
        ASSERT_EQ(expected_column[i], input->column);

        ASSERT(octaspire_input_pop_next_ucs_character(input));
    }

    ASSERT_FALSE(octaspire_input_is_good(input));

    size_t const lastIndex = octaspire_input_get_length_in_ucs_characters(input) - 1;

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT_EQ(expected_column[lastIndex], input->column);
        ASSERT_FALSE(octaspire_input_is_good(input));
        ASSERT_EQ(expected_line[lastIndex],   input->line);
        ASSERT_EQ(expected_column[lastIndex], input->column);
        ASSERT_FALSE(octaspire_input_pop_next_ucs_character(input));
    }

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_is_good_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT(octaspire_input_is_good(input));
        ASSERT(octaspire_input_pop_next_ucs_character(input));
    }

    ASSERT_FALSE(octaspire_input_is_good(input));

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT_FALSE(octaspire_input_is_good(input));
        ASSERT_FALSE(octaspire_input_pop_next_ucs_character(input));
    }

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_private_is_ucs_character_index_valid_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < 1024; ++i)
    {
        bool const valid = octaspire_input_private_is_ucs_character_index_valid(input, i);
        if (i < octaspire_input_get_length_in_ucs_characters(input))
        {
            ASSERT(valid);
        }
        else
        {
            ASSERT_FALSE(valid);
        }
    }

    octaspire_input_release(input);
    input = 0;

    PASS();
}

GREATEST_SUITE(octaspire_input_suite)
{
    octaspireInputTestAllocator = octaspire_allocator_new(0);
    octaspireInputTestStdio     = octaspire_stdio_new(octaspireInputTestAllocator);

    assert(octaspireInputTestAllocator);
    assert(octaspireInputTestStdio);

    RUN_TEST(octaspire_input_new_from_c_string_test);
    RUN_TEST(octaspire_input_new_from_c_string_called_with_null_string_test);
    RUN_TEST(octaspire_input_new_from_c_string_with_allocation_failure_test);
    RUN_TEST(octaspire_input_new_from_buffer_test);
    RUN_TEST(octaspire_input_new_from_buffer_with_allocation_failure_0x00_test);
    RUN_TEST(octaspire_input_new_from_buffer_with_allocation_failure_0x01_test);
    RUN_TEST(octaspire_input_new_from_path_test);
    RUN_TEST(octaspire_input_new_from_path_failure_on_nonexisting_file_test);
    RUN_TEST(octaspire_input_new_from_path_allocation_failure_test);
    RUN_TEST(octaspire_input_get_length_in_ucs_characters_test);
    RUN_TEST(octaspire_input_clear_test);
    RUN_TEST(octaspire_input_rewind_test);
    RUN_TEST(octaspire_input_peek_next_ucs_character_test);
    RUN_TEST(octaspire_input_pop_next_ucs_character_test);
    RUN_TEST(octaspire_input_pop_next_ucs_character_current_line_and_column_are_calculated_correctly_test);
    RUN_TEST(octaspire_input_is_good_test);
    RUN_TEST(octaspire_input_private_is_ucs_character_index_valid_test);

    octaspire_stdio_release(octaspireInputTestStdio);
    octaspireInputTestStdio = 0;

    octaspire_allocator_release(octaspireInputTestAllocator);
    octaspireInputTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_input.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_vector.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireContainerVectorTestAllocator = 0;

TEST octaspire_vector_private_index_to_pointer_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);
    }

    for (size_t i = 0; i < len; ++i)
    {
        size_t const * expected = (size_t const *)(vec->elements) + i;

        ASSERT_EQ(
            expected,
            (size_t const *)octaspire_vector_private_index_to_pointer(vec, i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_private_index_to_pointer_const_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);
    }

    for (size_t i = 0; i < len; ++i)
    {
        size_t const * expected = (size_t const *)(vec->elements) + i;

        ASSERT_EQ(
            expected,
            (size_t const *)octaspire_vector_private_index_to_pointer_const(vec, i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_private_grow_with_factor_2_success_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(double), false, 0, octaspireContainerVectorTestAllocator);

    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    char *expectedInitializedMemory =
        octaspire_allocator_malloc(octaspireContainerVectorTestAllocator, originalElementSize);

    float const factor = 2;

    ASSERT(octaspire_vector_private_grow(vec, factor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,           vec->elementSize);
    ASSERT_EQ(originalNumElements,           vec->numElements);

    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * factor),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    ASSERT(octaspire_vector_private_grow(vec, factor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,                      vec->elementSize);
    ASSERT_EQ(originalNumElements,                      vec->numElements);
    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * (factor * factor)),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    octaspire_vector_release(vec);
    vec = 0;
    octaspire_allocator_free(octaspireContainerVectorTestAllocator, expectedInitializedMemory);

    PASS();
}

TEST octaspire_vector_private_grow_with_factor_100_success_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(char), false, 0, octaspireContainerVectorTestAllocator);

    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    char *expectedInitializedMemory =
        octaspire_allocator_malloc(octaspireContainerVectorTestAllocator, originalElementSize);

    float const factor = 100;

    ASSERT(octaspire_vector_private_grow(vec, factor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,           vec->elementSize);
    ASSERT_EQ(originalNumElements,           vec->numElements);

    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * factor),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    ASSERT(octaspire_vector_private_grow(vec, factor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,                      vec->elementSize);
    ASSERT_EQ(originalNumElements,                      vec->numElements);

    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * (factor * factor)),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    octaspire_vector_release(vec);
    vec = 0;
    octaspire_allocator_free(octaspireContainerVectorTestAllocator, expectedInitializedMemory);

    PASS();
}

TEST octaspire_vector_private_grow_with_factor_2_even_when_zero_is_given_as_factor_success_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(double), false, 0, octaspireContainerVectorTestAllocator);

    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    char *expectedInitializedMemory =
        octaspire_allocator_malloc(octaspireContainerVectorTestAllocator, originalElementSize);

    float const badFactor = 0;
    float const factor = 2;

    ASSERT(octaspire_vector_private_grow(vec, badFactor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,           vec->elementSize);
    ASSERT_EQ(originalNumElements,           vec->numElements);

    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * factor),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    ASSERT(octaspire_vector_private_grow(vec, badFactor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,                      vec->elementSize);
    ASSERT_EQ(originalNumElements,                      vec->numElements);
    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * (factor * factor)),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    octaspire_vector_release(vec);
    vec = 0;
    octaspire_allocator_free(octaspireContainerVectorTestAllocator, expectedInitializedMemory);

    PASS();
}

TEST octaspire_vector_private_grow_with_factor_2_even_when_one_is_given_as_factor_success_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(double), false, 0, octaspireContainerVectorTestAllocator);

    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    char *expectedInitializedMemory =
        octaspire_allocator_malloc(octaspireContainerVectorTestAllocator, originalElementSize);

    float const badFactor = 1;
    float const factor = 2;

    ASSERT(octaspire_vector_private_grow(vec, badFactor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,           vec->elementSize);
    ASSERT_EQ(originalNumElements,           vec->numElements);

    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * factor),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    ASSERT(octaspire_vector_private_grow(vec, badFactor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,                      vec->elementSize);
    ASSERT_EQ(originalNumElements,                      vec->numElements);
    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * (factor * factor)),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    octaspire_vector_release(vec);
    vec = 0;
    octaspire_allocator_free(octaspireContainerVectorTestAllocator, expectedInitializedMemory);

    PASS();
}

TEST octaspire_vector_private_grow_failure_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    void const * const originalElements     = vec->elements;
    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerVectorTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(octaspire_vector_private_grow(vec, 2));

    ASSERT_EQ(
        0,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerVectorTestAllocator));

    ASSERT_EQ(originalElements,     vec->elements);
    ASSERT_EQ(originalElementSize,  vec->elementSize);
    ASSERT_EQ(originalNumElements,  vec->numElements);
    ASSERT_EQ(originalNumAllocated, vec->numAllocated);

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_private_compact_success_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(octaspire_vector_private_grow(vec, 1000));

    for (size_t i = 0; i < 250; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);
    }

    //void              *originalElements     = vec->elements;
    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;

    ASSERT(octaspire_vector_private_compact(vec));

    //ASSERT_EQ(originalElements,              vec->elements);
    ASSERT_EQ(originalElementSize,           vec->elementSize);
    ASSERT_EQ(originalNumElements,           vec->numElements);
    // Compacting should have made self->numAllocated == self->numElements
    ASSERT_EQ(originalNumElements,           vec->numAllocated);

    // TODO Continue here

    for (size_t i = 0; i < vec->numElements; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_private_compact_failure_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(octaspire_vector_private_grow(vec, 1000));

    for (size_t i = 0; i < 250; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);
    }

    void              *originalElements     = vec->elements;
    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator, 1, 0);

    ASSERT_FALSE(octaspire_vector_private_compact(vec));

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    ASSERT_EQ(originalElements,     vec->elements);
    ASSERT_EQ(originalElementSize,  vec->elementSize);
    ASSERT_EQ(originalNumElements,  vec->numElements);
    ASSERT_EQ(originalNumAllocated, vec->numAllocated);

    for (size_t i = 0; i < vec->numElements; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_new_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(vec);

    ASSERT(vec->elements);
    ASSERT_EQ(sizeof(size_t),                          vec->elementSize);
    ASSERT_EQ(0,                                       vec->numElements);
    ASSERT_EQ(OCTASPIRE_VECTOR_INITIAL_SIZE, vec->numAllocated);
    ASSERT_EQ(0,                                       vec->elementReleaseCallback);
    ASSERT_EQ(octaspireContainerVectorTestAllocator,                               vec->allocator);

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_new_failure_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator, 1, 0);

    ASSERT_EQ(1, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_FALSE(vec);

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_new_with_preallocated_elements_test(void)
{
    size_t const numPreAllocated = 100;

    octaspire_vector_t *vec = octaspire_vector_new_with_preallocated_elements(
        sizeof(size_t),
        false,
        numPreAllocated,
        0,
        octaspireContainerVectorTestAllocator);

    ASSERT(vec);

    ASSERT(vec->elements);
    ASSERT_EQ(sizeof(size_t),       vec->elementSize);
    ASSERT_EQ(0,                    vec->numElements);
    ASSERT_EQ(numPreAllocated,      vec->numAllocated);
    ASSERT_EQ(0,                    vec->elementReleaseCallback);
    ASSERT_EQ(octaspireContainerVectorTestAllocator,            vec->allocator);

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_new_with_preallocated_elements_allocation_failure_on_first_allocation_test(void)
{
    size_t const numPreAllocated = 100;

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    octaspire_vector_t *vec = octaspire_vector_new_with_preallocated_elements(
        sizeof(size_t),
        false,
        numPreAllocated,
        0,
        octaspireContainerVectorTestAllocator);

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(vec);

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_new_with_preallocated_elements_allocation_failure_on_second_allocation_test(void)
{
    size_t const numPreAllocated = 100;

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    octaspire_vector_t *vec = octaspire_vector_new_with_preallocated_elements(
        sizeof(size_t),
        false,
        numPreAllocated,
        0,
        octaspireContainerVectorTestAllocator);

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(vec);

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}



// TODO XXX test octaspire_vector_new_with_preallocated_elements
// It has newer allocation failure test that must also be tested




TEST octaspire_vector_new_shallow_copy_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(vec);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
    }

    ASSERT_EQ(
        len,
        octaspire_vector_get_length(vec));

    octaspire_vector_t *cpy=
        octaspire_vector_new_shallow_copy(vec, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(
        octaspire_vector_get_length(vec),
        octaspire_vector_get_length(cpy));

    for (size_t i = 0; i < octaspire_vector_get_length(cpy); ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                cpy,
                (ptrdiff_t)i));
    }

    ASSERT_EQ(vec->elementSize, cpy->elementSize);
    ASSERT_EQ(vec->numElements, cpy->numElements);

    // Copy is compact
    ASSERT_EQ(cpy->numElements, cpy->numAllocated);
    ASSERT_MEM_EQ(vec->elements, cpy->elements, cpy->numElements);
    ASSERT_EQ(vec->elementReleaseCallback, cpy->elementReleaseCallback);
    ASSERT_EQ(vec->allocator, cpy->allocator);

    octaspire_vector_release(vec);
    vec = 0;

    octaspire_vector_release(cpy);
    cpy = 0;

    PASS();
}

TEST octaspire_vector_new_shallow_copy_allocation_failure_on_first_allocation_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(vec);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
    }

    ASSERT_EQ(
        len,
        octaspire_vector_get_length(vec));

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(octaspire_vector_new_shallow_copy(vec, octaspireContainerVectorTestAllocator));

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_new_shallow_copy_allocation_failure_on_second_allocation_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(vec);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
    }

    ASSERT_EQ(
        len,
        octaspire_vector_get_length(vec));

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(octaspire_vector_new_shallow_copy(vec, octaspireContainerVectorTestAllocator));

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_release_null_test(void)
{
    octaspire_vector_release(0);
    PASS();
}

void octaspire_vector_test_element_callback1(void *element);
void octaspire_vector_test_element_callback3_shrink_vector(void *element);
void octaspire_vector_test_element_callback2_grow_vector(void *element);

static size_t octaspireContainerVectorTestElementCallback1TimesCalled = 0;

void octaspire_vector_test_element_callback1(void *element)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(element);
    ++octaspireContainerVectorTestElementCallback1TimesCalled;
}

void octaspire_vector_test_element_callback2_grow_vector(void *element)
{
    octaspire_vector_t *vec = element;

    ++octaspireContainerVectorTestElementCallback1TimesCalled;

    if (octaspireContainerVectorTestElementCallback1TimesCalled < 100)
    {
        octaspire_vector_push_back_element(vec, &vec);
    }
}

void octaspire_vector_test_element_callback3_shrink_vector(void *element)
{
    octaspire_vector_t *vec = element;

    ++octaspireContainerVectorTestElementCallback1TimesCalled;

    if (!octaspire_vector_is_empty(vec))
    {
        octaspire_vector_pop_back_element(vec);
    }
}

TEST octaspire_vector_release_element_callback_called_for_all_elements_test(void)
{
    octaspireContainerVectorTestElementCallback1TimesCalled = 0;

    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, octaspire_vector_test_element_callback1, octaspireContainerVectorTestAllocator);

    ASSERT(vec);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    ASSERT_EQ(len, octaspireContainerVectorTestElementCallback1TimesCalled);

    PASS();
}

TEST octaspire_vector_get_length_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, octaspire_vector_get_length(vec));
        octaspire_vector_push_back_element(vec, &i);
        ASSERT_EQ(i + 1, octaspire_vector_get_length(vec));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_is_empty_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT(octaspire_vector_is_empty(vec));
    }

    for (size_t i = 0; i < 100; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);
        ASSERT_FALSE(octaspire_vector_is_empty(vec));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_remove_element_at_index_minus_one_100_times_of_100_elements_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);

        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_remove_element_at(vec, -1));

        if (i < (len - 1))
        {
            ASSERT_EQ(
                len - 2 - i,
                *(size_t*)octaspire_vector_peek_back_element(vec));

            for (size_t j = 0; j < octaspire_vector_get_length(vec); ++j)
            {
                ASSERT_EQ(
                    j,
                    *(size_t*)octaspire_vector_get_element_at(vec, (ptrdiff_t)j));
            }
        }
    }

    ASSERT(octaspire_vector_is_empty(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_remove_element_at_index_0_of_100_elements_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);

        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    ASSERT(octaspire_vector_remove_element_at(vec, 0));

    for (size_t i = 0; i < len - 1; ++i)
    {
            ASSERT_EQ(
                i + 1,
                *(size_t*)octaspire_vector_get_element_at(
                    vec,
                    (ptrdiff_t)i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_remove_element_at_index_50_of_100_elements_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);

        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    ASSERT(octaspire_vector_remove_element_at(vec, 50));

    for (size_t i = 0; i < len - 1; ++i)
    {
        if (i < 50)
        {
            ASSERT_EQ(
                i,
                *(size_t*)octaspire_vector_get_element_at(
                    vec,
                    (ptrdiff_t)i));
        }
        else
        {
            ASSERT_EQ(
                i + 1,
                *(size_t*)octaspire_vector_get_element_at(
                    vec,
                    (ptrdiff_t)i));
        }
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_remove_element_at_index_99_of_100_elements_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);

        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    ASSERT(octaspire_vector_remove_element_at(vec, 99));

    for (size_t i = 0; i < len - 1; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_remove_element_at_failure_removing_index_100_of_100_elements_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    ASSERT_FALSE(octaspire_vector_remove_element_at(vec, 100));

    ASSERT_EQ(len, octaspire_vector_get_length(vec));

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_remove_element_at_failure_removing_indices_100_to_200_of_100_elements_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);

        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (size_t i = 100; i < 201; ++i)
    {
        ASSERT_FALSE(octaspire_vector_remove_element_at(
            vec,
            (ptrdiff_t)i));
    }

    ASSERT_EQ(len, octaspire_vector_get_length(vec));

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_remove_element_at_remove_all_100_elements_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_remove_element_at(vec, 0));

        ASSERT_EQ(len - (i + 1), octaspire_vector_get_length(vec));

        for (size_t j = 0; j < octaspire_vector_get_length(vec); ++j)
        {
            ASSERT_EQ(
                j + i + 1,
                *(size_t*)octaspire_vector_get_element_at(
                    vec,
                    (ptrdiff_t)j));
        }
    }

    ASSERT_EQ(0, octaspire_vector_get_length(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_at_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_FALSE((size_t*)octaspire_vector_get_element_at(
            vec,
            (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_FALSE((size_t*)octaspire_vector_get_element_at(
            vec,
            (ptrdiff_t)i));

        octaspire_vector_push_back_element(vec, &i);

        ASSERT_EQ(i, *(size_t*)octaspire_vector_get_element_at(
            vec,
            (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    ASSERT_FALSE((size_t*)octaspire_vector_get_element_at(
        vec,
        (ptrdiff_t)(len + 1)));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_at_const_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_FALSE((size_t const *)octaspire_vector_get_element_at_const(
            vec,
            (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_FALSE((size_t const *)octaspire_vector_get_element_at_const(
            vec,
            (ptrdiff_t)i));

        octaspire_vector_push_back_element(vec, &i);

        ASSERT_EQ(
            i,
            *(size_t const *)octaspire_vector_get_element_at_const(
                vec,
                (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t const *)octaspire_vector_get_element_at_const(
                vec,
                (ptrdiff_t)i));
    }

    ASSERT_FALSE((size_t const *)octaspire_vector_get_element_at_const(
        vec,
        (ptrdiff_t)(len + 1)));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_at_called_with_negative_indices_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);

        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (ptrdiff_t i = -1; i > -((ptrdiff_t)len); --i)
    {
        ASSERT_EQ(
            (size_t)((ptrdiff_t)len + i),
            *(size_t*)octaspire_vector_get_element_at(vec, i));
    }

    for (ptrdiff_t i = len + 1; i < (ptrdiff_t)(3 * len); ++i)
    {
        ASSERT_EQ(0, (size_t*)octaspire_vector_get_element_at(vec, -i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_at_const_called_with_negative_indices_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);

        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (ptrdiff_t i = -1; i > -((ptrdiff_t)len); --i)
    {
        ASSERT_EQ(
            (size_t)((ptrdiff_t)len + i),
            *(size_t const * const)octaspire_vector_get_element_at_const(
                vec,
                i));
    }

    for (ptrdiff_t i = len + 1; i < (ptrdiff_t)(3 * len); ++i)
    {
        ASSERT_EQ(0, (size_t const * const)octaspire_vector_get_element_at_const(vec, -i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_size_in_octets_when_element_is_of_type_uint8_t_test(void)
{
    size_t const expectedSize = sizeof(uint8_t);

    octaspire_vector_t *vec =
        octaspire_vector_new(expectedSize, false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_vector_get_element_size_in_octets(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_size_in_octets_when_element_is_of_type_int_test(void)
{
    size_t const expectedSize = sizeof(int);

    octaspire_vector_t *vec =
        octaspire_vector_new(expectedSize, false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_vector_get_element_size_in_octets(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_size_in_octets_when_element_is_of_type_size_t_test(void)
{
    size_t const expectedSize = sizeof(size_t);

    octaspire_vector_t *vec =
        octaspire_vector_new(expectedSize, false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_vector_get_element_size_in_octets(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_size_in_octets_when_element_is_of_type_double_test(void)
{
    size_t const expectedSize = sizeof(double);

    octaspire_vector_t *vec =
        octaspire_vector_new(expectedSize, false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_vector_get_element_size_in_octets(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_size_in_octets_when_element_is_of_type_void_ptr_test(void)
{
    size_t const expectedSize = sizeof(void*);

    octaspire_vector_t *vec =
        octaspire_vector_new(expectedSize, true, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_vector_get_element_size_in_octets(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_size_in_octets_when_element_size_is_10000_test(void)
{
    size_t const expectedSize = 10000;

    octaspire_vector_t *vec =
        octaspire_vector_new(expectedSize, false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_vector_get_element_size_in_octets(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_size_in_octets_when_element_size_is_illegal_zero_test(void)
{
    size_t const expectedSize = sizeof(char);

    octaspire_vector_t *vec =
        octaspire_vector_new(0, false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_vector_get_element_size_in_octets(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_insert_element_before_the_element_at_index_minus_one_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t value = 2;

    octaspire_vector_push_front_element(vec, &value);

    value = 1;

    ASSERT(octaspire_vector_insert_element_before_the_element_at_index(vec, &value, -1));

    ASSERT_EQ(2,  octaspire_vector_get_length(vec));
    ASSERT_EQ(1, *(size_t*)octaspire_vector_get_element_at(vec, 0));
    ASSERT_EQ(2, *(size_t*)octaspire_vector_get_element_at(vec, 1));

    value = 9;

    ASSERT(octaspire_vector_insert_element_before_the_element_at_index(vec, &value, -1));

    ASSERT_EQ(3,  octaspire_vector_get_length(vec));
    ASSERT_EQ(1, *(size_t*)octaspire_vector_get_element_at(vec, 0));
    ASSERT_EQ(9, *(size_t*)octaspire_vector_get_element_at(vec, 1));
    ASSERT_EQ(2, *(size_t*)octaspire_vector_get_element_at(vec, 2));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_insert_element_before_the_element_at_index_zero_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    octaspire_vector_push_front_element(vec, &len);

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_insert_element_before_the_element_at_index(vec, &i, 0));
        ASSERT_EQ(i, *(size_t*)octaspire_vector_get_element_at(vec, 0));
    }

    ASSERT_EQ(len + 1, octaspire_vector_get_length(vec));
    ASSERT_EQ(len, *(size_t*)octaspire_vector_peek_back_element(vec));

    for (size_t i = 0; i < octaspire_vector_get_length(vec) - 1; ++i)
    {
        ASSERT_EQ(
            len - (i + 1),
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_insert_element_before_the_element_at_index_called_on_empty_vector_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(
            octaspire_vector_insert_element_before_the_element_at_index(vec, &i, 0));
    }

    ASSERT(octaspire_vector_is_empty(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_insert_element_before_the_element_at_index_the_end_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    octaspire_vector_push_front_element(vec, &len);

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(
            octaspire_vector_insert_element_before_the_element_at_index(
                vec,
                &i,
                (ptrdiff_t)octaspire_vector_get_length(vec) - 1));

        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    ASSERT_EQ(len + 1, octaspire_vector_get_length(vec));
    ASSERT_EQ(len, *(size_t*)octaspire_vector_peek_back_element(vec));

    for (size_t i = 0; i < octaspire_vector_get_length(vec); ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_insert_element_before_the_element_at_index_past_the_end_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const value = 100;

    octaspire_vector_push_front_element(vec, &value);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(
            octaspire_vector_insert_element_before_the_element_at_index(
                vec,
                &i,
                10));

        ASSERT_EQ(1, octaspire_vector_get_length(vec));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_insert_element_before_the_element_at_index_allocation_failure_test(void)
{
    size_t const value = 123;

    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(octaspire_vector_push_front_element(vec, &value));

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerVectorTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(
        octaspire_vector_insert_element_before_the_element_at_index(
            vec,
            &value,
            0));

    ASSERT_EQ(
        0,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerVectorTestAllocator));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_insert_element_before_the_element_at_index_the_middle_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
        ASSERT_EQ(i, *(size_t*)octaspire_vector_peek_back_element(vec));
    }

    ASSERT_EQ(len, octaspire_vector_get_length(vec));

    ASSERT(octaspire_vector_insert_element_before_the_element_at_index(vec, &len, 50));

    ASSERT_EQ(len + 1, octaspire_vector_get_length(vec));

    for (size_t i = 0; i < octaspire_vector_get_length(vec); ++i)
    {
        if (i < 50)
        {
            ASSERT_EQ(
                i,
                *(size_t*)octaspire_vector_get_element_at(
                    vec,
                    (ptrdiff_t)i));
        }
        else if (i == 50)
        {
            ASSERT_EQ(
                100,
                *(size_t*)octaspire_vector_get_element_at(
                    vec,
                    (ptrdiff_t)i));
        }
        else
        {
            ASSERT_EQ(
                i - 1,
                *(size_t*)octaspire_vector_get_element_at(
                    vec,
                    (ptrdiff_t)i));
        }
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_insert_element_at_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);

        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    size_t a = 900;
    size_t b = 901;
    size_t c = 902;

    ASSERT(octaspire_vector_insert_element_at(vec, &a, 0));
    ASSERT_EQ(a, *(size_t*)octaspire_vector_get_element_at(vec, 0));
    for (size_t i = 1; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    ASSERT(octaspire_vector_insert_element_at(vec, &b, 50));
    ASSERT_EQ(b, *(size_t*)octaspire_vector_get_element_at(vec, 50));
    ASSERT_EQ(a, *(size_t*)octaspire_vector_get_element_at(vec, 0));
    for (size_t i = 1; i < len; ++i)
    {
        if (i != 50)
        {
            ASSERT_EQ(
                i,
                *(size_t*)octaspire_vector_get_element_at(
                    vec,
                    (ptrdiff_t)i));
        }
    }

    ASSERT(octaspire_vector_insert_element_at(vec, &c, 102));
    ASSERT_EQ(a, *(size_t*)octaspire_vector_get_element_at(vec, 0));
    ASSERT_EQ(b, *(size_t*)octaspire_vector_get_element_at(vec, 50));
    for (size_t i = 1; i < len; ++i)
    {
        if (i != 50)
        {
            ASSERT_EQ(
                i,
                *(size_t*)octaspire_vector_get_element_at(
                    vec,
                    (ptrdiff_t)i));
        }
    }
    ASSERT_EQ(c, *(size_t*)octaspire_vector_get_element_at(vec, 102));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_replace_element_at_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const first       = 10;
    size_t const last        = 20;
    size_t const replacement = 99;

    ASSERT(octaspire_vector_push_back_element(vec, &first));
    ASSERT(octaspire_vector_push_back_element(vec, &last));

    ASSERT_FALSE(octaspire_vector_replace_element_at(vec,  2, &replacement));
    ASSERT_FALSE(octaspire_vector_replace_element_at(vec, -3, &replacement));

    // First
    ASSERT(octaspire_vector_replace_element_at(vec, 0, &replacement));

    ASSERT_EQ(
        replacement,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 0));

    ASSERT_EQ(
        last,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 1));

    // Last
    ASSERT(octaspire_vector_replace_element_at(vec, 1, &replacement));

    ASSERT_EQ(
        replacement,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 0));

    ASSERT_EQ(
        replacement,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 1));

    size_t const newReplacement = 99;

    // First using negative indices
    ASSERT(octaspire_vector_replace_element_at(vec, -2, &newReplacement));

    ASSERT_EQ(
        newReplacement,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 0));

    ASSERT_EQ(
        replacement,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 1));

    // Last using negative indices
    ASSERT(octaspire_vector_replace_element_at(vec, -1, &newReplacement));

    ASSERT_EQ(
        newReplacement,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 0));

    ASSERT_EQ(
        newReplacement,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 1));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_replace_element_at_index_or_push_back_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t expected = 123;

    ASSERT(octaspire_vector_replace_element_at_index_or_push_back(vec, &expected, 0));
    ASSERT_EQ(1, octaspire_vector_get_length(vec));
    ASSERT_EQ(expected, *(size_t*)octaspire_vector_get_element_at(vec, 0));

    expected = 987;

    ASSERT(octaspire_vector_replace_element_at_index_or_push_back(vec, &expected, 0));
    ASSERT_EQ(1, octaspire_vector_get_length(vec));
    ASSERT_EQ(expected, *(size_t*)octaspire_vector_get_element_at(vec, 0));

    expected = 297;

    ASSERT(octaspire_vector_replace_element_at_index_or_push_back(vec, &expected, 1));
    ASSERT_EQ(2,        octaspire_vector_get_length(vec));
    ASSERT_EQ(987,      *(size_t*)octaspire_vector_get_element_at(vec, 0));
    ASSERT_EQ(expected, *(size_t*)octaspire_vector_get_element_at(vec, 1));

    expected = 777;

    ASSERT(octaspire_vector_replace_element_at_index_or_push_back(vec, &expected, 1));
    ASSERT_EQ(2,        octaspire_vector_get_length(vec));
    ASSERT_EQ(987,      *(size_t*)octaspire_vector_get_element_at(vec, 0));
    ASSERT_EQ(expected, *(size_t*)octaspire_vector_get_element_at(vec, 1));

    expected = 222;

    ASSERT(octaspire_vector_replace_element_at_index_or_push_back(vec, &expected, 0));
    ASSERT_EQ(2,        octaspire_vector_get_length(vec));
    ASSERT_EQ(expected, *(size_t*)octaspire_vector_get_element_at(vec, 0));
    ASSERT_EQ(777,      *(size_t*)octaspire_vector_get_element_at(vec, 1));

    expected = 1111;

    ASSERT(octaspire_vector_replace_element_at_index_or_push_back(vec, &expected, 2));
    ASSERT_EQ(3,        octaspire_vector_get_length(vec));
    ASSERT_EQ(222,      *(size_t*)octaspire_vector_get_element_at(vec, 0));
    ASSERT_EQ(777,      *(size_t*)octaspire_vector_get_element_at(vec, 1));
    ASSERT_EQ(expected, *(size_t*)octaspire_vector_get_element_at(vec, 2));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_insert_element_at_index_100_of_empty_vector_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t a = 900;
    size_t const index = 100;
    ASSERT(octaspire_vector_insert_element_at(vec, &a, index));

    ASSERT_EQ(index + 1, octaspire_vector_get_length(vec));

    for (size_t i = 0; i < (index - 1); ++i)
    {
        ASSERT_EQ(
            0,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    ASSERT_EQ(a, *(size_t*)octaspire_vector_get_element_at(vec, index));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_insert_element_at_failure_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const element = 0;

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerVectorTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(octaspire_vector_insert_element_at(vec, &element, 4));

    ASSERT_EQ(
        0,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerVectorTestAllocator));

    ASSERT_EQ(0, octaspire_vector_get_length(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_push_front_element_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_front_element(vec, &i));
        ASSERT_EQ(i + 1, octaspire_vector_get_length(vec));
        ASSERT_EQ(i, *(size_t*)octaspire_vector_get_element_at(vec, 0));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            len - (i + 1),
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_push_back_element_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
        ASSERT_EQ(i + 1, octaspire_vector_get_length(vec));

        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_push_back_char_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(char), false, 0, octaspireContainerVectorTestAllocator);

    char const len = 127;

    for (char i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_back_char(vec, i));
        ASSERT_EQ((size_t)i + 1, octaspire_vector_get_length(vec));

        ASSERT_EQ(
            (char)i,
            *(char*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    for (char i = 0; i < len; ++i)
    {
        ASSERT_EQ(
            (char)i,
            *(char*)octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_push_back_char_to_vector_containing_floats_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(float), false, 0, octaspireContainerVectorTestAllocator);

    char const len = 127;

    for (char i = 0; i < len; ++i)
    {
        ASSERT_FALSE(octaspire_vector_push_back_char(vec, i));
        ASSERT_EQ(0, octaspire_vector_get_length(vec));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_for_each_called_on_empty_vector_test(void)
{
    octaspireContainerVectorTestElementCallback1TimesCalled = 0;

    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    octaspire_vector_for_each(vec, octaspire_vector_test_element_callback1);

    ASSERT_EQ(0, octaspireContainerVectorTestElementCallback1TimesCalled);

    octaspireContainerVectorTestElementCallback1TimesCalled = 0;
    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_for_each_called_on_vector_with_one_element_test(void)
{
    octaspireContainerVectorTestElementCallback1TimesCalled = 0;

    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const element = 999;

    octaspire_vector_push_back_element(vec, &element);

    octaspire_vector_for_each(vec, octaspire_vector_test_element_callback1);

    ASSERT_EQ(1, octaspireContainerVectorTestElementCallback1TimesCalled);

    octaspireContainerVectorTestElementCallback1TimesCalled = 0;
    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_for_each_called_on_vector_with_hundred_elements_test(void)
{
    octaspireContainerVectorTestElementCallback1TimesCalled = 0;

    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        octaspire_vector_push_back_element(vec, &i);
    }

    octaspire_vector_for_each(vec, octaspire_vector_test_element_callback1);

    ASSERT_EQ(100, octaspireContainerVectorTestElementCallback1TimesCalled);

    octaspireContainerVectorTestElementCallback1TimesCalled = 0;
    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_for_each_called_on_vector_that_grows_during_iteration_test(void)
{
    octaspireContainerVectorTestElementCallback1TimesCalled = 0;

    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(octaspire_vector_t*), true, 0, octaspireContainerVectorTestAllocator);

    octaspire_vector_push_back_element(vec, &vec);

    octaspire_vector_for_each(vec, octaspire_vector_test_element_callback2_grow_vector);

    ASSERT_EQ(100, octaspireContainerVectorTestElementCallback1TimesCalled);

    octaspireContainerVectorTestElementCallback1TimesCalled = 0;
    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_for_each_called_on_vector_that_shrinks_during_iteration_test(void)
{
    octaspireContainerVectorTestElementCallback1TimesCalled = 0;

    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(octaspire_vector_t*), true, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        octaspire_vector_push_back_element(vec, &vec);
    }

    octaspire_vector_for_each(
        vec,
        octaspire_vector_test_element_callback3_shrink_vector);

    ASSERT_EQ(50, octaspireContainerVectorTestElementCallback1TimesCalled);

    octaspireContainerVectorTestElementCallback1TimesCalled = 0;
    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_pop_back_element_called_on_empty_vector_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_vector_pop_back_element(vec));
    }

    ASSERT_EQ(0, octaspire_vector_get_length(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_pop_back_element_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
    }

    ASSERT_EQ(len, octaspire_vector_get_length(vec));

    for (size_t i = len; i != 0; --i)
    {
        ASSERT_EQ(i-1, *(size_t*)octaspire_vector_peek_back_element(vec));
        ASSERT(octaspire_vector_pop_back_element(vec));
        ASSERT_EQ(i-1, octaspire_vector_get_length(vec));

        if (i > 1)
        {
            ASSERT_FALSE(octaspire_vector_is_empty(vec));
            ASSERT_EQ(i - 2, *(size_t*)octaspire_vector_peek_back_element(vec));
        }
    }

    ASSERT_EQ(0, octaspire_vector_get_length(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}



















TEST octaspire_vector_peek_back_element_called_on_empty_vector_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_vector_peek_back_element(vec));
    }

    ASSERT_EQ(0, octaspire_vector_get_length(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_peek_back_element_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
        ASSERT_EQ(i, *(size_t*)octaspire_vector_peek_back_element(vec));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_peek_back_element_const_called_on_empty_vector_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_vector_peek_back_element_const(vec));
    }

    ASSERT_EQ(0, octaspire_vector_get_length(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_peek_back_element_const_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
        ASSERT_EQ(i, *(size_t const *)octaspire_vector_peek_back_element_const(vec));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_pop_front_element_called_on_empty_vector_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    void const * const originalElements     = vec->elements;
    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_FALSE(octaspire_vector_pop_front_element(vec));
    }

    ASSERT_EQ(originalElements,     vec->elements);
    ASSERT_EQ(originalElementSize,  vec->elementSize);
    ASSERT_EQ(originalNumElements,  vec->numElements);
    ASSERT_EQ(originalNumAllocated, vec->numAllocated);

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_pop_front_element_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
        ASSERT_EQ(i, *(size_t const *)octaspire_vector_peek_back_element_const(vec));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_pop_front_element(vec));
        ASSERT_EQ(len - 1 - i, octaspire_vector_get_length(vec));

        if (!octaspire_vector_is_empty(vec))
        {
            ASSERT_EQ(i + 1, *(size_t const *)octaspire_vector_peek_front_element_const(vec));
        }
        else
        {
            ASSERT_EQ(len - 1, i);
        }
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_peek_front_element_called_on_empty_vector_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_vector_peek_front_element(vec));
    }

    ASSERT_EQ(0, octaspire_vector_get_length(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_peek_front_element_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_front_element(vec, &i));
        ASSERT_EQ(i, *(size_t*)octaspire_vector_peek_front_element(vec));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_peek_front_element_const_called_on_empty_vector_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_vector_peek_front_element_const(vec));
    }

    ASSERT_EQ(0, octaspire_vector_get_length(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_peek_front_element_const_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_front_element(vec, &i));
        ASSERT_EQ(i, *(size_t const *)octaspire_vector_peek_front_element_const(vec));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_release_callback_const_when_it_is_null_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(0, octaspire_vector_get_element_release_callback_const(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_get_element_release_callback_const_test(void)
{
    octaspire_vector_element_callback_t const expected =
        (octaspire_vector_element_callback_t)octaspire_vector_release;

    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(octaspire_vector_t*),
        true,
        expected,
        octaspireContainerVectorTestAllocator);

    ASSERT_EQ(
        expected,
        octaspire_vector_get_element_release_callback_const(vec));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_clear_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_vector_push_front_element(vec, &i));
        ASSERT_EQ(i, *(size_t const *)octaspire_vector_peek_front_element_const(vec));
    }

    ASSERT_EQ(len, octaspire_vector_get_length(vec));

    ASSERT(octaspire_vector_clear(vec));

    ASSERT_EQ(0, octaspire_vector_get_length(vec));

    ASSERT_EQ(0, vec->numElements);
    ASSERT_EQ(1, vec->numAllocated);

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_clear_called_on_empty_vector_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(0, octaspire_vector_get_length(vec));

    ASSERT(octaspire_vector_clear(vec));

    ASSERT_EQ(0, octaspire_vector_get_length(vec));

    ASSERT_EQ(0, vec->numElements);
    ASSERT_EQ(1, vec->numAllocated);

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_is_valid_index_test(void)
{
    octaspire_vector_t *vec =
        octaspire_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (ptrdiff_t i = -10; i < 10; ++i)
    {
        ASSERT_FALSE(octaspire_vector_is_valid_index(vec, i));
    }

    size_t const element = 999;
    ASSERT(octaspire_vector_push_back_element(vec, &element));

    for (ptrdiff_t i = -10; i < 10; ++i)
    {
        ASSERT_EQ((i == -1 || i == 0), octaspire_vector_is_valid_index(vec, i));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_swap_indices_0_and_2_of_vector_containing_three_size_t_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 3; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
    }

    ASSERT(octaspire_vector_swap(vec, 0, 2));

    ASSERT_EQ(3, octaspire_vector_get_length(vec));

    ASSERT_EQ(
        2,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 0));

    ASSERT_EQ(
        1,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 1));

    ASSERT_EQ(
        0,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 2));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_swap_indices_0_and_1_of_vector_containing_two_size_t_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 2; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
    }

    ASSERT(octaspire_vector_swap(vec, 0, 1));

    ASSERT_EQ(2, octaspire_vector_get_length(vec));

    ASSERT_EQ(
        1,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 0));

    ASSERT_EQ(
        0,
        *(size_t const * const)octaspire_vector_get_element_at(vec, 1));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_swap_indices_2_and_3_of_vector_containing_six_chars_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(char),
        false,
        0,
        octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 6; ++i)
    {
        char const c = (char)i;
        ASSERT(octaspire_vector_push_back_element(vec, &c));
    }

    ASSERT(octaspire_vector_swap(vec, 2, 3));

    ASSERT_EQ(6, octaspire_vector_get_length(vec));

    ASSERT_EQ(
        0,
        *(char const * const)octaspire_vector_get_element_at(vec, 0));

    ASSERT_EQ(
        1,
        *(char const * const)octaspire_vector_get_element_at(vec, 1));

    ASSERT_EQ(
        3,
        *(char const * const)octaspire_vector_get_element_at(vec, 2));

    ASSERT_EQ(
        2,
        *(char const * const)octaspire_vector_get_element_at(vec, 3));

    ASSERT_EQ(
        4,
        *(char const * const)octaspire_vector_get_element_at(vec, 4));

    ASSERT_EQ(
        5,
        *(char const * const)octaspire_vector_get_element_at(vec, 5));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_swap_indices_0_and_5_of_vector_containing_six_chars_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(char),
        false,
        0,
        octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 6; ++i)
    {
        char const c = (char)i;
        ASSERT(octaspire_vector_push_back_element(vec, &c));
    }

    ASSERT(octaspire_vector_swap(vec, 0, 5));

    ASSERT_EQ(6, octaspire_vector_get_length(vec));

    ASSERT_EQ(
        0,
        *(char const * const)octaspire_vector_get_element_at(vec, 5));

    ASSERT_EQ(
        1,
        *(char const * const)octaspire_vector_get_element_at(vec, 1));

    ASSERT_EQ(
        2,
        *(char const * const)octaspire_vector_get_element_at(vec, 2));

    ASSERT_EQ(
        3,
        *(char const * const)octaspire_vector_get_element_at(vec, 3));

    ASSERT_EQ(
        4,
        *(char const * const)octaspire_vector_get_element_at(vec, 4));

    ASSERT_EQ(
        5,
        *(char const * const)octaspire_vector_get_element_at(vec, 0));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_swap_indices_0_and_5_of_vector_containing_six_shorts_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(short),
        false,
        0,
        octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 6; ++i)
    {
        short const s = (short)i;
        ASSERT(octaspire_vector_push_back_element(vec, &s));
    }

    ASSERT(octaspire_vector_swap(vec, 0, 5));

    ASSERT_EQ(6, octaspire_vector_get_length(vec));

    ASSERT_EQ(
        0,
        *(short const * const)octaspire_vector_get_element_at(vec, 5));

    ASSERT_EQ(
        1,
        *(short const * const)octaspire_vector_get_element_at(vec, 1));

    ASSERT_EQ(
        2,
        *(short const * const)octaspire_vector_get_element_at(vec, 2));

    ASSERT_EQ(
        3,
        *(short const * const)octaspire_vector_get_element_at(vec, 3));

    ASSERT_EQ(
        4,
        *(short const * const)octaspire_vector_get_element_at(vec, 4));

    ASSERT_EQ(
        5,
        *(short const * const)octaspire_vector_get_element_at(vec, 0));

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_permutation_iterator_0_short_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(short),
        false,
        0,
        octaspireContainerVectorTestAllocator);

    ASSERT_EQ(0, octaspire_vector_get_length(vec));

    octaspire_vector_permutation_iterator_t *iter =
        octaspire_vector_permutation_iterator_new(
            vec,
            octaspireContainerVectorTestAllocator);

    ASSERT(iter);

    ASSERT_EQ(0, octaspire_vector_get_element_at_const(vec, 0));
    ASSERT_FALSE(octaspire_vector_permutation_iterator_next(iter));
    ASSERT_EQ(0, octaspire_vector_get_element_at_const(vec, 0));

    octaspire_vector_permutation_iterator_release(iter);
    iter = 0;

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_permutation_iterator_1_short_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(short),
        false,
        0,
        octaspireContainerVectorTestAllocator);

    short const s = 0;
    ASSERT(octaspire_vector_push_back_element(vec, &s));

    ASSERT_EQ(1, octaspire_vector_get_length(vec));

    ASSERT_EQ(
        0,
        *(short const * const)octaspire_vector_get_element_at_const(
            vec,
            0));

    octaspire_vector_permutation_iterator_t *iter =
        octaspire_vector_permutation_iterator_new(
            vec,
            octaspireContainerVectorTestAllocator);

    ASSERT(iter);

    ASSERT_EQ(
        0,
        *(short const * const)octaspire_vector_get_element_at_const(vec, 0));

    for (size_t i = 0; i < 10; ++i)
    {
        ASSERT_FALSE(octaspire_vector_permutation_iterator_next(iter));

        ASSERT_EQ(
            0,
            *(short const * const)octaspire_vector_get_element_at_const(vec, 0));
    }

    octaspire_vector_permutation_iterator_release(iter);
    iter = 0;

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

static bool octaspire_vector_permutation_iterator_2_shorts_test_helper(
    octaspire_vector_t const * const vec,
    short const expected1,
    short const expected2)
{
    if (expected1 !=
        *(short const * const)octaspire_vector_get_element_at_const(vec, 0))
    {
        return false;
    }

    if (expected2 != 
        *(short const * const)octaspire_vector_get_element_at_const(vec, 1))
    {
        return false;
    }

    return true;
}

TEST octaspire_vector_permutation_iterator_2_shorts_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(short),
        false,
        0,
        octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 2; ++i)
    {
        short const s = (short)i;
        ASSERT(octaspire_vector_push_back_element(vec, &s));
    }

    ASSERT_EQ(2, octaspire_vector_get_length(vec));

    for (size_t i = 0; i < octaspire_vector_get_length(vec); ++i)
    {
        ASSERT_EQ(
            (short)i,
            *(short const * const)octaspire_vector_get_element_at_const(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_permutation_iterator_t *iter =
        octaspire_vector_permutation_iterator_new(
            vec,
            octaspireContainerVectorTestAllocator);

    ASSERT(iter);

    ASSERT(octaspire_vector_permutation_iterator_2_shorts_test_helper(
            vec, 0, 1));

    ASSERT(octaspire_vector_permutation_iterator_next(iter));

    ASSERT(octaspire_vector_permutation_iterator_2_shorts_test_helper(
            vec, 1, 0));

    for (size_t i = 0; i < 10; ++i)
    {
        ASSERT_FALSE(octaspire_vector_permutation_iterator_next(iter));
        ASSERT(octaspire_vector_permutation_iterator_2_shorts_test_helper(
                vec, 1, 0));
    }

    octaspire_vector_permutation_iterator_release(iter);
    iter = 0;

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

static bool octaspire_vector_permutation_iterator_3_longs_test_helper(
    octaspire_vector_t const * const vec,
    long const * const expected)
{
    if (expected[0] !=
        *(long const * const)octaspire_vector_get_element_at_const(vec, 0))
    {
        return false;
    }

    if (expected[1] != 
        *(long const * const)octaspire_vector_get_element_at_const(vec, 1))
    {
        return false;
    }

    if (expected[2] != 
        *(long const * const)octaspire_vector_get_element_at_const(vec, 2))
    {
        return false;
    }

    return true;
}

TEST octaspire_vector_permutation_iterator_3_longs_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(long),
        false,
        0,
        octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 3; ++i)
    {
        long const l = (long)i;
        ASSERT(octaspire_vector_push_back_element(vec, &l));
    }

    ASSERT_EQ(3, octaspire_vector_get_length(vec));

    for (size_t i = 0; i < octaspire_vector_get_length(vec); ++i)
    {
        ASSERT_EQ(
            (long)i,
            *(long const * const)octaspire_vector_get_element_at_const(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_permutation_iterator_t *iter =
        octaspire_vector_permutation_iterator_new(
            vec,
            octaspireContainerVectorTestAllocator);

    ASSERT(iter);

    long expected[6][3] = {
        {0, 1, 2},
        {1, 0, 2},
        {2, 0, 1},
        {0, 2, 1},
        {1, 2, 0},
        {2, 1, 0}
    };

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT(octaspire_vector_permutation_iterator_3_longs_test_helper(
                vec, expected[i]));

        if (i < 5)
        {
            ASSERT(octaspire_vector_permutation_iterator_next(iter));
        }
        else
        {
            ASSERT_FALSE(octaspire_vector_permutation_iterator_next(iter));
        }
    }

    for (size_t i = 0; i < 10; ++i)
    {
        ASSERT_FALSE(octaspire_vector_permutation_iterator_next(iter));
        ASSERT(octaspire_vector_permutation_iterator_3_longs_test_helper(
                vec, expected[5]));
    }

    octaspire_vector_permutation_iterator_release(iter);
    iter = 0;

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

static bool octaspire_vector_permutation_iterator_4_size_ts_test_helper(
    octaspire_vector_t const * const vec,
    size_t const * const expected)
{
    for (size_t i = 0; i < 4; ++i)
    {
        if (expected[i] !=
            *(size_t const * const)octaspire_vector_get_element_at_const(
                vec,
                (ptrdiff_t)i))
        {
            return false;
        }
    }

    return true;
}

TEST octaspire_vector_permutation_iterator_4_size_ts_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 4; ++i)
    {
        ASSERT(octaspire_vector_push_back_element(vec, &i));
    }

    ASSERT_EQ(4, octaspire_vector_get_length(vec));

    for (size_t i = 0; i < octaspire_vector_get_length(vec); ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t const * const)octaspire_vector_get_element_at_const(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_permutation_iterator_t *iter =
        octaspire_vector_permutation_iterator_new(
            vec,
            octaspireContainerVectorTestAllocator);

    ASSERT(iter);

    size_t expected[24][4] = {
        {0, 1, 2, 3},
        {1, 0, 2, 3},
        {2, 0, 1, 3},
        {0, 2, 1, 3},
        {1, 2, 0, 3},
        {2, 1, 0, 3},
        {3, 1, 0, 2},
        {1, 3, 0, 2},
        {0, 3, 1, 2},
        {3, 0, 1, 2},
        {1, 0, 3, 2},
        {0, 1, 3, 2},
        {0, 2, 3, 1},
        {2, 0, 3, 1},
        {3, 0, 2, 1},
        {0, 3, 2, 1},
        {2, 3, 0, 1},
        {3, 2, 0, 1},
        {3, 2, 1, 0},
        {2, 3, 1, 0},
        {1, 3, 2, 0},
        {3, 1, 2, 0},
        {2, 1, 3, 0},
        {1, 2, 3, 0}
    };

    for (size_t i = 0; i < 24; ++i)
    {
        ASSERT(octaspire_vector_permutation_iterator_4_size_ts_test_helper(
                vec, expected[i]));

        if (i < 23)
        {
            ASSERT(octaspire_vector_permutation_iterator_next(iter));
        }
        else
        {
            ASSERT_FALSE(octaspire_vector_permutation_iterator_next(iter));
        }
    }

    for (size_t i = 0; i < 10; ++i)
    {
        ASSERT_FALSE(octaspire_vector_permutation_iterator_next(iter));
        ASSERT(octaspire_vector_permutation_iterator_4_size_ts_test_helper(
                vec, expected[23]));
    }

    octaspire_vector_permutation_iterator_release(iter);
    iter = 0;

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_vector_permutation_iterator_2_pointers_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(size_t*),
        true,
        0,
        octaspireContainerVectorTestAllocator);

    size_t const first  = 0;
    size_t const second = 1;

    size_t const * const p1 = &first;
    size_t const * const p2 = &second;

    ASSERT(octaspire_vector_push_back_element(vec, &p1));
    ASSERT(octaspire_vector_push_back_element(vec, &p2));

    ASSERT_EQ(2, octaspire_vector_get_length(vec));

    for (size_t i = 0; i < octaspire_vector_get_length(vec); ++i)
    {
        ASSERT_EQ(
            i,
            *(size_t const * const)octaspire_vector_get_element_at_const(
                vec,
                (ptrdiff_t)i));
    }

    octaspire_vector_permutation_iterator_t *iter =
        octaspire_vector_permutation_iterator_new(
            vec,
            octaspireContainerVectorTestAllocator);

    ASSERT(iter);

    ASSERT(octaspire_vector_permutation_iterator_next(iter));

    ASSERT_EQ(
        1,
        *(size_t const * const)octaspire_vector_get_element_at_const(vec, 0));

    ASSERT_EQ(
        0,
        *(size_t const * const)octaspire_vector_get_element_at_const(vec, 1));

    for (size_t i = 0; i < 10; ++i)
    {
        ASSERT_FALSE(octaspire_vector_permutation_iterator_next(iter));

        ASSERT_EQ(
            1,
            *(size_t const * const)octaspire_vector_get_element_at_const(
                vec,
                0));

        ASSERT_EQ(
            0,
            *(size_t const * const)octaspire_vector_get_element_at_const(
                vec,
                1));
    }

    octaspire_vector_permutation_iterator_release(iter);
    iter = 0;

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

GREATEST_SUITE(octaspire_vector_suite)
{
    octaspireContainerVectorTestAllocator = octaspire_allocator_new(0);
    assert(octaspireContainerVectorTestAllocator);

    RUN_TEST(octaspire_vector_private_index_to_pointer_test);
    RUN_TEST(octaspire_vector_private_index_to_pointer_const_test);
    RUN_TEST(octaspire_vector_private_grow_with_factor_2_success_test);
    RUN_TEST(octaspire_vector_private_grow_with_factor_100_success_test);
    RUN_TEST(octaspire_vector_private_grow_with_factor_2_even_when_zero_is_given_as_factor_success_test);
    RUN_TEST(octaspire_vector_private_grow_with_factor_2_even_when_one_is_given_as_factor_success_test);
    RUN_TEST(octaspire_vector_private_grow_failure_test);
    RUN_TEST(octaspire_vector_private_compact_success_test);
    RUN_TEST(octaspire_vector_private_compact_failure_test);
    RUN_TEST(octaspire_vector_new_test);
    RUN_TEST(octaspire_vector_new_failure_test);
    RUN_TEST(octaspire_vector_new_with_preallocated_elements_test);
    RUN_TEST(octaspire_vector_new_with_preallocated_elements_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_vector_new_with_preallocated_elements_allocation_failure_on_second_allocation_test);
    RUN_TEST(octaspire_vector_new_shallow_copy_test);
    RUN_TEST(octaspire_vector_new_shallow_copy_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_vector_new_shallow_copy_allocation_failure_on_second_allocation_test);
    RUN_TEST(octaspire_vector_release_null_test);
    RUN_TEST(octaspire_vector_release_element_callback_called_for_all_elements_test);
    RUN_TEST(octaspire_vector_get_length_test);
    RUN_TEST(octaspire_vector_is_empty_test);

    RUN_TEST(octaspire_vector_remove_element_at_index_minus_one_100_times_of_100_elements_test);
    RUN_TEST(octaspire_vector_remove_element_at_index_0_of_100_elements_test);
    RUN_TEST(octaspire_vector_remove_element_at_index_50_of_100_elements_test);
    RUN_TEST(octaspire_vector_remove_element_at_index_99_of_100_elements_test);
    RUN_TEST(octaspire_vector_remove_element_at_failure_removing_index_100_of_100_elements_test);
    RUN_TEST(octaspire_vector_remove_element_at_failure_removing_indices_100_to_200_of_100_elements_test);
    RUN_TEST(octaspire_vector_remove_element_at_remove_all_100_elements_test);

    RUN_TEST(octaspire_vector_get_element_at_test);
    RUN_TEST(octaspire_vector_get_element_at_const_test);

    RUN_TEST(octaspire_vector_get_element_at_called_with_negative_indices_test);
    RUN_TEST(octaspire_vector_get_element_at_const_called_with_negative_indices_test);

    RUN_TEST(octaspire_vector_get_element_size_in_octets_when_element_is_of_type_uint8_t_test);
    RUN_TEST(octaspire_vector_get_element_size_in_octets_when_element_is_of_type_int_test);
    RUN_TEST(octaspire_vector_get_element_size_in_octets_when_element_is_of_type_size_t_test);
    RUN_TEST(octaspire_vector_get_element_size_in_octets_when_element_is_of_type_double_test);
    RUN_TEST(octaspire_vector_get_element_size_in_octets_when_element_is_of_type_void_ptr_test);
    RUN_TEST(octaspire_vector_get_element_size_in_octets_when_element_size_is_10000_test);
    RUN_TEST(octaspire_vector_get_element_size_in_octets_when_element_size_is_illegal_zero_test);
    RUN_TEST(octaspire_vector_insert_element_before_the_element_at_index_minus_one_test);
    RUN_TEST(octaspire_vector_insert_element_before_the_element_at_index_zero_test);
    RUN_TEST(octaspire_vector_insert_element_before_the_element_at_index_called_on_empty_vector_test);
    RUN_TEST(octaspire_vector_insert_element_before_the_element_at_index_the_end_test);
    RUN_TEST(octaspire_vector_insert_element_before_the_element_at_index_past_the_end_test);
    RUN_TEST(octaspire_vector_insert_element_before_the_element_at_index_allocation_failure_test);
    RUN_TEST(octaspire_vector_insert_element_before_the_element_at_index_the_middle_test);
    RUN_TEST(octaspire_vector_insert_element_at_test);

    RUN_TEST(octaspire_vector_replace_element_at_test);

    RUN_TEST(octaspire_vector_replace_element_at_index_or_push_back_test);

    RUN_TEST(octaspire_vector_insert_element_at_index_100_of_empty_vector_test);
    RUN_TEST(octaspire_vector_insert_element_at_failure_test);
    RUN_TEST(octaspire_vector_push_front_element_test);
    RUN_TEST(octaspire_vector_push_back_element_test);
    RUN_TEST(octaspire_vector_push_back_char_test);
    RUN_TEST(octaspire_vector_push_back_char_to_vector_containing_floats_test);
    RUN_TEST(octaspire_vector_for_each_called_on_empty_vector_test);
    RUN_TEST(octaspire_vector_for_each_called_on_vector_with_one_element_test);
    RUN_TEST(octaspire_vector_for_each_called_on_vector_with_hundred_elements_test);
    RUN_TEST(octaspire_vector_for_each_called_on_vector_that_grows_during_iteration_test);
    RUN_TEST(octaspire_vector_for_each_called_on_vector_that_shrinks_during_iteration_test);
    RUN_TEST(octaspire_vector_pop_back_element_called_on_empty_vector_test);
    RUN_TEST(octaspire_vector_pop_back_element_test);
    RUN_TEST(octaspire_vector_peek_back_element_called_on_empty_vector_test);
    RUN_TEST(octaspire_vector_peek_back_element_test);
    RUN_TEST(octaspire_vector_peek_back_element_const_called_on_empty_vector_test);
    RUN_TEST(octaspire_vector_peek_back_element_const_test);
    RUN_TEST(octaspire_vector_pop_front_element_called_on_empty_vector_test);
    RUN_TEST(octaspire_vector_pop_front_element_test);
    RUN_TEST(octaspire_vector_peek_front_element_called_on_empty_vector_test);
    RUN_TEST(octaspire_vector_peek_front_element_test);
    RUN_TEST(octaspire_vector_peek_front_element_const_called_on_empty_vector_test);
    RUN_TEST(octaspire_vector_peek_front_element_const_test);
    RUN_TEST(octaspire_vector_get_element_release_callback_const_when_it_is_null_test);
    RUN_TEST(octaspire_vector_get_element_release_callback_const_test);
    RUN_TEST(octaspire_vector_clear_test);
    RUN_TEST(octaspire_vector_clear_called_on_empty_vector_test);

    RUN_TEST(octaspire_vector_is_valid_index_test);

    RUN_TEST(octaspire_vector_swap_indices_0_and_2_of_vector_containing_three_size_t_test);
    RUN_TEST(octaspire_vector_swap_indices_0_and_1_of_vector_containing_two_size_t_test);
    RUN_TEST(octaspire_vector_swap_indices_2_and_3_of_vector_containing_six_chars_test);
    RUN_TEST(octaspire_vector_swap_indices_0_and_5_of_vector_containing_six_chars_test);
    RUN_TEST(octaspire_vector_swap_indices_0_and_5_of_vector_containing_six_shorts_test);

    RUN_TEST(octaspire_vector_permutation_iterator_0_short_test);
    RUN_TEST(octaspire_vector_permutation_iterator_1_short_test);
    RUN_TEST(octaspire_vector_permutation_iterator_2_shorts_test);
    RUN_TEST(octaspire_vector_permutation_iterator_3_longs_test);
    RUN_TEST(octaspire_vector_permutation_iterator_4_size_ts_test);
    RUN_TEST(octaspire_vector_permutation_iterator_2_pointers_test);

    octaspire_allocator_release(octaspireContainerVectorTestAllocator);
    octaspireContainerVectorTestAllocator = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_vector.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_list.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireContainerListTestAllocator = 0;

TEST octaspire_list_new_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_new_allocation_failure_on_first_allocation_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerListTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerListTestAllocator));

    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT_EQ(0, list);

    ASSERT_EQ(
        0,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerListTestAllocator));

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_release_called_with_null_pointer_test(void)
{
    octaspire_list_release(0);

    PASS();
}

TEST octaspire_list_get_front_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_list_get_front(list));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_front(list, &i));

        octaspire_list_node_t const * const front =
            octaspire_list_get_front(list);

        ASSERT_EQ(i, *((size_t const * const)octaspire_list_node_get_element_const(front)));
    }

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_get_front_const_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_list_get_front_const(list));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_front(list, &i));

        octaspire_list_node_t const * const front =
            octaspire_list_get_front_const(list);

        ASSERT_EQ(i, *((size_t const * const)octaspire_list_node_get_element_const(front)));
    }

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_get_back_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_list_get_back(list));

    size_t const numElements = 10;

    octaspire_list_node_t const *first = 0;
    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));

        octaspire_list_node_t const * const back =
            octaspire_list_get_back(list);

        if (i == 0)
        {
            first = back;
        }

        ASSERT_EQ(first, octaspire_list_get_front(list));
        ASSERT_EQ(i, *((size_t const * const)octaspire_list_node_get_element_const(back)));
    }

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_get_back_const_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_list_get_back_const(list));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));

        octaspire_list_node_t const * const back =
            octaspire_list_get_back_const(list);

        ASSERT_EQ(i, *((size_t const * const)octaspire_list_node_get_element_const(back)));
    }

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_clear_called_on_empty_list_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
            sizeof(size_t),
            false,
            0,
            octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_list_get_length(list));

    ASSERT(octaspire_list_clear(list));

    ASSERT_EQ(0, octaspire_list_get_length(list));

    ASSERT_EQ(0, list->numElements);

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_clear_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));
    }

    ASSERT_EQ(numElements, list->numElements);

    ASSERT(octaspire_list_clear(list));

    ASSERT_EQ(0, octaspire_list_get_length(list));
    ASSERT_EQ(0, list->numElements);

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_push_back_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_list_get_length(list));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));

        ASSERT_EQ(i + 1, octaspire_list_get_length(list));
        octaspire_list_node_t const * front = octaspire_list_get_front(list);
        octaspire_list_node_t const * back  = octaspire_list_get_back(list);

        ASSERT_EQ(0,     *((size_t const * const)octaspire_list_node_get_element_const(front)));
        ASSERT_EQ(i,     *((size_t const * const)octaspire_list_node_get_element_const(back)));
    }

    ASSERT_EQ(numElements, list->numElements);

    octaspire_list_node_t const * node = octaspire_list_get_front(list);

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(node);
        ASSERT_EQ(i, *((size_t const * const)octaspire_list_node_get_element_const(node)));
        node = octaspire_list_node_get_next_const(node);
    }

    ASSERT(node == 0);

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_push_front_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_list_get_length(list));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_front(list, &i));

        ASSERT_EQ(i + 1, octaspire_list_get_length(list));
        octaspire_list_node_t const * front = octaspire_list_get_front(list);
        octaspire_list_node_t const * back  = octaspire_list_get_back(list);

        ASSERT_EQ(i,     *((size_t const * const)octaspire_list_node_get_element_const(front)));
        ASSERT_EQ(0,     *((size_t const * const)octaspire_list_node_get_element_const(back)));
    }

    ASSERT_EQ(numElements, list->numElements);

    octaspire_list_node_t const * node = octaspire_list_get_front(list);

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(node);
        ASSERT_EQ(numElements - 1 - i, *((size_t const * const)octaspire_list_node_get_element_const(node)));
        node = octaspire_list_node_get_next_const(node);
    }

    ASSERT(node == 0);

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_pop_front_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));
    }

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_list_node_t const * node = octaspire_list_get_front(list);
        ASSERT(node);
        ASSERT_EQ(i, *((size_t const * const)octaspire_list_node_get_element_const(node)));

        ASSERT(octaspire_list_pop_front(list));
    }

    ASSERT_EQ(0, octaspire_list_get_length(list));
    ASSERT_EQ(0, octaspire_list_get_front(list));
    ASSERT_EQ(0, octaspire_list_get_back(list));

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_pop_back_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));
    }

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_list_node_t const * const first1 =
            octaspire_list_get_front_const(list);

        ASSERT(first1);
        ASSERT_EQ(0, *((size_t const * const)octaspire_list_node_get_element_const(first1)));

        ASSERT(octaspire_list_pop_back(list));

        if (i < (numElements - 1))
        {
            // Make sure that front doesn't change
            octaspire_list_node_t const * const first2 =
                octaspire_list_get_front_const(list);

            ASSERT(first2);
            ASSERT_EQ(first1, first2);

            // Check back
            octaspire_list_node_t const * const last =
                octaspire_list_get_back_const(list);

            ASSERT(last);

            ASSERT_EQ(
                numElements - 2 - i,
                *((size_t const * const)octaspire_list_node_get_element_const(last)));
        }
    }

    ASSERT_EQ(0, octaspire_list_get_length(list));
    ASSERT_EQ(0, octaspire_list_get_front(list));
    ASSERT_EQ(0, octaspire_list_get_back(list));

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_remove_middle_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    size_t const numElements = 10;

    octaspire_list_node_t * node = 0;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));

        if (i == 5)
        {
            node = octaspire_list_get_back(list);
        }
    }

    ASSERT(node);
    ASSERT(octaspire_list_remove(list, node));

    ASSERT_EQ(numElements - 1, octaspire_list_get_length(list));

    for (size_t i = 0; i < (numElements - 1); ++i)
    {
        node = octaspire_list_get_at(list, (ptrdiff_t)i);

        ASSERT(node);

        if (i < 5)
        {
            ASSERT_EQ(
                i < 5 ? i : (i + 1),
                *((size_t const * const)octaspire_list_node_get_element_const(node)));
        }
    }

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_remove_first_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    size_t const numElements = 10;

    octaspire_list_node_t * node = 0;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));

        if (i == 0)
        {
            node = octaspire_list_get_back(list);
        }
    }

    ASSERT(node);
    ASSERT(octaspire_list_remove(list, node));

    ASSERT_EQ(numElements - 1, octaspire_list_get_length(list));

    for (size_t i = 0; i < (numElements - 1); ++i)
    {
        node = octaspire_list_get_at(list, (ptrdiff_t)i);

        ASSERT(node);

        ASSERT_EQ(
            (i + 1),
            *((size_t const * const)octaspire_list_node_get_element_const(node)));
    }

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_remove_last_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    size_t const numElements = 10;

    octaspire_list_node_t * node = 0;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));

        if (i == (numElements - 1))
        {
            node = octaspire_list_get_back(list);
        }
    }

    ASSERT(node);
    ASSERT(octaspire_list_remove(list, node));

    ASSERT_EQ(numElements - 1, octaspire_list_get_length(list));

    for (size_t i = 0; i < (numElements - 1); ++i)
    {
        node = octaspire_list_get_at(list, (ptrdiff_t)i);

        ASSERT(node);

        ASSERT_EQ(
            i,
            *((size_t const * const)octaspire_list_node_get_element_const(node)));
    }

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_remove_even_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));
    }

    octaspire_list_node_t *node = octaspire_list_get_front(list);
    size_t index = 0;

    while (node)
    {
        octaspire_list_node_t * const next = octaspire_list_node_get_next(node);

        if (index % 2 == 0)
        {
            octaspire_list_remove(list, node);
            node = 0;
        }

        ++index;

        node = next;
    }

    ASSERT_EQ(5, octaspire_list_get_length(list));

    node = octaspire_list_get_front(list);
    index = 0;

    while (node)
    {
        octaspire_list_node_t * const next = octaspire_list_node_get_next(node);

        if (index % 2 == 0)
        {
            ++index;
        }

        ASSERT_EQ(
            index,
            *((size_t const * const)octaspire_list_node_get_element_const(node)));

        ++index;

        node = next;
    }

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_get_at_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    size_t const numElements = 128;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));
    }

    // Positive indices
    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_list_node_t const * const node =
            octaspire_list_get_at(list, (ptrdiff_t)i);

        ASSERT_EQ(
            i,
            *((size_t const * const)octaspire_list_node_get_element_const(node)));
    }

    // Negative indices
    for (size_t i = 0; i < numElements; ++i)
    {
        ptrdiff_t tmpIndex = -1 - (ptrdiff_t)i;
        octaspire_list_node_t const * const node =
            octaspire_list_get_at(list, tmpIndex);

        ASSERT_EQ(
            numElements - 1 - i,
            *((size_t const * const)octaspire_list_node_get_element_const(node)));
    }

    // Test failure
    ASSERT_FALSE(octaspire_list_get_at(list, numElements + 1));
    ASSERT_FALSE(octaspire_list_get_at(list, -((ptrdiff_t)(numElements + 2))));

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_get_at_const_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    size_t const numElements = 128;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));
    }

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_list_node_t const * const node =
            octaspire_list_get_at_const(list, (ptrdiff_t)i);

        ASSERT_EQ(
            i,
            *((size_t const * const)octaspire_list_node_get_element_const(node)));
    }

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_node_iterator_called_on_empty_list_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    octaspire_list_node_iterator_t iter =
        octaspire_list_node_iterator_init(list);

    for (size_t i = 0; i < 10; ++i)
    {
        ASSERT_EQ(iter.list, list);
        ASSERT_FALSE(iter.currentNode);
        ASSERT_FALSE(octaspire_list_node_iterator_next(&iter));
    }

    octaspire_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_list_node_iterator_test(void)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    size_t const numElements = 128;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_list_push_back(list, &i));
    }

    octaspire_list_node_iterator_t iter =
        octaspire_list_node_iterator_init(list);

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(iter.currentNode);

        size_t const fromIter =
            *(size_t const * const)octaspire_list_node_get_element_const(
                iter.currentNode);

        ASSERT_EQ(iter.list, list);
        ASSERT_EQ(i, fromIter);

        if ((i + 1) < numElements)
        {
            ASSERT(octaspire_list_node_iterator_next(&iter));
        }
    }

    ASSERT_FALSE(octaspire_list_node_iterator_next(&iter));
    ASSERT_FALSE(iter.currentNode);

    octaspire_list_release(list);
    list = 0;

    PASS();
}

GREATEST_SUITE(octaspire_list_suite)
{
    octaspireContainerListTestAllocator = octaspire_allocator_new(0);
    assert(octaspireContainerListTestAllocator);

    RUN_TEST(octaspire_list_new_test);
    RUN_TEST(octaspire_list_new_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_list_release_called_with_null_pointer_test);
    RUN_TEST(octaspire_list_get_front_test);
    RUN_TEST(octaspire_list_get_front_const_test);
    RUN_TEST(octaspire_list_get_back_test);
    RUN_TEST(octaspire_list_get_back_const_test);
    RUN_TEST(octaspire_list_clear_called_on_empty_list_test);
    RUN_TEST(octaspire_list_clear_test);
    RUN_TEST(octaspire_list_push_back_test);
    RUN_TEST(octaspire_list_push_front_test);
    RUN_TEST(octaspire_list_pop_front_test);
    RUN_TEST(octaspire_list_pop_back_test);
    RUN_TEST(octaspire_list_remove_middle_test);
    RUN_TEST(octaspire_list_remove_first_test);
    RUN_TEST(octaspire_list_remove_last_test);
    RUN_TEST(octaspire_list_remove_even_test);
    RUN_TEST(octaspire_list_get_at_test);
    RUN_TEST(octaspire_list_get_at_const_test);
    RUN_TEST(octaspire_list_node_iterator_called_on_empty_list_test);
    RUN_TEST(octaspire_list_node_iterator_test);

    octaspire_allocator_release(octaspireContainerListTestAllocator);
    octaspireContainerListTestAllocator = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_list.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_queue.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireContainerQueueTestAllocator = 0;

TEST octaspire_queue_new_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);
    ASSERT_EQ(0, octaspire_queue_get_max_length(queue));
    ASSERT_FALSE(octaspire_queue_has_max_length(queue));

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_new_allocation_failure_on_first_allocation_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerQueueTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerQueueTestAllocator));

    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT_EQ(0, queue);

    ASSERT_EQ(
        0,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerQueueTestAllocator));

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_new_with_max_length_of_56_with_size_t_elements_test(void)
{
    size_t const maxLength = 56;

    octaspire_queue_t *queue = octaspire_queue_new_with_max_length(
        maxLength,
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);
    ASSERT_EQ(maxLength, octaspire_queue_get_max_length(queue));
    ASSERT(octaspire_queue_has_max_length(queue));

    for (size_t i = 0; i < (3 * maxLength); ++i)
    {
        octaspire_queue_push(queue, &i);

        ASSERT(octaspire_queue_get_length(queue) <= maxLength);

        ASSERT_EQ(
            i < maxLength ? 0 : (i + 1 - maxLength),
            *(size_t const * const)octaspire_queue_peek(queue));

        size_t firstExpectedNumber = 0;

        if (i >= (maxLength-1))
        {
            firstExpectedNumber += (i - (maxLength - 1));
        }

        for (size_t j = 0; j < octaspire_queue_get_length(queue); ++j)
        {
            size_t const storedNum =
                *(size_t const * const)octaspire_queue_get_at_const(
                    queue,
                    (ptrdiff_t)j);

            size_t const expectedNum = firstExpectedNumber + j;

            ASSERT_EQ(expectedNum, storedNum);
        }
    }

    ASSERT_EQ(maxLength, octaspire_queue_get_length(queue));

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_new_with_max_length_of_10_with_ostring_ptr_elements_test(void)
{
    size_t const maxLength = 10;

    octaspire_queue_t *queue = octaspire_queue_new_with_max_length(
        maxLength,
        sizeof(octaspire_string_t*),
        true,
        (octaspire_queue_element_callback_t)octaspire_string_release,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);
    ASSERT_EQ(maxLength, octaspire_queue_get_max_length(queue));
    ASSERT(octaspire_queue_has_max_length(queue));

    for (size_t i = 0; i < (3 * maxLength); ++i)
    {
        octaspire_string_t * const str = octaspire_string_new_format(
            octaspireContainerQueueTestAllocator,
            "This is string %zu.",
            i);

        octaspire_queue_push(queue, &str);

        ASSERT(octaspire_queue_get_length(queue) <= maxLength);

        size_t firstExpectedNumber = 0;

        if (i >= maxLength)
        {
            firstExpectedNumber += (i - (maxLength - 1));
        }

        for (size_t j = 0; j < octaspire_queue_get_length(queue); ++j)
        {
            octaspire_string_t const * const storedStr =
                octaspire_queue_get_at_const(
                    queue,
                    (ptrdiff_t)j);

            octaspire_string_t * expectedStr =
                octaspire_string_new_format(
                    octaspireContainerQueueTestAllocator,
                    "This is string %zu.",
                    firstExpectedNumber + j);

            ASSERT(octaspire_string_is_equal(expectedStr, storedStr));

            octaspire_string_release(expectedStr);
            expectedStr = 0;
        }
    }

    ASSERT_EQ(maxLength, octaspire_queue_get_length(queue));

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_release_called_with_null_pointer_test(void)
{
    octaspire_queue_release(0);

    PASS();
}

TEST octaspire_queue_peek_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT_EQ(0, octaspire_queue_peek(queue));

    size_t const expected = 123;
    ASSERT(octaspire_queue_push(queue, &expected));
    ASSERT_EQ(expected, *(size_t const * const)octaspire_queue_peek(queue));

    size_t const next = 9876;
    ASSERT(octaspire_queue_push(queue, &next));
    ASSERT_EQ(expected, *(size_t const * const)octaspire_queue_peek(queue));

    ASSERT(octaspire_queue_pop(queue));
    ASSERT_EQ(next, *(size_t const * const)octaspire_queue_peek(queue));

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_peek_const_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT_EQ(0, octaspire_queue_peek_const(queue));

    size_t const expected = 123;
    ASSERT(octaspire_queue_push(queue, &expected));
    ASSERT_EQ(expected, *(size_t const * const)octaspire_queue_peek_const(queue));

    size_t const next = 9876;
    ASSERT(octaspire_queue_push(queue, &next));
    ASSERT_EQ(expected, *(size_t const * const)octaspire_queue_peek_const(queue));

    ASSERT(octaspire_queue_pop(queue));
    ASSERT_EQ(next, *(size_t const * const)octaspire_queue_peek_const(queue));

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_pop_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    size_t const numElements = 100;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_queue_push(queue, &i));
    }

    ASSERT_EQ(numElements, octaspire_queue_get_length(queue));

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_queue_pop(queue));
        size_t const * const ptr = (size_t const * const)octaspire_queue_peek(queue);

        if (i != (numElements -1))
        {
            ASSERT(ptr);
            ASSERT_EQ(i + 1, *ptr);
        }
        else
        {
            ASSERT_FALSE(ptr);
        }
    }

    ASSERT_EQ(0, octaspire_queue_get_length(queue));

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_push_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    size_t const numElements = 100;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT_EQ(i, octaspire_queue_get_length(queue));
        ASSERT(octaspire_queue_push(queue, &i));
        ASSERT_EQ(i + 1, octaspire_queue_get_length(queue));
        size_t const * const ptr = (size_t const * const)octaspire_queue_peek(queue);
        ASSERT_EQ(0, *ptr);

        for (size_t j = 0; j < octaspire_queue_get_length(queue); ++j)
        {
            size_t const * const jth =
                (size_t const * const)octaspire_queue_get_at(
                    queue,
                    (ptrdiff_t)j);

            ASSERT_EQ(j, *jth);
        }
    }

    ASSERT_EQ(numElements, octaspire_queue_get_length(queue));

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_queue_pop(queue));
        size_t const * const ptr = (size_t const * const)octaspire_queue_peek(queue);

        if (i != (numElements -1))
        {
            ASSERT(ptr);
            ASSERT_EQ(i + 1, *ptr);
        }
        else
        {
            ASSERT_FALSE(ptr);
        }
    }

    ASSERT_EQ(0, octaspire_queue_get_length(queue));

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_clear_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT(octaspire_queue_clear(queue));
    ASSERT(octaspire_queue_is_empty(queue));
    ASSERT_EQ(0, octaspire_queue_get_length(queue));
    ASSERT_FALSE(octaspire_queue_peek(queue));

    size_t const value = 10;
    ASSERT(octaspire_queue_push(queue, &value));

    ASSERT(octaspire_queue_clear(queue));
    ASSERT(octaspire_queue_is_empty(queue));
    ASSERT_EQ(0, octaspire_queue_get_length(queue));
    ASSERT_FALSE(octaspire_queue_peek(queue));

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_get_length_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT_EQ(0, octaspire_queue_get_length(queue));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_queue_push(queue, &i));
        ASSERT_EQ(i + 1, octaspire_queue_get_length(queue));
    }

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_queue_pop(queue));
        ASSERT_EQ(numElements - 1 - i, octaspire_queue_get_length(queue));
    }

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_is_empty_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT(octaspire_queue_is_empty(queue));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_queue_push(queue, &i));
        ASSERT_FALSE(octaspire_queue_is_empty(queue));
    }

    for (size_t i = 0; i < (numElements - 1); ++i)
    {
        ASSERT(octaspire_queue_pop(queue));
        ASSERT_FALSE(octaspire_queue_is_empty(queue));
    }

    ASSERT(octaspire_queue_pop(queue));
    ASSERT(octaspire_queue_is_empty(queue));

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_get_at_failure_on_too_large_index_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT_FALSE(octaspire_queue_get_at(queue, 0));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_queue_push(queue, &i));

        size_t j;
        for (j = 0; j < i; ++j)
        {
            ASSERT(octaspire_queue_get_at(queue, (ptrdiff_t)j));
        }

        ++j;
        ASSERT_FALSE(octaspire_queue_get_at(queue, (ptrdiff_t)j));
    }

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_get_at_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    size_t const numElements = 100;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_queue_push(queue, &i));

        for (size_t j = 0; j < i; ++j)
        {
            size_t const * const ptr =
                octaspire_queue_get_at(queue, (ptrdiff_t)j);

            ASSERT(ptr);
            ASSERT_EQ(j, *ptr);
        }

        // Negative index
        size_t * const ptr =
            octaspire_queue_get_at(queue, -1);

        ASSERT(ptr);
        ASSERT_EQ(i, *ptr);

        // Failure test
        ASSERT_FALSE(octaspire_queue_get_at(
            queue,
            -((ptrdiff_t)(i + 2))));

        ASSERT_FALSE(octaspire_queue_get_at(
            queue,
            (ptrdiff_t)(i + 1)));
    }

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_get_at_const_failure_on_too_large_index_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT_FALSE(octaspire_queue_get_at_const(queue, 0));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_queue_push(queue, &i));

        size_t j;
        for (j = 0; j < i; ++j)
        {
            ASSERT(octaspire_queue_get_at_const(queue, (ptrdiff_t)j));
        }

        ++j;
        ASSERT_FALSE(octaspire_queue_get_at_const(queue, (ptrdiff_t)j));
    }

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_get_at_const_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    size_t const numElements = 100;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_queue_push(queue, &i));

        for (size_t j = 0; j < i; ++j)
        {
            size_t const * const ptr =
                octaspire_queue_get_at_const(
                    queue,
                    (ptrdiff_t)j);
            ASSERT(ptr);
            ASSERT_EQ(j, *ptr);
        }

        // Negative index
        size_t const * const ptr =
            octaspire_queue_get_at_const(queue, -1);

        ASSERT(ptr);
        ASSERT_EQ(i, *ptr);

        // Failure test
        ASSERT_FALSE(octaspire_queue_get_at_const(
            queue,
            -((ptrdiff_t)(i + 2))));

        ASSERT_FALSE(octaspire_queue_get_at_const(
            queue,
            (ptrdiff_t)(i + 1)));
    }

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_get_set_has_max_length_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT_EQ(0, octaspire_queue_get_max_length(queue));
    ASSERT_FALSE(octaspire_queue_has_max_length(queue));

    size_t const value = 100;

    for (size_t i = 0; i < value; ++i)
    {
        ASSERT(octaspire_queue_set_max_length(queue, i));
        ASSERT_EQ(i, octaspire_queue_get_max_length(queue));
        ASSERT_EQ(0, octaspire_queue_get_length(queue));
    }

    size_t const numElements = 256;
    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_queue_push(queue, &i));
    }

    ASSERT_EQ(numElements, octaspire_queue_get_length(queue));
    ASSERT_FALSE(octaspire_queue_has_max_length(queue));

    for (size_t i = value; i > 0; --i)
    {
        ASSERT(octaspire_queue_set_max_length(queue, i));
        ASSERT(octaspire_queue_set_has_max_length(queue, true));
        ASSERT(octaspire_queue_has_max_length(queue));
        ASSERT_EQ(i, octaspire_queue_get_max_length(queue));
        ASSERT_EQ(i, octaspire_queue_get_length(queue));
    }

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_iterator_called_on_empty_queue_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    octaspire_queue_iterator_t iter =
        octaspire_queue_iterator_init(queue);

    for (size_t i = 0; i < 10; ++i)
    {
        ASSERT_EQ(iter.queue, queue);
        ASSERT_FALSE(iter.iterator.currentNode);
        ASSERT_FALSE(octaspire_queue_iterator_next(&iter));
    }

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_queue_iterator_test(void)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    size_t const numElements = 128;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_queue_push(queue, &i));
    }

    octaspire_queue_iterator_t iter =
        octaspire_queue_iterator_init(queue);

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(iter.iterator.currentNode);

        size_t const fromIter =
            *(size_t const * const)octaspire_list_node_get_element_const(
                iter.iterator.currentNode);

        ASSERT_EQ(iter.queue, queue);
        ASSERT_EQ(i, fromIter);

        if ((i + 1) < numElements)
        {
            ASSERT(octaspire_queue_iterator_next(&iter));
        }
    }

    ASSERT_FALSE(octaspire_queue_iterator_next(&iter));
    ASSERT_FALSE(iter.iterator.currentNode);

    octaspire_queue_release(queue);
    queue = 0;

    PASS();
}

GREATEST_SUITE(octaspire_queue_suite)
{
    octaspireContainerQueueTestAllocator = octaspire_allocator_new(0);
    assert(octaspireContainerQueueTestAllocator);

    RUN_TEST(octaspire_queue_new_test);
    RUN_TEST(octaspire_queue_new_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_queue_new_with_max_length_of_56_with_size_t_elements_test);
    RUN_TEST(octaspire_queue_new_with_max_length_of_10_with_ostring_ptr_elements_test);
    RUN_TEST(octaspire_queue_release_called_with_null_pointer_test);
    RUN_TEST(octaspire_queue_peek_test);
    RUN_TEST(octaspire_queue_peek_const_test);
    RUN_TEST(octaspire_queue_pop_test);
    RUN_TEST(octaspire_queue_push_test);
    RUN_TEST(octaspire_queue_clear_test);
    RUN_TEST(octaspire_queue_get_length_test);
    RUN_TEST(octaspire_queue_is_empty_test);
    RUN_TEST(octaspire_queue_get_at_failure_on_too_large_index_test);
    RUN_TEST(octaspire_queue_get_at_test);
    RUN_TEST(octaspire_queue_get_at_const_failure_on_too_large_index_test);
    RUN_TEST(octaspire_queue_get_at_const_test);
    RUN_TEST(octaspire_queue_get_set_has_max_length_test);
    RUN_TEST(octaspire_queue_iterator_called_on_empty_queue_test);
    RUN_TEST(octaspire_queue_iterator_test);

    octaspire_allocator_release(octaspireContainerQueueTestAllocator);
    octaspireContainerQueueTestAllocator = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_queue.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_string.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireContainerUtf8StringTestAllocator = 0;

TEST octaspire_string_new_called_with_null_argument_test(void)
{
    octaspire_string_t *str =
        octaspire_string_new(0, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(0, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(0, octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("", octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_with_simple_ascii_string_test(void)
{
    char const * const expected = "Hello World!";
    octaspire_string_t *str =
        octaspire_string_new(expected, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(strlen((char const * const)expected), octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(strlen((char const * const)expected), octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ(expected, octaspire_string_get_c_string(str));

    for (size_t i = 0; i < octaspire_string_get_length_in_ucs_characters(str); ++i)
    {
        ASSERT_EQ(
            (uint32_t)(expected[i]),
            octaspire_string_get_ucs_character_at_index(
                str,
                (ptrdiff_t)i));
    }

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_with_some_multioctet_ucs_characters_test(void)
{
    char const * const input = "Hello World!  How are you?";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_with_simple_ascii_string_with_error_test(void)
{
    char const * const input    = "Hello World\xC0\xB3";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_DECODING_ERROR, str->errorStatus);
    ASSERT_EQ(11,                                                          str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                                   str->allocator);

    ASSERT(octaspire_string_is_error(str));
    ASSERT_EQ(11, octaspire_string_get_error_position_in_octets(str));

    char const * const expected = "Hello World";

    ASSERT_EQ(strlen((char const * const)expected), octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(strlen((char const * const)expected), octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ(expected, octaspire_string_get_c_string(str));

    for (size_t i = 0;
         i < octaspire_string_get_length_in_ucs_characters(str);
         ++i)
    {
        ASSERT_EQ(
            (uint32_t)(expected[i]),
            octaspire_string_get_ucs_character_at_index(
                str,
                (ptrdiff_t)i));
    }

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_from_buffer_with_some_multioctet_ucs_characters_test(void)
{
    char const * const input               = "Hello World!  How are you?";
    size_t const       lengthInOctets      = strlen(input);
    octaspire_string_t *str =
        octaspire_string_new_from_buffer(input, lengthInOctets, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_from_buffer_allocation_failure_on_first_allocation_test(void)
{
    char const * const input               = "Hello World!  How are you?";
    size_t const       lengthInOctets      = strlen(input);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator));

    octaspire_string_t *str =
        octaspire_string_new_from_buffer(input, lengthInOctets, octaspireContainerUtf8StringTestAllocator);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    ASSERT_FALSE(str);

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_from_buffer_allocation_failure_on_second_allocation_test(void)
{
    char const * const input               = "Hello World!  How are you?";
    size_t const       lengthInOctets      = strlen(input);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator));

    octaspire_string_t *str =
        octaspire_string_new_from_buffer(input, lengthInOctets, octaspireContainerUtf8StringTestAllocator);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    ASSERT_FALSE(str);

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_from_buffer_allocation_failure_on_third_allocation_test(void)
{
    char const * const input               = "Hello World!  How are you?";
    size_t const       lengthInOctets      = strlen(input);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 3, 0x03);
    ASSERT_EQ(3, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator));

    octaspire_string_t *str =
        octaspire_string_new_from_buffer(input, lengthInOctets, octaspireContainerUtf8StringTestAllocator);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    ASSERT_FALSE(str);

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_from_buffer_allocation_failure_on_sixth_2_allocation_test(void)
{
    char const * const input               = "Hello World!  How are you?";
    size_t const       lengthInOctets      = strlen(input);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 6, 0x1F);
    ASSERT_EQ(6, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator));

    octaspire_string_t *str =
        octaspire_string_new_from_buffer(input, lengthInOctets, octaspireContainerUtf8StringTestAllocator);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    ASSERT_FALSE(str);

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_format_with_string_test(void)
{
    char const * const name  = "Mike";
    char const * const input = "Hello! My name is %s. What's yours?";
    octaspire_string_t *str =
        octaspire_string_new_format(octaspireContainerUtf8StringTestAllocator, input, name);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(37, octaspire_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "Hello! My name is Mike. What's yours?";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_format_with_size_t_test(void)
{
    size_t const value = 62039;
    char const * const input = "Hello World!  How are you? My age is %zu. What's yours?";
    octaspire_string_t *str =
        octaspire_string_new_format(octaspireContainerUtf8StringTestAllocator, input, value);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(68, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(61, octaspire_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you? My age is 62039. What's yours?";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_format_with_doubles_test(void)
{
    double const value1 = 12.001;
    double const value2 = 2015.12;
    double const value3 = 4.9;
    char const * const input = "The doubles are %g, %g and %g\n";
    octaspire_string_t *str =
        octaspire_string_new_format(octaspireContainerUtf8StringTestAllocator, input, value1, value2, value3);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(40, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(40, octaspire_string_get_length_in_ucs_characters(str));

    char const * const expected = "The doubles are 12.001, 2015.12 and 4.9\n";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_format_with_string_and_size_t_test(void)
{
    size_t const value = 62039;
    char const * const name  = "Hello";
    char const * const input = "Hello World!  How are you? My name is \"%s\" and my age is %zu. What's yours?";
    octaspire_string_t *str =
        octaspire_string_new_format(octaspireContainerUtf8StringTestAllocator, input, name, value);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(93, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(85, octaspire_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you? My name is \"\xC2\xA9Hello\" and my age is 62039. What's yours?";

    ASSERT_MEM_EQ(
        expected,
        octaspire_string_get_c_string(str),
        octaspire_string_get_length_in_octets(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_format_with_string_and_size_t_on_otherwise_empty_format_string_test(void)
{
    size_t const value = 62039;
    char const * const name  = "Hello";
    char const * const input = "%s%zu";
    octaspire_string_t *str =
        octaspire_string_new_format(octaspireContainerUtf8StringTestAllocator, input, name, value);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(10, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(10, octaspire_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "Hello62039";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_format_with_empty_format_string_test(void)
{
    char const * const input = "";
    octaspire_string_t *str =
        octaspire_string_new_format(octaspireContainerUtf8StringTestAllocator, input);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(0, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(0, octaspire_string_get_length_in_ucs_characters(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_copy_test(void)
{
    char const * const input = "Hello World!  How are you?";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(str));

    octaspire_string_t *cpy =
        octaspire_string_new_copy(str, octaspireContainerUtf8StringTestAllocator);

    ASSERT_EQ(
        octaspire_string_get_length_in_octets(str),
        octaspire_string_get_length_in_octets(cpy));

    ASSERT_MEM_EQ(
        octaspire_vector_get_element_at_const(str->octets, 0),
        octaspire_vector_get_element_at_const(cpy->octets, 0),
        octaspire_string_get_length_in_octets(str));

    ASSERT_EQ(
        octaspire_vector_get_length_in_octets(str->ucsCharacters),
        octaspire_vector_get_length_in_octets(cpy->ucsCharacters));

    ASSERT_MEM_EQ(
        octaspire_vector_get_element_at_const(str->ucsCharacters, 0),
        octaspire_vector_get_element_at_const(cpy->ucsCharacters, 0),
        octaspire_vector_get_length_in_octets(str->ucsCharacters));

    ASSERT_EQ(str->errorStatus,  cpy->errorStatus);
    ASSERT_EQ(str->errorAtOctet, cpy->errorAtOctet);

    ASSERT_EQ(cpy->allocator,     octaspireContainerUtf8StringTestAllocator);

    octaspire_string_release(str);
    str = 0;

    octaspire_string_release(cpy);
    cpy = 0;

    PASS();
}

TEST octaspire_string_new_copy_failure_test(void)
{
    char const * const input = "Hello World!  How are you?";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(str));

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator));

    ASSERT_FALSE(octaspire_string_new_copy(str, octaspireContainerUtf8StringTestAllocator));

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_get_length_in_ucs_characters_test(void)
{
    char const * const input = "Hello World!  How are you?";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    //ASSERT_EQ(37, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_string_get_length_in_ucs_characters(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_get_length_in_ucs_characters_called_with_empty_string_test(void)
{
    char const * const input = "";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(0, octaspire_string_get_length_in_ucs_characters(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_get_length_in_octets_test(void)
{
    char const * const input = "Hello World!  How are you?";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_string_get_length_in_octets(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_get_length_in_octets_called_with_empty_string_test(void)
{
    char const * const input = "";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(0, octaspire_string_get_length_in_octets(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_get_ucs_character_at_index_test(void)
{
    char const * const input = "Hello World!  How are you?";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

#define EXPECTED_LENGTH 30

    ASSERT_EQ(EXPECTED_LENGTH, octaspire_string_get_length_in_ucs_characters(str));

    uint32_t expected[EXPECTED_LENGTH] =
    {
        0xA9,    // Copyright symbol
        0x48,    // H
        0x65,    // e
        0x6C,    // l
        0x6C,    // l
        0x6F,    // o
        0x20,    // SPACE
        0x57,    // W
        0x6F,    // o
        0x72,    // r
        0x6C,    // l
        0x64,    // d
        0x21,    // !
        0x20,    // SPACE
        0xA9,    // Copyright symbol
        0x20,    // SPACE
        0x2260,  // NOT EQUAL SIGN
        0x10000, // LINEAR B SYLLABLE B008 A
        0x48,    // H
        0x6F,    // o
        0x77,    // w
        0x20,    // SPACE
        0x61,    // a
        0x72,    // r
        0x65,    // e
        0x20,    // SPACE
        0x79,    // y
        0x6F,    // o
        0x75,    // u
        0x3F,    // ?
    };

    for (size_t i = 0; i < EXPECTED_LENGTH; ++i)
    {
        ASSERT_EQ(
            expected[i],
            octaspire_string_get_ucs_character_at_index(
                str,
                (ptrdiff_t)i));
    }

    for (size_t i = 0; i < EXPECTED_LENGTH; ++i)
    {
        ptrdiff_t const index = -((ptrdiff_t)(i + 1));
        ASSERT_EQ(
            expected[EXPECTED_LENGTH - 1 - i],
            octaspire_string_get_ucs_character_at_index(str, index));
    }

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_get_c_string_test(void)
{
    char const * const input    = "Hello World! ";
    char const * const expected = "Hello World! \xc2\xa9";

    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(15, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(14, octaspire_string_get_length_in_ucs_characters(str));

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_get_c_string_called_with_empty_string_test(void)
{
    char const * const input    = "";

    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(0, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(0, octaspire_string_get_length_in_ucs_characters(str));

    ASSERT_EQ('\0', *octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_is_error_false_case_test(void)
{
    char const * const input    = "Hello World";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_string_is_error(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_is_error_true_case_test(void)
{
    char const * const input    = "Hello World\xC0\xB3";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT(octaspire_string_is_error(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_get_error_position_in_octets_called_when_has_error_test(void)
{
    char const * const input    = "Hello World\xC0\xB3";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_EQ(11, octaspire_string_get_error_position_in_octets(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_get_error_position_in_octets_called_when_has_no_error_test(void)
{
    char const * const input    = "Hello World";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_reset_error_status_called_when_there_is_error_test(void)
{
    char const * const input    = "Hello World\xC0\xB3";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT(octaspire_string_is_error(str));
    ASSERT_EQ(11, octaspire_string_get_error_position_in_octets(str));

    octaspire_string_reset_error_status(str);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_reset_error_status_called_when_there_is_no_error_test(void)
{
    char const * const input    = "Hello World";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    octaspire_string_reset_error_status(str);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_concatenate_c_string_called_with_null_and_empty_string_arguments_test(void)
{
    char const * const input = "Hello World!  How are you?";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    octaspire_string_concatenate_c_string(str, 0);
    octaspire_string_concatenate_c_string(str, "");

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

// TODO XXX Add test cases for allocation failures in concatenate_c_string...

TEST octaspire_string_concatenate_c_string_test(void)
{
    char const * const input  = "Hello World!";
    char const * const input2 = "  How are you?";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    octaspire_string_concatenate_c_string(str, input2);

    ASSERT_FALSE(octaspire_string_is_error(str));
    ASSERT_EQ(0, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_concatenate_c_string_with_decode_error_test(void)
{
    char const * const input  = "Hello World!";
    char const * const input2 = "  How are you?\xC0\xB3";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    octaspire_string_concatenate_c_string(str, input2);

    ASSERT(octaspire_string_is_error(str));
    ASSERT_EQ(23, octaspire_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_concatenate_c_string_allocation_failure_one_test(void)
{
    char const * const input  = "Hello World!";
    char const * const input2 = "  How are you?";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 1, 0);

    ASSERT_FALSE(octaspire_string_concatenate_c_string(str, input2));

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_concatenate_c_string_allocation_failure_two_test(void)
{
    char const * const input  = "a";
    char const * const input2 = "bcd";
    octaspire_string_t *str =
        octaspire_string_new(input, octaspireContainerUtf8StringTestAllocator);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerUtf8StringTestAllocator,
        2, 0x00000002);

    ASSERT_FALSE(octaspire_string_concatenate_c_string(str, input2));

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_c_strings_end_always_in_null_byte_test(void)
{
    octaspire_string_t *str = octaspire_string_new("", octaspireContainerUtf8StringTestAllocator);
    ASSERT(octaspire_vector_is_empty(str->octets));
    ASSERT_STR_EQ("", octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    str = octaspire_string_new("a", octaspireContainerUtf8StringTestAllocator);
    ASSERT(octaspire_vector_is_empty(str->octets));
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;


    str = octaspire_string_new_format(octaspireContainerUtf8StringTestAllocator, "");
    ASSERT(octaspire_vector_is_empty(str->octets));
    ASSERT_STR_EQ("", octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;


    size_t const size = 112;
    str = octaspire_string_new_format(octaspireContainerUtf8StringTestAllocator, "%zu", size);
    ASSERT(octaspire_vector_is_empty(str->octets));
    ASSERT_STR_EQ("112", octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_new_format_numbers_into_vector_test(void)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(octaspire_string_t*),
        true,
        (octaspire_vector_element_callback_t)octaspire_string_release,
        octaspireContainerUtf8StringTestAllocator);

    size_t const numElements = 256;

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_string_t *str = octaspire_string_new_format(
            octaspireContainerUtf8StringTestAllocator,
            "%zu",
            i);

        octaspire_vector_push_back_element(vec, &str);

    }

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_string_t const * const str =
            octaspire_vector_get_element_at_const(vec, (ptrdiff_t)i);

        ASSERT_EQ(i, (size_t)atoi(octaspire_string_get_c_string(str)));
    }

    octaspire_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_string_new_format_number_test(void)
{
    size_t const i = 2000;
    octaspire_string_t *str = octaspire_string_new_format(
            octaspireContainerUtf8StringTestAllocator,
            "%zu",
            i);

    ASSERT_EQ(i, (size_t)atoi(octaspire_string_get_c_string(str)));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_char_a_from_string_a123a56a89a_using_negative_indice_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "a123a56a89a",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *character =
        octaspire_string_new("a123",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && character);

    // Test failure first
    octaspire_vector_t *indices = octaspire_string_find_char(
        str,
        character,
        -5);

    ASSERT_FALSE(indices);

    // Test success
    indices = octaspire_string_find_char(
        str,
        character,
        -4);

    ASSERT(indices);

    ASSERT_EQ(4, octaspire_vector_get_length(indices));

    ASSERT_EQ(0,  *(size_t*)octaspire_vector_get_element_at(indices, 0));
    ASSERT_EQ(4,  *(size_t*)octaspire_vector_get_element_at(indices, 1));
    ASSERT_EQ(7,  *(size_t*)octaspire_vector_get_element_at(indices, 2));
    ASSERT_EQ(10, *(size_t*)octaspire_vector_get_element_at(indices, 3));

    octaspire_vector_release(indices);
    indices = 0;

    octaspire_string_release(character);
    character = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_char_a_from_string_a123a56a89a_using_index_zero_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "a123a56a89a",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *character =
        octaspire_string_new("a123",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && character);

    octaspire_vector_t *indices = octaspire_string_find_char(
        str,
        character,
        0);

    ASSERT(indices);

    ASSERT_EQ(4, octaspire_vector_get_length(indices));

    ASSERT_EQ(0,  *(size_t*)octaspire_vector_get_element_at(indices, 0));
    ASSERT_EQ(4,  *(size_t*)octaspire_vector_get_element_at(indices, 1));
    ASSERT_EQ(7,  *(size_t*)octaspire_vector_get_element_at(indices, 2));
    ASSERT_EQ(10, *(size_t*)octaspire_vector_get_element_at(indices, 3));

    octaspire_vector_release(indices);
    indices = 0;

    octaspire_string_release(character);
    character = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_char_q_from_string_a123a56q89q_using_index_one_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "a123a56q89q",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *character =
        octaspire_string_new("aq123",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && character);

    octaspire_vector_t *indices = octaspire_string_find_char(
        str,
        character,
        1);

    ASSERT(indices);

    ASSERT_EQ(2, octaspire_vector_get_length(indices));

    ASSERT_EQ(7,  *(size_t*)octaspire_vector_get_element_at(indices, 0));
    ASSERT_EQ(10, *(size_t*)octaspire_vector_get_element_at(indices, 1));

    octaspire_vector_release(indices);
    indices = 0;

    octaspire_string_release(character);
    character = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_char_c_from_string_a123c56q89q_using_index_two_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "a123c56q89q",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *character =
        octaspire_string_new("aqc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && character);

    octaspire_vector_t *indices = octaspire_string_find_char(
        str,
        character,
        2);

    ASSERT(indices);

    ASSERT_EQ(1, octaspire_vector_get_length(indices));

    ASSERT_EQ(4, *(size_t*)octaspire_vector_get_element_at(indices, 0));

    octaspire_vector_release(indices);
    indices = 0;

    octaspire_string_release(character);
    character = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_char_c_from_string_a123y56q89q_using_index_two_failure_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "a123y56q89q",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *character =
        octaspire_string_new("aqc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && character);

    octaspire_vector_t *indices = octaspire_string_find_char(
        str,
        character,
        2);

    ASSERT(indices);

    ASSERT_EQ(0, octaspire_vector_get_length(indices));

    octaspire_vector_release(indices);
    indices = 0;

    octaspire_string_release(character);
    character = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_string_Xcat_from_string_cat_dog_cat_zebra_car_kitten_cat_using_index_minus_3_and_length_of_3_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "cat dog cat zebra car kitten cat",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *lookFor =
        octaspire_string_new("Xcat",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_vector_t *indices = octaspire_string_find_string(
        str,
        lookFor,
        -3,
        3);

    ASSERT(indices);

    ASSERT_EQ(3, octaspire_vector_get_length(indices));

    ASSERT_EQ(0,   *(size_t*)octaspire_vector_get_element_at(indices, 0));
    ASSERT_EQ(8,   *(size_t*)octaspire_vector_get_element_at(indices, 1));
    ASSERT_EQ(29,  *(size_t*)octaspire_vector_get_element_at(indices, 2));

    octaspire_vector_release(indices);
    indices = 0;

    octaspire_string_release(lookFor);
    lookFor = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_string_cat_from_string_cat_dog_cat_zebra_car_kitten_cat_using_index_zero_and_length_of_3_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "cat dog cat zebra car kitten cat",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *lookFor =
        octaspire_string_new("cat",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_vector_t *indices = octaspire_string_find_string(
        str,
        lookFor,
        0,
        3);

    ASSERT(indices);

    ASSERT_EQ(3, octaspire_vector_get_length(indices));

    ASSERT_EQ(0,   *(size_t*)octaspire_vector_get_element_at(indices, 0));
    ASSERT_EQ(8,   *(size_t*)octaspire_vector_get_element_at(indices, 1));
    ASSERT_EQ(29,  *(size_t*)octaspire_vector_get_element_at(indices, 2));

    octaspire_vector_release(indices);
    indices = 0;

    octaspire_string_release(lookFor);
    lookFor = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_string_cat_from_string_cat_dog_cat_zebra_car_kitten_cat_using_index_one_and_length_of_3_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "cat dog cat zebra car kitten cat",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *lookFor =
        octaspire_string_new(">cat<",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_vector_t *indices = octaspire_string_find_string(
        str,
        lookFor,
        1,
        3);

    ASSERT(indices);

    ASSERT_EQ(3, octaspire_vector_get_length(indices));

    ASSERT_EQ(0,   *(size_t*)octaspire_vector_get_element_at(indices, 0));
    ASSERT_EQ(8,   *(size_t*)octaspire_vector_get_element_at(indices, 1));
    ASSERT_EQ(29,  *(size_t*)octaspire_vector_get_element_at(indices, 2));

    octaspire_vector_release(indices);
    indices = 0;

    octaspire_string_release(lookFor);
    lookFor = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_string_dog_from_string_dog_cat_zebra_using_index_zero_and_length_of_three_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "dog cat zebra",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *lookFor =
        octaspire_string_new("dog",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_vector_t *indices = octaspire_string_find_string(
        str,
        lookFor,
        0,
        3);

    ASSERT(indices);

    ASSERT_EQ(1, octaspire_vector_get_length(indices));

    ASSERT_EQ(0,   *(size_t*)octaspire_vector_get_element_at(indices, 0));

    octaspire_vector_release(indices);
    indices = 0;

    octaspire_string_release(lookFor);
    lookFor = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_string_dog_from_string_cat_zebra_dog_using_index_zero_and_length_of_three_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "cat zebra dog",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *lookFor =
        octaspire_string_new("dog",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_vector_t *indices = octaspire_string_find_string(
        str,
        lookFor,
        0,
        3);

    ASSERT(indices);

    ASSERT_EQ(1, octaspire_vector_get_length(indices));

    ASSERT_EQ(10,   *(size_t*)octaspire_vector_get_element_at(indices, 0));

    octaspire_vector_release(indices);
    indices = 0;

    octaspire_string_release(lookFor);
    lookFor = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_string_dog_from_string_cat_zebra_kitten_using_index_zero_and_length_of_three_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "cat zebra kitten",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *lookFor =
        octaspire_string_new("dog",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_vector_t *indices = octaspire_string_find_string(
        str,
        lookFor,
        0,
        3);

    ASSERT(indices);

    ASSERT_EQ(0, octaspire_vector_get_length(indices));

    octaspire_vector_release(indices);
    indices = 0;

    octaspire_string_release(lookFor);
    lookFor = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_string_kitten_from_string_cat_using_index_zero_and_length_of_six_failure_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "cat",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *lookFor =
        octaspire_string_new("kitten",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_vector_t *indices = octaspire_string_find_string(
        str,
        lookFor,
        0,
        6);

    ASSERT(indices);

    ASSERT_EQ(0, octaspire_vector_get_length(indices));

    octaspire_vector_release(indices);
    indices = 0;

    octaspire_string_release(lookFor);
    lookFor = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_private_check_substring_match_at_middle_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "123kitten456",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *substring =
        octaspire_string_new("kitten",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    for (size_t i = 0; i < octaspire_string_get_length_in_ucs_characters(str); ++i)
    {
        ASSERT_EQ(i == 3 ? true : false,
            octaspire_string_private_check_substring_match_at(
                str,
                i,
                substring));
    }

    octaspire_string_release(substring);
    substring = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_private_check_substring_match_at_the_beginning_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "kitten456",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *substring =
        octaspire_string_new("kitten",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    for (size_t i = 0; i < octaspire_string_get_length_in_ucs_characters(str); ++i)
    {
        ASSERT_EQ(i == 0 ? true : false,
            octaspire_string_private_check_substring_match_at(
                str,
                i,
                substring));
    }

    octaspire_string_release(substring);
    substring = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_private_check_substring_match_at_the_end_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "123kitten",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *substring =
        octaspire_string_new("kitten",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    for (size_t i = 0; i < octaspire_string_get_length_in_ucs_characters(str); ++i)
    {
        ASSERT_EQ(i == 3 ? true : false,
            octaspire_string_private_check_substring_match_at(
                str,
                i,
                substring));
    }

    octaspire_string_release(substring);
    substring = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_first_substring_abc_from_123abc456abc_starting_from_index_0_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "123abc456abc",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *substring =
        octaspire_string_new("abc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    ASSERT_EQ(
        3,
        octaspire_string_find_first_substring(
            str,
            0,
            substring));

    octaspire_string_release(substring);
    substring = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_first_substring_abc_from_123abc456abc_starting_from_index_minus_three_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "123abc456abc",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *substring =
        octaspire_string_new("abc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    ASSERT_EQ(
        9,
        octaspire_string_find_first_substring(
            str,
            -3,
            substring));

    ASSERT_EQ(
        9,
        octaspire_string_find_first_substring(
            str,
            -4,
            substring));

    ASSERT_EQ(
        3,
        octaspire_string_find_first_substring(
            str,
            -9,
            substring));

    ASSERT_EQ(
        3,
        octaspire_string_find_first_substring(
            str,
            -12,
            substring));

    // Not found
    ASSERT_EQ(
        -1,
        octaspire_string_find_first_substring(
            str,
            -2,
            substring));

    octaspire_string_release(substring);
    substring = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_first_substring_abc_from_123abc456abc_starting_from_index_4_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "123abc456abc",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *substring =
        octaspire_string_new("abc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    ASSERT_EQ(
        9,
        octaspire_string_find_first_substring(
            str,
            4,
            substring));

    octaspire_string_release(substring);
    substring = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_find_first_substring_abcd_from_123abc456abc_starting_from_index_0_failure_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "123abc456abc",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *substring =
        octaspire_string_new("abcd",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    ASSERT_EQ(
        -1,
        octaspire_string_find_first_substring(
            str,
            0,
            substring));

    octaspire_string_release(substring);
    substring = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_remove_character_at_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "0123456789",
            octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(octaspire_string_remove_character_at(str, 1));
    ASSERT_STR_EQ("023456789", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_remove_character_at(str, 0));
    ASSERT_STR_EQ("23456789", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_remove_character_at(str, 7));
    ASSERT_STR_EQ("2345678", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_remove_character_at(str, -1));
    ASSERT_STR_EQ("234567", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_remove_character_at(str, -1));
    ASSERT_STR_EQ("23456", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_remove_character_at(str, -5));
    ASSERT_STR_EQ("3456", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_remove_character_at(str, -4));
    ASSERT_STR_EQ("456", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_remove_character_at(str, -2));
    ASSERT_STR_EQ("46", octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_remove_character_at_called_on_string_with_two_os_with_diaeresis_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "",
            octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);
    ASSERT_EQ(2, octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_remove_character_at(str, 1));
    ASSERT_EQ(1, octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_remove_character_at(str, 0));
    ASSERT_EQ(0, octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("", octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_remove_characters_at_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
        "0123456789",
        octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT_EQ(3, octaspire_string_remove_characters_at(str, 7, 3));
    ASSERT_STR_EQ("0123456", octaspire_string_get_c_string(str));

    ASSERT_EQ(3, octaspire_string_remove_characters_at(str, 2, 3));
    ASSERT_STR_EQ("0156", octaspire_string_get_c_string(str));

    ASSERT_EQ(3, octaspire_string_remove_characters_at(str, 0, 3));
    ASSERT_STR_EQ("6", octaspire_string_get_c_string(str));

    ASSERT_EQ(1, octaspire_string_remove_characters_at(str, 0, 1));
    ASSERT_STR_EQ("", octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    // Using negative indices
    str = octaspire_string_new(
        "0123456789",
        octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    // Failures
    ASSERT_EQ(0, octaspire_string_remove_characters_at(str, -11, 3));
    ASSERT_STR_EQ("0123456789", octaspire_string_get_c_string(str));

    ASSERT_EQ(0, octaspire_string_remove_characters_at(str, -12, 3));
    ASSERT_STR_EQ("0123456789", octaspire_string_get_c_string(str));

    // Success
    ASSERT_EQ(3, octaspire_string_remove_characters_at(str, -3, 3));
    ASSERT_STR_EQ("0123456", octaspire_string_get_c_string(str));

    ASSERT_EQ(3, octaspire_string_remove_characters_at(str, -5, 3));
    ASSERT_STR_EQ("0156", octaspire_string_get_c_string(str));

    ASSERT_EQ(3, octaspire_string_remove_characters_at(str, -4, 3));
    ASSERT_STR_EQ("6", octaspire_string_get_c_string(str));

    ASSERT_EQ(1, octaspire_string_remove_characters_at(str, -1, 1));
    ASSERT_STR_EQ("", octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_remove_all_substrings_kitten_from_string_kitten_cat_kitten_dog_kitten_zebra_kitten_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
            "kitten cat kitten dog kitten zebra kitten",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *substring =
        octaspire_string_new("kitten",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    ASSERT_EQ(4, octaspire_string_remove_all_substrings(str, substring));

    ASSERT_STR_EQ(
        " cat  dog  zebra ",
        octaspire_string_get_c_string(str));

    octaspire_string_release(substring);
    substring = 0;

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_insert_string_to_bc_into_index_1_of_ade_test(void)
{
    octaspire_string_t *strTarget = octaspire_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *strAddition =
        octaspire_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_string_insert_string_to(strTarget, strAddition, 1));

    ASSERT_EQ(5, octaspire_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "abcde",
        octaspire_string_get_c_string(strTarget));

    octaspire_string_release(strAddition);
    strAddition = 0;

    octaspire_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_string_insert_string_to_bc_into_index_minus_1_of_ade_test(void)
{
    octaspire_string_t *strTarget = octaspire_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *strAddition =
        octaspire_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_string_insert_string_to(strTarget, strAddition, -1));

    ASSERT_EQ(5, octaspire_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "adbce",
        octaspire_string_get_c_string(strTarget));

    octaspire_string_release(strAddition);
    strAddition = 0;

    octaspire_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_string_insert_string_to_bc_into_index_minus_3_of_ade_test(void)
{
    octaspire_string_t *strTarget = octaspire_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *strAddition =
        octaspire_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_string_insert_string_to(strTarget, strAddition, -3));

    ASSERT_EQ(5, octaspire_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "bcade",
        octaspire_string_get_c_string(strTarget));

    octaspire_string_release(strAddition);
    strAddition = 0;

    octaspire_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_string_insert_string_to_bc_into_index_minus_4_of_ade_failure_test(void)
{
    octaspire_string_t *strTarget = octaspire_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *strAddition =
        octaspire_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT_FALSE(octaspire_string_insert_string_to(strTarget, strAddition, -4));

    ASSERT_EQ(3, octaspire_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "ade",
        octaspire_string_get_c_string(strTarget));

    octaspire_string_release(strAddition);
    strAddition = 0;

    octaspire_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_string_insert_string_to_bc_into_index_3_of_ade_failure_test(void)
{
    octaspire_string_t *strTarget = octaspire_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *strAddition =
        octaspire_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT_FALSE(octaspire_string_insert_string_to(strTarget, strAddition, 3));

    ASSERT_EQ(3, octaspire_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "ade",
        octaspire_string_get_c_string(strTarget));

    octaspire_string_release(strAddition);
    strAddition = 0;

    octaspire_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_string_insert_string_to_bc_into_index_0_of_ade_test(void)
{
    octaspire_string_t *strTarget = octaspire_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *strAddition =
        octaspire_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_string_insert_string_to(strTarget, strAddition, 0));

    ASSERT_EQ(5, octaspire_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "bcade",
        octaspire_string_get_c_string(strTarget));

    octaspire_string_release(strAddition);
    strAddition = 0;

    octaspire_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_string_insert_string_to_bc_into_index_2_of_ade_test(void)
{
    octaspire_string_t *strTarget = octaspire_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *strAddition =
        octaspire_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_string_insert_string_to(strTarget, strAddition, 2));

    ASSERT_EQ(5, octaspire_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "adbce",
        octaspire_string_get_c_string(strTarget));

    octaspire_string_release(strAddition);
    strAddition = 0;

    octaspire_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_string_overwrite_with_string_at_first_test(void)
{
    octaspire_string_t *strTarget = octaspire_string_new(
            "",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *strAddition =
        octaspire_string_new("ab",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_string_overwrite_with_string_at(strTarget, strAddition, 0));
    ASSERT_EQ(3, octaspire_string_get_length_in_ucs_characters(strTarget));
    ASSERT_EQ(4, octaspire_string_get_length_in_octets(strTarget));
    ASSERT_STR_EQ(
        "ab",
        octaspire_string_get_c_string(strTarget));

    octaspire_string_release(strAddition);
    strAddition = 0;

    strAddition = octaspire_string_new("q",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_string_overwrite_with_string_at(strTarget, strAddition, 1));
    ASSERT_EQ(3, octaspire_string_get_length_in_ucs_characters(strTarget));
    ASSERT_EQ(4, octaspire_string_get_length_in_octets(strTarget));
    ASSERT_STR_EQ(
        "aq",
        octaspire_string_get_c_string(strTarget));

    octaspire_string_release(strAddition);
    strAddition = 0;

    octaspire_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_string_overwrite_with_string_at_second_test(void)
{
    octaspire_string_t *strTarget = octaspire_string_new(
            "abc",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *strAddition =
        octaspire_string_new("",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_string_overwrite_with_string_at(strTarget, strAddition, 1));
    ASSERT_EQ(3, octaspire_string_get_length_in_ucs_characters(strTarget));
    ASSERT_EQ(4, octaspire_string_get_length_in_octets(strTarget));
    ASSERT_STR_EQ(
        "ac",
        octaspire_string_get_c_string(strTarget));

    octaspire_string_release(strAddition);
    strAddition = 0;

    octaspire_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_string_overwrite_with_string_at_called_with_negative_index_test(void)
{
    octaspire_string_t *strTarget = octaspire_string_new(
            "abc",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *strAddition =
        octaspire_string_new(
            "",
            octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_string_overwrite_with_string_at(
            strTarget,
            strAddition,
            -2));

    ASSERT_EQ(3, octaspire_string_get_length_in_ucs_characters(strTarget));
    ASSERT_EQ(4, octaspire_string_get_length_in_octets(strTarget));
    ASSERT_STR_EQ(
        "ac",
        octaspire_string_get_c_string(strTarget));

    octaspire_string_release(strAddition);
    strAddition = 0;

    octaspire_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_string_pop_front_ucs_character_test(void)
{
    octaspire_string_t *str = octaspire_string_new(
        "abc",
        octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);
    ASSERT_EQ(3, octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("abc", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_pop_front_ucs_character(str));
    ASSERT_EQ(2, octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("bc", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_pop_front_ucs_character(str));
    ASSERT_EQ(1, octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("c", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_pop_front_ucs_character(str));
    ASSERT_EQ(0, octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("", octaspire_string_get_c_string(str));

    for (size_t i = 0; i < 10; ++i)
    {
        ASSERT_FALSE(octaspire_string_pop_front_ucs_character(str));
        ASSERT_EQ(0, octaspire_string_get_length_in_ucs_characters(str));
        ASSERT_STR_EQ("", octaspire_string_get_c_string(str));
    }

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_pop_back_ucs_character_test(void)
{
    octaspire_string_t *str = octaspire_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);
    ASSERT_EQ(3, octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("abc", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_pop_back_ucs_character(str));
    ASSERT_EQ(2, octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("ab", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_pop_back_ucs_character(str));
    ASSERT_EQ(1, octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(str));

    ASSERT(octaspire_string_pop_back_ucs_character(str));
    ASSERT_EQ(0, octaspire_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("", octaspire_string_get_c_string(str));

    for (size_t i = 0; i < 10; ++i)
    {
        ASSERT_FALSE(octaspire_string_pop_back_ucs_character(str));
        ASSERT_EQ(0, octaspire_string_get_length_in_ucs_characters(str));
        ASSERT_STR_EQ("", octaspire_string_get_c_string(str));
    }

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_compare_with_two_empty_strings_test(void)
{
    octaspire_string_t *str1 =
        octaspire_string_new("", octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *str2 =
        octaspire_string_new("", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT_EQ(0, octaspire_string_compare(str1, str2));

    octaspire_string_release(str1);
    str1 = 0;

    octaspire_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_string_compare_with_abc_and_empty_string_test(void)
{
    octaspire_string_t *str1 =
        octaspire_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *str2 =
        octaspire_string_new("", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(octaspire_string_compare(str1, str2) > 0);

    octaspire_string_release(str1);
    str1 = 0;

    octaspire_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_string_compare_with_empty_string_and_abc_test(void)
{
    octaspire_string_t *str1 =
        octaspire_string_new("", octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *str2 =
        octaspire_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(octaspire_string_compare(str1, str2) < 0);

    octaspire_string_release(str1);
    str1 = 0;

    octaspire_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_string_compare_with_string_abc_and_abc_test(void)
{
    octaspire_string_t *str1 =
        octaspire_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *str2 =
        octaspire_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT_EQ(0, octaspire_string_compare(str1, str2));

    octaspire_string_release(str1);
    str1 = 0;

    octaspire_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_string_compare_with_string_abd_and_abc_test(void)
{
    octaspire_string_t *str1 =
        octaspire_string_new("abd", octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *str2 =
        octaspire_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(octaspire_string_compare(str1, str2) > 0);

    octaspire_string_release(str1);
    str1 = 0;

    octaspire_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_string_compare_with_string_abca_and_abc_test(void)
{
    octaspire_string_t *str1 =
        octaspire_string_new("abca", octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *str2 =
        octaspire_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(octaspire_string_compare(str1, str2) > 0);

    octaspire_string_release(str1);
    str1 = 0;

    octaspire_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_string_compare_with_string_abb_and_abc_test(void)
{
    octaspire_string_t *str1 =
        octaspire_string_new("abb", octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *str2 =
        octaspire_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(octaspire_string_compare(str1, str2) < 0);

    octaspire_string_release(str1);
    str1 = 0;

    octaspire_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_string_compare_with_string_abc_and_abca_test(void)
{
    octaspire_string_t *str =
        octaspire_string_new(
            "",
            octaspireContainerUtf8StringTestAllocator);

    for (ptrdiff_t i = -64; i < 64; ++i)
    {
        ASSERT_FALSE(octaspire_string_is_index_valid(str, i));
    }

    octaspire_string_concatenate_c_string(str, "a");

    for (ptrdiff_t i = -64; i < 64; ++i)
    {
        ASSERT_EQ(
            i== -1 || i == 0,
            octaspire_string_is_index_valid(str, i));
    }

    octaspire_string_concatenate_c_string(str, "b");

    for (ptrdiff_t i = -64; i < 64; ++i)
    {
        ASSERT_EQ(
            i == -1 || i == -2 || i == 0 || i == 1,
            octaspire_string_is_index_valid(str, i));
    }

    ASSERT(str);

    octaspire_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_string_is_index_valid_test(void)
{
    octaspire_string_t *str1 =
        octaspire_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *str2 =
        octaspire_string_new("abca", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(octaspire_string_compare(str1, str2) < 0);

    octaspire_string_release(str1);
    str1 = 0;

    octaspire_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_string_set_from_c_string_test(void)
{
    octaspire_string_t *str1 = octaspire_string_new(
        "",
        octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *str2 = octaspire_string_new(
        "ab",
        octaspireContainerUtf8StringTestAllocator);

    octaspire_string_t *str3 = octaspire_string_new(
        "abc",
        octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(str3);

    char const * const expected = "xy";

    ASSERT(octaspire_string_set_from_c_string(str1, expected));
    ASSERT(octaspire_string_set_from_c_string(str2, expected));
    ASSERT(octaspire_string_set_from_c_string(str3, expected));

    ASSERT(octaspire_string_compare_to_c_string(str1, expected) == 0);
    ASSERT(octaspire_string_compare_to_c_string(str2, expected) == 0);
    ASSERT(octaspire_string_compare_to_c_string(str3, expected) == 0);

    ASSERT_STR_EQ(expected, octaspire_string_get_c_string(str1));
    ASSERT_STR_EQ(expected, octaspire_string_get_c_string(str2));
    ASSERT_STR_EQ(expected, octaspire_string_get_c_string(str3));

    octaspire_string_release(str1);
    str1 = 0;

    octaspire_string_release(str2);
    str2 = 0;

    octaspire_string_release(str3);
    str3 = 0;

    PASS();
}

TEST octaspire_string_set_from_c_string_allocation_failure_on_first_allocation_test(void)
{
    char const * const expected = "abc";

    octaspire_string_t *str = octaspire_string_new(
        expected,
        octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerUtf8StringTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerUtf8StringTestAllocator));

    ASSERT_FALSE(octaspire_string_set_from_c_string(str, "xy"));

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    octaspire_string_release(str);
    str = 0;

    PASS();
}

GREATEST_SUITE(octaspire_string_suite)
{
    octaspireContainerUtf8StringTestAllocator = octaspire_allocator_new(0);

    assert(octaspireContainerUtf8StringTestAllocator);

    RUN_TEST(octaspire_string_new_called_with_null_argument_test);
    RUN_TEST(octaspire_string_new_with_simple_ascii_string_test);
    RUN_TEST(octaspire_string_new_with_some_multioctet_ucs_characters_test);
    RUN_TEST(octaspire_string_new_with_simple_ascii_string_with_error_test);
    RUN_TEST(octaspire_string_new_from_buffer_with_some_multioctet_ucs_characters_test);
    RUN_TEST(octaspire_string_new_from_buffer_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_string_new_from_buffer_allocation_failure_on_second_allocation_test);
    RUN_TEST(octaspire_string_new_from_buffer_allocation_failure_on_third_allocation_test);



    RUN_TEST(octaspire_string_new_from_buffer_allocation_failure_on_sixth_2_allocation_test);
    RUN_TEST(octaspire_string_new_format_with_string_test);
    RUN_TEST(octaspire_string_new_format_with_size_t_test);
    RUN_TEST(octaspire_string_new_format_with_doubles_test);
    RUN_TEST(octaspire_string_new_format_with_string_and_size_t_test);
    RUN_TEST(octaspire_string_new_format_with_string_and_size_t_on_otherwise_empty_format_string_test);
    RUN_TEST(octaspire_string_new_format_with_empty_format_string_test);
    RUN_TEST(octaspire_string_new_copy_test);
    RUN_TEST(octaspire_string_new_copy_failure_test);
    RUN_TEST(octaspire_string_get_length_in_ucs_characters_test);
    RUN_TEST(octaspire_string_get_length_in_ucs_characters_called_with_empty_string_test);
    RUN_TEST(octaspire_string_get_length_in_octets_test);
    RUN_TEST(octaspire_string_get_length_in_octets_called_with_empty_string_test);
    RUN_TEST(octaspire_string_get_ucs_character_at_index_test);
    RUN_TEST(octaspire_string_get_c_string_test);
    RUN_TEST(octaspire_string_get_c_string_called_with_empty_string_test);
    RUN_TEST(octaspire_string_is_error_false_case_test);
    RUN_TEST(octaspire_string_is_error_true_case_test);
    RUN_TEST(octaspire_string_get_error_position_in_octets_called_when_has_error_test);
    RUN_TEST(octaspire_string_get_error_position_in_octets_called_when_has_no_error_test);
    RUN_TEST(octaspire_string_reset_error_status_called_when_there_is_error_test);
    RUN_TEST(octaspire_string_reset_error_status_called_when_there_is_no_error_test);
    RUN_TEST(octaspire_string_concatenate_c_string_called_with_null_and_empty_string_arguments_test);
    RUN_TEST(octaspire_string_concatenate_c_string_test);
    RUN_TEST(octaspire_string_concatenate_c_string_with_decode_error_test);
    RUN_TEST(octaspire_string_concatenate_c_string_allocation_failure_one_test);
    RUN_TEST(octaspire_string_concatenate_c_string_allocation_failure_two_test);
    RUN_TEST(octaspire_string_c_strings_end_always_in_null_byte_test);
    RUN_TEST(octaspire_string_new_format_numbers_into_vector_test);
    RUN_TEST(octaspire_string_new_format_number_test);
    RUN_TEST(octaspire_string_find_char_a_from_string_a123a56a89a_using_negative_indice_test);
    RUN_TEST(octaspire_string_find_char_a_from_string_a123a56a89a_using_index_zero_test);
    RUN_TEST(octaspire_string_find_char_q_from_string_a123a56q89q_using_index_one_test);
    RUN_TEST(octaspire_string_find_char_c_from_string_a123c56q89q_using_index_two_test);
    RUN_TEST(octaspire_string_find_char_c_from_string_a123y56q89q_using_index_two_failure_test);
    RUN_TEST(octaspire_string_find_string_Xcat_from_string_cat_dog_cat_zebra_car_kitten_cat_using_index_minus_3_and_length_of_3_test);
    RUN_TEST(octaspire_string_find_string_cat_from_string_cat_dog_cat_zebra_car_kitten_cat_using_index_zero_and_length_of_3_test);
    RUN_TEST(octaspire_string_find_string_cat_from_string_cat_dog_cat_zebra_car_kitten_cat_using_index_one_and_length_of_3_test);
    RUN_TEST(octaspire_string_find_string_dog_from_string_dog_cat_zebra_using_index_zero_and_length_of_three_test);
    RUN_TEST(octaspire_string_find_string_dog_from_string_cat_zebra_dog_using_index_zero_and_length_of_three_test);
    RUN_TEST(octaspire_string_find_string_dog_from_string_cat_zebra_kitten_using_index_zero_and_length_of_three_test);
    RUN_TEST(octaspire_string_find_string_kitten_from_string_cat_using_index_zero_and_length_of_six_failure_test);
    RUN_TEST(octaspire_string_private_check_substring_match_at_middle_test);
    RUN_TEST(octaspire_string_private_check_substring_match_at_the_beginning_test);
    RUN_TEST(octaspire_string_private_check_substring_match_at_the_end_test);
    RUN_TEST(octaspire_string_find_first_substring_abc_from_123abc456abc_starting_from_index_0_test);
    RUN_TEST(octaspire_string_find_first_substring_abc_from_123abc456abc_starting_from_index_minus_three_test);
    RUN_TEST(octaspire_string_find_first_substring_abc_from_123abc456abc_starting_from_index_4_test);
    RUN_TEST(octaspire_string_find_first_substring_abcd_from_123abc456abc_starting_from_index_0_failure_test);
    RUN_TEST(octaspire_string_remove_character_at_test);
    RUN_TEST(octaspire_string_remove_character_at_called_on_string_with_two_os_with_diaeresis_test);
    RUN_TEST(octaspire_string_remove_characters_at_test);
    RUN_TEST(octaspire_string_remove_all_substrings_kitten_from_string_kitten_cat_kitten_dog_kitten_zebra_kitten_test);
    RUN_TEST(octaspire_string_insert_string_to_bc_into_index_1_of_ade_test);
    RUN_TEST(octaspire_string_insert_string_to_bc_into_index_minus_1_of_ade_test);
    RUN_TEST(octaspire_string_insert_string_to_bc_into_index_minus_3_of_ade_test);
    RUN_TEST(octaspire_string_insert_string_to_bc_into_index_minus_4_of_ade_failure_test);
    RUN_TEST(octaspire_string_insert_string_to_bc_into_index_3_of_ade_failure_test);
    RUN_TEST(octaspire_string_insert_string_to_bc_into_index_0_of_ade_test);
    RUN_TEST(octaspire_string_insert_string_to_bc_into_index_2_of_ade_test);

    RUN_TEST(octaspire_string_overwrite_with_string_at_first_test);
    RUN_TEST(octaspire_string_overwrite_with_string_at_second_test);
    RUN_TEST(octaspire_string_overwrite_with_string_at_called_with_negative_index_test);

    RUN_TEST(octaspire_string_pop_front_ucs_character_test);
    RUN_TEST(octaspire_string_pop_back_ucs_character_test);

    RUN_TEST(octaspire_string_compare_with_two_empty_strings_test);
    RUN_TEST(octaspire_string_compare_with_abc_and_empty_string_test);
    RUN_TEST(octaspire_string_compare_with_empty_string_and_abc_test);
    RUN_TEST(octaspire_string_compare_with_string_abc_and_abc_test);
    RUN_TEST(octaspire_string_compare_with_string_abd_and_abc_test);
    RUN_TEST(octaspire_string_compare_with_string_abca_and_abc_test);
    RUN_TEST(octaspire_string_compare_with_string_abb_and_abc_test);
    RUN_TEST(octaspire_string_compare_with_string_abc_and_abca_test);

    RUN_TEST(octaspire_string_is_index_valid_test);

    RUN_TEST(octaspire_string_set_from_c_string_test);
    RUN_TEST(octaspire_string_set_from_c_string_allocation_failure_on_first_allocation_test);

    octaspire_allocator_release(octaspireContainerUtf8StringTestAllocator);
    octaspireContainerUtf8StringTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_string.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_pair.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireContainerPairTestAllocator = 0;

TEST octaspire_pair_new_short_and_long_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    ASSERT(p->first);
    ASSERT(p->second);

    ASSERT_EQ(0, *(short const*)p->first);
    ASSERT_EQ(0, *(long const*)p->second);

    ASSERT_EQ(sizeof(short), p->firstSize);
    ASSERT_EQ(sizeof(long),  p->secondSize);
    ASSERT_EQ(0,             p->firstReleaseCallback);
    ASSERT_EQ(0,             p->secondReleaseCallback);
    ASSERT_EQ(octaspireContainerPairTestAllocator,     p->allocator);

    short const expectedFirst  = 11;
    long  const expectedSecond = 12;
    octaspire_pair_set(p, &expectedFirst, &expectedSecond);

    ASSERT_EQ(expectedFirst,  *(short const *)p->first);
    ASSERT_EQ(expectedSecond, *(long const *) p->second);

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_new_long_and_short_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    ASSERT(p->first);
    ASSERT(p->second);

    ASSERT_EQ(0, *(long const*)p->first);
    ASSERT_EQ(0, *(short const*)p->second);

    ASSERT_EQ(sizeof(long), p->firstSize);
    ASSERT_EQ(sizeof(short),  p->secondSize);
    ASSERT_EQ(0,             p->firstReleaseCallback);
    ASSERT_EQ(0,             p->secondReleaseCallback);
    ASSERT_EQ(octaspireContainerPairTestAllocator,     p->allocator);

    long  const expectedFirst  = 11;
    short const expectedSecond = 12;
    octaspire_pair_set(p, &expectedFirst, &expectedSecond);

    ASSERT_EQ(expectedFirst,  *(long const*) p->first);
    ASSERT_EQ(expectedSecond, *(short const*)p->second);

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_new_uint32_t_and_double_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(uint32_t),
        false,
        sizeof(double),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    ASSERT(p->first);
    ASSERT(p->second);

    ASSERT_IN_RANGE(0, *(uint32_t*)p->first, 0.000001);
    ASSERT_IN_RANGE(0, *(double*)p->second,  0.000001);

    ASSERT_EQ(sizeof(uint32_t), p->firstSize);
    ASSERT_EQ(sizeof(double),   p->secondSize);
    ASSERT_EQ(0,                p->firstReleaseCallback);
    ASSERT_EQ(0,                p->secondReleaseCallback);
    ASSERT_EQ(octaspireContainerPairTestAllocator,        p->allocator);

    uint32_t  const expectedFirst  = 11;
    double    const expectedSecond = 12.12;
    octaspire_pair_set(p, &expectedFirst, &expectedSecond);

    ASSERT_EQ(expectedFirst,  *(uint32_t const*)p->first);
    ASSERT_IN_RANGE(expectedSecond, *(double const*)p->second, 0.000001);

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_new_allocation_failure_on_first_allocation_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerPairTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerPairTestAllocator));

    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerPairTestAllocator, 0, 0x00);

    ASSERT_FALSE(p);

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_new_allocation_failure_on_second_allocation_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerPairTestAllocator,
        2,
        0x01);

    ASSERT_EQ(
        2,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerPairTestAllocator));

    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerPairTestAllocator, 0, 0x00);

    ASSERT_FALSE(p);

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_new_allocation_failure_on_third_allocation_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerPairTestAllocator,
        3,
        0x03);

    ASSERT_EQ(
        3,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerPairTestAllocator));

    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerPairTestAllocator, 0, 0x00);

    ASSERT_FALSE(p);

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_new_shallow_copy_uint32_t_and_double_test(void)
{
    octaspire_pair_t *expected = octaspire_pair_new(
        sizeof(uint32_t),
        false,
        sizeof(double),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(expected);

    uint32_t  const expectedFirst  = 11;
    double    const expectedSecond = 12.12;
    octaspire_pair_set(expected, &expectedFirst, &expectedSecond);

    octaspire_pair_t *p = octaspire_pair_new_shallow_copy(
        expected,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    ASSERT(p->first);
    ASSERT(p->second);

    ASSERT_EQ(*(uint32_t const*)expected->first,  *(uint32_t const*)p->first);
    ASSERT_IN_RANGE(*(double const*)expected->second, *(double const*)p->second, 0.000001);

    ASSERT_EQ(sizeof(uint32_t), p->firstSize);
    ASSERT_EQ(sizeof(double),   p->secondSize);
    ASSERT_EQ(0,                p->firstReleaseCallback);
    ASSERT_EQ(0,                p->secondReleaseCallback);
    ASSERT_EQ(octaspireContainerPairTestAllocator,        p->allocator);

    octaspire_pair_release(p);
    p = 0;

    octaspire_pair_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_pair_new_shallow_copy_failure_on_first_allocation_test(void)
{
    octaspire_pair_t *expected = octaspire_pair_new(
        sizeof(uint32_t),
        false,
        sizeof(double),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(expected);

    uint32_t  const expectedFirst  = 11;
    double    const expectedSecond = 12.12;
    octaspire_pair_set(expected, &expectedFirst, &expectedSecond);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerPairTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerPairTestAllocator));

    octaspire_pair_t *p = octaspire_pair_new_shallow_copy(
        expected,
        octaspireContainerPairTestAllocator);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerPairTestAllocator, 0, 0x00);

    ASSERT_FALSE(p);

    octaspire_pair_release(p);
    p = 0;

    octaspire_pair_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_pair_new_shallow_copy_failure_on_second_allocation_test(void)
{
    octaspire_pair_t *expected = octaspire_pair_new(
        sizeof(uint32_t),
        false,
        sizeof(double),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(expected);

    uint32_t  const expectedFirst  = 11;
    double    const expectedSecond = 12.12;
    octaspire_pair_set(expected, &expectedFirst, &expectedSecond);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerPairTestAllocator,
        2,
        0x1);

    ASSERT_EQ(
        2,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerPairTestAllocator));

    octaspire_pair_t *p = octaspire_pair_new_shallow_copy(
        expected,
        octaspireContainerPairTestAllocator);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerPairTestAllocator, 0, 0x00);

    ASSERT_FALSE(p);

    octaspire_pair_release(p);
    p = 0;

    octaspire_pair_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_pair_new_shallow_copy_failure_on_third_allocation_test(void)
{
    octaspire_pair_t *expected = octaspire_pair_new(
        sizeof(uint32_t),
        false,
        sizeof(double),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(expected);

    uint32_t  const expectedFirst  = 11;
    double    const expectedSecond = 12.12;
    octaspire_pair_set(expected, &expectedFirst, &expectedSecond);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerPairTestAllocator,
        3,
        0x3);

    ASSERT_EQ(
        3,
        octaspire_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerPairTestAllocator));

    octaspire_pair_t *p = octaspire_pair_new_shallow_copy(
        expected,
        octaspireContainerPairTestAllocator);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerPairTestAllocator, 0, 0x00);

    ASSERT_FALSE(p);

    octaspire_pair_release(p);
    p = 0;

    octaspire_pair_release(expected);
    expected = 0;

    PASS();
}

static size_t octaspire_pair_release_test_private_release_callback_for_first_callcount = 0;

static void octaspire_pair_release_test_private_release_callback_for_first(void *element)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(element);
    ++octaspire_pair_release_test_private_release_callback_for_first_callcount;
}

static size_t octaspire_pair_release_test_private_release_callback_for_second_callcount = 0;

static void octaspire_pair_release_test_private_release_callback_for_second(void *element)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(element);
    ++octaspire_pair_release_test_private_release_callback_for_second_callcount;
}

TEST octaspire_pair_release_test(void)
{
    octaspire_pair_release_test_private_release_callback_for_first_callcount  = 0;
    octaspire_pair_release_test_private_release_callback_for_second_callcount = 0;

    octaspire_string_t *second = octaspire_string_new(
        "second element of the pair in octaspire_pair_release_test",
        octaspireContainerPairTestAllocator);

    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(size_t),
        false,
        sizeof(octaspire_string_t*),
        true,
        octaspire_pair_release_test_private_release_callback_for_first,
        octaspire_pair_release_test_private_release_callback_for_second,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    size_t const first  = 11;
    octaspire_pair_set(p, &first, &second);

    ASSERT_EQ(first,  *(size_t const *)p->first);
    ASSERT_EQ(second, *(octaspire_string_t **)p->second);

    octaspire_pair_release(p);
    p = 0;

    octaspire_string_release(second);
    second = 0;

    ASSERT_EQ(1, octaspire_pair_release_test_private_release_callback_for_first_callcount);
    ASSERT_EQ(1, octaspire_pair_release_test_private_release_callback_for_second_callcount);

    PASS();
}

TEST octaspire_pair_get_first_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    long  const expectedFirst = -11;
    short const second        =  12;
    octaspire_pair_set(p, &expectedFirst, &second);

    ASSERT_EQ(expectedFirst, *(long const*)octaspire_pair_get_first(p));

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_get_first_const_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    long  const expectedFirst = -11;
    short const second        =  12;
    octaspire_pair_set(p, &expectedFirst, &second);

    ASSERT_EQ(expectedFirst, *(long const*)octaspire_pair_get_first_const(p));

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_get_second_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    long  const first           =  11;
    short const expectedSecond  = -12;
    octaspire_pair_set(p, &first, &expectedSecond);

    ASSERT_EQ(expectedSecond, *(short const*)octaspire_pair_get_second(p));

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_get_second_const_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    long  const first           =  11;
    short const expectedSecond  = -12;
    octaspire_pair_set(p, &first, &expectedSecond);

    ASSERT_EQ(expectedSecond, *(short const*)octaspire_pair_get_second_const(p));

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_get_size_of_first_element_in_octets_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    ASSERT_EQ(sizeof(long), octaspire_pair_get_size_of_first_element_in_octets(p));

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_get_size_of_second_element_in_octets_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    ASSERT_EQ(sizeof(short), octaspire_pair_get_size_of_second_element_in_octets(p));

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_set_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    short const expectedFirst  = 11;
    long  const expectedSecond = 12;
    octaspire_pair_set(p, &expectedFirst, &expectedSecond);

    ASSERT_EQ(expectedFirst,  *(short const *)p->first);
    ASSERT_EQ(expectedSecond, *(long const *) p->second);

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_set_first_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    short const expectedFirst  = 11;
    long  const expectedSecond = 0;
    octaspire_pair_set_first(p, &expectedFirst);

    ASSERT_EQ(expectedFirst,  *(short const *)p->first);
    ASSERT_EQ(expectedSecond, *(long const *) p->second);

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_set_second_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    short const expectedFirst  = 0;
    long  const expectedSecond = 11;
    octaspire_pair_set_second(p, &expectedSecond);

    ASSERT_EQ(expectedFirst,  *(short const *)p->first);
    ASSERT_EQ(expectedSecond, *(long const *) p->second);

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_set_first_to_void_pointer_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(void*),
        true,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    void *expectedFirst = p;
    long  const expectedSecond = 0;
    ASSERT(octaspire_pair_set_first_to_void_pointer(p, expectedFirst));

    ASSERT_EQ(expectedFirst,  *(void **)p->first);
    ASSERT_EQ(expectedSecond, *(long const *)p->second);

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_set_first_to_void_pointer_failure_on_element_size_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(char),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    void *ptr = 0;
    ASSERT_FALSE(octaspire_pair_set_first_to_void_pointer(p, ptr));

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_set_second_to_void_pointer_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(long),
        false,
        sizeof(void*),
        true,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    void *expectedSecond = p;
    long  const expectedFirst = 0;
    ASSERT(octaspire_pair_set_second_to_void_pointer(p, expectedSecond));

    ASSERT_EQ(expectedFirst,  *(long const *)p->first);
    ASSERT_EQ(expectedSecond, *(void const **)p->second);

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_set_second_to_void_pointer_failure_on_element_size_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(long),
        false,
        sizeof(char),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    void *ptr = 0;
    ASSERT_FALSE(octaspire_pair_set_second_to_void_pointer(p, ptr));

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_pair_clear_test(void)
{
    octaspire_pair_t *p = octaspire_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    short const expectedFirst  = 11;
    long  const expectedSecond = 12;
    octaspire_pair_set(p, &expectedFirst, &expectedSecond);

    ASSERT_EQ(11, *(short const*)p->first);
    ASSERT_EQ(12, *(long const*)p->second);

    octaspire_pair_clear(p);

    ASSERT_EQ(0, *(short const*)p->first);
    ASSERT_EQ(0, *(long const*)p->second);

    octaspire_pair_release(p);
    p = 0;

    PASS();
}

GREATEST_SUITE(octaspire_pair_suite)
{
    octaspireContainerPairTestAllocator = octaspire_allocator_new(0);
    assert(octaspireContainerPairTestAllocator);

    RUN_TEST(octaspire_pair_new_short_and_long_test);
    RUN_TEST(octaspire_pair_new_long_and_short_test);
    RUN_TEST(octaspire_pair_new_uint32_t_and_double_test);
    RUN_TEST(octaspire_pair_new_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_pair_new_allocation_failure_on_second_allocation_test);
    RUN_TEST(octaspire_pair_new_allocation_failure_on_third_allocation_test);
    RUN_TEST(octaspire_pair_new_shallow_copy_uint32_t_and_double_test);
    RUN_TEST(octaspire_pair_new_shallow_copy_failure_on_first_allocation_test);
    RUN_TEST(octaspire_pair_new_shallow_copy_failure_on_second_allocation_test);
    RUN_TEST(octaspire_pair_new_shallow_copy_failure_on_third_allocation_test);
    RUN_TEST(octaspire_pair_release_test);
    RUN_TEST(octaspire_pair_get_first_test);
    RUN_TEST(octaspire_pair_get_first_const_test);
    RUN_TEST(octaspire_pair_get_second_test);
    RUN_TEST(octaspire_pair_get_second_const_test);
    RUN_TEST(octaspire_pair_get_size_of_first_element_in_octets_test);
    RUN_TEST(octaspire_pair_get_size_of_second_element_in_octets_test);
    RUN_TEST(octaspire_pair_set_test);
    RUN_TEST(octaspire_pair_set_first_test);
    RUN_TEST(octaspire_pair_set_second_test);
    RUN_TEST(octaspire_pair_set_first_to_void_pointer_test);
    RUN_TEST(octaspire_pair_set_first_to_void_pointer_failure_on_element_size_test);
    RUN_TEST(octaspire_pair_set_second_to_void_pointer_test);
    RUN_TEST(octaspire_pair_set_second_to_void_pointer_failure_on_element_size_test);
    RUN_TEST(octaspire_pair_clear_test);

    octaspire_allocator_release(octaspireContainerPairTestAllocator);
    octaspireContainerPairTestAllocator = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_pair.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_map.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireContainerHashMapTestAllocator = 0;



TEST octaspire_map_element_new_allocation_failure_on_first_allocation_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator));

    size_t const value = 0;
    octaspire_map_element_t *element = octaspire_map_element_new(
        0,
        sizeof(value),
        false,
        &value,
        sizeof(value),
        false,
        &value,
        octaspireContainerHashMapTestAllocator);

    ASSERT_FALSE(element);
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 0, 0x00);

    octaspire_map_element_release(element);
    element = 0;

    PASS();
}

TEST octaspire_map_element_new_allocation_failure_on_second_allocation_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator));

    size_t const value = 0;
    octaspire_map_element_t *element = octaspire_map_element_new(
        0,
        sizeof(value),
        false,
        &value,
        sizeof(value),
        false,
        &value,
        octaspireContainerHashMapTestAllocator);

    ASSERT_FALSE(element);
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 0, 0x00);

    octaspire_map_element_release(element);
    element = 0;

    PASS();
}

TEST octaspire_map_element_new_allocation_failure_on_third_allocation_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 3, 0x03);
    ASSERT_EQ(3, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator));

    size_t const value = 0;
    octaspire_map_element_t *element = octaspire_map_element_new(
        0,
        sizeof(value),
        false,
        &value,
        sizeof(value),
        false,
        &value,
        octaspireContainerHashMapTestAllocator);

    ASSERT_FALSE(element);
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 0, 0x00);

    octaspire_map_element_release(element);
    element = 0;

    PASS();
}

static bool octaspire_map_new_test_key_compare_function_for_size_t_keys(
    void const * const key1,
    void const * const key2);

static uint32_t octaspire_map_new_test_key_hash_function_for_size_t_keys(
    void const * const key);

static bool octaspire_map_new_test_key_compare_function_for_size_t_keys(
    void const * const key1,
    void const * const key2)
{
    return *(size_t const * const)key1 == *(size_t const * const)key2;
}

static uint32_t octaspire_map_new_test_key_hash_function_for_size_t_keys(
    void const * const key)
{
    size_t const value = *(size_t const * const)key;
    return (uint32_t)value;
}

TEST octaspire_map_private_rehash_allocation_failure_on_first_allocation_test(void)
{
    octaspire_map_t *hashMap = octaspire_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT(hashMap);

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 1, 0x00);
    ASSERT_EQ(1, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator));

    ASSERT_FALSE(octaspire_map_private_rehash(hashMap));
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 0, 0x00);

    octaspire_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_map_new_keys_uint32_t_and_values_size_t_test(void)
{
    octaspire_map_t *hashMap = octaspire_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT(hashMap);

    size_t const numElements = 128;

    for (size_t i = 0; i < numElements; ++i)
    {
        uint32_t hash = (uint32_t)i;

        octaspire_map_put(hashMap, hash, &i, &i);
    }

    ASSERT_EQ(numElements, octaspire_map_get_number_of_elements(hashMap));

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_map_element_t *element =
            octaspire_map_get(hashMap, (uint32_t)i, &i);

        ASSERT_EQ(i,   octaspire_map_element_get_hash(element));
        ASSERT_EQ(i,   *(size_t*)octaspire_map_element_get_key(element));
        ASSERT_EQ(i,   *(size_t*)octaspire_map_element_get_value(element));
    }

    octaspire_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_map_add_same_key_many_times_test(void)
{
    octaspire_map_t *hashMap = octaspire_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT(hashMap);

    size_t const key = 1024;

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT(octaspire_map_put(
            hashMap,
            octaspire_helpers_calculate_hash_for_size_t_argument(key),
            &key,
            &i));

        octaspire_map_element_t * const element = octaspire_map_get(
            hashMap,
            octaspire_helpers_calculate_hash_for_size_t_argument(key),
            &key);

        ASSERT(element);

        ASSERT_EQ(key, *(size_t*)octaspire_map_element_get_key(element));

        octaspire_vector_t * const values =
            octaspire_map_element_get_values(element);

        ASSERT_EQ(i + 1,   octaspire_vector_get_length(values));

        for (size_t j = 0; j < octaspire_vector_get_length(values) ; ++j)
        {
            ASSERT_EQ(
                j,
                *(size_t*)octaspire_vector_get_element_at(
                    values,
                    (ptrdiff_t)j));
        }
    }

    octaspire_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_map_new_allocation_failure_on_first_allocation_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator));

    octaspire_map_t *hashMap = octaspire_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT_FALSE(hashMap);
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 0, 0x00);

    octaspire_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_map_new_allocation_failure_on_second_allocation_test(void)
{
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator));

    octaspire_map_t *hashMap = octaspire_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT_FALSE(hashMap);
    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 0, 0x00);

    octaspire_map_release(hashMap);
    hashMap = 0;

    PASS();
}

static bool octaspire_map_new_test_key_compare_function_for_ostring_t_keys(
    void const * const key1,
    void const * const key2);

static uint32_t octaspire_map_new_test_key_hash_function_for_ostring_t_keys(
    void const * const key);

static bool octaspire_map_new_test_key_compare_function_for_ostring_t_keys(
    void const * const key1,
    void const * const key2)
{
    assert(key1);
    assert(key2);

    return octaspire_string_is_equal(
        (octaspire_string_t const * const)key1,
        (octaspire_string_t const * const)key2);
}

static uint32_t octaspire_map_new_test_key_hash_function_for_ostring_t_keys(
    void const * const key)
{
    assert(key);
    return octaspire_string_get_hash((octaspire_string_t const * const)key);
}

TEST octaspire_map_new_keys_ostring_t_and_values_ostring_t_test(void)
{
    octaspire_map_t *hashMap = octaspire_map_new(
        sizeof(octaspire_string_t *),
        true,
        sizeof(octaspire_string_t *),
        true,
        octaspire_map_new_test_key_compare_function_for_ostring_t_keys,
        octaspire_map_new_test_key_hash_function_for_ostring_t_keys,
        (octaspire_map_element_callback_t)octaspire_string_release,
        (octaspire_map_element_callback_t)octaspire_string_release,
        octaspireContainerHashMapTestAllocator);

    size_t const numElements = 32;

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_string_t *str = octaspire_string_new_format(
            octaspireContainerHashMapTestAllocator,
            "%zu",
            i);

        uint32_t const hash = octaspire_string_get_hash(str);

        octaspire_string_t *cpyStr = octaspire_string_new_copy(str, octaspireContainerHashMapTestAllocator);
        ASSERT(octaspire_string_is_equal(str, cpyStr));
        octaspire_map_put(hashMap, hash, &cpyStr, &str);

        ASSERT_EQ(i+1, octaspire_map_get_number_of_elements(hashMap));
    }

    ASSERT_EQ(numElements, octaspire_map_get_number_of_elements(hashMap));

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_string_t *str = octaspire_string_new_format(
            octaspireContainerHashMapTestAllocator,
            "%zu",
            i);

        uint32_t hash = octaspire_string_get_hash(str);

        octaspire_map_element_t *element =
            octaspire_map_get(hashMap, hash, &str);

        ASSERT(element);

        ASSERT_EQ(hash, octaspire_map_element_get_hash(element));

        ASSERT(octaspire_string_is_equal(str, (octaspire_string_t*)octaspire_map_element_get_key(element)));

        ASSERT(octaspire_string_is_equal(str, (octaspire_string_t*)octaspire_map_element_get_value(element)));

        octaspire_string_release(str);
        str = 0;
    }

    octaspire_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_map_new_with_octaspire_string_keys_test(void)
{
    octaspire_map_t *hashMap =
        octaspire_map_new_with_octaspire_string_keys(
            sizeof(octaspire_string_t *),
            true,
            (octaspire_map_element_callback_t)
                octaspire_string_release,
            octaspireContainerHashMapTestAllocator);

    size_t const numElements = 32;

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_string_t *str = octaspire_string_new_format(
            octaspireContainerHashMapTestAllocator,
            "%zu",
            i);

        uint32_t const hash = octaspire_string_get_hash(str);

        octaspire_string_t *cpyStr = octaspire_string_new_copy(str, octaspireContainerHashMapTestAllocator);
        ASSERT(octaspire_string_is_equal(str, cpyStr));
        octaspire_map_put(hashMap, hash, &cpyStr, &str);

        ASSERT_EQ(i+1, octaspire_map_get_number_of_elements(hashMap));
    }

    ASSERT_EQ(numElements, octaspire_map_get_number_of_elements(hashMap));

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_string_t *str = octaspire_string_new_format(
            octaspireContainerHashMapTestAllocator,
            "%zu",
            i);

        uint32_t hash = octaspire_string_get_hash(str);

        octaspire_map_element_t *element =
            octaspire_map_get(hashMap, hash, &str);

        ASSERT(element);

        ASSERT_EQ(hash, octaspire_map_element_get_hash(element));

        ASSERT(octaspire_string_is_equal(str, (octaspire_string_t*)octaspire_map_element_get_key(element)));

        ASSERT(octaspire_string_is_equal(str, (octaspire_string_t*)octaspire_map_element_get_value(element)));

        octaspire_string_release(str);
        str = 0;
    }

    octaspire_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_map_new_with_size_t_keys_test(void)
{
    octaspire_map_t *hashMap =
        octaspire_map_new_with_size_t_keys(
            sizeof(octaspire_string_t *),
            true,
            (octaspire_map_element_callback_t)
                octaspire_string_release,
            octaspireContainerHashMapTestAllocator);

    size_t const numElements = 32;

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_string_t *str = octaspire_string_new_format(
            octaspireContainerHashMapTestAllocator,
            "%zu",
            i);

        uint32_t const hash = octaspire_map_helper_size_t_get_hash(i);

        ASSERT(octaspire_map_put(hashMap, hash, &i, &str));

        ASSERT_EQ(i+1, octaspire_map_get_number_of_elements(hashMap));
    }

    ASSERT_EQ(numElements, octaspire_map_get_number_of_elements(hashMap));

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_string_t *str = octaspire_string_new_format(
            octaspireContainerHashMapTestAllocator,
            "%zu",
            i);

        uint32_t const hash = octaspire_map_helper_size_t_get_hash(i);

        octaspire_map_element_t *element =
            octaspire_map_get(hashMap, hash, &i);

        ASSERT(element);

        ASSERT_EQ(hash, octaspire_map_element_get_hash(element));

        ASSERT_EQ(i, *(size_t const * const)octaspire_map_element_get_key(element));

        ASSERT(octaspire_string_is_equal(str, (octaspire_string_t*)octaspire_map_element_get_value(element)));

        octaspire_string_release(str);
        str = 0;
    }

    octaspire_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_map_element_iterator_test(void)
{
    octaspire_map_t *hashMap = octaspire_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT(hashMap);

    octaspire_map_element_iterator_t iterator =
        octaspire_map_element_iterator_init(hashMap);

    ASSERT_EQ(hashMap, iterator.hashMap);
    ASSERT_EQ(0,       iterator.element);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_map_element_iterator_next(&iterator));

        ASSERT_EQ(hashMap, iterator.hashMap);
        ASSERT_EQ(0,       iterator.element);
    }

    size_t const numElements = 128;

    for (size_t i = 0; i < numElements; ++i)
    {
        uint32_t hash = (uint32_t)i;

        octaspire_map_put(hashMap, hash, &i, &i);
    }

    ASSERT_EQ(numElements, octaspire_map_get_number_of_elements(hashMap));

    iterator =
        octaspire_map_element_iterator_init(hashMap);

    ASSERT_EQ(hashMap, iterator.hashMap);

    size_t counter = 0;
    while (iterator.element)
    {
        ASSERT_EQ(hashMap, iterator.hashMap);
        ASSERT_EQ(counter, octaspire_map_element_get_hash(iterator.element));
        ASSERT_EQ(counter, *(size_t*)octaspire_map_element_get_key(iterator.element));
        ASSERT_EQ(counter, *(size_t*)octaspire_map_element_get_value(iterator.element));

        ++counter;
        octaspire_map_element_iterator_next(&iterator);
    }

    ASSERT_EQ(numElements, counter);

    octaspire_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_map_element_const_iterator_test(void)
{
    octaspire_map_t *hashMap = octaspire_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT(hashMap);

    octaspire_map_element_const_iterator_t iterator =
        octaspire_map_element_const_iterator_init(hashMap);

    ASSERT_EQ(hashMap, iterator.hashMap);
    ASSERT_EQ(0,       iterator.element);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_map_element_const_iterator_next(&iterator));

        ASSERT_EQ(hashMap, iterator.hashMap);
        ASSERT_EQ(0,       iterator.element);
    }

    size_t const numElements = 128;

    for (size_t i = 0; i < numElements; ++i)
    {
        uint32_t hash = (uint32_t)i;

        octaspire_map_put(hashMap, hash, &i, &i);
    }

    ASSERT_EQ(numElements, octaspire_map_get_number_of_elements(hashMap));

    iterator =
        octaspire_map_element_const_iterator_init(hashMap);

    ASSERT_EQ(hashMap, iterator.hashMap);

    size_t counter = 0;
    while (iterator.element)
    {
        ASSERT_EQ(hashMap, iterator.hashMap);
        ASSERT_EQ(counter, octaspire_map_element_get_hash(iterator.element));
        ASSERT_EQ(counter, *(size_t const*)octaspire_map_element_get_key_const(iterator.element));
        ASSERT_EQ(counter, *(size_t const*)octaspire_map_element_get_value_const(iterator.element));

        ++counter;
        octaspire_map_element_const_iterator_next(&iterator);
    }

    ASSERT_EQ(numElements, counter);

    octaspire_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_map_get_at_index_test(void)
{
    octaspire_map_t *hashMap = octaspire_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT(hashMap);

    size_t const numElements = 3;

    for (size_t i = 0; i < numElements; ++i)
    {
        uint32_t hash = (uint32_t)i;
        octaspire_map_put(hashMap, hash, &i, &i);
    }

    ASSERT_EQ(numElements, octaspire_map_get_number_of_elements(hashMap));

    // Test failures
    octaspire_map_element_t *element =
        octaspire_map_get_at_index(hashMap, 3);

    ASSERT_FALSE(element);

    element =
        octaspire_map_get_at_index(hashMap, -4);

    ASSERT_FALSE(element);

    // Test success with positive and negative indices
    element =
        octaspire_map_get_at_index(hashMap, 1);

    ASSERT(element);

    ASSERT_EQ(
        1,
        *(size_t const * const)octaspire_map_element_get_value(element));

    element =
        octaspire_map_get_at_index(hashMap, -2);

    ASSERT(element);

    ASSERT_EQ(
        1,
        *(size_t const * const)octaspire_map_element_get_value(element));

    octaspire_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_map_is_empty_test(void)
{
    octaspire_map_t *hashMap = octaspire_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT(hashMap);

    ASSERT(octaspire_map_is_empty(hashMap));

    size_t const numElements = 3;

    for (size_t i = 0; i < numElements; ++i)
    {
        uint32_t hash = (uint32_t)i;
        octaspire_map_put(hashMap, hash, &i, &i);
        ASSERT_FALSE(octaspire_map_is_empty(hashMap));
    }

    octaspire_map_release(hashMap);
    hashMap = 0;

    PASS();
}

GREATEST_SUITE(octaspire_map_suite)
{
    octaspireContainerHashMapTestAllocator = octaspire_allocator_new(0);

    assert(octaspireContainerHashMapTestAllocator);

    RUN_TEST(octaspire_map_element_new_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_map_element_new_allocation_failure_on_second_allocation_test);
    RUN_TEST(octaspire_map_element_new_allocation_failure_on_third_allocation_test);
    RUN_TEST(octaspire_map_private_rehash_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_map_new_keys_uint32_t_and_values_size_t_test);
    RUN_TEST(octaspire_map_add_same_key_many_times_test);
    RUN_TEST(octaspire_map_new_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_map_new_allocation_failure_on_second_allocation_test);
    RUN_TEST(octaspire_map_new_keys_ostring_t_and_values_ostring_t_test);
    RUN_TEST(octaspire_map_new_with_octaspire_string_keys_test);
    RUN_TEST(octaspire_map_new_with_size_t_keys_test);
    RUN_TEST(octaspire_map_element_iterator_test);
    RUN_TEST(octaspire_map_element_const_iterator_test);

    RUN_TEST(octaspire_map_get_at_index_test);
    RUN_TEST(octaspire_map_is_empty_test);

    octaspire_allocator_release(octaspireContainerHashMapTestAllocator);
    octaspireContainerHashMapTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_map.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_semver.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireSemverTestAllocator = 0;

TEST octaspire_semver_new_called_with_null_allocator_test(void)
{
    octaspire_vector_t * preRelease =
        octaspire_vector_new(
            sizeof(octaspire_string_t*),
            true,
            (octaspire_vector_element_callback_t)octaspire_string_release,
            octaspireSemverTestAllocator);

    ASSERT(preRelease);

    octaspire_vector_t * buildMetadata =
        octaspire_vector_new(
            sizeof(octaspire_string_t*),
            true,
            (octaspire_vector_element_callback_t)octaspire_string_release,
            octaspireSemverTestAllocator);

    ASSERT(buildMetadata);

    octaspire_semver_t * semver =
        octaspire_semver_new(
            0,
            0,
            0,
            preRelease,
            buildMetadata,
            0);

    ASSERT_EQ(semver, 0);

    octaspire_vector_release(preRelease);
    preRelease = 0;

    octaspire_vector_release(buildMetadata);
    buildMetadata = 0;

    octaspire_semver_release(semver);
    semver = 0;

    PASS();
}

TEST octaspire_semver_new_prerelease_0_1_2_alpha_3_and_metadata_sha_5214f_test(void)
{
    octaspire_semver_t * semver =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver);

    octaspire_string_t * str = octaspire_semver_to_string(semver);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "0.1.2-alpha.3"));
    octaspire_string_release(str);
    str = 0;

    ASSERT(octaspire_semver_add_buildmetadata(semver, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver, "5214f"));

    str = octaspire_semver_to_string(semver);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "0.1.2-alpha.3+sha.5214f"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver);
    semver = 0;

    PASS();
}

TEST octaspire_semver_compare_0_1_2_alpha_3_metadata_sha_5214f_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver1);
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "5214f"));

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver2);
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "5214f"));

    ASSERT_EQ(0, octaspire_semver_compare(semver1, semver2));
    ASSERT_EQ(0, octaspire_semver_compare(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_compare_0_1_2_alpha_3_sha_5214f_and_0_1_2_alpha_3_sha_5214g_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver1);
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "5214f"));

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver2);
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "5214g"));

    ASSERT_EQ(0, octaspire_semver_compare(semver1, semver2));
    ASSERT_EQ(0, octaspire_semver_compare(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_compare_0_1_2_alpha_3_sha_5214f_and_0_1_2_alpha_4_sha_5214f_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver1);
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "5214f"));

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "4",
            "");

    ASSERT(semver2);
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "5214f"));

    ASSERT_EQ(-1, octaspire_semver_compare(semver1, semver2));
    ASSERT_EQ( 1, octaspire_semver_compare(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_compare_0_1_2_alpha_4_sha_5214f_and_0_1_2_alpha_3_sha_5214f_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "4",
            "");

    ASSERT(semver1);
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "5214f"));

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver2);
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "5214f"));

    ASSERT_EQ( 1, octaspire_semver_compare(semver1, semver2));
    ASSERT_EQ(-1, octaspire_semver_compare(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_compare_0_1_2_alphb_3_sha_5214f_and_0_1_2_alpha_3_sha_5214f_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alphb",
            "3",
            "");

    ASSERT(semver1);
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "5214f"));

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver2);
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "5214f"));

    ASSERT_EQ( 1, octaspire_semver_compare(semver1, semver2));
    ASSERT_EQ(-1, octaspire_semver_compare(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_compare_0_1_2_alpha_3_sha_5214f_and_0_1_2_alphb_3_sha_5214f_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver1);
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "5214f"));

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alphb",
            "3",
            "");

    ASSERT(semver2);
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "5214f"));

    ASSERT_EQ(-1, octaspire_semver_compare(semver1, semver2));
    ASSERT_EQ( 1, octaspire_semver_compare(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_compare_0_1_3_alpha_3_sha_5214f_and_0_1_2_alpha_3_sha_5214f_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            0,
            1,
            3,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver1);
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "5214f"));

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver2);
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "5214f"));

    ASSERT_EQ( 1, octaspire_semver_compare(semver1, semver2));
    ASSERT_EQ(-1, octaspire_semver_compare(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_compare_0_1_2_alpha_3_sha_5214f_and_0_1_3_alpha_3_sha_5214f_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver1);
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "5214f"));

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            1,
            3,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver2);
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "5214f"));

    ASSERT_EQ(-1, octaspire_semver_compare(semver1, semver2));
    ASSERT_EQ( 1, octaspire_semver_compare(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_compare_0_2_2_alpha_3_sha_5214f_and_0_1_2_alpha_3_sha_5214f_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            0,
            2,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver1);
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "5214f"));

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver2);
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "5214f"));

    ASSERT_EQ( 1, octaspire_semver_compare(semver1, semver2));
    ASSERT_EQ(-1, octaspire_semver_compare(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_compare_0_1_2_alpha_3_sha_5214f_and_0_2_2_alpha_3_sha_5214f_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver1);
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "5214f"));

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            2,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver2);
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "5214f"));

    ASSERT_EQ(-1, octaspire_semver_compare(semver1, semver2));
    ASSERT_EQ( 1, octaspire_semver_compare(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_compare_1_1_2_alpha_3_sha_5214f_and_0_1_2_alpha_3_sha_5214f_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver1);
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "5214f"));

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver2);
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "5214f"));

    ASSERT_EQ( 1, octaspire_semver_compare(semver1, semver2));
    ASSERT_EQ(-1, octaspire_semver_compare(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_compare_0_1_2_alpha_3_sha_5214f_and_1_1_2_alpha_3_sha_5214f_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            0,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver1);
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver1, "5214f"));

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            1,
            1,
            2,
            octaspireSemverTestAllocator,
            "alpha",
            "3",
            "");

    ASSERT(semver2);
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "sha"));
    ASSERT(octaspire_semver_add_buildmetadata(semver2, "5214f"));

    ASSERT_EQ(-1, octaspire_semver_compare(semver1, semver2));
    ASSERT_EQ( 1, octaspire_semver_compare(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_comparison_operators_called_with_1_0_0_alpha_and_1_0_0_alpha_1_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "alpha",
            "");

    ASSERT(semver1);

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "alpha",
            "1",
            "");

    ASSERT(semver2);

    // Regular.
    ASSERT(octaspire_semver_is_smaller_than(semver1, semver2));
    ASSERT(octaspire_semver_is_smaller_or_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_than(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_or_equal_to(semver1, semver2));

    // Reverse order.
    ASSERT_FALSE(octaspire_semver_is_smaller_than(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_smaller_or_equal_to(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_than(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_or_equal_to(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_comparison_operators_called_with_1_0_0_alpha_1_and_1_0_0_alpha_beta_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "alpha",
            "1",
            "");

    ASSERT(semver1);

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "alpha",
            "beta",
            "");

    ASSERT(semver2);

    // Regular.
    ASSERT(octaspire_semver_is_smaller_than(semver1, semver2));
    ASSERT(octaspire_semver_is_smaller_or_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_than(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_or_equal_to(semver1, semver2));

    // Reverse order.
    ASSERT_FALSE(octaspire_semver_is_smaller_than(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_smaller_or_equal_to(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_than(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_or_equal_to(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_comparison_operators_called_with_1_0_0_alpha_beta_and_1_0_0_beta_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "alpha",
            "beta",
            "");

    ASSERT(semver1);

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "beta",
            "");

    ASSERT(semver2);

    // Regular.
    ASSERT(octaspire_semver_is_smaller_than(semver1, semver2));
    ASSERT(octaspire_semver_is_smaller_or_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_than(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_or_equal_to(semver1, semver2));

    // Reverse order.
    ASSERT_FALSE(octaspire_semver_is_smaller_than(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_smaller_or_equal_to(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_than(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_or_equal_to(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_comparison_operators_called_with_1_0_0_beta_and_1_0_0_beta_2_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "beta",
            "");

    ASSERT(semver1);

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "beta",
            "2",
            "");

    ASSERT(semver2);

    // Regular.
    ASSERT(octaspire_semver_is_smaller_than(semver1, semver2));
    ASSERT(octaspire_semver_is_smaller_or_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_than(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_or_equal_to(semver1, semver2));

    // Reverse order.
    ASSERT_FALSE(octaspire_semver_is_smaller_than(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_smaller_or_equal_to(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_than(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_or_equal_to(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_comparison_operators_called_with_1_0_0_beta_2_and_1_0_0_beta_11_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "beta",
            "2",
            "");

    ASSERT(semver1);

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "beta",
            "11",
            "");

    ASSERT(semver2);

    // Regular.
    ASSERT(octaspire_semver_is_smaller_than(semver1, semver2));
    ASSERT(octaspire_semver_is_smaller_or_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_than(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_or_equal_to(semver1, semver2));

    // Reverse order.
    ASSERT_FALSE(octaspire_semver_is_smaller_than(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_smaller_or_equal_to(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_than(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_or_equal_to(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_comparison_operators_called_with_1_0_0_beta_11_and_1_0_0_rc_1_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "beta",
            "11",
            "");

    ASSERT(semver1);

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver2);

    // Regular.
    ASSERT(octaspire_semver_is_smaller_than(semver1, semver2));
    ASSERT(octaspire_semver_is_smaller_or_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_than(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_or_equal_to(semver1, semver2));

    // Reverse order.
    ASSERT_FALSE(octaspire_semver_is_smaller_than(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_smaller_or_equal_to(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_than(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_or_equal_to(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_comparison_operators_called_with_1_0_0_rc_1_and_1_0_0_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            1,
            0,
            0,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Regular.
    ASSERT(octaspire_semver_is_smaller_than(semver1, semver2));
    ASSERT(octaspire_semver_is_smaller_or_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_than(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_or_equal_to(semver1, semver2));

    // Reverse order.
    ASSERT_FALSE(octaspire_semver_is_smaller_than(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_smaller_or_equal_to(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_than(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_or_equal_to(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_comparison_operators_called_with_3_0_1_rc_1_and_3_0_1_rc_1_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            3,
            0,
            1,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            3,
            0,
            1,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver2);

    ASSERT_FALSE(octaspire_semver_is_smaller_than(semver1, semver2));
    ASSERT(octaspire_semver_is_smaller_or_equal_to(semver1, semver2));
    ASSERT(octaspire_semver_is_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_than(semver1, semver2));
    ASSERT(octaspire_semver_is_greater_or_equal_to(semver1, semver2));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_comparison_operators_called_with_1_9_0_and_1_10_0_test(void)
{
    // First
    octaspire_semver_t * semver1 =
        octaspire_semver_new(
            1,
            9,
            0,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver1);

    // Second
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            1,
            10,
            0,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Regular.
    ASSERT(octaspire_semver_is_smaller_than(semver1, semver2));
    ASSERT(octaspire_semver_is_smaller_or_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_than(semver1, semver2));
    ASSERT_FALSE(octaspire_semver_is_greater_or_equal_to(semver1, semver2));

    // Reverse order.
    ASSERT_FALSE(octaspire_semver_is_smaller_than(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_smaller_or_equal_to(semver2, semver1));
    ASSERT_FALSE(octaspire_semver_is_equal_to(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_than(semver2, semver1));
    ASSERT(octaspire_semver_is_greater_or_equal_to(semver2, semver1));

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_0_0_rc_1_and_0_0_1_and_true_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            0,
            0,
            1,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Add.
    ASSERT(octaspire_semver_add_or_subtract(semver1, semver2, true));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.0.1-rc.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_0_1_rc_1_and_0_1_0_and_true_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            0,
            1,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            0,
            1,
            0,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Add.
    ASSERT(octaspire_semver_add_or_subtract(semver1, semver2, true));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.1.0-rc.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_1_0_0_and_true_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            1,
            1,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            1,
            0,
            0,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Add.
    ASSERT(octaspire_semver_add_or_subtract(semver1, semver2, true));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "2.0.0-rc.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_and_0_0_0_rc_1_and_true_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new(
            1,
            1,
            1,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            0,
            0,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");


    ASSERT(semver2);

    // Add.
    ASSERT(octaspire_semver_add_or_subtract(semver1, semver2, true));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.1.1-rc.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_and_1_1_1_and_true_failure_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new(
            1,
            1,
            1,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            1,
            1,
            1,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Add.
    ASSERT_FALSE(octaspire_semver_add_or_subtract(semver1, semver2, true));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.1.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_and_1_1_0_and_true_failure_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new(
            1,
            1,
            1,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            1,
            1,
            0,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Add.
    ASSERT_FALSE(octaspire_semver_add_or_subtract(semver1, semver2, true));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.1.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_and_1_0_1_and_true_failure_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new(
            1,
            1,
            1,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            1,
            0,
            1,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Add.
    ASSERT_FALSE(octaspire_semver_add_or_subtract(semver1, semver2, true));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.1.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_and_0_1_1_and_true_failure_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new(
            1,
            1,
            1,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            0,
            1,
            1,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Add.
    ASSERT_FALSE(octaspire_semver_add_or_subtract(semver1, semver2, true));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.1.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_0_0_rc_1_and_0_0_1_and_false_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            0,
            0,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            0,
            0,
            1,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Add.
    ASSERT_FALSE(octaspire_semver_add_or_subtract(semver1, semver2, false));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.0.0-rc.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_0_1_rc_1_and_0_0_1_and_false_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            0,
            1,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            0,
            0,
            1,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Add.
    ASSERT(octaspire_semver_add_or_subtract(semver1, semver2, false));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.0.0-rc.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_0_1_0_and_false_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            1,
            1,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            0,
            1,
            0,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Add.
    ASSERT(octaspire_semver_add_or_subtract(semver1, semver2, false));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.0.1-rc.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_1_0_0_and_false_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            1,
            1,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new(
            1,
            0,
            0,
            0,
            0,
            octaspireSemverTestAllocator);

    ASSERT(semver2);

    // Add.
    ASSERT(octaspire_semver_add_or_subtract(semver1, semver2, false));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "0.1.1-rc.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_0_0_0_rc_and_false_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            1,
            1,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            0,
            0,
            octaspireSemverTestAllocator,
            "rc",
            "");


    ASSERT(semver2);

    // Add.
    ASSERT(octaspire_semver_add_or_subtract(semver1, semver2, false));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.1.1-1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_0_0_0_1_and_false_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            1,
            1,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            0,
            0,
            octaspireSemverTestAllocator,
            "1",
            "");


    ASSERT(semver2);

    // Add.
    ASSERT(octaspire_semver_add_or_subtract(semver1, semver2, false));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.1.1-rc"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_0_0_0_rc_1_and_false_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            1,
            1,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            0,
            0,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");


    ASSERT(semver2);

    // Add.
    ASSERT(octaspire_semver_add_or_subtract(semver1, semver2, false));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.1.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_0_0_0_ra_and_false_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            1,
            1,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            0,
            0,
            octaspireSemverTestAllocator,
            "ra",
            "");


    ASSERT(semver2);

    // Add.
    ASSERT_FALSE(octaspire_semver_add_or_subtract(semver1, semver2, false));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.1.1-rc.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

TEST octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_0_0_0_2_and_false_test(void)
{
    // Target.
    octaspire_semver_t * semver1 =
        octaspire_semver_new_prerelease(
            1,
            1,
            1,
            octaspireSemverTestAllocator,
            "rc",
            "1",
            "");

    ASSERT(semver1);

    // To be added.
    octaspire_semver_t * semver2 =
        octaspire_semver_new_prerelease(
            0,
            0,
            0,
            octaspireSemverTestAllocator,
            "2",
            "");


    ASSERT(semver2);

    // Add.
    ASSERT_FALSE(octaspire_semver_add_or_subtract(semver1, semver2, false));

    // Check result of addition.
    octaspire_string_t * str = octaspire_semver_to_string(semver1);
    ASSERT(str);
    ASSERT(octaspire_string_is_equal_to_c_string(str, "1.1.1-rc.1"));
    octaspire_string_release(str);
    str = 0;

    octaspire_semver_release(semver1);
    semver1 = 0;
    octaspire_semver_release(semver2);
    semver2 = 0;

    PASS();
}

GREATEST_SUITE(octaspire_semver_suite)
{
    octaspireSemverTestAllocator = octaspire_allocator_new(0);

    assert(octaspireSemverTestAllocator);

    RUN_TEST(octaspire_semver_new_called_with_null_allocator_test);
    RUN_TEST(octaspire_semver_new_prerelease_0_1_2_alpha_3_and_metadata_sha_5214f_test);
    RUN_TEST(octaspire_semver_compare_0_1_2_alpha_3_metadata_sha_5214f_test);
    RUN_TEST(octaspire_semver_compare_0_1_2_alpha_3_sha_5214f_and_0_1_2_alpha_3_sha_5214g_test);
    RUN_TEST(octaspire_semver_compare_0_1_2_alpha_3_sha_5214f_and_0_1_2_alpha_4_sha_5214f_test);
    RUN_TEST(octaspire_semver_compare_0_1_2_alpha_4_sha_5214f_and_0_1_2_alpha_3_sha_5214f_test);
    RUN_TEST(octaspire_semver_compare_0_1_2_alphb_3_sha_5214f_and_0_1_2_alpha_3_sha_5214f_test);
    RUN_TEST(octaspire_semver_compare_0_1_2_alpha_3_sha_5214f_and_0_1_2_alphb_3_sha_5214f_test);
    RUN_TEST(octaspire_semver_compare_0_1_3_alpha_3_sha_5214f_and_0_1_2_alpha_3_sha_5214f_test);
    RUN_TEST(octaspire_semver_compare_0_1_2_alpha_3_sha_5214f_and_0_1_3_alpha_3_sha_5214f_test);
    RUN_TEST(octaspire_semver_compare_0_2_2_alpha_3_sha_5214f_and_0_1_2_alpha_3_sha_5214f_test);
    RUN_TEST(octaspire_semver_compare_0_1_2_alpha_3_sha_5214f_and_0_2_2_alpha_3_sha_5214f_test);
    RUN_TEST(octaspire_semver_compare_1_1_2_alpha_3_sha_5214f_and_0_1_2_alpha_3_sha_5214f_test);
    RUN_TEST(octaspire_semver_compare_0_1_2_alpha_3_sha_5214f_and_1_1_2_alpha_3_sha_5214f_test);

    RUN_TEST(octaspire_semver_comparison_operators_called_with_1_0_0_alpha_and_1_0_0_alpha_1_test);
    RUN_TEST(octaspire_semver_comparison_operators_called_with_1_0_0_alpha_1_and_1_0_0_alpha_beta_test);
    RUN_TEST(octaspire_semver_comparison_operators_called_with_1_0_0_alpha_beta_and_1_0_0_beta_test);
    RUN_TEST(octaspire_semver_comparison_operators_called_with_1_0_0_beta_and_1_0_0_beta_2_test);
    RUN_TEST(octaspire_semver_comparison_operators_called_with_1_0_0_beta_2_and_1_0_0_beta_11_test);
    RUN_TEST(octaspire_semver_comparison_operators_called_with_1_0_0_beta_11_and_1_0_0_rc_1_test);
    RUN_TEST(octaspire_semver_comparison_operators_called_with_1_0_0_rc_1_and_1_0_0_test);

    RUN_TEST(octaspire_semver_comparison_operators_called_with_3_0_1_rc_1_and_3_0_1_rc_1_test);
    RUN_TEST(octaspire_semver_comparison_operators_called_with_1_9_0_and_1_10_0_test);

    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_0_0_rc_1_and_0_0_1_and_true_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_0_1_rc_1_and_0_1_0_and_true_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_1_0_0_and_true_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_and_0_0_0_rc_1_and_true_test);

    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_and_1_1_1_and_true_failure_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_and_1_1_0_and_true_failure_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_and_1_0_1_and_true_failure_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_and_0_1_1_and_true_failure_test);

    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_0_0_rc_1_and_0_0_1_and_false_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_0_1_rc_1_and_0_0_1_and_false_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_0_1_0_and_false_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_1_0_0_and_false_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_0_0_0_rc_and_false_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_0_0_0_1_and_false_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_0_0_0_rc_1_and_false_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_0_0_0_ra_and_false_test);
    RUN_TEST(octaspire_semver_add_or_subtract_called_with_1_1_1_rc_1_and_0_0_0_2_and_false_test);

    octaspire_allocator_release(octaspireSemverTestAllocator);
    octaspireSemverTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_semver.c
//////////////////////////////////////////////////////////////////////////////////////////////////
void octaspire_core_amalgamated_write_test_file(
    char const * const name,
    unsigned char const * const buffer,
    size_t const bufferSize)
{
    FILE *stream = fopen(name, "wb");

    if (!stream)
    {
        abort();
    }

    if (!buffer || !bufferSize)
    {
        if (fclose(stream) != 0)
        {
            abort();
        }

        stream = 0;

        printf("  Wrote empty file '%s'\n", name);

        return;
    }
    else
    {
        if (fwrite(buffer, sizeof(char), bufferSize, stream) != bufferSize)
        {
            fclose(stream);
            stream = 0;
            abort();
        }
    }

    if (fclose(stream) != 0)
    {
        abort();
    }

    printf("  Wrote file '%s'\n", name);
}

GREATEST_MAIN_DEFS();

int main(int argc, char **argv)
{
    // This banner is created with figlet using font 'small'
    unsigned char octaspire_core_amalgamated_version_banner[] = {
      0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x2f, 0x20,
      0x5f, 0x20, 0x5c, 0x20, 0x5f, 0x5f, 0x7c, 0x20, 0x7c, 0x5f, 0x20, 0x5f,
      0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x5f, 0x5f, 0x20, 0x5f, 0x5f, 0x28,
      0x5f, 0x29, 0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20,
      0x2f, 0x20, 0x5f, 0x5f, 0x7c, 0x5f, 0x5f, 0x5f, 0x20, 0x5f, 0x20, 0x5f,
      0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x0a, 0x7c, 0x20, 0x28, 0x5f, 0x29, 0x20,
      0x2f, 0x20, 0x5f, 0x7c, 0x20, 0x20, 0x5f, 0x2f, 0x20, 0x5f, 0x60, 0x20,
      0x28, 0x5f, 0x2d, 0x3c, 0x20, 0x27, 0x5f, 0x20, 0x5c, 0x20, 0x7c, 0x20,
      0x27, 0x5f, 0x2f, 0x20, 0x2d, 0x5f, 0x29, 0x20, 0x7c, 0x20, 0x28, 0x5f,
      0x5f, 0x2f, 0x20, 0x5f, 0x20, 0x5c, 0x20, 0x27, 0x5f, 0x2f, 0x20, 0x2d,
      0x5f, 0x29, 0x0a, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x2f, 0x5c, 0x5f, 0x5f,
      0x7c, 0x5c, 0x5f, 0x5f, 0x5c, 0x5f, 0x5f, 0x2c, 0x5f, 0x2f, 0x5f, 0x5f,
      0x2f, 0x20, 0x2e, 0x5f, 0x5f, 0x2f, 0x5f, 0x7c, 0x5f, 0x7c, 0x20, 0x5c,
      0x5f, 0x5f, 0x5f, 0x7c, 0x20, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x5c, 0x5f,
      0x5f, 0x5f, 0x2f, 0x5f, 0x7c, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x7c, 0x0a,
      0x20, 0x20, 0x41, 0x6d, 0x61, 0x6c, 0x67, 0x61, 0x6d, 0x61, 0x74, 0x65,
      0x64, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x7c, 0x5f, 0x7c,
      0x73, 0x74, 0x61, 0x6e, 0x64, 0x2d, 0x61, 0x6c, 0x6f, 0x6e, 0x65, 0x20,
      0x75, 0x6e, 0x69, 0x74, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x72, 0x75,
      0x6e, 0x6e, 0x65, 0x72, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x0a, '\0'
    };

    printf(
        "%s  %s\n\n",
        octaspire_core_amalgamated_version_banner,
        OCTASPIRE_CORE_CONFIG_VERSION_STR);

    printf(
        "  This is stand-alone unit test runner for the amalgamated version of\n"
        "  Octaspire Core. Some of the unit tests test reading of files from\n"
        "  the filesystem. The full source distribution has these files in\n"
        "  the 'test/resource' directory. But because this amalgamated\n"
        "  distribution can have only one file, to be able to run all\n"
        "  the tests succesfully something must be done. What do you\n"
        "  want to do? Select 'a', 'b', 'c' or any other key:\n"
        "\n"
        "  a) Let this program to write those files to disk to the current working\n"
        "     directory. All existing files with the same name will be OVERWRITTEN.\n"
        "     The files to be written are of form 'octaspire_XYZ_test', where XYZ\n"
        "     is the name of the test.\n"
        "\n"
        "  b) Let those tests to fail on missing files, or succeed if the files are\n"
        "     already present in the current working directory.\n"
        "\n"
        "  c) Abort and quit this program.\n"
        "\n"
        "  > ");

    int c = 0;

    if (argc >= 2)
    {
        if (strcmp(argv[1], "--write-test-files") == 0)
        {
            --argc;
            ++argv;
            c = (int)'a';
        }
        else
        {
            printf("Unknown option '%s'\n", argv[1]);
            return EXIT_FAILURE;
        }
        printf("Option '%c' given with command line argument.\n", (char)c);
    }
    else
    {
        c = getchar();
    }

    switch (c)
    {
        case 'a':
        {
            printf("Writing test files to current working directory...\n");

            octaspire_core_amalgamated_write_test_file(
                "octaspire_helpers_path_to_buffer_failure_on_empty_file_test", 0, 0);



            unsigned char const octaspire_helpers_path_to_buffer_test[] = {
                0xc2, 0xa9, 0xe2, 0x89, 0xa0, 0xf0, 0x90, 0x80, 0x80
            };
            size_t const octaspire_helpers_path_to_buffer_test_len = 9;

            octaspire_core_amalgamated_write_test_file(
                "octaspire_helpers_path_to_buffer_test",
                octaspire_helpers_path_to_buffer_test,
                octaspire_helpers_path_to_buffer_test_len);


            unsigned char const octaspire_input_new_from_path_test[] = {
              0x61, 0x62, 0x63, 0xc2, 0xa9, 0xe2, 0x89, 0xa0, 0xf0, 0x90, 0x80, 0x80
            };
            size_t const octaspire_input_new_from_path_test_len = 12;

            octaspire_core_amalgamated_write_test_file(
                "octaspire_input_new_from_path_test",
                octaspire_input_new_from_path_test,
                octaspire_input_new_from_path_test_len);



            unsigned char const octaspire_stdio_fread_test[] = {
              0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x71, 0x77,
              0x65, 0x72, 0x74, 0x79, 0x75, 0x69, 0x6f, 0x70, 0x0a
            };
            size_t const octaspire_stdio_fread_test_len = 21;

            octaspire_core_amalgamated_write_test_file(
                "octaspire_stdio_fread_test",
                octaspire_stdio_fread_test,
                octaspire_stdio_fread_test_len);




            printf("Done.\n");
        }
        break;

        case 'b':
        {
            printf("Tests reading files will fail, if the required files are not available.\n");
        }
        break;

        case 'c':
        default:
        {
            printf("Going to quit now, as requested\n");
            return EXIT_FAILURE;
        }
        break;
    }

    GREATEST_MAIN_BEGIN();
    RUN_SUITE(octaspire_helpers_suite);
    RUN_SUITE(octaspire_utf8_suite);
    RUN_SUITE(octaspire_memory_suite);
    RUN_SUITE(octaspire_stdio_suite);
    RUN_SUITE(octaspire_input_suite);
    RUN_SUITE(octaspire_vector_suite);
    RUN_SUITE(octaspire_list_suite);
    RUN_SUITE(octaspire_queue_suite);
    RUN_SUITE(octaspire_string_suite);
    RUN_SUITE(octaspire_semver_suite);
    RUN_SUITE(octaspire_pair_suite);
    RUN_SUITE(octaspire_map_suite);
    GREATEST_MAIN_END();
}


#endif  // OCTASPIRE_CORE_AMALGAMATED_UNIT_TEST_IMPLEMENTATION
#endif  // OCTASPIRE_CORE_AMALGAMATED_H
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/external/octaspire_core/release/octaspire-core-amalgamated.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/dern/octaspire_dern_config.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_CONFIG_H
#define OCTASPIRE_DERN_CONFIG_H

#define OCTASPIRE_DERN_CONFIG_VERSION_MAJOR "0"
#define OCTASPIRE_DERN_CONFIG_VERSION_MINOR "366"
#define OCTASPIRE_DERN_CONFIG_VERSION_PATCH "0"

#define OCTASPIRE_DERN_CONFIG_VERSION_STR "Octaspire Dern version " \
    OCTASPIRE_DERN_CONFIG_VERSION_MAJOR "." \
    OCTASPIRE_DERN_CONFIG_VERSION_MINOR "." \
    OCTASPIRE_DERN_CONFIG_VERSION_PATCH

#define OCTASPIRE_DERN_CONFIG_TEST_RES_PATH ""

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/dern/octaspire_dern_config.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/dern/octaspire_dern_lexer.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_LEXER_H
#define OCTASPIRE_DERN_LEXER_H


#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif

#ifdef __cplusplus
extern "C"       {
#endif

typedef enum
{
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT
}
octaspire_dern_lexer_token_tag_t;

typedef struct octaspire_dern_lexer_token_t octaspire_dern_lexer_token_t;

typedef struct octaspire_dern_lexer_token_position_t
{
    size_t start;
    size_t end;
}
octaspire_dern_lexer_token_position_t;

octaspire_dern_lexer_token_position_t octaspire_dern_lexer_token_position_init(
    size_t const start, size_t const end);

bool octaspire_dern_lexer_token_position_is_equal(
    octaspire_dern_lexer_token_position_t const * const self,
    octaspire_dern_lexer_token_position_t const * const other);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_token_new(
    octaspire_dern_lexer_token_tag_t const typeTag,
    void const * const value,
    octaspire_dern_lexer_token_position_t const line,
    octaspire_dern_lexer_token_position_t const column,
    octaspire_dern_lexer_token_position_t const ucsIndex,
    octaspire_allocator_t *allocator);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_token_new_format(
    octaspire_dern_lexer_token_tag_t const typeTag,
    octaspire_dern_lexer_token_position_t const line,
    octaspire_dern_lexer_token_position_t const column,
    octaspire_dern_lexer_token_position_t const ucsIndex,
    octaspire_allocator_t *allocator,
    void const * const format,
    ...);

void octaspire_dern_lexer_token_release(
    octaspire_dern_lexer_token_t *self);

octaspire_dern_lexer_token_tag_t octaspire_dern_lexer_token_get_type_tag(
    octaspire_dern_lexer_token_t const * const self);

char const *octaspire_dern_lexer_token_get_type_tag_as_c_string(
    octaspire_dern_lexer_token_t const * const self);

int32_t octaspire_dern_lexer_token_get_integer_value(
    octaspire_dern_lexer_token_t const * const self);

double octaspire_dern_lexer_token_get_real_value(
    octaspire_dern_lexer_token_t const * const self);

char const *octaspire_dern_lexer_token_get_string_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self);

char const *octaspire_dern_lexer_token_get_character_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self);

char const *octaspire_dern_lexer_token_get_symbol_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self);

char const *octaspire_dern_lexer_token_get_error_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self);

char const *octaspire_dern_lexer_token_get_multiline_comment_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self);



octaspire_dern_lexer_token_position_t *octaspire_dern_lexer_token_get_position_line(
    octaspire_dern_lexer_token_t const * const self);

octaspire_dern_lexer_token_position_t *octaspire_dern_lexer_token_get_position_column(
    octaspire_dern_lexer_token_t const * const self);

octaspire_dern_lexer_token_position_t *octaspire_dern_lexer_token_get_position_ucs_index(
    octaspire_dern_lexer_token_t const * const self);



bool octaspire_dern_lexer_token_is_equal(
    octaspire_dern_lexer_token_t const * const self,
    octaspire_dern_lexer_token_t const * const other);


octaspire_string_t *octaspire_dern_lexer_token_to_string(
    octaspire_dern_lexer_token_t const * const self);

void octaspire_dern_lexer_token_print(
    octaspire_dern_lexer_token_t const * const self);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_pop_next_token(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/dern/octaspire_dern_lexer.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/dern/octaspire_dern_c_data.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_C_DATA_H
#define OCTASPIRE_DERN_C_DATA_H


#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif

#ifdef __cplusplus
extern "C"       {
#endif

typedef struct octaspire_dern_c_data_t octaspire_dern_c_data_t;

octaspire_dern_c_data_t *octaspire_dern_c_data_new(
    char const * const pluginName,
    char const * const typeNameForPayload,
    void * const payload,
    char const * const cleanUpCallbackName,
    char const * const stdLibLenCallbackName,
    char const * const stdLibLinkAtCallbackName,
    char const * const stdLibCopyAtCallbackName,
    bool const copyingAllowed,
    octaspire_allocator_t *allocator);

octaspire_dern_c_data_t *octaspire_dern_c_data_new_copy(
    octaspire_dern_c_data_t * const other,
    octaspire_allocator_t *allocator);

void octaspire_dern_c_data_release(octaspire_dern_c_data_t *self);

octaspire_string_t *octaspire_dern_c_data_to_string(
    octaspire_dern_c_data_t const * const self,
    octaspire_allocator_t * const allocator);

bool octaspire_dern_c_data_is_equal(
    octaspire_dern_c_data_t const * const self,
    octaspire_dern_c_data_t const * const other);

int octaspire_dern_c_data_compare(
    octaspire_dern_c_data_t const * const self,
    octaspire_dern_c_data_t const * const other);

bool octaspire_dern_c_data_is_plugin_and_payload_type_name(
    octaspire_dern_c_data_t const * const self,
    char const * const pluginName,
    char const * const typeNameForPayload);

char const *octaspire_dern_c_data_get_plugin_name(
    octaspire_dern_c_data_t const * const self);

char const *octaspire_dern_c_data_get_payload_typename(
    octaspire_dern_c_data_t const * const self);

void *octaspire_dern_c_data_get_payload(
    octaspire_dern_c_data_t const * const self);

bool octaspire_dern_c_data_is_copying_allowed(
    octaspire_dern_c_data_t const * const self);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/dern/octaspire_dern_c_data.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/dern/octaspire_dern_port.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_PORT_H
#define OCTASPIRE_DERN_PORT_H


#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif

#ifdef __cplusplus
extern "C"       {
#endif

typedef enum
{
    OCTASPIRE_DERN_PORT_TAG_NOT_OPEN,
    OCTASPIRE_DERN_PORT_TAG_INPUT_FILE,
    OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE,
    OCTASPIRE_DERN_PORT_TAG_IO_FILE
}
octaspire_dern_port_tag_t;

typedef struct octaspire_dern_port_t octaspire_dern_port_t;

octaspire_dern_port_t *octaspire_dern_port_new_copy(
    octaspire_dern_port_t * const other,
    octaspire_allocator_t *allocator);

octaspire_dern_port_t *octaspire_dern_port_new_input_file(
    char const * const path,
    octaspire_allocator_t *allocator);

octaspire_dern_port_t *octaspire_dern_port_new_output_file(
    char const * const path,
    octaspire_allocator_t *allocator);

octaspire_dern_port_t *octaspire_dern_port_new_io_file(
    char const * const path,
    octaspire_allocator_t *allocator);

void octaspire_dern_port_release(octaspire_dern_port_t *self);

ptrdiff_t octaspire_dern_port_write(
    octaspire_dern_port_t * const self,
    void const * const buffer,
    size_t const bufferSizeInOctets);

ptrdiff_t octaspire_dern_port_read(
    octaspire_dern_port_t * const self,
    void * const buffer,
    size_t const bufferSizeInOctets);

bool octaspire_dern_port_close(
    octaspire_dern_port_t * const self);

ptrdiff_t octaspire_dern_port_get_length_in_octets(octaspire_dern_port_t const * const self);

octaspire_string_t *octaspire_dern_port_to_string(
    octaspire_dern_port_t const * const self,
    octaspire_allocator_t * const allocator);

bool octaspire_dern_port_seek(
    octaspire_dern_port_t * const self,
    ptrdiff_t const amount,
    bool const fromCurrentPos);

bool octaspire_dern_port_flush(octaspire_dern_port_t * const self);
ptrdiff_t octaspire_dern_port_distance(octaspire_dern_port_t const * const self);

bool octaspire_dern_port_supports_output(
    octaspire_dern_port_t const * const self);

bool octaspire_dern_port_supports_input(
    octaspire_dern_port_t const * const self);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/dern/octaspire_dern_port.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/dern/octaspire_dern_value.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_VALUE_H
#define OCTASPIRE_DERN_VALUE_H


#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif


#ifdef __cplusplus
extern "C"       {
#endif

typedef enum
{
    OCTASPIRE_DERN_VALUE_TAG_ILLEGAL,
    OCTASPIRE_DERN_VALUE_TAG_NIL,
    OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,
    OCTASPIRE_DERN_VALUE_TAG_INTEGER,
    OCTASPIRE_DERN_VALUE_TAG_REAL,
    OCTASPIRE_DERN_VALUE_TAG_STRING,
    OCTASPIRE_DERN_VALUE_TAG_CHARACTER,
    OCTASPIRE_DERN_VALUE_TAG_SYMBOL,
    OCTASPIRE_DERN_VALUE_TAG_ERROR,
    OCTASPIRE_DERN_VALUE_TAG_VECTOR,
    OCTASPIRE_DERN_VALUE_TAG_HASH_MAP,
    OCTASPIRE_DERN_VALUE_TAG_QUEUE,
    OCTASPIRE_DERN_VALUE_TAG_LIST,
    OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT,
    OCTASPIRE_DERN_VALUE_TAG_FUNCTION,
    OCTASPIRE_DERN_VALUE_TAG_SPECIAL,
    OCTASPIRE_DERN_VALUE_TAG_BUILTIN,
    OCTASPIRE_DERN_VALUE_TAG_PORT,
    OCTASPIRE_DERN_VALUE_TAG_C_DATA
}
octaspire_dern_value_tag_t;

struct octaspire_dern_vm_t;

char const * octaspire_dern_value_helper_get_type_as_c_string(
    octaspire_dern_value_tag_t const typeTag);

typedef struct octaspire_dern_value_t octaspire_dern_value_t;

typedef octaspire_dern_value_t *(*octaspire_dern_c_function)(
    struct octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

typedef struct octaspire_dern_function_t
{
    octaspire_string_t            *name;
    octaspire_string_t            *docstr;
    struct octaspire_dern_value_t *formals;
    struct octaspire_dern_value_t *body;
    struct octaspire_dern_value_t *definitionEnvironment;
    octaspire_allocator_t         *allocator;
    bool                           howtoAllowed;
}
octaspire_dern_function_t;

octaspire_dern_function_t *octaspire_dern_function_new(
    struct octaspire_dern_value_t *formals,
    struct octaspire_dern_value_t *body,
    struct octaspire_dern_value_t *definitionEnvironment,
    octaspire_allocator_t  *allocator);

octaspire_dern_function_t *octaspire_dern_function_new_copy(
    octaspire_dern_function_t const * const other,
    struct octaspire_dern_vm_t * const vm,
    octaspire_allocator_t  *allocator);

void octaspire_dern_function_release(octaspire_dern_function_t *self);

bool octaspire_dern_function_is_equal(
    octaspire_dern_function_t const * const self,
    octaspire_dern_function_t const * const other);

int octaspire_dern_function_compare(
    octaspire_dern_function_t const * const self,
    octaspire_dern_function_t const * const other);

bool octaspire_dern_function_set_howto_data(
    octaspire_dern_function_t * const self,
    char const * const name,
    char const * const docstr,
    bool const howtoAllowed);

size_t octaspire_dern_function_get_number_of_required_arguments(
    octaspire_dern_function_t const * const self);

octaspire_string_t *octaspire_dern_function_are_all_formals_mentioned_in_docvec(
    octaspire_dern_function_t const * const self,
    octaspire_dern_value_t const * const docvec);

typedef struct octaspire_dern_special_t
{
    octaspire_dern_c_function          cFunction;
    octaspire_allocator_t      *allocator;
    octaspire_string_t *name;
    size_t                             numRequiredActualArguments;
    octaspire_string_t *docstr;
    bool                               howtoAllowed;
}
octaspire_dern_special_t;

octaspire_dern_special_t *octaspire_dern_special_new(
    octaspire_dern_c_function const cFunction,
    octaspire_allocator_t *allocator,
    char const * const name,
    size_t const numRequiredActualArguments,
    char const * const docstr,
    bool const howtoAllowed);

octaspire_dern_special_t *octaspire_dern_special_new_copy(
    octaspire_dern_special_t * const other,
    octaspire_allocator_t * const allocator);

void octaspire_dern_special_release(octaspire_dern_special_t *self);

size_t octaspire_dern_special_get_number_of_required_arguments(
    octaspire_dern_special_t const * const self);

bool octaspire_dern_special_is_howto_allowed(
    octaspire_dern_special_t const * const self);

octaspire_string_t *octaspire_dern_special_to_string(
    octaspire_dern_special_t const * const self,
    octaspire_allocator_t * const allocator);

typedef struct octaspire_dern_builtin_t
{
    octaspire_dern_c_function          cFunction;
    octaspire_allocator_t      *allocator;
    octaspire_string_t *name;
    size_t                             numRequiredActualArguments;
    octaspire_string_t *docstr;
    bool                               howtoAllowed;
}
octaspire_dern_builtin_t;

octaspire_dern_builtin_t *octaspire_dern_builtin_new(
    octaspire_dern_c_function const cFunction,
    octaspire_allocator_t *allocator,
    char const * const name,
    size_t const numRequiredActualArguments,
    char const * const docstr,
    bool const howtoAllowed);

octaspire_dern_builtin_t *octaspire_dern_builtin_new_copy(
    octaspire_dern_builtin_t * const other,
    octaspire_allocator_t * const allocator);

void octaspire_dern_builtin_release(octaspire_dern_builtin_t *self);

size_t octaspire_dern_builtin_get_number_of_required_arguments(
    octaspire_dern_builtin_t const * const self);

bool octaspire_dern_builtin_is_howto_allowed(
    octaspire_dern_builtin_t const * const self);

octaspire_string_t *octaspire_dern_builtin_to_string(
    octaspire_dern_builtin_t const * const self,
    octaspire_allocator_t * const allocator);



bool octaspire_dern_function_is_howto_allowed(
    octaspire_dern_function_t const * const self);

octaspire_string_t *octaspire_dern_function_to_string(
    octaspire_dern_function_t const * const self,
    octaspire_allocator_t * const allocator);

struct octaspire_dern_environment_t;

typedef struct octaspire_dern_error_message_t
{
    octaspire_allocator_t *allocator;
    octaspire_string_t    *message;
    size_t                 lineNumber;
}
octaspire_dern_error_message_t;

octaspire_dern_error_message_t *octaspire_dern_error_message_new(
    octaspire_allocator_t *allocator,
    char const * const message,
    size_t const lineNumber);

octaspire_dern_error_message_t *octaspire_dern_error_message_new_copy(
    octaspire_dern_error_message_t * const other,
    octaspire_allocator_t * const allocator);

void octaspire_dern_error_message_release(octaspire_dern_error_message_t *self);

int octaspire_dern_error_message_compare(
    octaspire_dern_error_message_t const * const self,
    octaspire_dern_error_message_t const * const other);


struct octaspire_dern_value_t
{
    octaspire_dern_value_t      *docstr;
    octaspire_dern_value_t      *docvec;
    struct octaspire_dern_vm_t  *vm;
    uintmax_t                    uniqueId;

    union
    {
        bool                                boolean;
        int32_t                             integer;
        double                              real;
        octaspire_string_t                  *string;
        octaspire_string_t                  *comment;
        octaspire_string_t                  *character;
        octaspire_string_t                  *symbol;
        octaspire_dern_error_message_t      *error;
        octaspire_vector_t                  *vector;
        octaspire_map_t                     *hashMap;
        octaspire_queue_t                   *queue;
        octaspire_list_t                    *list;
        struct octaspire_dern_environment_t *environment;
        octaspire_dern_function_t           *function;
        octaspire_dern_special_t            *special;
        octaspire_dern_builtin_t            *builtin;
        octaspire_dern_port_t               *port;
        octaspire_dern_c_data_t             *cData;
    }
    value;

    octaspire_dern_value_tag_t   typeTag;
    bool                         mark;
    bool                         howtoAllowed;
    char                         padding[2];
};

octaspire_dern_value_tag_t octaspire_dern_value_get_type(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_set(
    octaspire_dern_value_t  * const self,
    octaspire_dern_value_t  * const value);

bool octaspire_dern_value_set_collection(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t const * const indexOrKey,
    octaspire_dern_value_t * const value);

uint32_t octaspire_dern_value_get_hash(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_equal(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other);

bool octaspire_dern_value_is_less_than(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other);

bool octaspire_dern_value_is_greater_than(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other);

bool octaspire_dern_value_is_less_than_or_equal(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other);

bool octaspire_dern_value_is_greater_than_or_equal(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other);

octaspire_string_t *octaspire_dern_value_to_string(
    octaspire_dern_value_t const * const self,
    octaspire_allocator_t * const allocator);

octaspire_string_t *octaspire_dern_value_to_string_plain(
    octaspire_dern_value_t const * const self,
    octaspire_allocator_t * const allocator);

bool octaspire_dern_value_is_integer(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_real(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_number(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_nil(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_boolean(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_character(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_string(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_symbol(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_text(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_vector(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_hash_map(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_queue(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_list(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_port(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_environment(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_error(
    octaspire_dern_value_t const * const self);

void octaspire_dern_value_as_error_set_line_number(
    octaspire_dern_value_t const * const self,
    size_t const lineNumber);

char const *octaspire_dern_value_as_error_get_c_string(
    octaspire_dern_value_t const * const self);

struct octaspire_dern_environment_t *octaspire_dern_value_as_environment_get_value(
    octaspire_dern_value_t * const self);

struct octaspire_dern_environment_t const *octaspire_dern_value_as_environment_get_value_const(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_function(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_builtin(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_special(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_howto_allowed(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_c_data(
    octaspire_dern_value_t const * const self);

octaspire_dern_c_data_t *octaspire_dern_value_as_c_data_get_value(
    octaspire_dern_value_t * const self);

octaspire_dern_c_data_t const *octaspire_dern_value_as_c_data_get_value_const(
    octaspire_dern_value_t const * const self);

void octaspire_dern_value_print(
    octaspire_dern_value_t const * const self,
    octaspire_allocator_t *allocator);

uintmax_t octaspire_dern_value_get_unique_id(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_as_boolean_get_value(
    octaspire_dern_value_t const * const self);

int32_t octaspire_dern_value_as_integer_get_value(
    octaspire_dern_value_t const * const self);

void octaspire_dern_value_as_integer_set_value(
    octaspire_dern_value_t * const self,
    int32_t const value);

double octaspire_dern_value_as_real_get_value(
    octaspire_dern_value_t const * const self);

void octaspire_dern_value_as_real_set_value(
    octaspire_dern_value_t * const self,
    double const value);

void octaspire_dern_value_as_number_set_value(
    octaspire_dern_value_t * const self,
    double const value);

double octaspire_dern_value_as_number_get_value(
    octaspire_dern_value_t const * const self);

octaspire_dern_function_t *octaspire_dern_value_as_function(
    octaspire_dern_value_t * const self);

bool octaspire_dern_value_as_hash_map_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const toBeAdded1,
    octaspire_dern_value_t * const toBeAdded2);

bool octaspire_dern_value_as_hash_map_remove(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const keyValue);

bool octaspire_dern_value_as_queue_push(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const toBeAdded);

bool octaspire_dern_value_as_queue_pop(octaspire_dern_value_t * const self);

size_t octaspire_dern_value_as_queue_get_length(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_as_list_push_back(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const toBeAdded);

bool octaspire_dern_value_as_list_pop_back(octaspire_dern_value_t * const self);

bool octaspire_dern_value_as_list_pop_front(octaspire_dern_value_t * const self);

size_t octaspire_dern_value_as_list_get_length(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_as_character_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other);

bool octaspire_dern_value_as_character_subtract(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other);

bool octaspire_dern_value_as_integer_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other);

bool octaspire_dern_value_as_integer_subtract(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other);

bool octaspire_dern_value_as_real_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other);

bool octaspire_dern_value_as_real_subtract(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other);

char const *octaspire_dern_value_as_character_get_c_string(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_as_string_push_back(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const value);

bool octaspire_dern_value_as_symbol_push_back(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const value);

bool octaspire_dern_value_as_symbol_pop_back(
    octaspire_dern_value_t * const self);

bool octaspire_dern_value_as_symbol_pop_front(
    octaspire_dern_value_t * const self);

bool octaspire_dern_value_as_string_pop_back_ucs_character(
    octaspire_dern_value_t * const self);

bool octaspire_dern_value_as_string_pop_front_ucs_character(
    octaspire_dern_value_t * const self);

bool octaspire_dern_value_as_string_remove_all_substrings(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const value);

bool octaspire_dern_value_as_string_is_index_valid(
    octaspire_dern_value_t const * const self,
    ptrdiff_t const possiblyNegativeIndex);

char const *octaspire_dern_value_as_string_get_c_string(
    octaspire_dern_value_t const * const self);

size_t octaspire_dern_value_as_string_get_length_in_octets(
    octaspire_dern_value_t const * const self);

char const *octaspire_dern_value_as_symbol_get_c_string(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_symbol_and_equal_to_c_string(
    octaspire_dern_value_t const * const self,
    char const * const str);

bool octaspire_dern_value_as_symbol_is_equal_to_c_string(
    octaspire_dern_value_t const * const self,
    char const * const str);

bool octaspire_dern_value_as_text_is_equal_to_c_string(
    octaspire_dern_value_t const * const self,
    char const * const str);

char const *octaspire_dern_value_as_text_get_c_string(
    octaspire_dern_value_t const * const self);

size_t octaspire_dern_value_as_text_get_length_in_octets(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_as_vector_is_index_valid(
    octaspire_dern_value_t const * const self,
    ptrdiff_t const possiblyNegativeIndex);

size_t octaspire_dern_value_as_vector_get_length(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_as_vector_is_valid_index(
    octaspire_dern_value_t const * const self,
    ptrdiff_t const index);

bool octaspire_dern_value_as_vector_push_front_element(
    octaspire_dern_value_t *self,
    void const *element);

bool octaspire_dern_value_as_vector_push_back_element(
    octaspire_dern_value_t *self,
    void const *element);

bool octaspire_dern_value_as_vector_remove_element_at(
    octaspire_dern_value_t *self,
    ptrdiff_t const possiblyNegativeIndex);

bool octaspire_dern_value_as_vector_pop_back_element(octaspire_dern_value_t *self);

bool octaspire_dern_value_as_vector_pop_front_element(octaspire_dern_value_t *self);

octaspire_dern_value_t *octaspire_dern_value_as_vector_get_element_at(
    octaspire_dern_value_t * const self,
    ptrdiff_t const possiblyNegativeIndex);

octaspire_dern_value_t const *octaspire_dern_value_as_vector_get_element_at_const(
    octaspire_dern_value_t const * const self,
    ptrdiff_t const possiblyNegativeIndex);

octaspire_dern_value_t *octaspire_dern_value_as_vector_get_element_of_type_at(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_tag_t const typeTag,
    ptrdiff_t const possiblyNegativeIndex);

octaspire_dern_value_t const * octaspire_dern_value_as_vector_get_element_of_type_at_const(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_tag_t const typeTag,
    ptrdiff_t const possiblyNegativeIndex);

octaspire_dern_value_tag_t octaspire_dern_value_as_vector_get_element_type_at_const(
    octaspire_dern_value_t const * const self,
    ptrdiff_t const possiblyNegativeIndex);

octaspire_dern_value_t *octaspire_dern_value_as_list_get_element_at(
    octaspire_dern_value_t * const self,
    ptrdiff_t const possiblyNegativeIndex);

// TODO how about as_vector, should it have void* replaced with octaspire_dern_value_t*?
bool octaspire_dern_value_as_hash_map_put(
    octaspire_dern_value_t *self,
    uint32_t const hash,
    octaspire_dern_value_t const * const key,
    octaspire_dern_value_t *value);

size_t octaspire_dern_value_as_hash_map_get_number_of_elements(
    octaspire_dern_value_t const * const self);

octaspire_map_element_t *octaspire_dern_value_as_hash_map_get_at_index(
    octaspire_dern_value_t * const self,
    ptrdiff_t const possiblyNegativeIndex);

octaspire_map_element_t *octaspire_dern_value_as_hash_map_get(
    octaspire_dern_value_t * const self,
    uint32_t const hash,
    octaspire_dern_value_t const * const key);

octaspire_map_element_t const *octaspire_dern_value_as_hash_map_get_const(
    octaspire_dern_value_t const * const self,
    uint32_t const hash,
    octaspire_dern_value_t const * const key);

octaspire_dern_value_t *octaspire_dern_value_as_hash_map_get_value_for_symbol_key_using_c_string(
    octaspire_dern_value_t * const self,
    char const * const keySymbolsContentAsCString);

octaspire_dern_value_t const *
octaspire_dern_value_as_hash_map_get_value_for_symbol_key_using_c_string_const(
    octaspire_dern_value_t const * const self,
    char const * const keySymbolsContentAsCString);

size_t octaspire_dern_value_get_length(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_mark(octaspire_dern_value_t *self);

int octaspire_dern_value_compare(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other);

bool octaspire_dern_value_is_atom(octaspire_dern_value_t const * const self);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/dern/octaspire_dern_value.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/dern/octaspire_dern_helpers.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_HELPERS_H
#define OCTASPIRE_DERN_HELPERS_H

#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif


#ifdef __cplusplus
extern "C"       {
#endif

int octaspire_dern_helpers_compare_value_hash_maps(
    octaspire_map_t const * const firstValueHashMap,
    octaspire_map_t const * const otherValueHashMap);

double octaspire_dern_helpers_atof(
    char const * const str,
    octaspire_allocator_t * const allocator);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/dern/octaspire_dern_helpers.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/dern/octaspire_dern_environment.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_ENVIRONMENT_H
#define OCTASPIRE_DERN_ENVIRONMENT_H

#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif


#ifdef __cplusplus
extern "C"       {
#endif

struct octaspire_dern_vm_t;

typedef struct octaspire_dern_environment_t
{
    octaspire_map_t      *bindings;
    struct octaspire_dern_value_t       *enclosing;
    struct octaspire_dern_vm_t          *vm;
    octaspire_allocator_t        *allocator;
}
octaspire_dern_environment_t;

struct octaspire_dern_vm_t;

octaspire_dern_environment_t *octaspire_dern_environment_new(
    octaspire_dern_value_t *enclosing,
    struct octaspire_dern_vm_t *vm,
    octaspire_allocator_t *allocator);

octaspire_dern_environment_t *octaspire_dern_environment_new_copy(
    octaspire_dern_environment_t * const other,
    struct octaspire_dern_vm_t * const vm,
    octaspire_allocator_t * const allocator);

void octaspire_dern_environment_release(octaspire_dern_environment_t *self);

// Returns 0 or error
octaspire_dern_value_t *octaspire_dern_environment_extend(
    octaspire_dern_environment_t *self,
    octaspire_dern_value_t *formals,
    octaspire_dern_value_t *arguments);

octaspire_dern_value_t *octaspire_dern_environment_get(
    octaspire_dern_environment_t *self,
    octaspire_dern_value_t const * const key);

bool octaspire_dern_environment_set(
    octaspire_dern_environment_t *self,
    octaspire_dern_value_t const * const key,
    octaspire_dern_value_t *value);

octaspire_string_t *octaspire_dern_environment_to_string(
    octaspire_dern_environment_t const * const self);

bool octaspire_dern_environment_print(
    octaspire_dern_environment_t const * const self);

size_t octaspire_dern_environment_get_length(
    octaspire_dern_environment_t const * const self);

octaspire_map_element_t *octaspire_dern_environment_get_at_index(
    octaspire_dern_environment_t * const self,
    ptrdiff_t const index);

bool octaspire_dern_environment_mark(octaspire_dern_environment_t *self);

bool octaspire_dern_environment_is_equal(
    octaspire_dern_environment_t const * const self,
    octaspire_dern_environment_t const * const other);

int octaspire_dern_environment_compare(
    octaspire_dern_environment_t const * const self,
    octaspire_dern_environment_t const * const other);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/dern/octaspire_dern_environment.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/dern/octaspire_dern_lib.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_LIB_H
#define OCTASPIRE_DERN_LIB_H


#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif

#ifdef __cplusplus
extern "C"       {
#endif

typedef enum
{
    OCTASPIRE_DERN_LIB_TAG_SOURCE,
    OCTASPIRE_DERN_LIB_TAG_BINARY,
}
octaspire_dern_lib_tag_t;

typedef struct octaspire_dern_lib_t octaspire_dern_lib_t;
struct octaspire_dern_vm_t;

octaspire_dern_lib_t *octaspire_dern_lib_new_source(
    char const * const name,
    octaspire_input_t * const input,
    struct octaspire_dern_vm_t *vm,
    octaspire_allocator_t *allocator);

octaspire_dern_lib_t *octaspire_dern_lib_new_binary(
    char const * const name,
    char const * const fileName,
    struct octaspire_dern_vm_t *vm,
    octaspire_allocator_t *allocator);

void octaspire_dern_lib_release(octaspire_dern_lib_t *self);

bool octaspire_dern_lib_is_good(octaspire_dern_lib_t const * const self);

char const *octaspire_dern_lib_get_error_message(octaspire_dern_lib_t const * const self);

bool octaspire_dern_lib_mark_all(octaspire_dern_lib_t * const self);

void *octaspire_dern_lib_get_handle(octaspire_dern_lib_t * const self);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/dern/octaspire_dern_lib.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/dern/octaspire_dern_vm.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_VM_H
#define OCTASPIRE_DERN_VM_H


#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif


#ifdef __cplusplus
extern "C"       {
#endif

typedef octaspire_input_t*
    (*octaspire_dern_vm_custom_require_source_file_loader_t)(
            char const * const,
            octaspire_allocator_t * const allocator);

typedef struct octaspire_dern_vm_config_t
{
    octaspire_dern_vm_custom_require_source_file_loader_t preLoaderForRequireSrc;
    bool debugModeOn;
    bool noDlClose;
}
octaspire_dern_vm_config_t;

octaspire_dern_vm_config_t octaspire_dern_vm_config_default(void);

typedef struct octaspire_dern_vm_t octaspire_dern_vm_t;
struct octaspire_dern_value_t;

octaspire_dern_vm_t *octaspire_dern_vm_new(
    octaspire_allocator_t *allocator,
    octaspire_stdio_t *octaspireStdio);

octaspire_dern_vm_t *octaspire_dern_vm_new_with_config(
    octaspire_allocator_t *allocator,
    octaspire_stdio_t *octaspireStdio,
    octaspire_dern_vm_config_t const config);

void octaspire_dern_vm_release(octaspire_dern_vm_t *self);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_copy(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *valueToBeCopied);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_input_file(
    octaspire_dern_vm_t *self,
    char const * const path);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_output_file(
    octaspire_dern_vm_t *self,
    char const * const path);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_io_file(
    octaspire_dern_vm_t *self,
    char const * const path);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_nil(octaspire_dern_vm_t *self);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_boolean(
    octaspire_dern_vm_t *self,
    bool const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_integer(
    octaspire_dern_vm_t *self,
    int32_t const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_real(
    octaspire_dern_vm_t *self,
    double const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_string(
    octaspire_dern_vm_t *self,
    octaspire_string_t * const value);

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_string_format(
    octaspire_dern_vm_t *self,
    char const * const fmt,
    ...);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_string_from_c_string(
    octaspire_dern_vm_t *self,
    char const * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_character(
    octaspire_dern_vm_t *self,
    octaspire_string_t * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_character_from_uint32t(
    octaspire_dern_vm_t *self,
    uint32_t const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_symbol(
    octaspire_dern_vm_t *self,
    octaspire_string_t * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_symbol_from_c_string(
    octaspire_dern_vm_t *self,
    char const * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_error(
    octaspire_dern_vm_t *self,
    octaspire_string_t * const value);

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_error_format(
    octaspire_dern_vm_t *self,
    char const * const fmt,
    ...);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_error_from_c_string(
    octaspire_dern_vm_t *self,
    char const * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_vector_from_vector(
    octaspire_dern_vm_t *self,
    octaspire_vector_t * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_vector_from_values(
    octaspire_dern_vm_t *self,
    size_t const numArgs,
    ...);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_vector(
    octaspire_dern_vm_t *self);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_hash_map(
    octaspire_dern_vm_t *self);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_queue(
    octaspire_dern_vm_t *self);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_queue_with_max_length (
        octaspire_dern_vm_t * const self,
        size_t const maxLength);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_list(octaspire_dern_vm_t *self);

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_hash_map_from_hash_map(
    octaspire_dern_vm_t *self,
    octaspire_map_t * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_environment(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *enclosing);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_environment_from_environment(
    octaspire_dern_vm_t *self,
    octaspire_dern_environment_t * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_function(
    octaspire_dern_vm_t *self,
    octaspire_dern_function_t * const value,
    char const * const docstr,
    octaspire_vector_t *docVec);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_special(
    octaspire_dern_vm_t *self,
    octaspire_dern_special_t * const value,
    char const * const docstr);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_builtin(
    octaspire_dern_vm_t *self,
    octaspire_dern_builtin_t * const value,
    char const * const docstr);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_c_data(
    octaspire_dern_vm_t * const self,
    char const * const pluginName,
    char const * const typeNameForPayload,
    char const * const cleanUpCallbackName,
    char const * const stdLibLenCallbackName,
    char const * const stdLibLinkAtCallbackName,
    char const * const stdLibCopyAtCallbackName,
    bool const copyingAllowed,
    void * const payload);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_c_data_from_existing(
    octaspire_dern_vm_t * const self,
    octaspire_dern_c_data_t * const cData);

bool octaspire_dern_vm_push_value(octaspire_dern_vm_t *self, struct octaspire_dern_value_t *value);

bool octaspire_dern_vm_pop_value(
    octaspire_dern_vm_t *self,
    struct octaspire_dern_value_t *valueForBalanceCheck);

void const * octaspire_dern_vm_get_top_value(octaspire_dern_vm_t const * const self);

struct octaspire_dern_value_t *octaspire_dern_vm_peek_value(octaspire_dern_vm_t *self);

bool octaspire_dern_vm_gc(octaspire_dern_vm_t *self);

octaspire_dern_value_t *octaspire_dern_vm_parse(
    octaspire_dern_vm_t *self,
    octaspire_input_t *input);

octaspire_dern_value_t *octaspire_dern_vm_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value);

octaspire_dern_value_t *octaspire_dern_vm_call_lambda(
    octaspire_dern_vm_t * const self,
    octaspire_dern_function_t const * const function,
    octaspire_dern_value_t * const arguments,
    octaspire_dern_value_t * const environment);

octaspire_dern_value_t *octaspire_dern_vm_eval(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_read_from_octaspire_input_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    octaspire_input_t * const input);

octaspire_dern_value_t *octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    char const * const str);

octaspire_dern_value_t *octaspire_dern_vm_read_from_buffer_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    char const * const buffer,
    size_t const lengthInOctets);

octaspire_dern_value_t *octaspire_dern_vm_read_from_path_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    char const * const path);

octaspire_dern_value_t *octaspire_dern_vm_get_value_nil(
    octaspire_dern_vm_t *self);

octaspire_dern_value_t *octaspire_dern_vm_get_value_true(
    octaspire_dern_vm_t *self);

octaspire_dern_value_t *octaspire_dern_vm_get_value_false(
    octaspire_dern_vm_t *self);

octaspire_allocator_t *octaspire_dern_vm_get_allocator(
    octaspire_dern_vm_t *self);

void octaspire_dern_vm_set_exit_code(
    octaspire_dern_vm_t *self,
    int32_t const code);

int32_t octaspire_dern_vm_get_exit_code(
    octaspire_dern_vm_t const * const self);

bool octaspire_dern_vm_is_quit(
    octaspire_dern_vm_t const * const self);

void octaspire_dern_vm_quit(
    octaspire_dern_vm_t *self);

bool octaspire_dern_vm_create_and_register_new_builtin(
    octaspire_dern_vm_t * const self,
    char const * const name,
    octaspire_dern_c_function const funcPointer,
    size_t const numRequiredActualArguments,
    char const * const docStr,
    bool const howtoAllowed,
    octaspire_dern_environment_t * const targetEnv);

bool octaspire_dern_vm_create_and_register_new_special(
    octaspire_dern_vm_t * const self,
    char const * const name,
    octaspire_dern_c_function const funcPointer,
    size_t const numRequiredActualArguments,
    char const * const docStr,
    bool const howtoAllowed,
    octaspire_dern_environment_t * const targetEnv);

bool octaspire_dern_vm_create_and_define_new_integer(
    octaspire_dern_vm_t * const self,
    char const * const name,
    char const * const docstr,
    int32_t const value);

size_t octaspire_dern_vm_get_stack_length(
    octaspire_dern_vm_t const * const self);

void octaspire_dern_vm_print_stack(
    octaspire_dern_vm_t const * const self);

octaspire_dern_value_t *
octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
    octaspire_dern_vm_t * const self,
    octaspire_vector_t const * const vectorContainingSizeTs);

octaspire_dern_value_t *octaspire_dern_vm_find_from_value(
    octaspire_dern_vm_t * const self,
    octaspire_dern_value_t * const value,
    octaspire_dern_value_t const * const key);

octaspire_dern_value_t *octaspire_dern_vm_get_global_environment(
    octaspire_dern_vm_t *self);

octaspire_dern_value_t const *octaspire_dern_vm_get_global_environment_const(
    octaspire_dern_vm_t const * const self);

void  octaspire_dern_vm_set_user_data(octaspire_dern_vm_t * const self, void *userData);
void *octaspire_dern_vm_get_user_data(octaspire_dern_vm_t const * const self);

void octaspire_dern_vm_clear_value_to_nil(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value);

octaspire_dern_value_t *octaspire_dern_vm_get_function_return(
    octaspire_dern_vm_t * const self);

void octaspire_dern_vm_set_function_return(
    octaspire_dern_vm_t * const self,
    octaspire_dern_value_t * const value);

void octaspire_dern_vm_set_prevent_gc(octaspire_dern_vm_t * const self, bool const prevent);

void octaspire_dern_vm_set_gc_trigger_limit(
    octaspire_dern_vm_t * const self,
    size_t const numAllocs);

octaspire_dern_vm_custom_require_source_file_loader_t
octaspire_dern_vm_get_custom_require_source_file_pre_loader(
        octaspire_dern_vm_t * const self);

bool octaspire_dern_vm_add_library(
    octaspire_dern_vm_t *self,
    char const * const name,
    octaspire_dern_lib_t *library);

bool octaspire_dern_vm_has_library(
    octaspire_dern_vm_t const * const self,
    char const * const name);

octaspire_dern_lib_t *octaspire_dern_vm_get_library(
    octaspire_dern_vm_t * const self,
    char const * const name);

bool octaspire_dern_vm_add_command_line_argument(
    octaspire_dern_vm_t * const self,
    char const * const argument);

bool octaspire_dern_vm_add_environment_variable(
    octaspire_dern_vm_t * const self,
    char const * const variable);

octaspire_stdio_t *octaspire_dern_vm_get_stdio(octaspire_dern_vm_t * const self);

size_t octaspire_dern_vm_get_number_of_command_line_arguments(
    octaspire_dern_vm_t const * const self);

char const *octaspire_dern_vm_get_command_line_argument_at(
    octaspire_dern_vm_t const * const self,
    ptrdiff_t const index);

size_t octaspire_dern_vm_get_number_of_environment_variables(
    octaspire_dern_vm_t const * const self);

char const *octaspire_dern_vm_get_environment_variable_at(
    octaspire_dern_vm_t const * const self,
    ptrdiff_t const index);

octaspire_dern_vm_config_t const * octaspire_dern_vm_get_config_const(
    octaspire_dern_vm_t const * const self);

octaspire_dern_value_t *octaspire_dern_vm_parse_token(
    octaspire_dern_vm_t * const self,
    octaspire_dern_lexer_token_t const * const token,
    octaspire_input_t *input);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/dern/octaspire_dern_vm.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/include/octaspire/dern/octaspire_dern_stdlib.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_STDLIB_H
#define OCTASPIRE_DERN_STDLIB_H


#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#endif

#ifdef __cplusplus
extern "C"       {
#endif

octaspire_dern_value_t *octaspire_dern_vm_builtin_input_file_open(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_output_file_open(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_io_file_open(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_supports_output_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_supports_input_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_close(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_read(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_write(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_seek(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_dist(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_length(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_flush(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_not(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_abort(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_return(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_vector(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_and(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_or(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_do(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_exit(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_doc(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_len(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_read_and_eval_path(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_read_and_eval_string(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_string_format(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_to_string(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_to_integer(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_print(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_println(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_env_new(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_env_current(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_env_global(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus_equals_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_pop_back(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_pop_front(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_plus_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_plus_plus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus_minus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_mod(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_slash(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_times(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_plus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_find(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_split(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_hash_map(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_queue(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_queue_with_max_length(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_list(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_define(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_eval(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_quote(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_select(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_if(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_while(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_for(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

// TODO move to other builtins
octaspire_dern_value_t *octaspire_dern_vm_builtin_starts_with_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

// TODO move to other builtins
octaspire_dern_value_t *octaspire_dern_vm_builtin_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_equals_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_equals_equals_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_exclamation_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_less_than(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_greater_than(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_less_than_or_equal(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_greater_than_or_equal(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_fn(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_uid(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_ln_at_sign(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_cp_at_sign(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_require(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_integer_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_real_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_number_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_nil_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_boolean_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_character_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_string_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_symbol_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_vector_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_hash_map_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_copy(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_host_get_command_line_arguments(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_host_get_environment_variables(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_howto(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

#ifdef __cplusplus
/* extern "C" */ }
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/include/octaspire/dern/octaspire_dern_stdlib.h
//////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_dern_environment.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif


static octaspire_string_t *octaspire_dern_environment_private_to_string(
    octaspire_dern_environment_t const * const self,
    size_t const depth);

static int octaspire_dern_environment_helper_compare_function(
    void const * const a,
    void const * const b);

octaspire_dern_environment_t *octaspire_dern_environment_new(
    octaspire_dern_value_t *enclosing,
    octaspire_dern_vm_t *vm,
    octaspire_allocator_t *allocator)
{
    octaspire_dern_environment_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_environment_t));

    if (!self)
    {
        return 0;
    }

    self->allocator = allocator;
    self->vm        = vm;
    self->enclosing = enclosing;

    self->bindings  = octaspire_map_new(
        sizeof(octaspire_dern_value_t*),
        true,
        sizeof(octaspire_dern_value_t*),
        true,
        (octaspire_map_key_compare_function_t)octaspire_dern_value_is_equal,
        (octaspire_map_key_hash_function_t)octaspire_dern_value_get_hash,
        0,
        0,
        allocator);

    return self;
}

octaspire_dern_environment_t *octaspire_dern_environment_new_copy(
    octaspire_dern_environment_t * const other,
    struct octaspire_dern_vm_t * const vm,
    octaspire_allocator_t * const allocator)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_dern_environment_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_environment_t));

    if (!self)
    {
        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return 0;
    }

    self->allocator = allocator;
    self->vm        = vm;

    self->enclosing = octaspire_dern_vm_create_new_value_copy(vm, other->enclosing);


    self->bindings  = octaspire_map_new(
        sizeof(octaspire_dern_value_t*),
        true,
        sizeof(octaspire_dern_value_t*),
        true,
        (octaspire_map_key_compare_function_t)octaspire_dern_value_is_equal,
        (octaspire_map_key_hash_function_t)octaspire_dern_value_get_hash,
        0,
        0,
        allocator);

    octaspire_map_element_iterator_t iter =
        octaspire_map_element_iterator_init(other->bindings);

    do
    {
        if (iter.element)
        {
            octaspire_dern_value_t * const keyVal =
                octaspire_map_element_get_key(iter.element);

            octaspire_dern_value_t * const copyOfKeyVal =
                octaspire_dern_vm_create_new_value_copy(vm, keyVal);

            octaspire_dern_vm_push_value(vm, copyOfKeyVal);

            octaspire_dern_value_t * const valVal =
                octaspire_map_element_get_value(iter.element);

            octaspire_dern_value_t * const copyOfValVal =
                octaspire_dern_vm_create_new_value_copy(vm, valVal);

            octaspire_dern_vm_push_value(vm, copyOfValVal);

            octaspire_dern_vm_pop_value(vm, copyOfValVal);
            octaspire_dern_vm_pop_value(vm, copyOfKeyVal);

            if (octaspire_map_put(
                    self->bindings,
                    octaspire_dern_value_get_hash(copyOfKeyVal),
                    &copyOfKeyVal,
                    &copyOfValVal))
            {
                abort();
            }

        }
    }
    while (octaspire_map_element_iterator_next(&iter));


    octaspire_helpers_verify_true(
        stackLength == octaspire_dern_vm_get_stack_length(vm));

    return self;
}

void octaspire_dern_environment_release(octaspire_dern_environment_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_map_release(self->bindings);
    //octaspire_dern_environment_release(self->enclosing);
    octaspire_allocator_free(self->allocator, self);
}

// Returns 0 or error
octaspire_dern_value_t *octaspire_dern_environment_extend(
    octaspire_dern_environment_t *self,
    octaspire_dern_value_t *formals,
    octaspire_dern_value_t *arguments)
{
    assert(formals->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    assert(arguments->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_vector_t *formalsVec   = formals->value.vector;
    octaspire_vector_t *argumentsVec = arguments->value.vector;

    assert(formalsVec && argumentsVec);

    size_t const numFormalArgs   = octaspire_vector_get_length(formalsVec);

    size_t numDotArgs            = 0;
    size_t numNormalArgs         = 0;
    size_t numNormalArgsAfterDot = 0;

    for (size_t i = 0; i < numFormalArgs; ++i)
    {
        octaspire_dern_value_t *formal =
            octaspire_vector_get_element_at(formalsVec, (ptrdiff_t)i);

        assert(formal->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

        octaspire_string_t const * const formalAsStr = formal->value.string;

        if (octaspire_string_is_equal_to_c_string(formalAsStr, "..."))
        {
            ++numDotArgs;
        }
        else
        {
            if (numDotArgs)
            {
                ++numNormalArgsAfterDot;
            }
            else
            {
                ++numNormalArgs;
            }
        }
    }

    if (numDotArgs > 1)
    {
        return octaspire_dern_vm_create_new_value_error_format(
            self->vm,
            "Function can have only one formal ... argument for varargs. Now %zu were given.",
            numDotArgs);
    }

    if (numNormalArgsAfterDot > 0)
    {
        return octaspire_dern_vm_create_new_value_error_format(
            self->vm,
            "Function can have no formal arguments after ... "
            "for varargs. Now %zu formals were given after ...",
            numNormalArgsAfterDot);
    }

    if (numDotArgs)
    {
        assert(numNormalArgs);
        // for the vector name
        --numNormalArgs;
    }

    if (numDotArgs == 0 && numNormalArgs != numFormalArgs)
    {
        return octaspire_dern_vm_create_new_value_error_format(
            self->vm,
            "Number of formal and actual arguments must be equal for functions without "
            "varargs using the ...-formal. Now %zu formal and %zu actual arguments were given.",
            numFormalArgs,
            numNormalArgs);
    }

    size_t const numActualArgumentsGiven = octaspire_vector_get_length(argumentsVec);

    // If varargs, subtract 2 for the ... and the formal name before it.
    size_t const numArgumentsRequiredAtLeast = numFormalArgs - (numDotArgs ? 2 : 0);

    if (numActualArgumentsGiven < numArgumentsRequiredAtLeast)
    {
        return octaspire_dern_vm_create_new_value_error_format(
            self->vm,
            "Function expects %zu arguments. Now %zu arguments were given.",
            numArgumentsRequiredAtLeast,
            numActualArgumentsGiven);
    }

    for (size_t i = 0; i < numNormalArgs; ++i)
    {
        assert(i < octaspire_vector_get_length(formalsVec));
        assert(i < octaspire_vector_get_length(argumentsVec));

        octaspire_dern_value_t *formal =
            octaspire_vector_get_element_at(
                formalsVec,
                (ptrdiff_t)i);

        octaspire_dern_value_t *actual =
            octaspire_vector_get_element_at(
                argumentsVec,
                (ptrdiff_t)i);

        if (!octaspire_dern_environment_set(self, formal, actual))
        {
            abort();
        }
    }

    size_t const numActualRestArgs = numActualArgumentsGiven - numNormalArgs;

    if (numActualRestArgs)
    {
        if (numDotArgs != 1)
        {
            // TODO XXX better error message
            return octaspire_dern_vm_create_new_value_error_format(
                self->vm,
                "Function can have zero or one dot args. Now %zu dot-arguments were given.",
                numDotArgs);
        }

        octaspire_dern_value_t *formal = octaspire_vector_get_element_at(
            formalsVec,
            (ptrdiff_t)(octaspire_vector_get_length(formalsVec) - 2));

        octaspire_vector_t *actualVec =
            octaspire_vector_new_with_preallocated_elements(
                sizeof(octaspire_dern_value_t*),
                true,
                numNormalArgsAfterDot,
                0,
                self->allocator);

        octaspire_dern_value_t *actual =
            octaspire_dern_vm_create_new_value_vector_from_vector(self->vm, actualVec);

        //octaspire_dern_vm_push_value(self->vm, actual);

        for (size_t i = numNormalArgs;
             i < octaspire_vector_get_length(argumentsVec); ++i)
        {
            octaspire_dern_value_t *actualAfterDot =
                octaspire_vector_get_element_at(
                    argumentsVec,
                    (ptrdiff_t)i);

            if (!octaspire_vector_push_back_element(actualVec, &actualAfterDot))
            {
                abort();
            }
        }

        if (!octaspire_dern_environment_set(self, formal, actual))
        {
            abort();
        }
        //octaspire_dern_vm_pop_value(self->vm, actual); // actual
    }
    else if (numDotArgs > 0)
    {
        // Add empty rest-vector

        assert(numDotArgs == 1);

        octaspire_dern_value_t *formal = octaspire_vector_get_element_at(
            formalsVec,
            (ptrdiff_t)(octaspire_vector_get_length(formalsVec) - 2));

        octaspire_dern_value_t *actual = octaspire_dern_vm_create_new_value_vector(self->vm);

        //octaspire_dern_vm_push_value(self->vm, actual);

        if (!octaspire_dern_environment_set(self, formal, actual))
        {
            abort();
        }
        //octaspire_dern_vm_pop_value(self->vm, actual); // actual
    }

    return 0;
}

octaspire_dern_value_t *octaspire_dern_environment_get(
    octaspire_dern_environment_t *self,
    octaspire_dern_value_t const * const key)
{
    octaspire_map_element_t *element = octaspire_map_get(
        self->bindings,
        octaspire_dern_value_get_hash(key),
        &key);

    if (!element)
    {
        if (self->enclosing)
        {
            assert(self->enclosing->value.environment);
            return octaspire_dern_environment_get(self->enclosing->value.environment, key);
        }

        return 0;
    }

    return octaspire_map_element_get_value(element);
}

bool octaspire_dern_environment_set(
    octaspire_dern_environment_t *self,
    octaspire_dern_value_t const * const key,
    octaspire_dern_value_t *value)
{
    uint32_t const hash = octaspire_dern_value_get_hash(key);

    // TODO XXX should this be made more efficient? Now the element is searched
    // twice. There could be a method octaspire_map_put_overwriting etc.
    octaspire_map_remove(self->bindings, hash, &key);

    return octaspire_map_put(
        self->bindings,
        octaspire_dern_value_get_hash(key),
        &key,
        &value);
}

static int octaspire_dern_environment_helper_compare_function(
    void const * const a,
    void const * const b)
{
    octaspire_map_element_t const * const elemA =
        *(octaspire_map_element_t const * const *)a;

    octaspire_map_element_t const * const elemB =
        *(octaspire_map_element_t const * const *)b;

    octaspire_dern_value_t const * const keyA =
       (octaspire_dern_value_t*)octaspire_map_element_get_key(elemA);

    octaspire_dern_value_t const * const keyB =
       (octaspire_dern_value_t*)octaspire_map_element_get_key(elemB);

    return octaspire_dern_value_compare(keyA, keyB);
}

static octaspire_string_t *octaspire_dern_environment_private_to_string(
    octaspire_dern_environment_t const * const self,
    size_t const depth)
{
    octaspire_string_t *indent =
        octaspire_string_new("", self->allocator);

    for (size_t i = 0; i < depth; ++i)
    {
        octaspire_string_concatenate_c_string(indent, "\t");
    }

    octaspire_string_t *result = octaspire_string_new_format(
        self->allocator,
        "%s---------- environment ----------\n",
        octaspire_string_get_c_string(indent));

    if (self->enclosing)
    {
        octaspire_string_t *enclosing = octaspire_dern_environment_private_to_string(
            self->enclosing->value.environment,
            depth + 1);

        octaspire_string_concatenate_format(
            result,
            "%s",
            octaspire_string_get_c_string(enclosing));

        octaspire_string_release(enclosing);
        enclosing = 0;
    }

    octaspire_vector_t *sortVec = octaspire_vector_new(
        sizeof(octaspire_map_element_t*),
        true,
        0,
        self->allocator);

    size_t numCharsInLongestKey = 0;
    for (size_t i = 0; i < octaspire_map_get_number_of_elements(self->bindings); ++i)
    {
        octaspire_map_element_t const * const element =
            octaspire_map_get_at_index(
                self->bindings,
                (ptrdiff_t)i);

        assert(element);

        numCharsInLongestKey = octaspire_helpers_max_size_t(
            numCharsInLongestKey,
            octaspire_dern_value_get_length(octaspire_map_element_get_key(element)));

        if (!octaspire_vector_push_back_element(sortVec, &element))
        {
            abort();
        }
    }

    octaspire_vector_sort(
        sortVec,
        (octaspire_vector_element_compare_function_t)
            octaspire_dern_environment_helper_compare_function);

    for (size_t i = 0; i < octaspire_vector_get_length(sortVec); ++i)
    {
        octaspire_map_element_t const * const element =
            octaspire_vector_get_element_at(
                sortVec,
                (ptrdiff_t)i);

        octaspire_dern_value_t const * const key =
            octaspire_map_element_get_key(element);

        octaspire_dern_value_t const * const value =
            octaspire_map_element_get_value(element);

        octaspire_string_t *keyAsStr =
            octaspire_dern_value_to_string(key, self->allocator);

        octaspire_string_t *valueAsStr =
            octaspire_dern_value_to_string(value, self->allocator);

        octaspire_string_concatenate_format(
            result,
            "%s%-*s -> %s\n",
            octaspire_string_get_c_string(indent),
            (int)numCharsInLongestKey,
            octaspire_string_get_c_string(keyAsStr),
            octaspire_string_get_c_string(valueAsStr));

        octaspire_string_release(keyAsStr);
        keyAsStr = 0;

        octaspire_string_release(valueAsStr);
        valueAsStr = 0;
    }

    octaspire_string_concatenate_format(
        result,
        "%s---------------------------------\n",
        octaspire_string_get_c_string(indent));

    octaspire_string_release(indent);
    indent = 0;

    octaspire_vector_release(sortVec);
    sortVec = 0;

    return result;
}

octaspire_string_t *octaspire_dern_environment_to_string(
    octaspire_dern_environment_t const * const self)
{
    return octaspire_dern_environment_private_to_string(self, 0);
}

bool octaspire_dern_environment_print(
    octaspire_dern_environment_t const * const self)
{
    octaspire_string_t *str = octaspire_dern_environment_to_string(self);

    if (!str)
    {
        return false;
    }

    if (printf("%s", octaspire_string_get_c_string(str)) < 0)
    {
        return false;
    }

    return true;
}


size_t octaspire_dern_environment_get_length(
    octaspire_dern_environment_t const * const self)
{
    return octaspire_map_get_number_of_elements(self->bindings);
}

octaspire_map_element_t *octaspire_dern_environment_get_at_index(
    octaspire_dern_environment_t * const self,
    ptrdiff_t const index)
{
    return octaspire_map_get_at_index(self->bindings, index);
}

bool octaspire_dern_environment_mark(octaspire_dern_environment_t *self)
{
    if (!self)
    {
        return true;
    }

    bool statusKey = true;
    bool statusVal = true;

    octaspire_map_element_iterator_t iter =
        octaspire_map_element_iterator_init(self->bindings);

    while (iter.element)
    {
        octaspire_dern_value_t * const key =
            octaspire_map_element_get_key(iter.element);

        octaspire_dern_value_t * const val =
            octaspire_map_element_get_value(iter.element);

        statusKey = octaspire_dern_value_mark(key);
        statusVal = octaspire_dern_value_mark(val);

        octaspire_map_element_iterator_next(&iter);
    }

    if (self->enclosing && self->enclosing->value.environment != self)
    {
        return octaspire_dern_value_mark(self->enclosing) && statusKey && statusVal;
    }

    return true;
}

bool octaspire_dern_environment_is_equal(
    octaspire_dern_environment_t const * const self,
    octaspire_dern_environment_t const * const other)
{
    return (octaspire_dern_environment_compare(self, other) == 0);
}

int octaspire_dern_environment_compare(
    octaspire_dern_environment_t const * const self,
    octaspire_dern_environment_t const * const other)
{
    return octaspire_dern_helpers_compare_value_hash_maps(
        self->bindings,
        other->bindings);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_dern_environment.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_dern_lexer.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif

struct octaspire_dern_lexer_token_t
{
    octaspire_allocator_t                 *allocator;
    octaspire_dern_lexer_token_position_t *line;
    octaspire_dern_lexer_token_position_t *column;
    octaspire_dern_lexer_token_position_t *ucsIndex;

    union
    {
        octaspire_string_t *string;
        octaspire_string_t *character;
        octaspire_string_t *comment;
        octaspire_string_t *symbol;
        octaspire_string_t *error;
        octaspire_string_t *moreInputRequired;
        int32_t             integer;
        double              real;
    }
    value;

    octaspire_dern_lexer_token_tag_t typeTag;
    char                             padding[4];
};

static char const * const octaspire_dern_lexer_private_token_tag_types_as_c_strings[] =
{
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT"
};

void octaspire_dern_lexer_private_pop_whitespace(
    octaspire_input_t *input);

void octaspire_dern_lexer_private_pop_rest_of_line(
    octaspire_input_t *input);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_multiline_comment(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_left_parenthesis(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_right_parenthesis(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_quote(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_integer_or_real_number(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_string(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_character(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_true_or_false_or_nil_or_symbol(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

bool octaspire_dern_lexer_private_is_delimeter(uint32_t const c);



octaspire_dern_lexer_token_position_t octaspire_dern_lexer_token_position_init(
    size_t const start, size_t const end)
{
    octaspire_dern_lexer_token_position_t result;
    result.start = start;
    result.end   = end;
    return result;
}

bool octaspire_dern_lexer_token_position_is_equal(
    octaspire_dern_lexer_token_position_t const * const self,
    octaspire_dern_lexer_token_position_t const * const other)
{
    return self->start == other->start &&
           self->end   == other->end;
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_token_new(
    octaspire_dern_lexer_token_tag_t const typeTag,
    void const * const value,
    octaspire_dern_lexer_token_position_t const line,
    octaspire_dern_lexer_token_position_t const column,
    octaspire_dern_lexer_token_position_t const ucsIndex,
    octaspire_allocator_t *allocator)
{
    octaspire_dern_lexer_token_t *self = octaspire_allocator_malloc(
        allocator,
        sizeof(octaspire_dern_lexer_token_t));

    if (!self)
    {
        return self;
    }

    self->allocator = allocator;

    self->line =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_lexer_token_position_t));

    self->column =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_lexer_token_position_t));

    self->ucsIndex =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_lexer_token_position_t));

    if (!self->line || !self->column || !self->ucsIndex)
    {
        octaspire_dern_lexer_token_release(self);
        self = 0;
        return 0;
    }

    self->line->start = line.start;
    self->line->end   = line.end;

    self->column->start = column.start;
    self->column->end   = column.end;

    self->ucsIndex->start = ucsIndex.start;
    self->ucsIndex->end   = ucsIndex.end;

    self->typeTag   = typeTag;

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL:
        {
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER:
        {
            self->value.integer = *(int32_t const * const)value;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL:
        {
            self->value.real = *(double const * const)value;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING:
        {
            self->value.string = octaspire_string_new(
                (char const * const)value,
                allocator);

            if (!self->value.string)
            {
                octaspire_dern_lexer_token_release(self);
                self = 0;
                return 0;
            }

            octaspire_helpers_verify_true(
                octaspire_string_get_error_status(self->value.string) ==
                OCTASPIRE_STRING_ERROR_STATUS_OK);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT:
        {
            self->value.comment = octaspire_string_new(
                (char const * const)value,
                allocator);

            if (!self->value.comment)
            {
                octaspire_dern_lexer_token_release(self);
                self = 0;
                return 0;
            }

            octaspire_helpers_verify_true(
                octaspire_string_get_error_status(self->value.comment) ==
                OCTASPIRE_STRING_ERROR_STATUS_OK);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED:
        {
            self->value.moreInputRequired = octaspire_string_new(
                (char const * const)value,
                allocator);

            if (!self->value.moreInputRequired)
            {
                octaspire_dern_lexer_token_release(self);
                self = 0;
                return 0;
            }

            octaspire_helpers_verify_true(
                octaspire_string_get_error_status(self->value.moreInputRequired) ==
                OCTASPIRE_STRING_ERROR_STATUS_OK);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER:
        {
            self->value.character = octaspire_string_new(
                (char const * const)value,
                allocator);

            if (!self->value.character)
            {
                octaspire_dern_lexer_token_release(self);
                self = 0;
                return 0;
            }

            octaspire_helpers_verify_true(
                octaspire_string_get_error_status(self->value.character) ==
                OCTASPIRE_STRING_ERROR_STATUS_OK);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL:
        {
            self->value.symbol = octaspire_string_new(
                (char const * const)value,
                allocator);

            if (!self->value.symbol)
            {
                octaspire_dern_lexer_token_release(self);
                self = 0;
                return 0;
            }

            octaspire_helpers_verify_true(
                octaspire_string_get_error_status(self->value.symbol) ==
                OCTASPIRE_STRING_ERROR_STATUS_OK);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR:
        {
            self->value.error = octaspire_string_new(
                (char const * const)value,
                allocator);

            if (!self->value.error)
            {
                octaspire_dern_lexer_token_release(self);
                self = 0;
                return 0;
            }

            octaspire_helpers_verify_true(
                octaspire_string_get_error_status(self->value.error) ==
                OCTASPIRE_STRING_ERROR_STATUS_OK);
        }
        break;
    }

    return self;
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_token_new_format(
    octaspire_dern_lexer_token_tag_t const typeTag,
    octaspire_dern_lexer_token_position_t const line,
    octaspire_dern_lexer_token_position_t const column,
    octaspire_dern_lexer_token_position_t const ucsIndex,
    octaspire_allocator_t *allocator,
    void const * const format,
    ...)
{
    va_list arguments;
    va_start(arguments, format);
    octaspire_string_t *str = octaspire_string_new_vformat(
        allocator,
        format,
        arguments);
    va_end(arguments);

    assert(
        typeTag == OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING ||
        typeTag == OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR);

    octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
        typeTag,
        octaspire_string_get_c_string(str),
        line,
        column,
        ucsIndex,
        allocator);

    octaspire_string_release(str);
    str = 0;

    return result;
}


void octaspire_dern_lexer_token_release(
    octaspire_dern_lexer_token_t *self)
{
    if (!self)
    {
        return;
    }

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING:
        {
            octaspire_string_release(self->value.string);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER:
        {
            octaspire_string_release(self->value.character);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL:
        {
            octaspire_string_release(self->value.symbol);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR:
        {
            octaspire_string_release(self->value.error);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED:
        {
            octaspire_string_release(self->value.moreInputRequired);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT:
        {
            octaspire_string_release(self->value.comment);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL:
        {
            // Nothing to be done here
        }
        break;
    }

    octaspire_allocator_free(self->allocator, self->line);
    self->line = 0;

    octaspire_allocator_free(self->allocator, self->column);
    self->column = 0;

    octaspire_allocator_free(self->allocator, self->ucsIndex);
    self->ucsIndex = 0;

    octaspire_allocator_free(self->allocator, self);
}

octaspire_dern_lexer_token_tag_t octaspire_dern_lexer_token_get_type_tag(
    octaspire_dern_lexer_token_t const * const self)
{
    assert(self);
    return self->typeTag;
}

char const *octaspire_dern_lexer_token_get_type_tag_as_c_string(
    octaspire_dern_lexer_token_t const * const self)
{
    octaspire_dern_lexer_token_tag_t const tag = octaspire_dern_lexer_token_get_type_tag(self);

    assert(
        (size_t)tag <
            (sizeof(octaspire_dern_lexer_private_token_tag_types_as_c_strings) /
                sizeof(octaspire_dern_lexer_private_token_tag_types_as_c_strings[0])));

    return octaspire_dern_lexer_private_token_tag_types_as_c_strings[tag];
}

char const *octaspire_dern_lexer_token_get_string_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self)
{
    return octaspire_string_get_c_string(self->value.string);
}

char const *octaspire_dern_lexer_token_get_character_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self)
{
    return octaspire_string_get_c_string(self->value.character);
}

char const *octaspire_dern_lexer_token_get_symbol_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self)
{
    return octaspire_string_get_c_string(self->value.symbol);
}

int32_t octaspire_dern_lexer_token_get_integer_value(
    octaspire_dern_lexer_token_t const * const self)
{
    return self->value.integer;
}

double octaspire_dern_lexer_token_get_real_value(
    octaspire_dern_lexer_token_t const * const self)
{
    return self->value.real;
}

char const *octaspire_dern_lexer_token_get_error_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self)
{
    return octaspire_string_get_c_string(self->value.error);
}

char const *octaspire_dern_lexer_token_get_multiline_comment_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self)
{
    return octaspire_string_get_c_string(self->value.comment);
}

octaspire_dern_lexer_token_position_t *octaspire_dern_lexer_token_get_position_line(
    octaspire_dern_lexer_token_t const * const self)
{
    return self->line;
}

octaspire_dern_lexer_token_position_t *octaspire_dern_lexer_token_get_position_column(
    octaspire_dern_lexer_token_t const * const self)
{
    return self->column;
}

octaspire_dern_lexer_token_position_t *octaspire_dern_lexer_token_get_position_ucs_index(
    octaspire_dern_lexer_token_t const * const self)
{
    return self->ucsIndex;
}

bool octaspire_dern_lexer_token_is_equal(
    octaspire_dern_lexer_token_t const * const self,
    octaspire_dern_lexer_token_t const * const other)
{
    if (self->allocator != other->allocator)
    {
        return false;
    }

    if (!octaspire_dern_lexer_token_position_is_equal(self->line, other->line))
    {
        return false;
    }

    if (!octaspire_dern_lexer_token_position_is_equal(self->column, other->column))
    {
        return false;
    }

    if (!octaspire_dern_lexer_token_position_is_equal(self->ucsIndex, other->ucsIndex))
    {
        return false;
    }

    if (self->typeTag != other->typeTag)
    {
        return false;
    }

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING:
        {
            return octaspire_string_is_equal(
                self->value.string,
                other->value.string);
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER:
        {
            return octaspire_string_is_equal(
                self->value.character,
                other->value.character);
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL:
        {
            return octaspire_string_is_equal(
                self->value.symbol,
                other->value.symbol);
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR:
        {
            return octaspire_string_is_equal(self->value.error, other->value.error);
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED:
        {
            return octaspire_string_is_equal(
                self->value.moreInputRequired,
                other->value.moreInputRequired);
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER:
        {
            return self->value.integer == other->value.integer;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL:
        {
            // To prevent clang compiler warning on level
            // -Weverything without using #pragma
            return (self->value.real >= other->value.real) &&
                   (self->value.real <= other->value.real);
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT:
        {
            return octaspire_string_is_equal(
                self->value.comment,
                other->value.comment);
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL:
        {
            return true;
        }
    }

    abort();
    return false;
}

octaspire_string_t *octaspire_dern_lexer_token_to_string(
    octaspire_dern_lexer_token_t const * const self)
{
    assert(self);

    octaspire_string_t *result = octaspire_string_new_format(
        (void*)self->allocator,
        "token: line=%zu,%zu column=%zu,%zu ucsIndex=%zu,%zu type=%s value=",
        self->line->start, self->line->end,
        self->column->start, self->column->end,
        self->ucsIndex->start, self->ucsIndex->end,
        octaspire_dern_lexer_token_get_type_tag_as_c_string(self));

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN:
        {
            if (!octaspire_string_concatenate_c_string(result, "left parenthesis"))
            {
                return 0;
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN:
        {
            if (!octaspire_string_concatenate_c_string(result, "right parenthesis"))
            {
                return 0;
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE:
        {
            if (!octaspire_string_concatenate_c_string(result, "quote"))
            {
                return 0;
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE:
        {
            if (!octaspire_string_concatenate_c_string(result, "true"))
            {
                return 0;
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE:
        {
            if (!octaspire_string_concatenate_c_string(result, "false"))
            {
                return 0;
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL:
        {
            if (!octaspire_string_concatenate_c_string(result, "nil"))
            {
                return 0;
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER:
        {
            if (!octaspire_string_concatenate_format(
                result,
                "integer %" PRId32 "",
                self->value.integer))
            {
                return 0;
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL:
        {
            if (!octaspire_string_concatenate_format(
                result,
                "real %g",
                self->value.real))
            {
                return 0;
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING:
        {
            if (!octaspire_string_concatenate_format(
                result,
                "[%s]",
                octaspire_string_get_c_string(self->value.string)))
            {
                return 0;
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER:
        {
            if (octaspire_string_is_equal_to_c_string(self->value.character, "|"))
            {
                if (!octaspire_string_concatenate_c_string(result, "|bar|"))
                {
                    return 0;
                }
            }
            else if (octaspire_string_is_equal_to_c_string(
                self->value.character,
                "\n"))
            {
                if (!octaspire_string_concatenate_c_string(result, "|newline|"))
                {
                    return 0;
                }
            }
            else if (octaspire_string_is_equal_to_c_string(
                self->value.character,
                "\t"))
            {
                if (!octaspire_string_concatenate_c_string(result, "|tab|"))
                {
                    return 0;
                }
            }
            else if (octaspire_string_is_equal_to_c_string(
                self->value.character,
                "["))
            {
                if (!octaspire_string_concatenate_c_string(result, "|string-start|"))
                {
                    return 0;
                }
            }
            else if (octaspire_string_is_equal_to_c_string(
                self->value.character,
                "]"))
            {
                if (!octaspire_string_concatenate_c_string(result, "|string-end|"))
                {
                    return 0;
                }
            }
            else
            {
                if (!octaspire_string_concatenate_format(
                            result,
                            "|%s|",
                            octaspire_string_get_c_string(self->value.character)))
                {
                    return 0;
                }
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL:
        {
            if (!octaspire_string_concatenate_format(
                result,
                "%s",
                octaspire_string_get_c_string(self->value.symbol)))
            {
                return 0;
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR:
        {
            if (!octaspire_string_concatenate_format(
                result,
                "error: %s",
                octaspire_string_get_c_string(self->value.error)))
            {
                return 0;
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT:
        {
            if (!octaspire_string_concatenate_format(
                result,
                "%s",
                octaspire_string_get_c_string(self->value.comment)))
            {
                return 0;
            }

            return result;
        }

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED:
        {
            if (!octaspire_string_concatenate_format(
                result,
                "more input required: %s",
                octaspire_string_get_c_string(self->value.moreInputRequired)))
            {
                return 0;
            }

            return result;
        }
    }

    if (!octaspire_string_concatenate_format(
        result,
        "unknown token type %i",
        (int)self->typeTag))
    {
        return 0;
    }

    return result;
}

void octaspire_dern_lexer_token_print(
    octaspire_dern_lexer_token_t const * const self)
{
    octaspire_string_t *str = octaspire_dern_lexer_token_to_string(self);
    printf("%s\n", octaspire_string_get_c_string(str));
    octaspire_string_release(str);
    str = 0;
}

void octaspire_dern_lexer_private_pop_whitespace(
    octaspire_input_t *input)
{
    while (octaspire_input_is_good(input))
    {
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (!isspace((int const)c))
        {
            break;
        }

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }
    }
}

void octaspire_dern_lexer_private_pop_rest_of_line(
    octaspire_input_t *input)
{
    while (octaspire_input_is_good(input))
    {
        if (octaspire_input_peek_next_ucs_character(input) == '\n')
        {
            if (!octaspire_input_pop_next_ucs_character(input))
            {
                abort();
            }

            return;
        }

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }
    }
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_multiline_comment(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    if (octaspire_input_peek_next_ucs_character(input) != '#')
    {
        size_t const endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Number sign '#' expected to start multiline comment",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }

    if (!octaspire_input_pop_next_ucs_character(input))
    {
        abort();
    }

    if (octaspire_input_peek_next_ucs_character(input) != '!')
    {
        size_t const endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Exclamation mark '!' expected after '#' to start multiline comment",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }

    if (!octaspire_input_pop_next_ucs_character(input))
    {
        abort();
    }

    octaspire_string_t *commentStr =
        octaspire_string_new("", allocator);

    while (octaspire_input_is_good(input))
    {
        uint32_t currentChar = octaspire_input_peek_next_ucs_character(input);

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }

        if (currentChar == '!')
        {
            if (!octaspire_input_is_good(input))
            {
                octaspire_string_release(commentStr);
                commentStr = 0;

                size_t const endIndexInInput  = octaspire_input_get_ucs_character_index(input) - 1;
                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED,
                    "Number sign '#' expected after '!' to close multiline comment",
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startIndexInInput,
                        endIndexInInput),
                    allocator);
            }

            currentChar = octaspire_input_peek_next_ucs_character(input);

            if (currentChar == '#')
            {
                if (!octaspire_input_pop_next_ucs_character(input))
                {
                    abort();
                }

                octaspire_string_release(commentStr);
                commentStr = 0;

                // Multiline comment was lexed OK. Return 0 instead of a new
                // lexer token, because comments should not leave the lexer.
                return 0;
            }
            else
            {
                octaspire_string_push_back_ucs_character(commentStr, currentChar);
            }
        }
        else
        {
            octaspire_string_push_back_ucs_character(commentStr, currentChar);
        }
    }

    octaspire_string_release(commentStr);
    commentStr = 0;

    size_t const endIndexInInput  = octaspire_input_get_ucs_character_index(input) - 1;
    return octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED,
        "Multiline comment that is not closed with !#",
        octaspire_dern_lexer_token_position_init(
            startLine,
            octaspire_input_get_line_number(input)),
        octaspire_dern_lexer_token_position_init(
            startColumn,
            octaspire_input_get_column_number(input)),
        octaspire_dern_lexer_token_position_init(
            startIndexInInput,
            endIndexInInput),
        allocator);
}

bool octaspire_dern_lexer_private_is_delimeter(uint32_t const c)
{
    return (
        isspace(c) ||
        c == '|'   ||
        c == '['   ||
        c == ']'   ||
        c == '('   ||
        c == ')'   ||
        c == '\''  ||
        c == '\n'
    );
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_left_parenthesis(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   endIndexInInput = startIndexInInput;

    if (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (c == '(')
        {
            octaspire_dern_lexer_token_t * result = octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
                0,
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);

            if (!octaspire_input_pop_next_ucs_character(input))
            {
                abort();
            }

            return result;
        }
        else
        {
            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Left parenthesis '(' expected",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
    }
    else
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Left parenthesis '(' expected",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_right_parenthesis(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   endIndexInInput = startIndexInInput;

    if (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (c == ')')
        {
            octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN,
                0,
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);

            if (!octaspire_input_pop_next_ucs_character(input))
            {
                abort();
            }

            return result;
        }
        else
        {
            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Right parenthesis ')' expected",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
    }
    else
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Right parenthesis ')' expected",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_quote(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   endIndexInInput = startIndexInInput;

    if (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (c == '\'')
        {
            octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE,
                0,
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);

            if (!octaspire_input_pop_next_ucs_character(input))
            {
                abort();
            }

            return result;
        }
        else
        {
            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Quote ' expected",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
    }
    else
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Quote ' expected",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }
}

static octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_expect_octet(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput,
    char const * const sourceName,
    char const * const expected,
    uint32_t * octetRead)
{
    size_t   endIndexInInput = startIndexInInput;

    // Read one octet.
    if (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (!strchr(expected, c))
        {
            return octaspire_dern_lexer_token_new_format(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                allocator,
                "%s: one of octets '%s' expected. Instead '%c' was found.",
                sourceName,
                expected,
                (char)c);
        }

        *octetRead = c;

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }

        return 0;
    }
    else
    {
        return octaspire_dern_lexer_token_new_format(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator,
            "%s: one of octets '%s' expected",
            sourceName,
            expected);
    }
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_integer_or_real_number(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   charsRead       = 0;
    bool     dotRead         = false;

    size_t   endIndexInInput = startIndexInInput;
    size_t   endColumn       = startColumn;

    double   factor          = 1;
    size_t   base            = 10;
    uint32_t prevChar        = 0;

    char digits[256]         = {'\0'};
    size_t nextDigitIndex    = 0;

    uint32_t octetRead       = 0;

    // Read '{'
    octaspire_dern_lexer_token_t * potentialError =
        octaspire_dern_lexer_private_expect_octet(
            input,
            allocator,
            startLine,
            startColumn,
            startIndexInInput,
            "Number",
            "{",
            &octetRead);

    if (potentialError)
    {
        return potentialError;
    }

    // Read 'X', 'D','O' or 'B'
    potentialError =
        octaspire_dern_lexer_private_expect_octet(
            input,
            allocator,
            startLine,
            startColumn,
            startIndexInInput,
            "Number",
            "XDOB",
            &octetRead);

    if (potentialError)
    {
        return potentialError;
    }

    switch (octetRead)
    {
        case 'X': { base = 16; } break;
        case 'D': { base = 10; } break;
        case 'O': { base =  8; } break;
        case 'B': { base =  2; } break;
    }

    // Read '+' or '-'
    potentialError =
        octaspire_dern_lexer_private_expect_octet(
            input,
            allocator,
            startLine,
            startColumn,
            startIndexInInput,
            "Number",
            "+-",
            &octetRead);

    if (potentialError)
    {
        return potentialError;
    }

    factor = (octetRead == '-') ? -1 : 1;

    while (octaspire_input_is_good(input))
    {
        // Spaces can be used to make the number more readable,
        // for example {D+100 000 000}.
        octaspire_dern_lexer_private_pop_whitespace(input);

        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (c == '.')
        {
            if (dotRead)
            {
                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "Number can contain only one '.' character",
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startIndexInInput,
                        endIndexInInput),
                    allocator);
            }

            if (charsRead == 0)
            {
                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "Character '.' cannot start a number",
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startIndexInInput,
                        endIndexInInput),
                    allocator);
            }

            dotRead = true;
        }
        else if (isxdigit((int const)c))
        {
            if (dotRead)
            {
                factor /= base;
            }

            if (nextDigitIndex >= 256)
            {
                abort();
            }

            if (base == 2)
            {
                if (c != '0' && c != '1')
                {
                    return octaspire_dern_lexer_token_new(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        "Binary number can contain only '0' and '1' digits.",
                        octaspire_dern_lexer_token_position_init(
                            startLine,
                            octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startColumn,
                            octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startIndexInInput,
                            endIndexInInput),
                        allocator);
                }
            }
            else if (base == 8)
            {
                if (c != '0' && c != '1' && c != '2' && c != '3' && c != '4' &&
                    c != '5' && c != '6' && c != '7')
                {
                    return octaspire_dern_lexer_token_new(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        "Octal number can contain only digits '0' - '7'.",
                        octaspire_dern_lexer_token_position_init(
                            startLine,
                            octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startColumn,
                            octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startIndexInInput,
                            endIndexInInput),
                        allocator);
                }
            }
            else if (base == 10)
            {
                if (c != '0' && c != '1' && c != '2' && c != '3' && c != '4' &&
                    c != '5' && c != '6' && c != '7' && c != '8' && c != '9')
                {
                    return octaspire_dern_lexer_token_new(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        "Decimal number can contain only digits '0' - '9'.",
                        octaspire_dern_lexer_token_position_init(
                            startLine,
                            octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startColumn,
                            octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startIndexInInput,
                            endIndexInInput),
                        allocator);
                }
            }

            digits[nextDigitIndex] = c;
            ++nextDigitIndex;
        }
        else if (c == '}')
        {
            endColumn = octaspire_input_get_column_number(input);

            if (!octaspire_input_pop_next_ucs_character(input))
            {
                abort();
            }

            ++charsRead;
            break;
        }
        else
        {
            return octaspire_dern_lexer_token_new_format(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator,
                "Number cannot contain character '%c'",
                c);
        }

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }

        ++charsRead;

        if (c != ' ')
        {
            // ' ' could hide case where number has . or - as
            // last non-whitespace octet.
            prevChar = c;
        }
    }

    if (prevChar == '.')
    {
        return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Character '.' cannot end a number",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    endColumn),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
    }

    if (prevChar == '-')
    {
        return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Character '-' cannot end a number",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    endColumn),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
    }

    size_t value = 0;

    for (size_t i = 0; i < nextDigitIndex; ++i)
    {
        char const c = digits[nextDigitIndex - 1 - i];

        if (c >= '0' && c <= '9')
        {
            value += (pow(base, i) * (c - '0'));
        }
        else
        {
            value += (pow(base, i) * (10 + (tolower(c) - 'a')));
        }
    }

    if (dotRead)
    {
        double const resultValue = (double)value * factor;

        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL,
            &resultValue,
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                endColumn),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }

    int32_t const resultValue = (int32_t)value * factor;

    return octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER,
        &resultValue,
        octaspire_dern_lexer_token_position_init(
            startLine,
            octaspire_input_get_line_number(input)),
        octaspire_dern_lexer_token_position_init(
            startColumn,
            endColumn),
        octaspire_dern_lexer_token_position_init(
            startIndexInInput,
            endIndexInInput),
        allocator);
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_string(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   charsRead       = 0;
    bool     lastDelimiterRead = false;
    bool     endsInDelimiter = false;

    size_t   endIndexInInput = startIndexInInput;

    octaspire_string_t *tmpStr =
        octaspire_string_new("", allocator);

    if (!tmpStr)
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Memory allocation failed",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);
    }

    while (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t c = octaspire_input_peek_next_ucs_character(input);

        if (lastDelimiterRead)
        {
            if (octaspire_dern_lexer_private_is_delimeter(c))
            {
                --endIndexInInput;
                endsInDelimiter = true;
                break;
            }
            else
            {
                octaspire_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "After last ']' of string there must be dern delimiter",
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                    allocator);
            }
        }

        if (charsRead == 0)
        {
            if (c == '[')
            {
            }
            else
            {
                octaspire_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "String must begin with character '['",
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                    allocator);
            }
        }
        else
        {
            if (c == ']')
            {
                lastDelimiterRead = true;
            }
            else if (c == '|')
            {
                octaspire_dern_lexer_token_t *charToken =
                    octaspire_dern_lexer_private_pop_character(
                        input,
                        allocator,
                        startLine,
                        startColumn,
                        startIndexInInput);

                if (!charToken)
                {
                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    return octaspire_dern_lexer_token_new(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        "Problem with a character embedded in string: (character is not complete)",
                        octaspire_dern_lexer_token_position_init(
                            startLine,
                            octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startColumn, octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startIndexInInput,
                            endIndexInInput),
                        allocator);
                }

                if (octaspire_dern_lexer_token_get_type_tag(charToken) ==
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR)
                {
                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new_format(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        octaspire_dern_lexer_token_position_init(
                            startLine,
                            octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startColumn,
                            octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startIndexInInput,
                            endIndexInInput),
                        allocator,
                        "Problem with a character embedded in string: (%s)",
                        octaspire_dern_lexer_token_get_error_value_as_c_string(charToken));

                    octaspire_dern_lexer_token_release(charToken);
                    charToken = 0;

                    return result;
                }

                // TODO check that char available
                c = octaspire_string_get_ucs_character_at_index(
                    charToken->value.character,
                    0);

                if (!octaspire_string_push_back_ucs_character(tmpStr, c))
                {
                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    octaspire_dern_lexer_token_release(charToken);
                    charToken = 0;

                    return octaspire_dern_lexer_token_new(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        "Memory allocation failed",
                        octaspire_dern_lexer_token_position_init(
                            startLine,
                            octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startColumn,
                            octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startIndexInInput,
                            endIndexInInput),
                        allocator);
                }

                octaspire_dern_lexer_token_release(charToken);
                charToken = 0;
                // TODO should charsRead be incremented by some amount? (length of embedded string,
                // including the ||, etc.)
                goto loopEnd;
            }
            else
            {
                if (!octaspire_string_push_back_ucs_character(tmpStr, c))
                {
                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    return octaspire_dern_lexer_token_new(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        "Memory allocation failed",
                        octaspire_dern_lexer_token_position_init(
                            startLine,
                            octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startColumn,
                            octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startIndexInInput,
                            endIndexInInput),
                        allocator);
                }
            }
        }

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }

loopEnd:
        ++charsRead;
    }

    if (!lastDelimiterRead)
    {
        octaspire_string_release(tmpStr);
        tmpStr = 0;

        if (!octaspire_input_is_good(input))
        {
            return 0; // Out of input
        }

        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "String must end with character ']'",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);
    }

    octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING,
        octaspire_string_get_c_string(tmpStr),
        octaspire_dern_lexer_token_position_init(
            startLine,
            octaspire_input_get_line_number(input)),
        octaspire_dern_lexer_token_position_init(
            startColumn,
            octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
        octaspire_dern_lexer_token_position_init(
            startIndexInInput,
            endIndexInInput),
        allocator);

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    return result;
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_character(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   charsRead       = 0;
    bool     lastDelimiterRead = false;
    bool     endsInDelimiter = false;

    size_t   endIndexInInput = startIndexInInput;

    octaspire_string_t *tmpStr =
        octaspire_string_new("", allocator);

    if (!tmpStr)
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Memory allocation failed",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);
    }

    while (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (lastDelimiterRead)
        {
            if (octaspire_dern_lexer_private_is_delimeter(c))
            {
                --endIndexInInput;
                endsInDelimiter = true;
                break;
            }
            else
            {
                // NOP
                break;
            }
        }

        if (charsRead == 0)
        {
            if (c == '|')
            {
            }
            else
            {
                octaspire_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "Character must begin with character '|'",
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                    allocator);
            }
        }
        else
        {
            if (c == '|')
            {
                lastDelimiterRead = true;
            }
            else
            {
                if (!octaspire_string_push_back_ucs_character(tmpStr, c))
                {
                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    return octaspire_dern_lexer_token_new(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        "Memory allocation failed",
                        octaspire_dern_lexer_token_position_init(
                            startLine,
                            octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startColumn,
                            octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(
                            startIndexInInput,
                            endIndexInInput),
                        allocator);
                }
            }
        }

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }

        ++charsRead;
    }

    if (!lastDelimiterRead)
    {
        octaspire_string_release(tmpStr);
        tmpStr = 0;

        if (!octaspire_input_is_good(input))
        {
            return 0; // Out of input
        }

        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Character must end with character '|'",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);
    }

    if (octaspire_string_get_length_in_ucs_characters(tmpStr) > 1)
    {
        if (octaspire_string_is_equal_to_c_string(tmpStr, "bar"))
        {
            octaspire_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                "|",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
        else if (octaspire_string_is_equal_to_c_string(tmpStr, "newline"))
        {
            octaspire_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                "\n",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
        else if (octaspire_string_is_equal_to_c_string(tmpStr, "tab"))
        {
            octaspire_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                "\t",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
        else if (octaspire_string_is_equal_to_c_string(tmpStr, "string-start"))
        {
            octaspire_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                "[",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
        else if (octaspire_string_is_equal_to_c_string(tmpStr, "string-end"))
        {
            octaspire_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                "]",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
        else if (
            strspn(
                octaspire_string_get_c_string(tmpStr),
                "0123456789abcdefABCDEF") ==
                    octaspire_string_get_length_in_ucs_characters(tmpStr))
        {
            if (octaspire_string_get_length_in_ucs_characters(tmpStr) > 8)
            {
                octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new_format(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                    allocator,
                    "Number of hex digits (%zu) in character definition may not be larger "
                    "than eight",
                    octaspire_string_get_length_in_ucs_characters(tmpStr));

                octaspire_string_release(tmpStr);
                tmpStr = 0;

                return result;
            }

            octaspire_string_t *unicodeChar =
                octaspire_string_new("", allocator);

            if (!octaspire_string_push_back_ucs_character(
                unicodeChar,
                (uint32_t)strtol(
                    octaspire_string_get_c_string(tmpStr),
                    0,
                    16)))
            {
                abort();
            }

            if (octaspire_string_get_error_status(unicodeChar) !=
                OCTASPIRE_STRING_ERROR_STATUS_OK)
            {
                abort();
            }

            assert(unicodeChar);

            octaspire_dern_lexer_token_t * result = octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                octaspire_string_get_c_string(unicodeChar),
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);

            octaspire_string_release(unicodeChar);
            unicodeChar = 0;

            octaspire_string_release(tmpStr);
            tmpStr = 0;

            return result;
        }
        else
        {
            octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new_format(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                allocator,
                "Unknown character constant |%s|",
                octaspire_string_get_c_string(tmpStr));

            octaspire_string_release(tmpStr);
            tmpStr = 0;

            return result;
        }
    }

    if (octaspire_string_is_empty(tmpStr))
    {
        octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Character cannot be empty: ||",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        return result;
    }

    octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
        octaspire_string_get_c_string(tmpStr),
        octaspire_dern_lexer_token_position_init(
            startLine,
            octaspire_input_get_line_number(input)),
        octaspire_dern_lexer_token_position_init(
            startColumn,
            octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
        octaspire_dern_lexer_token_position_init(
            startIndexInInput,
            endIndexInInput),
        allocator);

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    return result;
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_true_or_false_or_nil_or_symbol(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   charsRead       = 0;
    bool     endsInDelimiter = false;

    size_t   endIndexInInput = startIndexInInput;

    octaspire_string_t *tmpStr =
        octaspire_string_new("", allocator);

    if (!tmpStr)
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Memory allocation failed",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);
    }

    while (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (octaspire_dern_lexer_private_is_delimeter(c))
        {
            --endIndexInInput;
            endsInDelimiter = true;
            break;
        }

        if (!octaspire_string_push_back_ucs_character(tmpStr, c))
        {
            octaspire_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Memory allocation failed",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                allocator);
        }

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }

        ++charsRead;
    }

    if (octaspire_string_is_empty(tmpStr))
    {
            octaspire_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Symbol cannot be empty",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                allocator);
    }

    octaspire_dern_lexer_token_t *result = 0;

    if (octaspire_string_is_equal_to_c_string(tmpStr, "true"))
    {
        result = octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE,
            0,
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }
    else if (octaspire_string_is_equal_to_c_string(tmpStr, "false"))
    {
        result = octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE,
            0,
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }
    else if (octaspire_string_is_equal_to_c_string(tmpStr, "nil"))
    {
        result = octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL,
            0,
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }
    else
    {
        result = octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL,
            octaspire_string_get_c_string(tmpStr),
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    return result;
}


octaspire_dern_lexer_token_t *octaspire_dern_lexer_pop_next_token(
    octaspire_input_t *input,
    octaspire_allocator_t *allocator)
{
    while (octaspire_input_is_good(input))
    {
        octaspire_dern_lexer_private_pop_whitespace(input);

        if (!octaspire_input_is_good(input))
        {
            return 0;
        }

        size_t const startLine         = octaspire_input_get_line_number(input);
        size_t const startColumn       = octaspire_input_get_column_number(input);
        size_t const startIndexInInput = octaspire_input_get_ucs_character_index(input);

        switch (octaspire_input_peek_next_ucs_character(input))
        {
            case ';':
            {
                octaspire_dern_lexer_private_pop_rest_of_line(input);
                return octaspire_dern_lexer_pop_next_token(input, allocator);
            }
            break;

            case '#':
            {
                switch (octaspire_input_peek_next_next_ucs_character(input))
                {
                    case '!':
                    {
                        octaspire_dern_lexer_token_t * const errorOrNull =
                            octaspire_dern_lexer_private_pop_multiline_comment(
                                input,
                                allocator,
                                startLine,
                                startColumn,
                                startIndexInInput);

                        if (errorOrNull)
                        {
                            return errorOrNull;
                        }

                        return octaspire_dern_lexer_pop_next_token(input, allocator);
                    }

                    default:
                    {
                        return octaspire_dern_lexer_private_pop_true_or_false_or_nil_or_symbol(
                            input,
                            allocator,
                            startLine,
                            startColumn,
                            startIndexInInput);
                    }
                }
            }

            case '(':
            {
                return octaspire_dern_lexer_private_pop_left_parenthesis(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }

            case ')':
            {
                return octaspire_dern_lexer_private_pop_right_parenthesis(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }

            case '\'':
            {
                return octaspire_dern_lexer_private_pop_quote(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }

            case '-':
            {
                return octaspire_dern_lexer_private_pop_true_or_false_or_nil_or_symbol(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }

            case '{':
            {
                return octaspire_dern_lexer_private_pop_integer_or_real_number(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }

            /*
            case '|':
            {
                return octaspire_dern_lexer_private_pop_string_or_character(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }
            break;
            */

            case '[':
            {
                return octaspire_dern_lexer_private_pop_string(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }

            case '|':
            {
                return octaspire_dern_lexer_private_pop_character(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }

            case 't':
            case 'f':
            case 'n':
            default:
            {
                return octaspire_dern_lexer_private_pop_true_or_false_or_nil_or_symbol(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }
        }
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_dern_lexer.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_dern_lib.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif


#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#ifdef _WIN32
#else
#endif
#endif

struct octaspire_dern_lib_t
{
    octaspire_allocator_t   *allocator;
    octaspire_dern_vm_t     *vm;
    octaspire_string_t      *name;
    octaspire_string_t      *errorMessage;
#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#ifdef _WIN32
    HINSTANCE                binaryLibHandle;
#else
    void                    *binaryLibHandle;
#endif
    bool (*libMarkFunc)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const);
#endif
    octaspire_dern_lib_tag_t typeTag;
    char                     padding[4];
};

octaspire_dern_lib_t *octaspire_dern_lib_new_source(
    char const * const name,
    octaspire_input_t * const input,
    octaspire_dern_vm_t *vm,
    octaspire_allocator_t *allocator)
{
    octaspire_dern_lib_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_lib_t));

    if (!self)
    {
        return self;
    }

    self->allocator = allocator;
    self->vm        = vm;
    self->name      = octaspire_string_new(name, self->allocator);
    self->typeTag   = OCTASPIRE_DERN_LIB_TAG_SOURCE;

#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#ifdef _WIN32
    /* NOP */
#else
    self->binaryLibHandle = 0;
#endif
    self->libMarkFunc = 0;
#endif

    octaspire_dern_value_t *value =
        octaspire_dern_vm_read_from_octaspire_input_and_eval_in_global_environment(vm, input);

    octaspire_helpers_verify_not_null(value);

    if (value->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
    {
        self->errorMessage =
            octaspire_string_new_copy(value->value.error->message,
                                      self->allocator);

        octaspire_helpers_verify_not_null(self->errorMessage);
    }

    return self;
}

#ifdef _WIN32
static char const *octaspire_dern_lib_private_format_win32_error_message(void)
{
    static char msgBuf[512];
    memset(msgBuf, 0, sizeof(msgBuf));

    int const errorCode = GetLastError();

    FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        0,
        errorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        msgBuf,
        sizeof(msgBuf),
        0);

    if (strlen(msgBuf) == 0)
    {
        snprintf(msgBuf, sizeof(msgBuf), "%d", errorCode);
    }

    return msgBuf;
}
#endif

octaspire_dern_lib_t *octaspire_dern_lib_new_binary(
    char const * const name,
    char const * const fileName,
    octaspire_dern_vm_t *vm,
    octaspire_allocator_t *allocator)
{
    octaspire_dern_lib_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_lib_t));

    if (!self)
    {
        return self;
    }

    self->allocator       = allocator;
    self->vm              = vm;
    self->name            = octaspire_string_new(name, self->allocator);
    self->typeTag         = OCTASPIRE_DERN_LIB_TAG_BINARY;

#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#ifdef _WIN32
    self->binaryLibHandle = LoadLibrary(fileName);

    if (!self->binaryLibHandle)
    {
        self->errorMessage =
            octaspire_string_new_format(
                self->allocator,
                "Binary library (name='%s' fileName='%s')\n"
                "cannot be loaded/opened with LoadLibrary: %s",
                name,
                fileName,
                octaspire_dern_lib_private_format_win32_error_message());

        octaspire_helpers_verify_not_null(self->errorMessage);
    }
    else
    {
        bool (*libInitFunc)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const);

        octaspire_string_t *libInitFuncName =
            octaspire_string_new_format(self->allocator, "%s_init", name);

        octaspire_helpers_verify_not_null(libInitFuncName);

        libInitFunc = (bool (*)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const))
            GetProcAddress(
                self->binaryLibHandle,
                octaspire_string_get_c_string(libInitFuncName));

        octaspire_string_release(libInitFuncName);
        libInitFuncName = 0;

        if (!libInitFunc)
        {
            self->errorMessage =
                octaspire_string_new_format(
                    self->allocator,
                    "Binary library (name='%s' fileName='%s'):\n"
                    "GetProcAddress failed on the init function for the library.",
                    name,
                    fileName);

            octaspire_helpers_verify_not_null(self->errorMessage);
        }
        else
        {
            if (!(*libInitFunc)(
                    vm,
                    octaspire_dern_vm_get_global_environment(vm)->value.environment))
            {
                self->errorMessage =
                    octaspire_string_new_format(
                        self->allocator,
                        "Binary library (name='%s' fileName='%s'):\n"
                        "init function failed.",
                        name,
                        fileName);

                octaspire_helpers_verify_not_null(self->errorMessage);
            }
        }

        // Mark function

        octaspire_string_t *libMarkFuncName =
            octaspire_string_new_format(self->allocator, "%s_mark_all", name);

        octaspire_helpers_verify_not_null(libMarkFuncName);

        self->libMarkFunc =
            (bool (*)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const))
                GetProcAddress(
                    self->binaryLibHandle,
                    octaspire_string_get_c_string(libMarkFuncName));

        octaspire_string_release(libMarkFuncName);
        libMarkFuncName = 0;
    }
#else
        // Clear any old errors
        dlerror();

        self->binaryLibHandle = dlopen(fileName, RTLD_LAZY);

        if (!self->binaryLibHandle)
        {
            self->errorMessage =
                octaspire_string_new_format(
                    self->allocator,
                    "Binary library (name='%s' fileName='%s')\n"
                    "cannot be loaded/opened with dlopen. dlerror is: %s",
                    name,
                    fileName,
                    dlerror());

            octaspire_helpers_verify_not_null(self->errorMessage);
        }
        else
        {
            bool (*libInitFunc)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const);

            octaspire_string_t *libInitFuncName =
                octaspire_string_new_format(self->allocator, "%s_init", name);

            octaspire_helpers_verify_not_null(libInitFuncName);

            libInitFunc =
                (bool (*)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const))dlsym(
                    self->binaryLibHandle,
                    octaspire_string_get_c_string(libInitFuncName));

            octaspire_string_release(libInitFuncName);
            libInitFuncName = 0;

            char *error = dlerror();

            if (error)
            {
                self->errorMessage =
                    octaspire_string_new_format(
                        self->allocator,
                        "Binary library (name='%s' fileName='%s'):\n"
                        "dlsym failed on the init function for the library. dlerror is: %s",
                        name,
                        fileName,
                        error);

                octaspire_helpers_verify_not_null(self->errorMessage);

                //dlclose(self->binaryLibHandle);
                //self->binaryLibHandle = 0;
            }
            else
            {
                if (!(*libInitFunc)(
                        vm,
                        octaspire_dern_vm_get_global_environment(vm)->value.environment))
                {
                    self->errorMessage =
                        octaspire_string_new_format(
                            self->allocator,
                            "Binary library (name='%s' fileName='%s'):\n"
                            "init function failed.",
                            name,
                            fileName);

                    octaspire_helpers_verify_not_null(self->errorMessage);

                    //dlclose(self->binaryLibHandle);
                    //self->binaryLibHandle = 0;
                }
            }

            // Mark function

            octaspire_string_t *libMarkFuncName =
                octaspire_string_new_format(self->allocator, "%s_mark_all", name);

            octaspire_helpers_verify_not_null(libMarkFuncName);

            self->libMarkFunc =
                (bool (*)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const))dlsym(
                    self->binaryLibHandle,
                    octaspire_string_get_c_string(libMarkFuncName));

            octaspire_string_release(libMarkFuncName);
            libMarkFuncName = 0;

            /*char *error = dlerror();

            if (!error && libMarkFunc)
            {
                self->libMarkFunc = libMarkFunc;
            }
            */
        }
#endif
#else

        self->errorMessage =
            octaspire_string_new_format(
                self->allocator,
                "Your version of Octaspire Dern is compiled\n"
                "WITHOUT support for binary libraries and this binary library\n"
                "(name='%s' fileName='%s')\n"
                "cannot thus be loaded. Use source-code libraries instead\n"
                "or compile Dern again with binary library support.\n",
                name,
                fileName);

        octaspire_helpers_verify_not_null(self->errorMessage);

#endif

        return self;
}

void octaspire_dern_lib_release(octaspire_dern_lib_t *self)
{
    if (!self)
    {
        return;
    }

    if (self->typeTag == OCTASPIRE_DERN_LIB_TAG_BINARY)
    {
#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#ifdef _WIN32
        if (self->binaryLibHandle)
        {
            bool (*libCleanFunc)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const);

            octaspire_string_t *libCleanFuncName =
                octaspire_string_new_format(
                    self->allocator,
                    "%s_clean",
                    octaspire_string_get_c_string(self->name));

            octaspire_helpers_verify_not_null(libCleanFuncName);

            libCleanFunc =
                (bool (*)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const))
                    GetProcAddress(
                        self->binaryLibHandle,
                        octaspire_string_get_c_string(libCleanFuncName));

            octaspire_string_release(libCleanFuncName);
            libCleanFuncName = 0;

            if (!libCleanFunc)
            {
                self->errorMessage =
                    octaspire_string_new_format(
                        self->allocator,
                        "Binary library (name='%s'):\n"
                        "GetProcAddress failed on the clean function for the library.",
                        octaspire_string_get_c_string(self->name));

                octaspire_helpers_verify_not_null(self->errorMessage);
            }
            else
            {
                if (!(*libCleanFunc)(
                        self->vm,
                        octaspire_dern_vm_get_global_environment(self->vm)->value.environment))
                {
                    self->errorMessage =
                        octaspire_string_new_format(
                            self->allocator,
                            "Binary library (name='%s'):\n"
                            "clean function failed.",
                            octaspire_string_get_c_string(self->name));

                    octaspire_helpers_verify_not_null(self->errorMessage);
                }
            }

            FreeLibrary(self->binaryLibHandle);
            self->binaryLibHandle = 0;
        }
#else
        if (self->binaryLibHandle)
        {
            bool (*libCleanFunc)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const);

            octaspire_string_t *libCleanFuncName =
                octaspire_string_new_format(
                    self->allocator,
                    "%s_clean",
                    octaspire_string_get_c_string(self->name));

            octaspire_helpers_verify_not_null(libCleanFuncName);

            libCleanFunc =
                (bool (*)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const))dlsym(
                    self->binaryLibHandle,
                    octaspire_string_get_c_string(libCleanFuncName));

            octaspire_string_release(libCleanFuncName);
            libCleanFuncName = 0;

            char *error = dlerror();

            if (error)
            {
                self->errorMessage =
                    octaspire_string_new_format(
                        self->allocator,
                        "Binary library (name='%s'):\n"
                        "dlsym failed on the clean function for the library. dlerror is: %s",
                        octaspire_string_get_c_string(self->name),
                        error);

                octaspire_helpers_verify_not_null(self->errorMessage);

                //dlclose(self->binaryLibHandle);
                //self->binaryLibHandle = 0;
            }
            else
            {
                if (!(*libCleanFunc)(
                        self->vm,
                        octaspire_dern_vm_get_global_environment(self->vm)->value.environment))
                {
                    self->errorMessage =
                        octaspire_string_new_format(
                            self->allocator,
                            "Binary library (name='%s'):\n"
                            "clean function failed.",
                            octaspire_string_get_c_string(self->name));

                    octaspire_helpers_verify_not_null(self->errorMessage);

                    //dlclose(self->binaryLibHandle);
                    //self->binaryLibHandle = 0;
                }
            }

            octaspire_dern_vm_config_t const * const config =
                octaspire_dern_vm_get_config_const(self->vm);

            octaspire_helpers_verify_not_null(config);

            if (!config->noDlClose)
            {
                dlclose(self->binaryLibHandle);
                self->binaryLibHandle = 0;
            }
        }
#endif
#endif
    }

    octaspire_string_release(self->name);
    self->name = 0;

    octaspire_string_release(self->errorMessage);
    self->errorMessage = 0;

    octaspire_allocator_free(self->allocator, self);
}

bool octaspire_dern_lib_is_good(octaspire_dern_lib_t const * const self)
{
    return (self->errorMessage == 0);
}

char const *octaspire_dern_lib_get_error_message(octaspire_dern_lib_t const * const self)
{
    if (!self->errorMessage)
    {
        return 0;
    }

    return octaspire_string_get_c_string(self->errorMessage);
}

bool octaspire_dern_lib_mark_all(octaspire_dern_lib_t * const self)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(self);
    
#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
    if (!self->libMarkFunc)
    {
        return 0;
    }

    if (!(*self->libMarkFunc)(
            self->vm,
            octaspire_dern_vm_get_global_environment(self->vm)->value.environment))
    {
        return false;
    }
#endif

    return true;
}

void *octaspire_dern_lib_get_handle(octaspire_dern_lib_t * const self)
{
#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#ifdef _WIN32
    return &(self->binaryLibHandle);
#else
    return self->binaryLibHandle;
#endif
#else
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(self);
    return 0;
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_dern_lib.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_dern_c_data.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif

#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#endif

struct octaspire_dern_c_data_t
{
    octaspire_string_t    *pluginName;
    octaspire_string_t    *typeNameForPayload;
    void                  *payload;
    octaspire_string_t    *cleanUpCallbackName;
    octaspire_string_t    *stdLibLenCallbackName;
    octaspire_string_t    *stdLibLinkAtCallbackName;
    octaspire_string_t    *stdLibCopyAtCallbackName;
    octaspire_allocator_t *allocator;
    bool                   copyingAllowed;
    char                   padding[7];
};

octaspire_dern_c_data_t *octaspire_dern_c_data_new(
    char const * const pluginName,
    char const * const typeNameForPayload,
    void * const payload,
    char const * const cleanUpCallbackName,
    char const * const stdLibLenCallbackName,
    char const * const stdLibLinkAtCallbackName,
    char const * const stdLibCopyAtCallbackName,
    bool const copyingAllowed,
    octaspire_allocator_t *allocator)
{
    octaspire_dern_c_data_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_c_data_t));

    if (!self)
    {
        return self;
    }

    self->allocator = allocator;

    self->pluginName = octaspire_string_new(
        pluginName,
        self->allocator);

    self->typeNameForPayload = octaspire_string_new(
        typeNameForPayload,
        self->allocator);

    self->payload = payload;

    self->cleanUpCallbackName = octaspire_string_new(
        cleanUpCallbackName,
        self->allocator);

    self->stdLibLenCallbackName = octaspire_string_new(
        stdLibLenCallbackName,
        self->allocator);

    self->stdLibLinkAtCallbackName = octaspire_string_new(
        stdLibLinkAtCallbackName,
        self->allocator);

    self->stdLibCopyAtCallbackName = octaspire_string_new(
        stdLibCopyAtCallbackName,
        self->allocator);

    self->copyingAllowed = copyingAllowed;

    return self;
}

octaspire_dern_c_data_t *octaspire_dern_c_data_new_copy(
    octaspire_dern_c_data_t * const other,
    octaspire_allocator_t *allocator)
{
    return octaspire_dern_c_data_new(
        octaspire_string_get_c_string(other->pluginName),
        octaspire_string_get_c_string(other->typeNameForPayload),
        other->payload,
        octaspire_string_get_c_string(other->cleanUpCallbackName),
        octaspire_string_get_c_string(other->stdLibLenCallbackName),
        octaspire_string_get_c_string(other->stdLibLinkAtCallbackName),
        octaspire_string_get_c_string(other->stdLibCopyAtCallbackName),
        other->copyingAllowed,
        allocator);
}

void octaspire_dern_c_data_release(octaspire_dern_c_data_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_string_release(self->cleanUpCallbackName);
    self->cleanUpCallbackName = 0;

    octaspire_string_release(self->stdLibLenCallbackName);
    self->stdLibLenCallbackName = 0;

    octaspire_string_release(self->stdLibLinkAtCallbackName);
    self->stdLibLinkAtCallbackName = 0;

    octaspire_string_release(self->stdLibCopyAtCallbackName);
    self->stdLibCopyAtCallbackName = 0;

    octaspire_string_release(self->pluginName);
    self->pluginName = 0;

    octaspire_string_release(self->typeNameForPayload);
    self->typeNameForPayload = 0;

    octaspire_allocator_free(self->allocator, self);
}

octaspire_string_t *octaspire_dern_c_data_to_string(
    octaspire_dern_c_data_t const * const self,
    octaspire_allocator_t * const allocator)
{
    return octaspire_string_new_format(
        allocator,
        "C data (%s : %s) payload=%p cleanUpCallbackName=%s stdLibLenCallbackName=%s "
        "stdLibLinkAtCallbackName=%s stdLibCopyAtCallbackName=%s",
        octaspire_string_get_c_string(self->pluginName),
        octaspire_string_get_c_string(self->typeNameForPayload),
        (void*)self->payload,
        octaspire_string_get_c_string(self->cleanUpCallbackName),
        octaspire_string_get_c_string(self->stdLibLenCallbackName),
        octaspire_string_get_c_string(self->stdLibLinkAtCallbackName),
        octaspire_string_get_c_string(self->stdLibCopyAtCallbackName));
}

bool octaspire_dern_c_data_is_equal(
    octaspire_dern_c_data_t const * const self,
    octaspire_dern_c_data_t const * const other)
{
    if (self->payload != other->payload)
    {
        return false;
    }

    if (octaspire_string_is_equal(self->pluginName, other->pluginName))
    {
        return false;
    }

    if (octaspire_string_is_equal(
        self->typeNameForPayload,
        other->typeNameForPayload))
    {
        return false;
    }

    return true;
}

int octaspire_dern_c_data_compare(
    octaspire_dern_c_data_t const * const self,
    octaspire_dern_c_data_t const * const other)
{
    int tmp = octaspire_string_compare(self->pluginName, other->pluginName);

    if (tmp != 0)
    {
        return tmp;
    }

    tmp = octaspire_string_compare(
        self->typeNameForPayload,
        other->typeNameForPayload);

    if (tmp != 0)
    {
        return tmp;
    }

    ptrdiff_t const diff = self - other;

    if (diff == 0)
    {
        return 0;
    }

    if (diff < 0)
    {
        return -1;
    }

    return 1;
}

bool octaspire_dern_c_data_is_plugin_and_payload_type_name(
    octaspire_dern_c_data_t const * const self,
    char const * const pluginName,
    char const * const typeNameForPayload)
{
    if (!octaspire_string_is_equal_to_c_string(self->pluginName, pluginName))
    {
        return false;
    }

    if (!octaspire_string_is_equal_to_c_string(
            self->typeNameForPayload,
            typeNameForPayload))
    {
        return false;
    }

    return true;
}

char const *octaspire_dern_c_data_get_plugin_name(
    octaspire_dern_c_data_t const * const self)
{
    return octaspire_string_get_c_string(self->pluginName);
}

char const *octaspire_dern_c_data_get_payload_typename(
    octaspire_dern_c_data_t const * const self)
{
    return octaspire_string_get_c_string(self->typeNameForPayload);
}

void *octaspire_dern_c_data_get_payload(
    octaspire_dern_c_data_t const * const self)
{
    return self->payload;
}

bool octaspire_dern_c_data_is_copying_allowed(
    octaspire_dern_c_data_t const * const self)
{
    return self->copyingAllowed;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_dern_c_data.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_dern_port.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif

struct octaspire_dern_port_t
{
    octaspire_allocator_t *allocator;
    octaspire_string_t    *name;
    ptrdiff_t              lengthInOctets;

    union
    {
        FILE *file;
    }
    value;

    octaspire_dern_port_tag_t typeTag;
    char                      padding[4];
};

octaspire_dern_port_t *octaspire_dern_port_new_copy(
    octaspire_dern_port_t * const other,
    octaspire_allocator_t *allocator)
{
    octaspire_dern_port_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_port_t));

    if (!self)
    {
        return self;
    }

    self->allocator      = allocator;
    self->name           = octaspire_string_new_copy(other->name, self->allocator);
    self->typeTag        = other->typeTag;
    self->lengthInOctets = other->lengthInOctets;

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        {
            self->value.file =
                fopen(octaspire_string_get_c_string(self->name), "a+b");

            if (self->value.file == 0)
            {
                self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
            }

            octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_END) == 0);
            self->lengthInOctets = ftell(self->value.file);
            octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_SET) == 0);
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        {
            self->value.file =
                fopen(octaspire_string_get_c_string(self->name), "rb");

            if (self->value.file == 0)
            {
                self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
            }

            octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_END) == 0);
            self->lengthInOctets = ftell(self->value.file);
            octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_SET) == 0);
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        {
            self->value.file =
                fopen(octaspire_string_get_c_string(self->name), "a");

            if (self->value.file == 0)
            {
                self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
            }

            self->lengthInOctets = ftell(self->value.file);
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            // NOP
        }
        break;
    }

    return self;
}

octaspire_dern_port_t *octaspire_dern_port_new_input_file(
    char const * const path,
    octaspire_allocator_t *allocator)
{
    octaspire_dern_port_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_port_t));

    if (!self)
    {
        return self;
    }

    self->allocator  = allocator;
    self->name       = octaspire_string_new(path, self->allocator);
    self->typeTag    = OCTASPIRE_DERN_PORT_TAG_INPUT_FILE;
    self->lengthInOctets = -1;
    self->value.file = fopen(path, "rb");

    if (self->value.file == 0)
    {
        self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
        return self;
    }

    octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_END) == 0);
    self->lengthInOctets = ftell(self->value.file);
    octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_SET) == 0);

    return self;
}

octaspire_dern_port_t *octaspire_dern_port_new_output_file(
    char const * const path,
    octaspire_allocator_t *allocator)
{
    octaspire_dern_port_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_port_t));

    if (!self)
    {
        return self;
    }

    self->allocator  = allocator;
    self->name       = octaspire_string_new(path, self->allocator);
    self->typeTag    = OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE;
    self->lengthInOctets = -1;
    self->value.file = fopen(path, "a");

    if (self->value.file == 0)
    {
        self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
        return self;
    }

    self->lengthInOctets = ftell(self->value.file);
    return self;
}

octaspire_dern_port_t *octaspire_dern_port_new_io_file(
    char const * const path,
    octaspire_allocator_t *allocator)
{
    octaspire_dern_port_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_port_t));

    if (!self)
    {
        return self;
    }

    self->allocator  = allocator;
    self->name       = octaspire_string_new(path, self->allocator);
    self->typeTag    = OCTASPIRE_DERN_PORT_TAG_IO_FILE;
    self->lengthInOctets = -1;
    self->value.file = fopen(path, "a+b");

    if (self->value.file == 0)
    {
        self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
        return self;
    }

    octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_END) == 0);
    self->lengthInOctets = ftell(self->value.file);
    octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_SET) == 0);

    return self;
}

void octaspire_dern_port_release(octaspire_dern_port_t *self)
{
    if (!self)
    {
        return;
    }

    if (self->typeTag == OCTASPIRE_DERN_PORT_TAG_INPUT_FILE  ||
        self->typeTag == OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE ||
        self->typeTag == OCTASPIRE_DERN_PORT_TAG_IO_FILE)
    {
        int const res = fclose(self->value.file);
        self->value.file = 0;
        self->lengthInOctets = -1;
        octaspire_helpers_verify_true(res == 0);
    }

    octaspire_string_release(self->name);
    self->name = 0;

    octaspire_allocator_free(self->allocator, self);
}

ptrdiff_t octaspire_dern_port_write(
    octaspire_dern_port_t * const self,
    void const * const buffer,
    size_t const bufferSizeInOctets)
{
    octaspire_helpers_verify_not_null(self);

    if (self->typeTag == OCTASPIRE_DERN_PORT_TAG_IO_FILE ||
        self->typeTag == OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE)
    {
        octaspire_helpers_verify_not_null(self->value.file);

        size_t const numItemsWritten =
            fwrite(buffer, sizeof(char), bufferSizeInOctets, self->value.file);

        return (ptrdiff_t)numItemsWritten;
    }

    return -1;
}

ptrdiff_t octaspire_dern_port_read(
    octaspire_dern_port_t * const self,
    void * const buffer,
    size_t const bufferSizeInOctets)
{
    octaspire_helpers_verify_not_null(self);

    if (self->typeTag == OCTASPIRE_DERN_PORT_TAG_INPUT_FILE ||
        self->typeTag == OCTASPIRE_DERN_PORT_TAG_IO_FILE)
    {
        octaspire_helpers_verify_not_null(self->value.file);

        size_t const numItemsRead =
            fread(buffer, sizeof(char), bufferSizeInOctets, self->value.file);

        return (ptrdiff_t)numItemsRead;
    }

    return -1;
}

bool octaspire_dern_port_close(
    octaspire_dern_port_t * const self)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        {
            int const res = fclose(self->value.file);
            self->value.file = 0;
            self->lengthInOctets = -1;
            self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
            return (res == 0);
        }

        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return false;
        }
    }

    abort();
    return false;
}

ptrdiff_t octaspire_dern_port_get_length_in_octets(octaspire_dern_port_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->lengthInOctets;
}

octaspire_string_t *octaspire_dern_port_to_string(
    octaspire_dern_port_t const * const self,
    octaspire_allocator_t * const allocator)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        {
            return octaspire_string_new_format(
                allocator,
#ifdef __AROS__
                "<input-port:%s (%ld octets)>",
#else
                "<input-port:%s (%td octets)>",
#endif
                octaspire_string_get_c_string(self->name),
                self->lengthInOctets);
        }

        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        {
            return octaspire_string_new_format(
                allocator,
#ifdef __AROS__
                "<output-port:%s (%ld octets)>",
#else
                "<output-port:%s (%td octets)>",
#endif
                octaspire_string_get_c_string(self->name),
                self->lengthInOctets);
        }

        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        {
            return octaspire_string_new_format(
                allocator,
#ifdef __AROS__
                "<input-output-port:%s (%ld octets)>",
#else
                "<input-output-port:%s (%td octets)>",
#endif
                octaspire_string_get_c_string(self->name),
                self->lengthInOctets);
        }

        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return octaspire_string_new_format(
                allocator,
#ifdef __AROS__
                "<NOT-OPEN-port:%s (%ld octets)>",
#else
                "<NOT-OPEN-port:%s (%td octets)>",
#endif
                octaspire_string_get_c_string(self->name),
                self->lengthInOctets);
        }
    }

    return 0;
}

bool octaspire_dern_port_seek(
    octaspire_dern_port_t * const self,
    ptrdiff_t const amount,
    bool const fromCurrentPos)
{
    octaspire_helpers_verify_not_null(self);

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        {
            octaspire_helpers_verify_not_null(self->value.file);

            if (amount < 0)
            {
                // Seek backwards from the end
                // TODO XXX check that amount fits into long and report error if it doesn't
                long const offset = fromCurrentPos ? amount : (amount + 1);
                return fseek(self->value.file, offset, fromCurrentPos ? SEEK_CUR : SEEK_END) == 0;
            }
            else
            {
                // Seek forward from the beginning
                // TODO XXX check that amount fits into long and report error if it doesn't
                long const offset = amount;
                return fseek(self->value.file, offset, fromCurrentPos ? SEEK_CUR : SEEK_SET) == 0;
            }
        }

        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return false;
        }
    }

    return false;
}

bool octaspire_dern_port_flush(octaspire_dern_port_t * const self)
{
    octaspire_helpers_verify_not_null(self);

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        {
            octaspire_helpers_verify_not_null(self->value.file);

            return fflush(self->value.file) == 0;
        }

        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return false;
        }
    }

    return false;
}

ptrdiff_t octaspire_dern_port_distance(octaspire_dern_port_t const * const self)
{
    octaspire_helpers_verify_not_null(self);

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        {
            octaspire_helpers_verify_not_null(self->value.file);

            return (ptrdiff_t)ftell(self->value.file);
        }

        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return -1;
        }
    }

    return -1;
}

bool octaspire_dern_port_supports_output(
    octaspire_dern_port_t const * const self)
{
    octaspire_helpers_verify_not_null(self);

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        {
            octaspire_helpers_verify_not_null(self->value.file);
            return true;
        }

        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return false;
        }
    }

    return false;
}

bool octaspire_dern_port_supports_input(
    octaspire_dern_port_t const * const self)
{
    octaspire_helpers_verify_not_null(self);

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        {
            octaspire_helpers_verify_not_null(self->value.file);
            return true;
        }

        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return false;
        }
    }

    return false;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_dern_port.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_dern_helpers.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif

int octaspire_dern_helpers_compare_value_hash_maps(
    octaspire_map_t const * const firstValueHashMap,
    octaspire_map_t const * const otherValueHashMap)
{
    if (octaspire_map_get_number_of_elements(firstValueHashMap) !=
        octaspire_map_get_number_of_elements(otherValueHashMap))
    {
        return octaspire_map_get_number_of_elements(firstValueHashMap) -
            octaspire_map_get_number_of_elements(otherValueHashMap);
    }

    octaspire_map_element_const_iterator_t iter =
        octaspire_map_element_const_iterator_init(firstValueHashMap);

    while (iter.element)
    {
        octaspire_dern_value_t const * const myKey =
            octaspire_map_element_get_key_const(iter.element);

        octaspire_dern_value_t const * const myVal =
            octaspire_map_element_get_value_const(iter.element);

        octaspire_map_element_t const * const otherElem =
            octaspire_map_get_const(
                otherValueHashMap,
                octaspire_dern_value_get_hash(myKey),
                &myKey);

        if (!otherElem)
        {
            return 1;
        }

        octaspire_dern_value_t const * const otherVal =
            octaspire_map_element_get_value(otherElem);

        int const cmp = octaspire_dern_value_compare(myVal, otherVal);

        if (cmp)
        {
            return cmp;
        }

        octaspire_map_element_const_iterator_next(&iter);
    }

    return 0;
}

double octaspire_dern_helpers_atof(
    char const * const str,
    octaspire_allocator_t * const allocator)
{
    octaspire_input_t * input = octaspire_input_new_from_c_string(str, allocator);
    octaspire_helpers_verify_not_null(input);
    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, allocator);
    octaspire_helpers_verify_not_null(token);

    if (octaspire_dern_lexer_token_get_type_tag(token) != OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL)
    {
        return octaspire_dern_lexer_token_get_real_value(token);
    }
    if (octaspire_dern_lexer_token_get_type_tag(token) != OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER)
    {
        return octaspire_dern_lexer_token_get_integer_value(token);
    }
    else
    {
        return 0;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_dern_helpers.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_dern_stdlib.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif


#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#endif

static octaspire_dern_value_t *octaspire_dern_stdlib_private_validate_function(
    octaspire_dern_vm_t* vm,
    octaspire_dern_function_t *function);

static octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_numerical(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

static octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_textual_string(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

static octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_textual_char(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

static octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_textual_symbol(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

static octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_vector(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

static octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_hash_map(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

static octaspire_dern_value_t *octaspire_dern_vm_builtin_private_minus_numerical(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

static octaspire_dern_value_t *octaspire_dern_vm_builtin_private_minus_textual(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

static octaspire_dern_value_t *octaspire_dern_vm_builtin_private_require_is_already_loaded(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

static octaspire_dern_value_t *octaspire_dern_vm_builtin_private_require_source_file(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

static octaspire_dern_value_t *octaspire_dern_vm_builtin_private_require_binary_file(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

///////////////////// VARIABLE /////////////////////////////
static octaspire_dern_value_t *octaspire_dern_vm_special_private_define_var_in_env(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *firstArg,
    octaspire_dern_value_t *evaluatedThirdArg,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    ///////// Validate form /////////////////////////
    if (numArgs != 6)
    {
        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'define' expects six arguments in this context. "
            "%zu arguments were given.",
            numArgs);
    }

    octaspire_dern_vm_push_value(vm, arguments);

    if (!octaspire_dern_value_is_symbol_and_equal_to_c_string(
            octaspire_dern_value_as_vector_get_element_at(arguments, 1),
            "as"))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                octaspire_dern_value_as_vector_get_element_at(arguments, 1),
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects symbol 'as' as the second argument in "
                "this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    if (!octaspire_dern_value_is_symbol_and_equal_to_c_string(
            octaspire_dern_value_as_vector_get_element_at(arguments, 4),
            "in"))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                octaspire_dern_value_as_vector_get_element_at(arguments, 4),
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects symbol 'in' as the fifth argument in "
                "this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_dern_value_t * const docStringEvaluated =
        octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, 3),
            environment);

    octaspire_dern_vm_push_value(vm, docStringEvaluated);

    if (!octaspire_dern_value_is_string(docStringEvaluated))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                docStringEvaluated,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects documentation string as the fourth argument "
                "in this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, docStringEvaluated);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_dern_value_t * const envEvaluated =
        octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, 5),
            environment);

    octaspire_dern_vm_push_value(vm, envEvaluated);

    if (!octaspire_dern_value_is_environment(envEvaluated))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                envEvaluated,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects environment as the sixth argument "
                "in this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, envEvaluated);
        octaspire_dern_vm_pop_value(vm, docStringEvaluated);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    ///////// Execute form /////////////////////////
    if (octaspire_dern_value_is_atom(evaluatedThirdArg))
    {
        evaluatedThirdArg = octaspire_dern_vm_create_new_value_copy(
            vm,
            evaluatedThirdArg);
    }

    octaspire_dern_vm_push_value(vm, evaluatedThirdArg);

    evaluatedThirdArg->docstr = docStringEvaluated;

    bool const status = octaspire_dern_environment_set(
        envEvaluated->value.environment,
        firstArg,
        evaluatedThirdArg);

    octaspire_dern_vm_pop_value(vm, evaluatedThirdArg);
    octaspire_dern_vm_pop_value(vm, envEvaluated);
    octaspire_dern_vm_pop_value(vm, docStringEvaluated);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(
        stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, status);
}
static octaspire_dern_value_t *octaspire_dern_vm_special_private_define_var_no_env(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *firstArg,
    octaspire_dern_value_t *evaluatedThirdArg,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    ///////// Validate form /////////////////////////
    if (numArgs != 4)
    {
        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'define' expects four arguments in this context. "
            "%zu arguments were given.",
            numArgs);
    }

    octaspire_dern_vm_push_value(vm, arguments);

    if (!octaspire_dern_value_is_symbol_and_equal_to_c_string(
            octaspire_dern_value_as_vector_get_element_at(arguments, 1),
            "as"))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                octaspire_dern_value_as_vector_get_element_at(arguments, 1),
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects symbol 'as' as the second argument in "
                "this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_dern_value_t * const docStringEvaluated =
        octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, 3),
            environment);

    octaspire_dern_vm_push_value(vm, docStringEvaluated);

    if (!octaspire_dern_value_is_string(docStringEvaluated))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                docStringEvaluated,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects documentation string as the fourth argument "
                "in this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, docStringEvaluated);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    ///////// Execute form /////////////////////////
    if (octaspire_dern_value_is_atom(evaluatedThirdArg))
    {
        evaluatedThirdArg = octaspire_dern_vm_create_new_value_copy(
            vm,
            evaluatedThirdArg);
    }

    octaspire_dern_vm_push_value(vm, evaluatedThirdArg);

    evaluatedThirdArg->docstr = docStringEvaluated;

    bool const status = octaspire_dern_environment_set(
        environment->value.environment,
        firstArg,
        evaluatedThirdArg);

    octaspire_dern_vm_pop_value(vm, evaluatedThirdArg);
    octaspire_dern_vm_pop_value(vm, docStringEvaluated);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(
        stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, status);
}
///////////////////// FUNCTION /////////////////////////////
static octaspire_dern_value_t *octaspire_dern_vm_special_private_define_fun_in_env(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *firstArg,
    octaspire_dern_value_t *evaluatedThirdArg,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    ///////// Validate form /////////////////////////
    if (numArgs != 8)
    {
        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'define' expects eight arguments in this context. "
            "%zu arguments were given.",
            numArgs);
    }

    octaspire_dern_vm_push_value(vm, arguments);

    if (!octaspire_dern_value_is_symbol_and_equal_to_c_string(
            octaspire_dern_value_as_vector_get_element_at(arguments, 1),
            "as"))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                octaspire_dern_value_as_vector_get_element_at(arguments, 1),
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects symbol 'as' as the second argument in "
                "this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    if (!octaspire_dern_value_is_symbol_and_equal_to_c_string(
            octaspire_dern_value_as_vector_get_element_at(arguments, 5),
            "in"))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                octaspire_dern_value_as_vector_get_element_at(arguments, 5),
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects symbol 'in' as the sixth argument in "
                "this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_dern_value_t * const howtoSymbolValue =
        octaspire_dern_value_as_vector_get_element_at(arguments, 7);


    bool howtoAllowed = false;

    if (octaspire_dern_value_is_symbol(howtoSymbolValue))
    {
        if (octaspire_dern_value_as_symbol_is_equal_to_c_string(
                howtoSymbolValue,
                "howto-ok"))
        {
            howtoAllowed = true;
        }
        else if (octaspire_dern_value_as_symbol_is_equal_to_c_string(
                howtoSymbolValue,
                "howto-no"))
        {
            howtoAllowed = false;
        }
        else
        {
            octaspire_string_t *tmpStr =
                octaspire_dern_value_to_string(
                    howtoSymbolValue,
                    octaspire_dern_vm_get_allocator(vm));

            octaspire_dern_value_t * const result =
                octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Special 'define' expects symbol 'howto-ok' or 'howto-no' as "
                    "the eight argument in this context. Value '%s' was given.",
                    octaspire_string_get_c_string(tmpStr));

            octaspire_string_release(tmpStr);
            tmpStr = 0;

            octaspire_dern_vm_pop_value(vm, arguments);

            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return result;
        }
    }
    else
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                howtoSymbolValue,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects symbol as the eight argument in "
                "this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_dern_value_t * const docStringEvaluated =
        octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, 3),
            environment);

    octaspire_dern_vm_push_value(vm, docStringEvaluated);

    if (!octaspire_dern_value_is_string(docStringEvaluated))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                docStringEvaluated,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects documentation string as the fourth argument "
                "in this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, docStringEvaluated);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_dern_value_t * const envEvaluated =
        octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, 6),
            environment);

    octaspire_dern_vm_push_value(vm, envEvaluated);

    if (!octaspire_dern_value_is_environment(envEvaluated))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                envEvaluated,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects environment as the seventh argument "
                "in this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, envEvaluated);
        octaspire_dern_vm_pop_value(vm, docStringEvaluated);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_dern_value_t * const docVecEvaluated =
        octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, 4),
            environment);

    octaspire_dern_vm_push_value(vm, docVecEvaluated);

    if (!octaspire_dern_value_is_vector(docVecEvaluated))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                docVecEvaluated,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects documentation vector as the fifth argument "
                "in this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, docVecEvaluated);
        octaspire_dern_vm_pop_value(vm, envEvaluated);
        octaspire_dern_vm_pop_value(vm, docStringEvaluated);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_string_t *errorMessage =
        octaspire_dern_function_are_all_formals_mentioned_in_docvec(
            evaluatedThirdArg->value.function,
            docVecEvaluated);

    octaspire_helpers_verify_not_null(errorMessage);

    if (!octaspire_string_is_empty(errorMessage))
    {
        octaspire_dern_vm_pop_value(vm, docVecEvaluated);
        octaspire_dern_vm_pop_value(vm, envEvaluated);
        octaspire_dern_vm_pop_value(vm, docStringEvaluated);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return octaspire_dern_vm_create_new_value_error(vm, errorMessage);
    }
    else
    {
        octaspire_string_release(errorMessage);
        errorMessage = 0;

        octaspire_string_t *strToModify =
            docStringEvaluated->value.string;

        if (!octaspire_string_concatenate_c_string(
                strToModify,
                "\nArguments are:"))
        {
            abort();
        }

        for (size_t i = 0; i < octaspire_dern_value_get_length(docVecEvaluated); i += 2)
        {
            if (!octaspire_string_concatenate_c_string(
                    strToModify,
                    "\n"))
            {
                abort();
            }

            octaspire_dern_value_t const * const formalSym =
                octaspire_dern_value_as_vector_get_element_of_type_at_const(
                    docVecEvaluated,
                    OCTASPIRE_DERN_VALUE_TAG_SYMBOL,
                    (ptrdiff_t)i);

            octaspire_helpers_verify_not_null(formalSym);

            octaspire_dern_value_t const * const formalDocStr =
                octaspire_dern_value_as_vector_get_element_of_type_at_const(
                    docVecEvaluated,
                    OCTASPIRE_DERN_VALUE_TAG_STRING,
                    (ptrdiff_t)(i + 1));

            octaspire_helpers_verify_not_null(formalDocStr);

            if (!octaspire_string_concatenate_format(
                    strToModify,
                    "%s -> %s",
                    octaspire_string_get_c_string(formalSym->value.symbol),
                    octaspire_string_get_c_string(formalDocStr->value.string)))
            {
                abort();
            }
        }
    }

    ///////// Execute form /////////////////////////
    if (octaspire_dern_value_is_atom(evaluatedThirdArg))
    {
        evaluatedThirdArg = octaspire_dern_vm_create_new_value_copy(
            vm,
            evaluatedThirdArg);
    }

    octaspire_dern_vm_push_value(vm, evaluatedThirdArg);

    evaluatedThirdArg->docstr       = docStringEvaluated;
    evaluatedThirdArg->docvec       = docVecEvaluated;
    evaluatedThirdArg->howtoAllowed = howtoAllowed;

    octaspire_dern_function_set_howto_data(
        evaluatedThirdArg->value.function,
        octaspire_dern_value_as_symbol_get_c_string(firstArg),
        octaspire_dern_value_as_string_get_c_string(docStringEvaluated),
        howtoAllowed);

    bool const status = octaspire_dern_environment_set(
        envEvaluated->value.environment,
        firstArg,
        evaluatedThirdArg);

    octaspire_dern_vm_pop_value(vm, evaluatedThirdArg);
    octaspire_dern_vm_pop_value(vm, docVecEvaluated);
    octaspire_dern_vm_pop_value(vm, envEvaluated);
    octaspire_dern_vm_pop_value(vm, docStringEvaluated);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(
        stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, status);
}
static octaspire_dern_value_t *octaspire_dern_vm_special_private_define_fun_no_env(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *firstArg,
    octaspire_dern_value_t * evaluatedThirdArg,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    ///////// Validate form /////////////////////////
    if (numArgs != 6)
    {
        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'define' expects six arguments in this context. "
            "%zu arguments were given.",
            numArgs);
    }

    octaspire_dern_vm_push_value(vm, arguments);

    if (!octaspire_dern_value_is_symbol_and_equal_to_c_string(
            octaspire_dern_value_as_vector_get_element_at(arguments, 1),
            "as"))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                octaspire_dern_value_as_vector_get_element_at(arguments, 1),
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects symbol 'as' as the second argument in "
                "this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_dern_value_t * const howtoSymbolValue =
        octaspire_dern_value_as_vector_get_element_at(arguments, 5);


    bool howtoAllowed = false;

    if (octaspire_dern_value_is_symbol(howtoSymbolValue))
    {
        if (octaspire_dern_value_as_symbol_is_equal_to_c_string(
                howtoSymbolValue,
                "howto-ok"))
        {
            howtoAllowed = true;
        }
        else if (octaspire_dern_value_as_symbol_is_equal_to_c_string(
                howtoSymbolValue,
                "howto-no"))
        {
            howtoAllowed = false;
        }
        else
        {
            octaspire_string_t *tmpStr =
                octaspire_dern_value_to_string(
                    howtoSymbolValue,
                    octaspire_dern_vm_get_allocator(vm));

            octaspire_dern_value_t * const result =
                octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Special 'define' expects symbol 'howto-ok' or 'howto-no' as "
                    "the sixth argument in this context. Value '%s' was given.",
                    octaspire_string_get_c_string(tmpStr));

            octaspire_string_release(tmpStr);
            tmpStr = 0;

            octaspire_dern_vm_pop_value(vm, arguments);

            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return result;
        }
    }
    else
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                howtoSymbolValue,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects symbol as the sixth argument in "
                "this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_dern_value_t * const docStringEvaluated =
        octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, 3),
            environment);

    octaspire_dern_vm_push_value(vm, docStringEvaluated);

    if (!octaspire_dern_value_is_string(docStringEvaluated))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                docStringEvaluated,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects documentation string as the fourth argument "
                "in this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, docStringEvaluated);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_dern_value_t * const docVecEvaluated =
        octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, 4),
            environment);

    octaspire_dern_vm_push_value(vm, docVecEvaluated);

    if (!octaspire_dern_value_is_vector(docVecEvaluated))
    {
        octaspire_string_t *tmpStr =
            octaspire_dern_value_to_string(
                docVecEvaluated,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define' expects documentation vector as the fifth argument "
                "in this context. Value '%s' was given.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_dern_vm_pop_value(vm, docVecEvaluated);
        octaspire_dern_vm_pop_value(vm, docStringEvaluated);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_string_t *errorMessage =
        octaspire_dern_function_are_all_formals_mentioned_in_docvec(
            evaluatedThirdArg->value.function,
            docVecEvaluated);

    octaspire_helpers_verify_not_null(errorMessage);

    if (!octaspire_string_is_empty(errorMessage))
    {
        octaspire_dern_vm_pop_value(vm, docVecEvaluated);
        octaspire_dern_vm_pop_value(vm, docStringEvaluated);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return octaspire_dern_vm_create_new_value_error(vm, errorMessage);
    }
    else
    {
        octaspire_string_release(errorMessage);
        errorMessage = 0;

        octaspire_string_t *strToModify =
            docStringEvaluated->value.string;

        if (!octaspire_string_concatenate_c_string(
                strToModify,
                "\nArguments are:"))
        {
            abort();
        }

        for (size_t i = 0; i < octaspire_dern_value_get_length(docVecEvaluated); i += 2)
        {
            if (!octaspire_string_concatenate_c_string(
                    strToModify,
                    "\n"))
            {
                abort();
            }

            octaspire_dern_value_t const * const formalSym =
                octaspire_dern_value_as_vector_get_element_of_type_at_const(
                    docVecEvaluated,
                    OCTASPIRE_DERN_VALUE_TAG_SYMBOL,
                    (ptrdiff_t)i);

            octaspire_helpers_verify_not_null(formalSym);

            octaspire_dern_value_t const * const formalDocStr =
                octaspire_dern_value_as_vector_get_element_of_type_at_const(
                    docVecEvaluated,
                    OCTASPIRE_DERN_VALUE_TAG_STRING,
                    (ptrdiff_t)(i + 1));

            octaspire_helpers_verify_not_null(formalDocStr);

            if (!octaspire_string_concatenate_format(
                    strToModify,
                    "%s -> %s",
                    octaspire_string_get_c_string(formalSym->value.symbol),
                    octaspire_string_get_c_string(formalDocStr->value.string)))
            {
                abort();
            }
        }
    }

    ///////// Execute form /////////////////////////
    if (octaspire_dern_value_is_atom(evaluatedThirdArg))
    {
        evaluatedThirdArg = octaspire_dern_vm_create_new_value_copy(
            vm,
            evaluatedThirdArg);
    }

    octaspire_dern_vm_push_value(vm, evaluatedThirdArg);

    evaluatedThirdArg->docstr       = docStringEvaluated;
    evaluatedThirdArg->docvec       = docVecEvaluated;
    evaluatedThirdArg->howtoAllowed = howtoAllowed;

    octaspire_dern_function_set_howto_data(
        evaluatedThirdArg->value.function,
        octaspire_dern_value_as_symbol_get_c_string(firstArg),
        octaspire_dern_value_as_string_get_c_string(docStringEvaluated),
        howtoAllowed);

    bool const status = octaspire_dern_environment_set(
        environment->value.environment,
        firstArg,
        evaluatedThirdArg);

    octaspire_dern_vm_pop_value(vm, evaluatedThirdArg);
    octaspire_dern_vm_pop_value(vm, docVecEvaluated);
    octaspire_dern_vm_pop_value(vm, docStringEvaluated);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(
        stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, status);
}


octaspire_dern_value_t *octaspire_dern_vm_special_define(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(
        arguments->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_helpers_verify_true(
        environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 4 && numArgs != 6 && numArgs != 8)
    {
        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'define' expects four, six or eight arguments. "
            "%zu arguments were given.",
            numArgs);
    }

    octaspire_dern_value_t * firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    if (octaspire_dern_value_is_vector(firstArg))
    {
        firstArg = octaspire_dern_vm_eval(vm, firstArg, environment);

        if (octaspire_dern_value_is_error(firstArg))
        {
            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return firstArg;
        }
    }

    if (!octaspire_dern_value_is_symbol(firstArg))
    {
        octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
            firstArg,
            octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t * const result =
            octaspire_dern_vm_create_new_value_error_format(
                vm,
                "The first argument of special 'define' is a vector but doesn't "
                "evaluate into a symbol. It evaluates into '%s'.",
                octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }

    octaspire_dern_vm_push_value(vm, firstArg);

    octaspire_dern_value_t * const evaluatedThirdArg =
        octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, 2),
            environment);

    if (octaspire_dern_value_is_error(evaluatedThirdArg))
    {
        octaspire_dern_vm_pop_value(vm, firstArg);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return evaluatedThirdArg;
    }

    octaspire_dern_vm_push_value(vm, evaluatedThirdArg);

    if (numArgs == 4)
    {
        octaspire_dern_value_t *result =
            octaspire_dern_vm_special_private_define_var_no_env(
                vm,
                firstArg,
                evaluatedThirdArg,
                arguments,
                environment);

        octaspire_dern_vm_pop_value(vm, evaluatedThirdArg);
        octaspire_dern_vm_pop_value(vm, firstArg);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }
    else if (numArgs == 6)
    {
        if (octaspire_dern_value_is_function(evaluatedThirdArg))
        {
            octaspire_dern_value_t *result =
                octaspire_dern_vm_special_private_define_fun_no_env(
                    vm,
                    firstArg,
                    evaluatedThirdArg,
                    arguments,
                    environment);

            octaspire_dern_vm_pop_value(vm, evaluatedThirdArg);
            octaspire_dern_vm_pop_value(vm, firstArg);

            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return result;
        }

        octaspire_dern_value_t *result =
            octaspire_dern_vm_special_private_define_var_in_env(
                vm,
                firstArg,
                evaluatedThirdArg,
                arguments,
                environment);

        octaspire_dern_vm_pop_value(vm, evaluatedThirdArg);
        octaspire_dern_vm_pop_value(vm, firstArg);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;
    }
    else //if (numArgs == 8)
    {
        octaspire_dern_value_t *result =
            octaspire_dern_vm_special_private_define_fun_in_env(
                vm,
                firstArg,
                evaluatedThirdArg,
                arguments,
                environment);

        octaspire_dern_vm_pop_value(vm, evaluatedThirdArg);
        octaspire_dern_vm_pop_value(vm, firstArg);

        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return result;

    }
}

octaspire_dern_value_t *octaspire_dern_vm_special_eval(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) != 1 &&
        octaspire_vector_get_length(vec) != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'eval' expects one or two arguments. %zu arguments were given.",
            octaspire_vector_get_length(vec));
    }

    octaspire_dern_value_t *valueToBeEvaluated = octaspire_vector_get_element_at(vec, 0);
    octaspire_helpers_verify_not_null(valueToBeEvaluated);

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *result = 0;

    if (octaspire_vector_get_length(vec) == 2)
    {
        octaspire_dern_value_t *envVal = octaspire_vector_get_element_at(vec, 1);
        octaspire_helpers_verify_not_null(envVal);

        if (envVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
        {
            result = octaspire_dern_vm_eval(vm, valueToBeEvaluated, envVal);
            octaspire_dern_vm_push_value(vm, result);
            octaspire_dern_value_t *tmpResult = octaspire_dern_vm_eval(vm, result, envVal);
            octaspire_dern_vm_pop_value(vm, result);
            result = tmpResult;
        }
        else
        {
            envVal = octaspire_dern_vm_eval(vm, envVal, environment);

            octaspire_helpers_verify_not_null(envVal);

            if (envVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
            {
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return envVal;
            }

            if (envVal->typeTag != OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
            {
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Second argument to special 'eval' must evaluate into environment value.\n"
                    "Now it evaluated into type %s.",
                    octaspire_dern_value_helper_get_type_as_c_string(envVal->typeTag));
            }

            octaspire_dern_vm_push_value(vm, envVal);
            result = octaspire_dern_vm_eval(vm, valueToBeEvaluated, envVal);
            octaspire_dern_vm_push_value(vm, result);
            octaspire_dern_value_t *tmpResult = octaspire_dern_vm_eval(vm, result, envVal);
            octaspire_dern_vm_pop_value(vm, result);
            octaspire_dern_vm_pop_value(vm, envVal);
            result = tmpResult;
        }
    }
    else
    {
        result = octaspire_dern_vm_eval(vm, valueToBeEvaluated, environment);
        octaspire_dern_vm_push_value(vm, result);
        octaspire_dern_value_t *tmpResult = octaspire_dern_vm_eval(vm, result, environment);
        octaspire_dern_vm_pop_value(vm, result);
        result = tmpResult;
    }

    octaspire_helpers_verify_not_null(result);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_special_quote(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'quote' expects one argument. %zu arguments were given.",
            octaspire_vector_get_length(vec));
    }

    octaspire_dern_value_t *quotedValue = octaspire_vector_get_element_at(vec, 0);

    octaspire_helpers_verify_not_null(quotedValue);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return quotedValue;
}

octaspire_dern_value_t *octaspire_dern_vm_special_select(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2 || numArgs % 2 != 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'select' expects at least two arguments and the number of arguments must be "
            "multiple of two. Now %zu arguments were given.",
            numArgs);
    }

    octaspire_dern_vm_push_value(vm, arguments);

    for (size_t i = 0; i < numArgs; i += 2)
    {
        octaspire_dern_value_t * testResult =
            octaspire_dern_value_as_vector_get_element_at(arguments, (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(testResult);

        if (testResult->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL &&
            octaspire_string_is_equal_to_c_string(
                testResult->value.symbol,
                "default"))
        {
            if (i != (numArgs-2))
            {
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_from_c_string(
                    vm,
                    "'default' must be the last selector in special 'select'.");
            }
            else
            {
                octaspire_dern_value_t * result = octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(
                        arguments,
                        (ptrdiff_t)(i + 1)),
                    environment);

                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return result;
            }
        }
        else
        {
            testResult = octaspire_dern_vm_eval(
                vm,
                octaspire_dern_value_as_vector_get_element_at(
                    arguments,
                    (ptrdiff_t)i),
                environment);

            octaspire_helpers_verify_not_null(testResult);

            if (testResult->typeTag != OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
            {
                if (testResult->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_dern_vm_pop_value(vm, arguments);

                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return testResult;
                }
                else
                {
                    octaspire_dern_vm_pop_value(vm, arguments);

                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_format(
                        vm,
                        "Selectors of special 'select' must evaluate into booleans. "
                        "Type '%s' was given.",
                        octaspire_dern_value_helper_get_type_as_c_string(testResult->typeTag));
                }
            }

            if (testResult->value.boolean)
            {
                octaspire_dern_value_t * result = octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(
                        arguments,
                        (ptrdiff_t)(i + 1)),
                    environment);

                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));
                return result;
            }
        }
    }

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_nil(vm);
}

octaspire_dern_value_t *octaspire_dern_vm_special_if(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 2 && numArgs != 3)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'if' expects two or three arguments. %zu arguments were given.",
            octaspire_dern_value_get_length(arguments));
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t * testResult = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_helpers_verify_not_null(testResult);
    octaspire_dern_vm_push_value(vm, testResult);

    if (testResult->typeTag == OCTASPIRE_DERN_VALUE_TAG_FUNCTION)
    {
        // Allow calling with   (fn () x)  instead of   ((fn (x) x))
        octaspire_dern_value_t *wrapperVecVal = octaspire_dern_vm_create_new_value_vector(vm);
        octaspire_dern_vm_push_value(vm, wrapperVecVal);
        octaspire_dern_value_as_vector_push_back_element(wrapperVecVal, &testResult);

        octaspire_dern_value_t * tmpVal = octaspire_dern_vm_eval(
            vm,
            wrapperVecVal,
            environment);

        octaspire_dern_vm_pop_value(vm, wrapperVecVal);
        // TODO is this needed, or does vector popping pop this too? Check...
        //octaspire_dern_vm_pop_value(vm, testResult);
        octaspire_dern_vm_pop_value(vm, testResult);
        testResult = tmpVal;
    }
    else
    {
        octaspire_dern_vm_pop_value(vm, testResult);
    }

    octaspire_helpers_verify_not_null(testResult);

    if (testResult->typeTag != OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
    {
        octaspire_dern_vm_pop_value(vm, arguments);

        if (testResult->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return testResult;
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "First argument to special 'if' must evaluate into boolean value. "
            "Now it evaluated into type %s.",
            octaspire_dern_value_helper_get_type_as_c_string(testResult->typeTag));
    }

    octaspire_dern_value_t *result = 0;

    if (octaspire_dern_value_get_length(arguments) == 2)
    {
        if (testResult->value.boolean)
        {
            result = octaspire_dern_vm_eval(
                vm,
                octaspire_dern_value_as_vector_get_element_at(arguments, 1),
                environment);
        }
        else
        {
            result = octaspire_dern_vm_get_value_nil(vm);
        }
    }
    else
    {
        result = octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (testResult->value.boolean) ? 1 : 2),

            environment);
    }

    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_not_null(result);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_special_while(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'while' expects at least two arguments. %zu arguments were given.",
            octaspire_dern_value_get_length(arguments));
    }

    octaspire_dern_vm_push_value(vm, arguments);

    bool testStat = false;
    int32_t counter = 0;

    while (true)
    {
        octaspire_dern_value_t * const testResult = octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, 0),
            environment);

        octaspire_helpers_verify_not_null(testResult);

        if (testResult->typeTag != OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
        {
            octaspire_dern_vm_pop_value(vm, arguments);

            if (testResult->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));
                return testResult;
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to special 'while' must evaluate into boolean value. "
                "Now it evaluated into type %s.",
                octaspire_dern_value_helper_get_type_as_c_string(testResult->typeTag));
        }

        testStat = testResult->value.boolean;

        if (!testStat)
        {
            break;
        }

        for (size_t i = 1; i < numArgs; ++i)
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                vm,
                octaspire_dern_value_as_vector_get_element_at(
                    arguments,
                    (ptrdiff_t)i),
                environment);

            octaspire_helpers_verify_not_null(result);

            if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
            {
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return result;

            }

            if (octaspire_dern_vm_get_function_return(vm))
            {
                result = octaspire_dern_vm_get_function_return(vm);
                //octaspire_dern_vm_set_function_return(vm, 0);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return result;
            }
        }

        ++counter;
    };

    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_integer(vm, counter);
}

octaspire_dern_value_t *octaspire_dern_vm_special_for(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t stepSize = 1; // Used for containers and numerical iteration.

    octaspire_dern_vm_push_value(vm, arguments);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 4)
    {
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'for' expects at least four (for iterating container or port) or five (for "
            "iterating numeric range) arguments. %zu arguments were given.",
            numArgs);
    }

    // 1. argument: counter symbol
    octaspire_dern_value_t *counterSymbol =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(counterSymbol);

    if (counterSymbol->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "First argument to special 'for' must be symbol value. "
            "Now it has type %s.",
            octaspire_dern_value_helper_get_type_as_c_string(counterSymbol->typeTag));
    }

    // 2. argument: 'in' or 'from' symbol
    octaspire_dern_value_t const * const inOrFromSymbol =
        octaspire_dern_value_as_vector_get_element_at(arguments, 1);

    octaspire_helpers_verify_not_null(inOrFromSymbol);

    if (inOrFromSymbol->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Second argument to special 'for' must be symbol 'in' or 'from'. "
            "Now it has type %s.",
            octaspire_dern_value_helper_get_type_as_c_string(inOrFromSymbol->typeTag));
    }

    if (octaspire_string_is_equal_to_c_string(inOrFromSymbol->value.symbol, "in"))
    {
        // (for i in '(1 2 3))
        // (for i in (hash-map a 1 b 2))
        // (for i in [kissa])

        // container
        octaspire_dern_value_t *container =
            octaspire_dern_value_as_vector_get_element_at(arguments, 2);

        octaspire_helpers_verify_not_null(container);

        container = octaspire_dern_vm_eval(vm, container, environment);

        octaspire_helpers_verify_not_null(container);

        octaspire_dern_vm_push_value(vm, container);

        if (container->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING      &&
            container->typeTag != OCTASPIRE_DERN_VALUE_TAG_VECTOR      &&
            container->typeTag != OCTASPIRE_DERN_VALUE_TAG_LIST        &&
            container->typeTag != OCTASPIRE_DERN_VALUE_TAG_QUEUE       &&
            container->typeTag != OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT &&
            container->typeTag != OCTASPIRE_DERN_VALUE_TAG_HASH_MAP    &&
            container->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Third argument to special 'for' using 'in' must be a container "
                "(string, vector, list, queue, hash map or environment) or a port. "
                "Now it has type %s.",
                octaspire_dern_value_helper_get_type_as_c_string(container->typeTag));

            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }

        // Check if there are optional 'step' and then integer
        size_t currentArgIdx = 3;

        // Optional 3 and 4. arguments: step integer
        octaspire_dern_value_t const * const optionalStep =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)currentArgIdx);

        octaspire_helpers_verify_not_null(optionalStep);

        if (optionalStep->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL &&
            octaspire_string_is_equal_to_c_string(
                optionalStep->value.symbol,
                "step"))
        {
            if (numArgs < 5)
            {
                octaspire_dern_vm_pop_value(vm, container);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Special 'for' expects at least five arguments for iterating containers or "
                    "ports with a given step size. %zu arguments were given.",
                    numArgs);
            }

            // There is 'step'. Now an integer is required next
            ++currentArgIdx;

            octaspire_dern_value_t const * const requiredStepSize =
                octaspire_dern_value_as_vector_get_element_at(
                    arguments,
                    (ptrdiff_t)currentArgIdx);

            octaspire_helpers_verify_not_null(requiredStepSize);

            if (requiredStepSize->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
            {
                octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Fifth argument to special 'for' using 'step' with containers must be "
                    "an integer step size. Now it has type %s.",
                    octaspire_dern_value_helper_get_type_as_c_string(requiredStepSize->typeTag));

                octaspire_dern_vm_pop_value(vm, container);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return result;
            }

            if (requiredStepSize->value.integer <= 0)
            {
                octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "The 'step' of special 'for' must be larger than zero. "
                    "Now it is %s%" PRId32 "}.",
                    (requiredStepSize->value.integer >= 0) ? "{D+" : "{D",
                    requiredStepSize->value.integer);

                octaspire_dern_vm_pop_value(vm, container);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return result;
            }

            stepSize = (size_t)requiredStepSize->value.integer;
        }

        // Extend env for the counter variable
        octaspire_dern_environment_t *extendedEnvironment =
            octaspire_dern_environment_new(
                environment,
                vm,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_helpers_verify_not_null(extendedEnvironment);

        octaspire_dern_value_t *extendedEnvVal =
            octaspire_dern_vm_create_new_value_environment_from_environment(
                vm,
                extendedEnvironment);

        octaspire_helpers_verify_not_null(extendedEnvVal);

        octaspire_dern_vm_push_value(vm, extendedEnvVal);

        if (container->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING)
        {
            octaspire_string_t const * const str = container->value.string;
            size_t const strLen = octaspire_string_get_length_in_ucs_characters(str);

            int32_t counter = 0;

            for (size_t i = 0; i < strLen; i += stepSize)
            {
                octaspire_string_t *charStr = octaspire_string_new(
                    "",
                    octaspire_dern_vm_get_allocator(vm));

                octaspire_string_push_back_ucs_character(
                    charStr,
                    octaspire_string_get_ucs_character_at_index(
                        str,
                        (ptrdiff_t)i));

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_dern_vm_create_new_value_character(vm, charStr));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(
                            arguments,
                            (ptrdiff_t)j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else if (container->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR)
        {
            octaspire_vector_t * const vec = container->value.vector;
            size_t const vecLen = octaspire_vector_get_length(vec);

            int32_t counter = 0;

            for (size_t i = 0; i < vecLen; i += stepSize)
            {
                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(
                            arguments,
                            (ptrdiff_t)j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }



        else if (container->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST)
        {
            octaspire_list_t * const list = container->value.list;
            size_t const listLen = octaspire_list_get_length(list);

            int32_t counter = 0;

            // TODO more efficient iteration of list
            for (size_t i = 0; i < listLen; i += stepSize)
            {
                octaspire_list_node_t *node =
                    octaspire_list_get_at(
                        list,
                        (ptrdiff_t)i);

                octaspire_helpers_verify_not_null(node);

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_list_node_get_element(node));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(
                            arguments,
                            (ptrdiff_t)j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else if (container->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE)
        {
            octaspire_queue_t * const queue = container->value.queue;
            size_t const queueLen = octaspire_queue_get_length(queue);

            int32_t counter = 0;

            // TODO more efficient iteration of queue
            for (size_t i = 0; i < queueLen; i += stepSize)
            {
                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_queue_get_at(
                        queue,
                        (ptrdiff_t)i));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(
                            arguments,
                            (ptrdiff_t)j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else if (container->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
        {
            octaspire_dern_environment_t * const env = container->value.environment;
            size_t const envLen = octaspire_dern_environment_get_length(env);

            int32_t counter = 0;

            for (size_t i = 0; i < envLen; i += stepSize)
            {
                octaspire_map_element_t *element =
                    octaspire_dern_environment_get_at_index(
                        env,
                        (ptrdiff_t)i);

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_dern_vm_create_new_value_vector_from_values(
                        vm,
                        2,
                        octaspire_map_element_get_key(element),
                        octaspire_map_element_get_value(element)));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(
                            arguments,
                            (ptrdiff_t)j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else if (container->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP)
        {
            octaspire_map_t * const hashMap = container->value.hashMap;
            size_t const hashMapLen = octaspire_map_get_number_of_elements(hashMap);

            int32_t counter = 0;

            for (size_t i = 0; i < hashMapLen; i += stepSize)
            {
                octaspire_map_element_t *element =
                    octaspire_map_get_at_index(
                        hashMap,
                        (ptrdiff_t)i);

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_dern_vm_create_new_value_vector_from_values(
                        vm,
                        2,
                        octaspire_map_element_get_key(element),
                        octaspire_map_element_get_value(element)));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(
                            arguments,
                            (ptrdiff_t)j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else if (container->typeTag == OCTASPIRE_DERN_VALUE_TAG_PORT)
        {
            octaspire_dern_port_t * const port = container->value.port;

            int32_t counter = 0;
            size_t  skip    = 0;

            bool noMoreInput = false;

            while (!noMoreInput)
            {
                char buffer[1];

                for (size_t i = 0; i < skip; ++i)
                {
                    if (octaspire_dern_port_read(port, buffer, sizeof(char)) < 1)
                    {
                        noMoreInput = true;
                        break;
                    }
                }

                if (noMoreInput)
                {
                    break;
                }

                if (octaspire_dern_port_read(port, buffer, sizeof(char)) < 1)
                {
                    noMoreInput = true;
                    break;
                }

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_dern_vm_create_new_value_integer(vm, (int32_t)buffer[0]));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(
                            arguments,
                            (ptrdiff_t)j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }

                }

                skip = (stepSize - 1);

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else
        {
            abort();
        }
    }
    else if (octaspire_string_is_equal_to_c_string(
        inOrFromSymbol->value.symbol,
        "from"))
    {
        // (for i from 0 to 100)
        // TODO XXX

        // 0
        octaspire_dern_value_t *fromValue =
            octaspire_dern_value_as_vector_get_element_at(arguments, 2);

        octaspire_helpers_verify_not_null(fromValue);

        fromValue = octaspire_dern_vm_eval(vm, fromValue, environment);

        octaspire_helpers_verify_not_null(fromValue);

        octaspire_dern_vm_push_value(vm, fromValue);

        if (fromValue->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Third argument to special 'for' using 'from' must be integer. "
                "Now it has type %s.",
                octaspire_dern_value_helper_get_type_as_c_string(fromValue->typeTag));

            octaspire_dern_vm_pop_value(vm, fromValue);
            octaspire_dern_vm_pop_value(vm, arguments);

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }

        // 100
        octaspire_dern_value_t *toValue =
            octaspire_dern_value_as_vector_get_element_at(arguments, 4);

        octaspire_helpers_verify_not_null(toValue);

        toValue = octaspire_dern_vm_eval(vm, toValue, environment);

        octaspire_helpers_verify_not_null(toValue);

        octaspire_dern_vm_push_value(vm, toValue);

        if (toValue->typeTag != fromValue->typeTag)
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Fifth argument to special 'for' using 'from' must be of same type than the "
                "third (%s). Now it has type %s.",
                octaspire_dern_value_helper_get_type_as_c_string(fromValue->typeTag),
                octaspire_dern_value_helper_get_type_as_c_string(toValue->typeTag));

            octaspire_dern_vm_pop_value(vm, toValue);
            octaspire_dern_vm_pop_value(vm, fromValue);
            octaspire_dern_vm_pop_value(vm, arguments);

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }

        // Check if there are optional 'step' and then integer
        size_t currentArgIdx = 5;

        // Optional 5. and 6. arguments: step integer
        octaspire_dern_value_t const * const optionalStep =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)currentArgIdx);

        octaspire_helpers_verify_not_null(optionalStep);

        if (optionalStep->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL &&
            octaspire_string_is_equal_to_c_string(
                optionalStep->value.symbol,
                "step"))
        {
            if (numArgs < 7)
            {
                octaspire_dern_vm_pop_value(vm, toValue);
                octaspire_dern_vm_pop_value(vm, fromValue);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Special 'for' expects at least seven arguments in numeric form with "
                    "a given step size. %zu arguments were given.",
                    numArgs);
            }

            // There is 'step'. Now an integer is required next
            ++currentArgIdx;

            octaspire_dern_value_t const * const requiredStepSize =
                octaspire_dern_value_as_vector_get_element_at(
                    arguments,
                    (ptrdiff_t)currentArgIdx);

            octaspire_helpers_verify_not_null(requiredStepSize);

            if (requiredStepSize->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
            {
                octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Seventh argument to special 'for' using 'step' with numeric iteration must be "
                    "an integer step size. Now it has type %s.",
                    octaspire_dern_value_helper_get_type_as_c_string(requiredStepSize->typeTag));

                octaspire_dern_vm_pop_value(vm, toValue);
                octaspire_dern_vm_pop_value(vm, fromValue);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return result;
            }

            if (requiredStepSize->value.integer <= 0)
            {
                octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "The 'step' of special 'for' must be larger than zero. "
                    "Now it is %s%" PRId32 "}.",
                    (requiredStepSize->value.integer >= 0) ? "{D+" : "{D",
                    requiredStepSize->value.integer);

                octaspire_dern_vm_pop_value(vm, toValue);
                octaspire_dern_vm_pop_value(vm, fromValue);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return result;
            }

            stepSize = (size_t)requiredStepSize->value.integer;
        }

        // Extend env for the counter variable
        octaspire_dern_environment_t *extendedEnvironment =
            octaspire_dern_environment_new(
                environment,
                vm,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_helpers_verify_not_null(extendedEnvironment);

        octaspire_dern_value_t *extendedEnvVal =
            octaspire_dern_vm_create_new_value_environment_from_environment(
                vm,
                extendedEnvironment);

        octaspire_helpers_verify_not_null(extendedEnvVal);

        octaspire_dern_vm_push_value(vm, extendedEnvVal);

        bool const fromIsSmaller = octaspire_dern_value_is_less_than_or_equal(fromValue, toValue);

        if (fromIsSmaller)
        {
            size_t const numIterations =
                (size_t)(toValue->value.integer - fromValue->value.integer) + 1;

            int32_t counter = 0;

            for (size_t i = 0; i < numIterations; i += stepSize)
            {
                octaspire_dern_value_t *iterator =
                    octaspire_dern_vm_create_new_value_copy(vm, fromValue);

                iterator->value.integer += i;

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    iterator);

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(
                            arguments,
                            (ptrdiff_t)j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, toValue);
                        octaspire_dern_vm_pop_value(vm, fromValue);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, toValue);
                        octaspire_dern_vm_pop_value(vm, fromValue);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, toValue);
            octaspire_dern_vm_pop_value(vm, fromValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else
        {
            size_t const numIterations =
                (size_t)(fromValue->value.integer - toValue->value.integer) + 1;

            int32_t counter = 0;

            for (size_t i = 0; i < numIterations; i += stepSize)
            {
                octaspire_dern_value_t *iterator =
                    octaspire_dern_vm_create_new_value_copy(vm, fromValue);

                iterator->value.integer -= i;

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    iterator);

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(
                            arguments,
                            (ptrdiff_t)j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, toValue);
                        octaspire_dern_vm_pop_value(vm, fromValue);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, toValue);
                        octaspire_dern_vm_pop_value(vm, fromValue);
                        octaspire_dern_vm_pop_value(vm, arguments);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, toValue);
            octaspire_dern_vm_pop_value(vm, fromValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
    }

    return 0;
}

// TODO move to other builtins
octaspire_dern_value_t *octaspire_dern_vm_builtin_starts_with_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'starts-with?' expects two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    octaspire_dern_value_t *secondArg = octaspire_dern_value_as_vector_get_element_at(arguments, 1);
    octaspire_helpers_verify_not_null(secondArg);

    if (firstArg->typeTag != secondArg->typeTag)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_get_value_false(vm);
    }

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        // TODO XXX implement rest of the fitting types
        //abort();
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_get_value_false(vm);
    }

    bool const result = octaspire_string_starts_with(
        firstArg->value.string,
        secondArg->value.string);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, result);
}

/*
    (= num 10)                         ; set variable to
    (= vec 1 [kissa])                  ; set vector index to
    (= map [john] [305-3848506428])    ; set map for key to
    (= str 1 |a|)                      ; set character of string at index to
*/
octaspire_dern_value_t *octaspire_dern_vm_builtin_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2 || numArgs > 3)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '=' expects two or three arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (numArgs == 2)
    {
        octaspire_dern_value_t *secondArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, 1);

        octaspire_helpers_verify_not_null(secondArg);

        if (octaspire_dern_value_set(firstArg, secondArg))
        {
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            //return octaspire_dern_vm_get_value_true(vm);
            return firstArg;
        }

        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(vm, "Builtin '=' failed");
    }
    else
    {
        octaspire_dern_value_t *secondArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, 1);

        octaspire_helpers_verify_not_null(secondArg);

        octaspire_dern_value_t *thirdArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, 2);

        octaspire_helpers_verify_not_null(thirdArg);

        if (octaspire_dern_value_set_collection(firstArg, secondArg, thirdArg))
        {
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            //return octaspire_dern_vm_get_value_true(vm);
            return firstArg;
        }

        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(vm, "Builtin '=' failed");
    }
}

octaspire_dern_value_t *octaspire_dern_vm_special_equals_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '==' expects at least two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstValue = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_dern_vm_push_value(vm, firstValue);

    for (size_t i = 1; i < numArgs; ++i)
    {
        octaspire_dern_value_t *secondValue = octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, (ptrdiff_t)i),
            environment);

        octaspire_dern_vm_push_value(vm, secondValue);

        if (!octaspire_dern_value_is_equal(firstValue, secondValue))
        {
            octaspire_dern_vm_pop_value(vm, secondValue);
            octaspire_dern_vm_pop_value(vm, firstValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_get_value_false(vm);
        }

        octaspire_dern_vm_pop_value(vm, secondValue);
    }

    octaspire_dern_vm_pop_value(vm, firstValue);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}

octaspire_dern_value_t *octaspire_dern_vm_special_equals_equals_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(
        arguments->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_helpers_verify_true(
        environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '===' expects at least two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstValue = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_dern_vm_push_value(vm, firstValue);

    for (size_t i = 1; i < numArgs; ++i)
    {
        octaspire_dern_value_t *secondValue = octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, (ptrdiff_t)i),
            environment);

        octaspire_dern_vm_push_value(vm, secondValue);

        if (firstValue->uniqueId != secondValue->uniqueId)
        {
            octaspire_dern_vm_pop_value(vm, secondValue);
            octaspire_dern_vm_pop_value(vm, firstValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_get_value_false(vm);
        }

        octaspire_dern_vm_pop_value(vm, secondValue);
    }

    octaspire_dern_vm_pop_value(vm, firstValue);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}

octaspire_dern_value_t *octaspire_dern_vm_special_exclamation_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    octaspire_dern_value_t *tmpVal =
        octaspire_dern_vm_special_equals_equals(vm, arguments, environment);

    if (tmpVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
    {
        return tmpVal;
    }

    if (tmpVal->typeTag != OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
    {
        abort();
    }

    return octaspire_dern_vm_create_new_value_boolean(
        vm,
        !octaspire_dern_value_as_boolean_get_value(tmpVal));
}

octaspire_dern_value_t *octaspire_dern_vm_special_less_than_or_equal(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Special '<=' expects at least two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstValue = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_dern_vm_push_value(vm, firstValue);

    for (size_t i = 1; i < numArgs; ++i)
    {
        if (!octaspire_dern_value_is_less_than_or_equal(
                firstValue,
                octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(
                        arguments,
                        (ptrdiff_t)i),
                    environment)))
        {
            octaspire_dern_vm_pop_value(vm, firstValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_get_value_false(vm);
        }
    }

    octaspire_dern_vm_pop_value(vm, firstValue);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}

octaspire_dern_value_t *octaspire_dern_vm_special_less_than(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Special '<' expects at least two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstValue = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_dern_vm_push_value(vm, firstValue);

    for (size_t i = 1; i < numArgs; ++i)
    {
        if (!octaspire_dern_value_is_less_than(
                firstValue,
                octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(
                        arguments,
                        (ptrdiff_t)i),
                    environment)))
        {
            octaspire_dern_vm_pop_value(vm, firstValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_get_value_false(vm);
        }
    }

    octaspire_dern_vm_pop_value(vm, firstValue);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}

octaspire_dern_value_t *octaspire_dern_vm_special_greater_than(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Special '>' expects at least two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstValue = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_dern_vm_push_value(vm, firstValue);

    for (size_t i = 1; i < numArgs; ++i)
    {
        if (!octaspire_dern_value_is_greater_than(
                firstValue,
                octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(
                        arguments,
                        (ptrdiff_t)i),
                    environment)))
        {
            octaspire_dern_vm_pop_value(vm, firstValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_get_value_false(vm);
        }
    }

    octaspire_dern_vm_pop_value(vm, firstValue);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}

octaspire_dern_value_t *octaspire_dern_vm_special_greater_than_or_equal(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Special '>=' expects at least two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstValue = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_dern_vm_push_value(vm, firstValue);

    for (size_t i = 1; i < numArgs; ++i)
    {
        if (!octaspire_dern_value_is_greater_than_or_equal(
                firstValue,
                octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(
                        arguments,
                        (ptrdiff_t)i),
                    environment)))
        {
            octaspire_dern_vm_pop_value(vm, firstValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_get_value_false(vm);
        }
    }

    octaspire_dern_vm_pop_value(vm, firstValue);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}

octaspire_dern_value_t *octaspire_dern_stdlib_private_validate_function(
    octaspire_dern_vm_t* vm,
    octaspire_dern_function_t *function)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_not_null(function);
    octaspire_helpers_verify_not_null(function->formals);
    octaspire_helpers_verify_true(function->formals->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_not_null(function->body);
    octaspire_helpers_verify_true(function->body->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_not_null(function->definitionEnvironment);

    octaspire_helpers_verify_true(
        function->definitionEnvironment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_helpers_verify_not_null(function->allocator);

    size_t const numFormalArgs = octaspire_vector_get_length(
        function->formals->value.vector);

    size_t numDotArgs            = 0;
    size_t numNormalArgs         = 0;
    size_t numNormalArgsAfterDot = 0;

    for (size_t i = 0; i < numFormalArgs; ++i)
    {
        octaspire_dern_value_t *formal = octaspire_vector_get_element_at(
            function->formals->value.vector,
            (ptrdiff_t)i);

        //octaspire_helpers_verify_true(formal->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);
        if (!octaspire_dern_value_is_symbol(formal))
        {

            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'fn' expects symbol for formal at %zu. argument. "
                "Now type '%s' was given.",
                (i + 1),
                octaspire_dern_value_helper_get_type_as_c_string(
                    octaspire_dern_value_get_type(formal)));
        }

        octaspire_string_t const * const formalAsStr = formal->value.string;

        if (octaspire_string_is_equal_to_c_string(formalAsStr, "."))
        {
            ++numDotArgs;
        }
        else
        {
            if (numDotArgs)
            {
                ++numNormalArgsAfterDot;
            }
            else
            {
                ++numNormalArgs;
            }
        }
    }

    if (numDotArgs > 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Function can have only one formal . for varargs. Now %zu dots were given.",
            numDotArgs);
    }

    if (numNormalArgsAfterDot > 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Function can have only one formal argument after . "
            "for varargs. Now %zu formals were given after dot.",
            numNormalArgsAfterDot);
    }

    if (numDotArgs == 0 && numNormalArgs != numFormalArgs)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Number of formal and actual arguments must be equal for functions without "
            "varargs using the dot-formal. Now %zu formal and %zu actual arguments were given.",
            numFormalArgs,
            numNormalArgs);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_special_fn(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_dern_vm_push_value(vm, arguments);
    octaspire_dern_vm_push_value(vm, environment);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) < 2)
    {
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'fn' expects at least two arguments. %zu arguments were given.",
            octaspire_vector_get_length(vec));
    }

    octaspire_dern_value_t *formals = octaspire_vector_get_element_at(vec, 0);

    if (formals->typeTag != OCTASPIRE_DERN_VALUE_TAG_VECTOR)
    {
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "First argument to special 'fn' must be vector (formals). Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(formals->typeTag));
    }

    octaspire_dern_value_t *body = octaspire_dern_vm_create_new_value_vector(vm);

    octaspire_dern_vm_push_value(vm, body);

    for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
    {
        octaspire_dern_value_t *tmpPtr =
            octaspire_vector_get_element_at(
                vec,
                (ptrdiff_t)i);

        if (tmpPtr->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_dern_vm_pop_value(vm, body);
            octaspire_dern_vm_pop_value(vm, environment);
            octaspire_dern_vm_pop_value(vm, arguments);

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return tmpPtr;
        }

        if (!octaspire_dern_value_as_vector_push_back_element(
            body,
            &tmpPtr))
        {
            abort();
        }
    }

    octaspire_dern_function_t *function = octaspire_dern_function_new(
        formals,
        body,
        environment,
        octaspire_dern_vm_get_allocator(vm));

    if (!function)
    {
        octaspire_dern_vm_pop_value(vm, body);
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Allocation failure when creating function.");
    }

    octaspire_dern_value_t *error = octaspire_dern_stdlib_private_validate_function(vm, function);

    if (error)
    {
        octaspire_dern_vm_pop_value(vm, body);
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_dern_function_release(function);
        function = 0;

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return error;
    }

    // Real docstring is set by define
    octaspire_dern_value_t * result =
        octaspire_dern_vm_create_new_value_function(vm, function, "", 0);

    octaspire_dern_vm_pop_value(vm, body);
    octaspire_dern_vm_pop_value(vm, environment);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_uid(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_dern_vm_push_value(vm, arguments);
    octaspire_dern_vm_push_value(vm, environment);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) != 1)
    {
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'uid' expects exactly one argument. %zu arguments were given.",
            octaspire_vector_get_length(vec));
    }

    uintmax_t const uid =
        octaspire_dern_value_get_unique_id(octaspire_vector_get_element_at(vec, 0));

    if (uid > INT32_MAX)
    {
        abort();
    }

    octaspire_dern_value_t * result =
        octaspire_dern_vm_create_new_value_integer(vm, (int32_t)uid);

    octaspire_dern_vm_pop_value(vm, environment);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_abort(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'abort' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    octaspire_dern_value_print(firstArg, octaspire_dern_vm_get_allocator(vm));

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    abort();
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_input_file_open(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'input-file-open' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'input-file-open' expects string argument.");
    }

    octaspire_dern_value_t * const result = octaspire_dern_vm_create_new_value_input_file(
        vm,
        octaspire_dern_value_as_string_get_c_string(firstArg));

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_output_file_open(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'output-file-open' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'output-file-open' expects string argument.");
    }

    octaspire_dern_value_t * const result = octaspire_dern_vm_create_new_value_output_file(
        vm,
        octaspire_dern_value_as_string_get_c_string(firstArg));

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_io_file_open(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'io-file-open' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'io-file-open' expects string argument.");
    }

    octaspire_dern_value_t * const result = octaspire_dern_vm_create_new_value_io_file(
        vm,
        octaspire_dern_value_as_string_get_c_string(firstArg));

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_supports_output_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-supports-output?' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-supports-output?' expects port argument.");
    }

    bool const result = octaspire_dern_port_supports_output(firstArg->value.port);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, result);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_supports_input_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-supports-input?' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-supports-input?' expects port argument.");
    }

    bool const result = octaspire_dern_port_supports_input(firstArg->value.port);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, result);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_close(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-close' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-close' expects port argument.");
    }

    bool const wasClosed = octaspire_dern_port_close(firstArg->value.port);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, wasClosed);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_read(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1 && numArgs != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-read' expects one or two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'port-read' must be a port. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    octaspire_dern_value_t *result = 0;

    if (numArgs == 2)
    {
        octaspire_dern_value_t *secondArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, 1);

        octaspire_helpers_verify_not_null(secondArg);

        if (secondArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
        {
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "The second argument to builtin 'port-read' must be an integer. "
                "Now type %s was given.",
                octaspire_dern_value_helper_get_type_as_c_string(secondArg->typeTag));
        }

        result = octaspire_dern_vm_create_new_value_vector(vm);

        octaspire_helpers_verify_not_null(result);

        octaspire_dern_vm_push_value(vm, result);

        // TODO better implementation
        for (ptrdiff_t i = 0; i < secondArg->value.integer; ++i)
        {
            char buffer[1];

            ptrdiff_t const numOctetsRead =
                octaspire_dern_port_read(firstArg->value.port, buffer, sizeof(buffer));

            if (numOctetsRead != 1)
            {
                break;
            }

            octaspire_dern_value_t *elem =
                octaspire_dern_vm_create_new_value_integer(vm, (int32_t)buffer[0]);

            octaspire_helpers_verify_not_null(elem);

            octaspire_dern_vm_push_value(vm, elem);
            octaspire_dern_value_as_vector_push_back_element(result, &elem);
            octaspire_dern_vm_pop_value(vm, elem);
        }

        octaspire_helpers_verify_not_null(result);

        octaspire_dern_vm_pop_value(vm, result);
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }
    else
    {
        char buffer[1];

        ptrdiff_t const numOctetsRead =
            octaspire_dern_port_read(firstArg->value.port, buffer, sizeof(buffer));

        if (numOctetsRead != 1)
        {
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'port-read' failed to read the requested one octet.");
        }

        result = octaspire_dern_vm_create_new_value_integer(vm, (int32_t)buffer[0]);

        octaspire_helpers_verify_not_null(result);

        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_write(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'port-write' expects exactly two arguments. %zu argument were given.",
            numArgs);
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'port-write' must be a port. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    if (!octaspire_dern_port_supports_output(firstArg->value.port))
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "The first argument to builtin 'port-write' must be a port supporting writing.");
    }

    octaspire_dern_value_t *secondArg = octaspire_dern_value_as_vector_get_element_at(arguments, 1);
    octaspire_helpers_verify_not_null(secondArg);

    if (secondArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER)
    {
        // TODO XXX check that value fits into one octet and report
        // error otherwise
        char buffer[1];
        buffer[0] = (char)secondArg->value.integer;

        ptrdiff_t const numWritten =
            octaspire_dern_port_write(firstArg->value.port, buffer, sizeof(buffer));

        octaspire_helpers_verify_true(numWritten >= 0);

        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_integer(vm, (int32_t)numWritten);
    }
    else if (secondArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER)
    {
        octaspire_string_t *str = secondArg->value.character;
        char const * const buffer = octaspire_string_get_c_string(str);
        size_t bufferLen = octaspire_string_get_length_in_octets(str);

        ptrdiff_t const numWritten =
            octaspire_dern_port_write(firstArg->value.port, buffer, bufferLen);

            if (numWritten < 0 || (size_t)numWritten != bufferLen)
            {
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Writing of %zu octets of character failed. Only %zu octets were written.",
                    bufferLen,
                    numWritten);
            }
            else
            {
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_integer(
                    vm,
                    (int32_t)bufferLen);
            }
    }
    else if (secondArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_string_t *str = secondArg->value.string;
        char const * const buffer = octaspire_string_get_c_string(str);
        size_t bufferLen = octaspire_string_get_length_in_octets(str);

        ptrdiff_t const numWritten =
            octaspire_dern_port_write(firstArg->value.port, buffer, bufferLen);

            if (numWritten < 0 || (size_t)numWritten != bufferLen)
            {
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Writing of %zu octets of string failed. Only %zu octets were written.",
                    bufferLen,
                    numWritten);
            }
            else
            {
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_integer(
                    vm,
                    (int32_t)bufferLen);
            }
    }
    else if (secondArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR)
    {
        int32_t counter = 0;
        for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(secondArg); ++i)
        {
            octaspire_dern_value_t * const elem =
                octaspire_dern_value_as_vector_get_element_at(
                    secondArg,
                    (ptrdiff_t)i);

            octaspire_helpers_verify_not_null(elem);

            octaspire_dern_value_t *tmpArgs = octaspire_dern_vm_create_new_value_vector(vm);
            octaspire_dern_vm_push_value(vm, tmpArgs);

            octaspire_dern_value_as_vector_push_back_element(tmpArgs, &firstArg);
            octaspire_dern_value_as_vector_push_back_element(tmpArgs, &elem);

            octaspire_dern_value_t * const countVal =
                octaspire_dern_vm_builtin_port_write(vm, tmpArgs, environment);

            octaspire_dern_vm_pop_value(vm, tmpArgs);

            octaspire_helpers_verify_not_null(countVal);

            if (countVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
            {
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return countVal;
            }

            octaspire_helpers_verify_true(countVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER);

            counter += countVal->value.integer;
        }

        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_integer(vm, counter);
    }
    else
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The second argument to builtin 'port-write' must be an integer, character, string\n"
            "or a vector of these types. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(secondArg->typeTag));
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_seek(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 2 && numArgs != 3)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-seek' expects two or three arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'port-seek' must be a port. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    octaspire_dern_value_t *secondArg = octaspire_dern_value_as_vector_get_element_at(arguments, 1);
    octaspire_helpers_verify_not_null(secondArg);

    if (secondArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The second argument to builtin 'port-seek' must be an integer. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(secondArg->typeTag));
    }

    bool seekFromCurrentPosition = false;

    if (numArgs == 3)
    {
        octaspire_dern_value_t *thirdArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, 2);

        octaspire_helpers_verify_not_null(thirdArg);

        if (thirdArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
        {
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "The third argument to builtin 'port-seek' must be symbol 'from-current'. "
                "Now type %s was given.",
                octaspire_dern_value_helper_get_type_as_c_string(thirdArg->typeTag));
        }

        seekFromCurrentPosition = true;
    }

    bool const success = octaspire_dern_port_seek(
        firstArg->value.port,
        secondArg->value.integer,
        seekFromCurrentPosition);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, success);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_dist(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-dist' expects exactly one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'port-dist' must be a port. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    ptrdiff_t dist = octaspire_dern_port_distance(firstArg->value.port);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    // TODO check that dist fits into int32_t and report error if it doesn'tk
    return octaspire_dern_vm_create_new_value_integer(vm, (int32_t)dist);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_length(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-length' expects exactly one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'port-length' must be a port. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    ptrdiff_t length  = octaspire_dern_port_get_length_in_octets(firstArg->value.port);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    // TODO check that length fits into int32_t and report error if it doesn'tk
    return octaspire_dern_vm_create_new_value_integer(vm, (int32_t)length);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_flush(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-flush' expects exactly one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'port-flush' must be a port. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    bool const success = octaspire_dern_port_flush(firstArg->value.port);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, success);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_not(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'not' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'not' expects boolean argument.");
    }

    bool const given = firstArg->value.boolean;

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, !given);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_return(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs > 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'return' expects zero or one arguments. %zu arguments were given.",
            numArgs);
    }

    if (numArgs == 1)
    {
        octaspire_dern_value_t *firstArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, 0);

        octaspire_helpers_verify_not_null(firstArg);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        octaspire_helpers_verify_true(octaspire_dern_vm_get_function_return(vm) == 0);

        octaspire_dern_vm_set_function_return(vm, firstArg);
        return firstArg;
    }
    else
    {
        octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_nil(vm);
        octaspire_helpers_verify_not_null(result);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        octaspire_helpers_verify_true(octaspire_dern_vm_get_function_return(vm) == 0);

        octaspire_dern_vm_set_function_return(vm, result);
        return result;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_vector(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_vector(vm);
    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(arguments); ++i)
    {
        octaspire_dern_value_t * arg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        if (octaspire_dern_value_is_atom(arg))
        {
            arg = octaspire_dern_vm_create_new_value_copy(vm, arg);
        }

        octaspire_dern_value_as_vector_push_back_element(result, &arg);
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_special_and(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_boolean(vm, true);
    }

    octaspire_dern_value_t *result = 0;

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(arguments); ++i)
    {
        octaspire_dern_value_t * const arg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(arg);

        result = octaspire_dern_vm_eval(vm, arg, environment);

        if (octaspire_dern_vm_get_function_return(vm))
        {
            result = octaspire_dern_vm_get_function_return(vm);
            break;
        }

        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
        {
            if (!result->value.boolean)
            {
                break;
            }
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_special_or(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_boolean(vm, false);
    }

    octaspire_dern_value_t *result = 0;

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(arguments); ++i)
    {
        octaspire_dern_value_t * const arg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(arg);

        result = octaspire_dern_vm_eval(vm, arg, environment);

        if (octaspire_dern_vm_get_function_return(vm))
        {
            result = octaspire_dern_vm_get_function_return(vm);
            break;
        }

        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
        {
            if (result->value.boolean)
            {
                break;
            }
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_special_do(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Special 'do' expects at least one argument.");
    }

    octaspire_dern_value_t *result = 0;

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(arguments); ++i)
    {
        octaspire_dern_value_t * const arg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(arg);

        result = octaspire_dern_vm_eval(vm, arg, environment);

        if (octaspire_dern_vm_get_function_return(vm))
        {
            result = octaspire_dern_vm_get_function_return(vm);
            //octaspire_dern_vm_set_function_return(vm, 0);
            break;
        }

        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_string_t *tmpStr =
                octaspire_dern_value_to_string(arg, octaspire_dern_vm_get_allocator(vm));

            octaspire_string_concatenate_format(
                result->value.error->message,
                "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                octaspire_string_get_c_string(tmpStr));

            octaspire_string_release(tmpStr);
            tmpStr = 0;

            break;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_exit(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) > 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'exit' expects zero or one argument.");
    }

    if (octaspire_vector_get_length(vec) == 1)
    {
        octaspire_dern_value_t *value = octaspire_vector_get_element_at(vec, 0);

        if (value->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Builtin 'exit' expects integer argument. Type %s was given.",
                octaspire_dern_value_helper_get_type_as_c_string(value->typeTag));
        }

        octaspire_dern_vm_set_exit_code(vm, value->value.integer);
    }

    octaspire_dern_vm_quit(vm);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}


octaspire_dern_value_t *octaspire_dern_vm_builtin_doc(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'doc' expects at least one argument.");
    }

    if (octaspire_vector_get_length(vec) == 1)
    {
        octaspire_dern_value_t *value = octaspire_vector_get_element_at(vec, 0);

        if (value->docstr)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return value->docstr;
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_get_value_nil(vm);
    }
    else
    {
        octaspire_vector_t *resultVec = octaspire_vector_new(
            sizeof(octaspire_dern_value_t*),
            true,
            0,
            octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t *resultVal =
            octaspire_dern_vm_create_new_value_vector_from_vector(vm, resultVec);

        octaspire_dern_vm_push_value(vm, resultVal);

        for (size_t i = 0; i < octaspire_vector_get_length(vec); ++i)
        {
            octaspire_dern_value_t * const value =
                octaspire_vector_get_element_at(vec, (ptrdiff_t)i);

            if (value->docstr)
            {
                octaspire_vector_push_back_element(resultVec, &(value->docstr));
            }
            else
            {
                octaspire_dern_value_t *valueNil = octaspire_dern_vm_get_value_nil(vm);
                octaspire_vector_push_back_element(resultVec, &valueNil);
            }
        }

        octaspire_dern_vm_pop_value(vm, resultVal);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return resultVal;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_len(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'len' expects at least one argument.");
    }

    if (octaspire_vector_get_length(vec) == 1)
    {
        octaspire_dern_value_t *value = octaspire_vector_get_element_at(vec, 0);

        // TODO XXX check number ranges for too large size_t value for int32_t?
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_integer(
            vm,
            (int32_t)octaspire_dern_value_get_length(value));
    }
    else
    {
        octaspire_dern_value_t *resultVal = octaspire_dern_vm_create_new_value_vector(vm);

        octaspire_dern_vm_push_value(vm, resultVal);

        for (size_t i = 0; i < octaspire_vector_get_length(vec); ++i)
        {
            octaspire_dern_value_t * const value =
                octaspire_vector_get_element_at(vec, (ptrdiff_t)i);

            // TODO XXX check number ranges for too large size_t value for int32_t?
            octaspire_dern_value_t *valueLen = octaspire_dern_vm_create_new_value_integer(
                vm,
                (int32_t)octaspire_dern_value_get_length(value));

            // TODO & or not?
            if (!octaspire_dern_value_as_vector_push_back_element(
                resultVal,
                &valueLen))
            {
                abort();
            }
        }

        octaspire_dern_vm_pop_value(vm, resultVal);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return resultVal;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_read_and_eval_path(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'read-and-eval-path' expects one argument. %zu arguments were given.",
            octaspire_vector_get_length(vec));
    }

    octaspire_dern_value_t *path = octaspire_vector_get_element_at(vec, 0);

    if (path->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "First argument to builtin 'read-and-eval-path' must be string (path). "
            "Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(path->typeTag));
    }

    octaspire_dern_value_t *result =
        octaspire_dern_vm_read_from_path_and_eval_in_global_environment(
            vm,
            octaspire_string_get_c_string(path->value.string));

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_read_and_eval_string(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'read-and-eval-string' expects one argument. %zu arguments were given.",
            octaspire_vector_get_length(vec));
    }

    octaspire_dern_value_t *stringToEval = octaspire_vector_get_element_at(vec, 0);

    if (stringToEval->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "First argument to builtin 'read-and-eval-string' must be string (to be evaluated). "
            "Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(stringToEval->typeTag));
    }

    octaspire_dern_value_t *result =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            octaspire_string_get_c_string(stringToEval->value.string));

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_string_format(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'string-format' expects one or more arguments.");
    }

    octaspire_dern_value_t const * const fmtStr =
        octaspire_dern_value_as_vector_get_element_at_const(arguments, 0);

    octaspire_helpers_verify_not_null(fmtStr);

    octaspire_string_t *resultStr = 0;

    if (numArgs == 1)
    {
        octaspire_string_t *str =
            octaspire_dern_value_to_string_plain(fmtStr, octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_string(vm, str);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }
    else
    {
        if (fmtStr->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to builtin 'string-format' must be format string if there are more "
                "than one argument. Type '%s' was given.",
                octaspire_dern_value_helper_get_type_as_c_string(fmtStr->typeTag));

        }

        resultStr = octaspire_string_new(
            "",
            octaspire_dern_vm_get_allocator(vm));

        size_t const fmtStrLen =
            octaspire_string_get_length_in_ucs_characters(fmtStr->value.string);

        uint32_t prevChar = 0;
        uint32_t curChar = 0;
        uint32_t nextChar = 0;

        size_t fmtValueIndex = 1;

        for (size_t c = 0; c < fmtStrLen; ++c)
        {
            curChar =
                octaspire_string_get_ucs_character_at_index(
                    fmtStr->value.string,
                    (ptrdiff_t)c);

            if ((c + 1) < fmtStrLen)
            {
                nextChar =
                    octaspire_string_get_ucs_character_at_index(
                        fmtStr->value.string,
                        (ptrdiff_t)(c + 1));
            }
            else
            {
                nextChar = 0;
            }

            if (curChar == '\'' && prevChar == '\'')
            {
                octaspire_string_push_back_ucs_character(resultStr, '\'');
                curChar = 0; // To prevent prevChar from becoming '
            }
            else if (curChar == '{' && prevChar != '\'')
            {
                if (nextChar == '}')
                {
                    if (fmtValueIndex >= numArgs)
                    {
                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return octaspire_dern_vm_create_new_value_error_from_c_string(
                            vm,
                            "Not enough arguments for the format string of 'string-format'.");
                    }

                    octaspire_string_t *tmpStr =
                        octaspire_dern_value_to_string_plain(
                            octaspire_dern_value_as_vector_get_element_at(
                                arguments,
                                (ptrdiff_t)fmtValueIndex),
                            octaspire_dern_vm_get_allocator(vm));

                    octaspire_string_concatenate(resultStr, tmpStr);

                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    ++c;
                    ++fmtValueIndex;
                }
                else
                {
                    octaspire_string_push_back_ucs_character(
                        resultStr,
                        curChar);
                }
            }
            else
            {
                octaspire_string_push_back_ucs_character(
                    resultStr,
                    curChar);
            }

            prevChar = curChar;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_string(vm, resultStr);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_to_string(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'to-string' expects one or more arguments.");
    }
    else
    {
        octaspire_string_t * const str = octaspire_dern_value_to_string(
            octaspire_dern_value_as_vector_get_element_at_const(
                arguments,
                0),
            octaspire_dern_vm_get_allocator(vm));

        for (size_t i = 1; i < numArgs; ++i)
        {
            octaspire_string_t * tmpStr =
                octaspire_dern_value_to_string(
                octaspire_dern_value_as_vector_get_element_at_const(
                    arguments,
                    (ptrdiff_t)i),
                octaspire_dern_vm_get_allocator(vm));

            octaspire_string_concatenate(str, tmpStr);

            octaspire_string_release(tmpStr);
            tmpStr = 0;
        }

        return octaspire_dern_vm_create_new_value_string(vm, str);
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_to_integer(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'to-integer' expects one or more arguments.");
    }
    else if (numArgs == 1)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_at_const(
                arguments,
                0);

        // TODO other types
        if (octaspire_dern_value_is_number(value))
        {
            return octaspire_dern_vm_create_new_value_integer(
                vm,
                (int32_t)(octaspire_dern_value_as_number_get_value(value)));
        }
        else if (octaspire_dern_value_is_string(value))
        {
            int32_t valueAsInt =
#ifdef OCTASPIRE_PLAN9_IMPLEMENTATION
                (int32_t)strtol(
#else
    #ifdef __amigaos__
                (int32_t)strtol(
    #else
                (int32_t)strtoimax(
    #endif
#endif
                octaspire_dern_value_as_string_get_c_string(value),
                0,
                10);

            return octaspire_dern_vm_create_new_value_integer(vm, valueAsInt);
        }
        else
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to 'to-integer' is currently unsupported type. "
                "Type '%s' was given.",
                octaspire_dern_value_helper_get_type_as_c_string(value->typeTag));
        }
    }
    else
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'to-integer' supports at the moment only one argument.");
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_print(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'print' expects one or more arguments.");
    }

    octaspire_dern_value_t const * const fmtStr =
        octaspire_dern_value_as_vector_get_element_at_const(arguments, 0);

    octaspire_helpers_verify_not_null(fmtStr);

    if (fmtStr->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_dern_value_print(fmtStr, octaspire_dern_vm_get_allocator(vm));

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_get_value_true(vm);
    }

    if (numArgs == 1)
    {
        printf("%s", octaspire_string_get_c_string(fmtStr->value.string));
    }
    else
    {
        size_t const fmtStrLen =
            octaspire_string_get_length_in_ucs_characters(fmtStr->value.string);

        uint32_t prevChar = 0;
        uint32_t curChar = 0;
        uint32_t nextChar = 0;

        size_t fmtValueIndex = 1;

        for (size_t c = 0; c < fmtStrLen; ++c)
        {
            curChar =
                octaspire_string_get_ucs_character_at_index(
                    fmtStr->value.string,
                    (ptrdiff_t)c);

            if ((c + 1) < fmtStrLen)
            {
                nextChar =
                    octaspire_string_get_ucs_character_at_index(
                        fmtStr->value.string,
                        (ptrdiff_t)(c + 1));
            }
            else
            {
                nextChar = 0;
            }

            if (curChar == '\'' && prevChar == '\'')
            {
                printf("'");
                curChar = 0; // To prevent prevChar from becoming '
            }
            else if (curChar == '{' && prevChar != '\'')
            {
                if (nextChar == '}')
                {
                    if (fmtValueIndex >= numArgs)
                    {
                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(vm));

                        return octaspire_dern_vm_create_new_value_error_from_c_string(
                            vm,
                            "Not enough arguments for the format string of 'println'.");
                    }

                    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
                        octaspire_dern_value_as_vector_get_element_at(
                            arguments,
                            (ptrdiff_t)fmtValueIndex),
                        octaspire_dern_vm_get_allocator(vm));

                    printf("%s", octaspire_string_get_c_string(tmpStr));

                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    ++c;
                    ++fmtValueIndex;
                }
                else
                {
                    printf("%c", (char)curChar);
                }
            }
            else
            {
                printf("%c", (char)curChar);
            }

            prevChar = curChar;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}


octaspire_dern_value_t *octaspire_dern_vm_builtin_println(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    if (octaspire_dern_value_as_vector_get_length(arguments) == 0)
    {
        printf("\n");
        return octaspire_dern_vm_get_value_true(vm);
    }
    else
    {
        octaspire_dern_value_t *result =
            octaspire_dern_vm_builtin_print(vm, arguments, environment);

        printf("\n");
        return result;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_env_new(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_environment(vm, 0);
    }
    else if (octaspire_vector_get_length(vec) == 1)
    {
        octaspire_dern_value_t *value = octaspire_vector_get_element_at(vec, 0);
        octaspire_helpers_verify_not_null(value);

        if (value->typeTag != OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Argument to builtin 'env-new' must be an environment. Now argument has type '%s'.",
                octaspire_dern_value_helper_get_type_as_c_string(value->typeTag));
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_environment(vm, value);
    }
    else
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'env-new' expects zero or one arguments.");
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_env_current(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) != 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'env-current' expects zero arguments.");
    }

    return environment;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_env_global(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) != 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'env-global' expects zero arguments.");
    }

    return octaspire_dern_vm_get_global_environment(vm);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '-=' expects at least one argument.");
    }

    octaspire_dern_value_t * const firstArg = octaspire_vector_get_element_at(vec, 0);

    switch (firstArg->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                if (i == 1)
                {
                    octaspire_dern_value_as_character_subtract(firstArg, anotherArg);
                }
                else
                {
                    octaspire_dern_value_as_string_pop_back_ucs_character(firstArg);
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                octaspire_dern_value_as_real_subtract(firstArg, anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                octaspire_dern_value_as_integer_subtract(firstArg, anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                // TODO XXX remove the need for '&' in &another for vectors!!!!!
                for (size_t j = 0; j < octaspire_dern_value_as_vector_get_length(firstArg); /*NOP*/)
                {
                    octaspire_dern_value_t * const val =
                        octaspire_dern_value_as_vector_get_element_at(
                            firstArg,
                            (ptrdiff_t)j);

                    if (octaspire_dern_value_is_equal(anotherArg, val))
                    {
                        octaspire_dern_value_as_vector_remove_element_at(
                            firstArg,
                            (ptrdiff_t)j);
                    }
                    else
                    {
                        ++j;
                    }
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                if (!octaspire_dern_value_as_string_remove_all_substrings(firstArg, anotherArg))
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "Builtin '-=' failed");
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                if (!octaspire_dern_value_as_hash_map_remove(firstArg, anotherArg))
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "Builtin '-=' failed");
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return firstArg;
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to builtin '-=' cannot be of type '%s'.",
                octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return firstArg;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus_equals_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '-==' expects at least one argument.");
    }

    octaspire_dern_value_t * const firstArg = octaspire_vector_get_element_at(vec, 0);

    switch (firstArg->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to builtin '-==' cannot be of type '%s'.",
                octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                for (size_t j = 0; j < octaspire_dern_value_as_vector_get_length(firstArg); /*NOP*/)
                {
                    octaspire_dern_value_t * const val =
                        octaspire_dern_value_as_vector_get_element_at(
                            firstArg,
                            (ptrdiff_t)j);

                    if (anotherArg->uniqueId == val->uniqueId)
                    {
                        octaspire_dern_value_as_vector_remove_element_at(
                            firstArg,
                            (ptrdiff_t)j);
                    }
                    else
                    {
                        ++j;
                    }
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return firstArg;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return firstArg;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_pop_back(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(
        arguments->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_helpers_verify_true(
        environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) != 1)
    {
        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'pop-back' expects exactly one argument.");
    }

    octaspire_dern_value_t * const firstArg =
        octaspire_vector_get_element_at(vec, 0);

    switch (firstArg->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            octaspire_dern_value_as_vector_pop_back_element(firstArg);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            octaspire_dern_value_as_list_pop_back(firstArg);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            octaspire_dern_value_as_queue_pop(firstArg);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_dern_value_as_string_pop_back_ucs_character(firstArg);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            octaspire_dern_value_as_symbol_pop_back(firstArg);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return firstArg;
        }

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to builtin 'pop-back' cannot be of type '%s'.",
                octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
        }
    }

    octaspire_helpers_verify_true(
        stackLength == octaspire_dern_vm_get_stack_length(vm));

    return firstArg;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_pop_front(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(
        arguments->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_helpers_verify_true(
        environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) != 1)
    {
        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'pop-front' expects exactly one argument.");
    }

    octaspire_dern_value_t * const firstArg =
        octaspire_vector_get_element_at(vec, 0);

    switch (firstArg->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            octaspire_dern_value_as_vector_pop_front_element(firstArg);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            octaspire_dern_value_as_list_pop_front(firstArg);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_dern_value_as_string_pop_front_ucs_character(firstArg);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            octaspire_dern_value_as_symbol_pop_front(firstArg);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return firstArg;
        }

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to builtin 'pop-front' cannot be of type '%s'.",
                octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
        }
    }

    octaspire_helpers_verify_true(
        stackLength == octaspire_dern_vm_get_stack_length(vm));

    return firstArg;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_plus_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '+=' expects at least one argument.");
    }

    octaspire_dern_value_t * const firstArg = octaspire_vector_get_element_at(vec, 0);

    switch (firstArg->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                if (i == 1)
                {
                    octaspire_dern_value_as_character_add(firstArg, anotherArg);
                }
                else
                {
                    octaspire_dern_value_as_string_push_back(firstArg, anotherArg);
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                octaspire_dern_value_as_real_add(firstArg, anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                octaspire_dern_value_as_integer_add(firstArg, anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                // TODO XXX remove the need for '&' in &another for vectors!!!!!
                octaspire_dern_value_as_vector_push_back_element(firstArg, &anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                octaspire_dern_value_as_list_push_back(firstArg, anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                octaspire_dern_value_as_queue_push(firstArg, anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        {
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                octaspire_dern_value_t *tmpArgs = octaspire_dern_vm_create_new_value_vector(vm);

                octaspire_dern_vm_push_value(vm, tmpArgs);

                octaspire_dern_value_as_vector_push_back_element(tmpArgs, &firstArg);
                octaspire_dern_value_as_vector_push_back_element(tmpArgs, &anotherArg);

                octaspire_dern_vm_builtin_port_write(vm, tmpArgs, environment);

                octaspire_dern_vm_pop_value(vm, tmpArgs);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            //bool success = true;
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                if (!octaspire_dern_value_as_string_push_back(firstArg, anotherArg))
                {
                    //success = false;
                }
            }

            // TODO report possible error?
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            //bool success = true;
            for (size_t i = 1; i < octaspire_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_vector_get_element_at(
                        vec,
                        (ptrdiff_t)i);

                if (!octaspire_dern_value_as_symbol_push_back(firstArg, anotherArg))
                {
                    //success = false;
                }
            }

            // TODO report possible error?
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            if (octaspire_vector_get_length(vec) == 2)
            {
                if (!octaspire_dern_value_as_hash_map_add(
                        firstArg,
                        octaspire_vector_get_element_at(vec, 1),
                        0))
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "Builtin '+=' failed");
                }
            }
            else if (octaspire_vector_get_length(vec) == 3)
            {
                if (!octaspire_dern_value_as_hash_map_add(
                        firstArg,
                        octaspire_vector_get_element_at(vec, 1),
                        octaspire_vector_get_element_at(vec, 2)))
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "Builtin '+=' failed");
                }
            }
            else
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_from_c_string(
                    vm,
                    "Builtin '+=' expects one or two additional arguments for hash map");
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return firstArg;
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to builtin '+=' cannot be of type '%s'.",
                octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return firstArg;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_plus_plus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '++' expects at least one argument.");
    }

    octaspire_dern_value_t *value = 0;

    for (size_t i = 0; i < octaspire_vector_get_length(vec); ++i)
    {
        value = octaspire_vector_get_element_at(vec, (ptrdiff_t)i);

        if (!octaspire_dern_value_is_number(value))
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Arguments to builtin '++' must be numbers. %zuth argument has type '%s'.",
                i + 1,
                octaspire_dern_value_helper_get_type_as_c_string(value->typeTag));
        }

        if (value->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER)
        {
            ++(value->value.integer);
        }
        else
        {
            ++(value->value.real);
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return value;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus_minus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_vector_t * const vec = arguments->value.vector;

    if (octaspire_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '--' expects at least one argument.");
    }

    octaspire_dern_value_t *value = 0;

    for (size_t i = 0; i < octaspire_vector_get_length(vec); ++i)
    {
        value = octaspire_vector_get_element_at(vec, (ptrdiff_t)i);

        if (octaspire_dern_value_is_integer(value))
        {
            --(value->value.integer);
        }
        else if (octaspire_dern_value_is_real(value))
        {
            --(value->value.real);
        }
        else if (octaspire_dern_value_is_queue(value))
        {
            if (!octaspire_dern_value_as_queue_pop(value))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '--' failed on %zuth argument (queue)",
                    i + 1);
            }
        }
        else if (octaspire_dern_value_is_list(value))
        {
            if (!octaspire_dern_value_as_list_pop_back(value))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '--' failed on %zuth argument (list)",
                    i + 1);
            }
        }
        else if (octaspire_dern_value_is_vector(value))
        {
            if (!octaspire_dern_value_as_vector_pop_back_element(value))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '--' failed on %zuth argument (vector)",
                    i + 1);
            }
        }
        else if (octaspire_dern_value_is_string(value))
        {
            if (!octaspire_dern_value_as_string_pop_back_ucs_character(value))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '--' failed on %zuth argument (string)",
                    i + 1);
            }
        }
        else
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "%zuth argument to builtin '--' has unsupported type '%s'.",
                i + 1,
                octaspire_dern_value_helper_get_type_as_c_string(value->typeTag));
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return value;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_mod(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'mod' expects two arguments (integers). %zu arguments were given.",
            numArgs);
    }

    octaspire_dern_value_t * const firstArgVal =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    if (firstArgVal->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
    {
        if (firstArgVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return firstArgVal;
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'mod' must be integer. Type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArgVal->typeTag));
    }

    octaspire_dern_value_t * const secondArgVal =
        octaspire_dern_value_as_vector_get_element_at(arguments, 1);

    if (secondArgVal->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
    {
        if (secondArgVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return secondArgVal;
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The second argument to builtin 'mod' must be integer. Type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(secondArgVal->typeTag));
    }

    if (secondArgVal->value.integer == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "The second argument to builtin 'mod' cannot be zero. "
            "It would cause division by zero.");
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_integer(
        vm,
        firstArgVal->value.integer % secondArgVal->value.integer);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_slash(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '/' expects at least one numeric argument (integer or real).");
    }

    if (numArgs == 1)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, 0);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
            {
                abort();
            }

            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                double const currentArgAsReal = currentArg->value.integer;

                // Fix warning on clang's -Weverything level
                if (currentArgAsReal >= 0 &&
                    currentArgAsReal <= 0)
                {
                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "First argument to builtin '/' cannot be zero. "
                        "It would cause division by zero.");
                }
                else
                {
                    return octaspire_dern_vm_create_new_value_real(vm, 1.0 / currentArgAsReal);
                }
            }

            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                double const currentArgAsReal = currentArg->value.real;

                if (currentArgAsReal >= 0 && currentArgAsReal <= 0)
                {
                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "First argument to builtin '/' cannot be zero. "
                        "It would cause division by zero.");
                }
                else
                {
                    return octaspire_dern_vm_create_new_value_real(vm, 1.0 / currentArgAsReal);
                }
            }

            case OCTASPIRE_DERN_VALUE_TAG_NIL:
            case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            case OCTASPIRE_DERN_VALUE_TAG_LIST:
            case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            case OCTASPIRE_DERN_VALUE_TAG_PORT:
            case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            {
                if (currentArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return currentArg;
                }

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '/' expects numeric arguments (integer or real). First argument has "
                    "type %s.",
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
        }
    }

    double realResult = 1;

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(currentArg);

        double currentValueAsNumber = 0;

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
            {
                abort();
            }

            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            {
                currentValueAsNumber = currentArg->value.integer;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            {
                currentValueAsNumber = currentArg->value.real;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_NIL:
            case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            case OCTASPIRE_DERN_VALUE_TAG_LIST:
            case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            case OCTASPIRE_DERN_VALUE_TAG_PORT:
            case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            {
                if (currentArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return currentArg;
                }

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '/' expects numeric arguments (integer or real). %zuth argument has "
                    "type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
        }

        if (i == 0)
        {
            realResult = currentValueAsNumber;
        }
        else
        {
            if (currentValueAsNumber >= 0 && currentValueAsNumber <= 0)
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Argument number %zu to builtin '/' cannot be zero. "
                    "It would cause division by zero.",
                    i + 1);
            }

            realResult /= currentValueAsNumber;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_real(vm, realResult);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_times(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    bool allArgsAreIntegers = true;
    double realResult = 1;
    int32_t integerResult = 1;

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
            {
                abort();
            }

            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            {
                integerResult *= currentArg->value.integer;
                realResult    *= (double)currentArg->value.integer;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            {
                allArgsAreIntegers = false;

                integerResult *= currentArg->value.real;
                realResult    *= currentArg->value.real;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_NIL:
            case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            case OCTASPIRE_DERN_VALUE_TAG_LIST:
            case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            case OCTASPIRE_DERN_VALUE_TAG_PORT:
            case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            {
                if (currentArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return currentArg;
                }

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '*' expects numeric arguments (integer or real). %zuth argument has "
                    "type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
        }
    }

    if (allArgsAreIntegers)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_integer(vm, integerResult);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_real(vm, realResult);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_numerical(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    bool allArgsAreIntegers = true;
    double realResult = 0;
    int32_t integerResult = 0;

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
            {
                abort();
            }

            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            {
                integerResult += currentArg->value.integer;
                realResult    += (double)currentArg->value.integer;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            {
                allArgsAreIntegers = false;

                integerResult += currentArg->value.real;
                realResult    += currentArg->value.real;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_NIL:
            case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            case OCTASPIRE_DERN_VALUE_TAG_LIST:
            case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            case OCTASPIRE_DERN_VALUE_TAG_PORT:
            case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            {
                if (currentArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return currentArg;
                }

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '+' expects numeric arguments (integer or real). %zuth argument has "
                    "type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
        }
    }

    if (allArgsAreIntegers)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_integer(vm, integerResult);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_real(vm, realResult);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_textual_string(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t *firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);
    octaspire_helpers_verify_true(firstArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);

    octaspire_dern_value_t * const result =
        octaspire_dern_vm_create_new_value_string_from_c_string(
            vm,
            octaspire_string_get_c_string(firstArg->value.symbol));

    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 1; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
            {
                abort();
            }

            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            {
                octaspire_string_concatenate(
                    result->value.string,
                    currentArg->value.string);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            {
                octaspire_string_concatenate(
                    result->value.string,
                    currentArg->value.character);
            }
            break;

            // TODO Add symbol and maybe automatic conversion from number -> string

            case OCTASPIRE_DERN_VALUE_TAG_NIL:
            case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            case OCTASPIRE_DERN_VALUE_TAG_LIST:
            case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            case OCTASPIRE_DERN_VALUE_TAG_PORT:
            case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            {
                octaspire_dern_vm_pop_value(vm, result);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '+' expects textual arguments if the first argument is string. %zuth "
                    "argument has type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
        }
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    // TODO what to return? Count of removals or the modified string-value?
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_textual_char(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t *firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    octaspire_helpers_verify_true(
        firstArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER);

    octaspire_dern_value_t * const result =
        octaspire_dern_vm_create_new_value_string_from_c_string(
            vm,
            octaspire_string_get_c_string(firstArg->value.character));

    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 1; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
            {
                abort();
            }

            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            {
                octaspire_string_concatenate(
                    result->value.string,
                    currentArg->value.string);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            {
                octaspire_string_concatenate(
                    result->value.string,
                    currentArg->value.character);
            }
            break;

            // TODO Add symbol and maybe automatic conversion from number -> string

            case OCTASPIRE_DERN_VALUE_TAG_NIL:
            case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            case OCTASPIRE_DERN_VALUE_TAG_LIST:
            case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            case OCTASPIRE_DERN_VALUE_TAG_PORT:
            case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            {
                octaspire_dern_vm_pop_value(vm, result);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '+' expects textual arguments if the first argument is character. "
                    "%zuth argument has type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
        }
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    // TODO what to return? Count of removals or the modified string-value?
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_textual_symbol(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t *firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    octaspire_helpers_verify_true(
        firstArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

    octaspire_dern_value_t * const result =
        octaspire_dern_vm_create_new_value_symbol_from_c_string(
            vm,
            octaspire_string_get_c_string(firstArg->value.symbol));

    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 1; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
            {
                abort();
            }

            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            {
                octaspire_string_concatenate(
                    result->value.symbol,
                    currentArg->value.string);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            {
                octaspire_string_concatenate(
                    result->value.symbol,
                    currentArg->value.character);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            {
                octaspire_string_concatenate(
                    result->value.symbol,
                    currentArg->value.symbol);
            }
            break;

            // TODO Add symbol and maybe automatic conversion from number -> string

            case OCTASPIRE_DERN_VALUE_TAG_NIL:
            case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            case OCTASPIRE_DERN_VALUE_TAG_LIST:
            case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            case OCTASPIRE_DERN_VALUE_TAG_PORT:
            case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            {
                octaspire_dern_vm_pop_value(vm, result);
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '+' expects textual arguments if the first argument is symbol. "
                    "%zuth argument has type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
        }
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    // TODO what to return? Count of removals or the modified string-value?
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_vector(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(
        arguments->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_helpers_verify_true(
        environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t * const firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    octaspire_helpers_verify_true(
        firstArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_dern_value_t * const result =
        octaspire_dern_vm_create_new_value_copy(
            vm,
            firstArg);

    octaspire_helpers_verify_not_null(result);

    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 1; i < numArgs; ++i)
    {
        octaspire_dern_value_t * const currentArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
            {
                abort();
            }

            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            case OCTASPIRE_DERN_VALUE_TAG_NIL:
            case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            case OCTASPIRE_DERN_VALUE_TAG_LIST:
            case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            case OCTASPIRE_DERN_VALUE_TAG_PORT:
            case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            {
                octaspire_dern_value_t * const copyOfArg =
                    octaspire_dern_vm_create_new_value_copy(
                        vm,
                        currentArg);

                octaspire_helpers_verify_not_null(copyOfArg);

                octaspire_helpers_verify_true(
                    octaspire_dern_value_as_vector_push_back_element(
                        result,
                        &copyOfArg));
            }
            break;
        }
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_hash_map(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(
        arguments->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_helpers_verify_true(
        environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs == 0 || (octaspire_helpers_is_odd_size_t(numArgs - 1)))
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin '+' for hash maps expects odd number of arguments. "
            "%zu arguments were given.",
            numArgs);
    }

    octaspire_dern_value_t * const firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    octaspire_helpers_verify_true(
        firstArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);

    octaspire_dern_value_t * const result =
        octaspire_dern_vm_create_new_value_copy(
            vm,
            firstArg);

    octaspire_helpers_verify_not_null(result);

    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 1; i < (numArgs - 1); i += 2)
    {
        octaspire_dern_value_t * const keyArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_dern_value_t * const valArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)(i + 1));

        octaspire_helpers_verify_not_null(keyArg);
        octaspire_helpers_verify_not_null(valArg);

        octaspire_helpers_verify_true(
            keyArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_ILLEGAL);

        octaspire_helpers_verify_true(
            valArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_ILLEGAL);

        octaspire_dern_value_t * const copyOfKey =
            octaspire_dern_vm_create_new_value_copy(
                vm,
                keyArg);

        octaspire_helpers_verify_not_null(copyOfKey);
        octaspire_dern_vm_push_value(vm, copyOfKey);

        octaspire_dern_value_t * const copyOfVal =
            octaspire_dern_vm_create_new_value_copy(
                vm,
                valArg);

        octaspire_helpers_verify_not_null(copyOfVal);
        octaspire_dern_vm_push_value(vm, copyOfVal);

        octaspire_helpers_verify_true(
            octaspire_dern_value_as_hash_map_add(
                result,
                copyOfKey,
                copyOfVal));

        octaspire_dern_vm_pop_value(vm, copyOfVal);
        octaspire_dern_vm_pop_value(vm, copyOfKey);
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_minus_numerical(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    bool allArgsAreIntegers = true;
    double realResult = 0;
    int32_t integerResult = 0;

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
            {
                abort();
            }

            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            {
                if (numArgs == 1)
                {
                    integerResult = -currentArg->value.integer;
                    realResult    = -(double)currentArg->value.integer;
                }
                else
                {
                    if (i == 0)
                    {
                        integerResult = currentArg->value.integer;
                        realResult    = (double)currentArg->value.integer;
                    }
                    else
                    {
                        integerResult -= currentArg->value.integer;
                        realResult    -= (double)currentArg->value.integer;
                    }
                }
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            {
                allArgsAreIntegers = false;

                if (numArgs == 1)
                {
                    integerResult = (int32_t)-currentArg->value.real;
                    realResult    = -currentArg->value.real;
                }
                else
                {
                    if (i == 0)
                    {
                        integerResult = (int32_t)currentArg->value.real;
                        realResult    = currentArg->value.real;
                    }
                    else
                    {
                        integerResult -= currentArg->value.real;
                        realResult    -= currentArg->value.real;
                    }
                }
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_NIL:
            case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            case OCTASPIRE_DERN_VALUE_TAG_LIST:
            case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            case OCTASPIRE_DERN_VALUE_TAG_PORT:
            case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            {
                if (currentArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return currentArg;
                }

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '-' expects numeric arguments (integer or real). "
                    "%zuth argument has type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
        }
    }

    if (allArgsAreIntegers)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_integer(vm, integerResult);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_real(vm, realResult);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_minus_textual(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t *firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);
    octaspire_helpers_verify_true(firstArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);

    for (size_t i = 1; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
            {
                abort();
            }

            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            {
                octaspire_string_remove_all_substrings(
                    firstArg->value.string,
                    currentArg->value.string);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            {
                octaspire_string_remove_all_substrings(
                    firstArg->value.string,
                    currentArg->value.character);
            }
            break;

            // TODO Add symbol and maybe automatic conversion from number -> string

            case OCTASPIRE_DERN_VALUE_TAG_NIL:
            case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            case OCTASPIRE_DERN_VALUE_TAG_LIST:
            case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            case OCTASPIRE_DERN_VALUE_TAG_PORT:
            case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '-' expects textual arguments if the first argument is textual. "
                    "%zuth argument has type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    // TODO what to return? Count of removals or the modified string-value?
    return firstArg;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_plus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_builtin_private_plus_numerical(vm, arguments, environment);
    }

    octaspire_dern_value_t *firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    switch (firstArg->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return octaspire_dern_vm_builtin_private_plus_textual_string(
                vm,
                arguments,
                environment);
        }

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return octaspire_dern_vm_builtin_private_plus_textual_char(
                vm,
                arguments,
                environment);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return octaspire_dern_vm_builtin_private_plus_textual_symbol(
                vm,
                arguments,
                environment);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return octaspire_dern_vm_builtin_private_plus_vector(
                vm,
                arguments,
                environment);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return octaspire_dern_vm_builtin_private_plus_hash_map(
                vm,
                arguments,
                environment);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_builtin_private_plus_numerical(vm, arguments, environment);
        }
    }

    abort();
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_builtin_private_minus_numerical(vm, arguments, environment);
    }

    octaspire_dern_value_t *firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    switch (firstArg->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_builtin_private_minus_textual(vm, arguments, environment);
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_builtin_private_minus_numerical(vm, arguments, environment);
        }
    }

    abort();
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_find(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_dern_vm_push_value(vm, arguments);
    octaspire_dern_vm_push_value(vm, environment);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'find' expects at least two arguments. %zu arguments was given.",
            numArgs);
    }

    octaspire_dern_value_t *container = octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(container);

    octaspire_dern_value_t *result = 0;

    if (numArgs > 2)
    {
        result = octaspire_dern_vm_create_new_value_vector(vm);
        octaspire_dern_vm_push_value(vm, result);

        for (size_t i = 1; i < numArgs; ++i)
        {
            octaspire_dern_value_t *keyArg =
                octaspire_dern_value_as_vector_get_element_at(
                    arguments,
                    (ptrdiff_t)i);

            octaspire_helpers_verify_not_null(keyArg);

            octaspire_dern_value_t *tmpVal =
                octaspire_dern_vm_find_from_value(vm, container, keyArg);

            octaspire_dern_value_as_vector_push_back_element(
                result,
                &tmpVal);
        }

        octaspire_dern_vm_pop_value(vm, result);
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }
    else
    {
        octaspire_dern_value_t *keyArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, 1);

        octaspire_helpers_verify_not_null(keyArg);

        result = octaspire_dern_vm_find_from_value(vm, container, keyArg);

        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_split(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'split' expects two arguments. %zu arguments was given.",
            numArgs);
    }

    octaspire_dern_value_t *container =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(container);

    octaspire_dern_value_t *splitByArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 1);

    octaspire_helpers_verify_not_null(splitByArg);

    switch (container->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            if (!octaspire_dern_value_is_character(splitByArg))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "The second argument to builtin 'split' must be a character when the first "
                    "is a string. Type '%s' was given.",
                    octaspire_dern_value_helper_get_type_as_c_string(splitByArg->typeTag));
            }

            octaspire_dern_value_t * const result = octaspire_dern_vm_create_new_value_vector(vm);
            octaspire_helpers_verify_not_null(result);

            octaspire_dern_vm_push_value(vm, result);

            octaspire_string_t *containerAsStr = container->value.string;
            octaspire_helpers_verify_not_null(containerAsStr);

            octaspire_vector_t *tokens = octaspire_string_split(
                containerAsStr,
                octaspire_dern_value_as_character_get_c_string(splitByArg));

            octaspire_helpers_verify_not_null(tokens);

            for (size_t i = 0; i < octaspire_vector_get_length(tokens); ++i)
            {
                octaspire_string_t const * const token =
                    (octaspire_string_t const * const)
                        octaspire_vector_get_element_at(
                            tokens,
                            (ptrdiff_t)i);

                octaspire_helpers_verify_not_null(token);

                octaspire_string_t * const copy =
                    octaspire_string_new_copy(
                        token,
                        octaspire_dern_vm_get_allocator(vm));

                octaspire_dern_value_t * const copyVal = octaspire_dern_vm_create_new_value_string(
                    vm,
                    copy);

                octaspire_dern_value_as_vector_push_back_element(result, &copyVal);
            }

            octaspire_vector_release(tokens);
            tokens = 0;

            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "The first argument to builtin 'split' must be a container. Currently only "
                "strings are supported. Type '%s' was given.",
                octaspire_dern_value_helper_get_type_as_c_string(container->typeTag));
        }
    }

    abort();
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_hash_map(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_hash_map(vm);
    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 0; i < numArgs; i += 2)
    {
        octaspire_dern_value_t *keyArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        if (!keyArg)
        {
            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'hash-map' expects key here.");
        }

        octaspire_dern_value_t *valArg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)(i + 1));

        if (!valArg)
        {
            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'hash-map' expects key here.");
        }

        if (!octaspire_dern_value_as_hash_map_put(
            result,
            octaspire_dern_value_get_hash(keyArg),
            keyArg,
            valArg))
        {
            abort();
        }
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_queue(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_queue(vm);
    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *arg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        if (!arg)
        {
            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'queue' expects value here.");
        }

        if (!octaspire_dern_value_as_queue_push(result, arg))
        {
            abort();
        }
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_queue_with_max_length(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'queue-with-max-length' expects at least one argument. "
            "Now %zu arguments were given.",
            numArgs);
    }

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    if (!octaspire_dern_value_is_integer(firstArg))
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'queue-with-max-length' must be integer. "
            "Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    int32_t const maxQueueLen = octaspire_dern_value_as_integer_get_value(firstArg);

    if (maxQueueLen < 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'queue-with-max-length' must be non negative integer. "
            "Negative integer %" PRId32 " was given.",
            maxQueueLen);
    }

    octaspire_dern_value_t *result =
        octaspire_dern_vm_create_new_value_queue_with_max_length(
            vm,
            (size_t)maxQueueLen);

    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 1; i < numArgs; ++i)
    {
        octaspire_dern_value_t *arg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        if (!arg)
        {
            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'queue-with-max-length' expects value here.");
        }

        if (!octaspire_dern_value_as_queue_push(result, arg))
        {
            abort();
        }
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_list(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_list(vm);
    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *arg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                (ptrdiff_t)i);

        if (!arg)
        {
            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'list' expects value here.");
        }

        if (!octaspire_dern_value_as_list_push_back(result, arg))
        {
            abort();
        }
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_require_is_already_loaded(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'require' expects exactly one argument.");
    }

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'require' must be a symbol. Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    char const * const name = octaspire_dern_value_as_symbol_get_c_string(firstArg);

    octaspire_helpers_verify_not_null(name);

    if (octaspire_dern_vm_has_library(vm, name))
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_boolean(vm, true);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_require_source_file(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'require' expects exactly one argument.");
    }

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'require' must be a symbol. Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    char const * const name = octaspire_dern_value_as_symbol_get_c_string(firstArg);

    octaspire_helpers_verify_not_null(name);

    octaspire_string_t *fileName = octaspire_string_new_format(
        octaspire_dern_vm_get_allocator(vm),
        "%s.dern",
        name);

    octaspire_helpers_verify_not_null(fileName);

    octaspire_input_t *input = 0;

    if (octaspire_dern_vm_get_custom_require_source_file_pre_loader(vm))
    {
        input =
            octaspire_dern_vm_get_custom_require_source_file_pre_loader(vm)(
                octaspire_string_get_c_string(fileName),
                octaspire_dern_vm_get_allocator(vm));
    }
    else
    {
        input = octaspire_input_new_from_path(
            octaspire_string_get_c_string(fileName),
            octaspire_dern_vm_get_allocator(vm),
            octaspire_dern_vm_get_stdio(vm));
    }

    if (!input)
    {
        octaspire_string_release(fileName);
        fileName = 0;

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return 0;
    }

    octaspire_dern_lib_t *library = octaspire_dern_lib_new_source(
        name,
        input,
        vm,
        octaspire_dern_vm_get_allocator(vm));

    octaspire_helpers_verify_not_null(library);

    if (!octaspire_dern_lib_is_good(library))
    {
        octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Source library '%s' failed to load: %s",
            name,
            octaspire_dern_lib_get_error_message(library));

        octaspire_helpers_verify_not_null(result);

        octaspire_string_release(fileName);
        fileName = 0;

        octaspire_input_release(input);
        input = 0;

        octaspire_dern_lib_release(library);
        library = 0;

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }

    octaspire_input_release(input);
    input = 0;

    if (!octaspire_dern_vm_add_library(vm, name, library))
    {
        abort();
    }

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_string(vm, fileName);

    octaspire_helpers_verify_not_null(result);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_require_binary_file(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'require' expects exactly one argument.");
    }

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'require' must be a symbol. Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    char const * const name = octaspire_dern_value_as_symbol_get_c_string(firstArg);

    octaspire_helpers_verify_not_null(name);

    octaspire_string_t *fileName = octaspire_string_new_format(
        octaspire_dern_vm_get_allocator(vm),
#ifdef OCTASPIRE_PLAN9_IMPLEMENTATION
        "lib%s.so",
#else
    #ifdef __APPLE__
        "lib%s.dylib",
    #elif _WIN32
        "lib%s.dll",
    #else
        "lib%s.so",
    #endif
#endif
        name);

    octaspire_helpers_verify_not_null(fileName);

    octaspire_dern_lib_t *library = octaspire_dern_lib_new_binary(
        name,
        octaspire_string_get_c_string(fileName),
        vm,
        octaspire_dern_vm_get_allocator(vm));

    octaspire_helpers_verify_not_null(library);

    if (!octaspire_dern_lib_is_good(library))
    {
        octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Binary library '%s' failed to load: %s",
            name,
            octaspire_dern_lib_get_error_message(library));

        octaspire_helpers_verify_not_null(result);

        octaspire_string_release(fileName);
        fileName = 0;

        octaspire_dern_lib_release(library);
        library = 0;

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }

    if (!octaspire_dern_vm_add_library(vm, name, library))
    {
        abort();
    }

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_string(vm, fileName);

    octaspire_helpers_verify_not_null(result);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_ln_at_sign(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'ln@' expects at least two arguments.");
    }

    octaspire_dern_value_t * const collectionVal =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(collectionVal);

    switch (octaspire_dern_value_get_type(collectionVal))
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'ln@' cannot be used with strings. Use 'cp@' instead.");
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            if (numArgs > 2)
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_from_c_string(
                    vm,
                    "Builtin 'ln@' expects exactly two arguments when used with vector.");
            }

            octaspire_dern_value_t const * const indexVal =
                octaspire_dern_value_as_vector_get_element_at_const(arguments, 1);

            octaspire_helpers_verify_not_null(indexVal);

            if (!octaspire_dern_value_is_integer(indexVal))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin 'ln@' expects integer as second argument when indexing a vector. "
                    "Now type '%s' was given.",
                    octaspire_dern_value_helper_get_type_as_c_string(
                        indexVal->typeTag));
            }

            ptrdiff_t const index =
                (ptrdiff_t)octaspire_dern_value_as_integer_get_value(indexVal);

            if (!octaspire_dern_value_as_vector_is_index_valid(
                    collectionVal,
                    index))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Index to builtin 'ln@' is not valid for the given vector. "
#ifdef __AROS__
                    "Index '%ld' was given.",
#else
                    "Index '%td' was given.",
#endif
                    index);
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_value_as_vector_get_element_at(
                collectionVal,
                octaspire_dern_value_as_integer_get_value(indexVal));
        }

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            if (numArgs != 3)
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_from_c_string(
                    vm,
                    "Builtin 'ln@' expects exactly three arguments when used with hash map.");
            }

            octaspire_dern_value_t const * const symbolVal =
                octaspire_dern_value_as_vector_get_element_at_const(arguments, 2);

            octaspire_helpers_verify_not_null(symbolVal);

            if (!octaspire_dern_value_is_symbol(symbolVal))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin 'ln@' expects symbol as third argument when indexing a hash map. "
                    "Now type '%s' was given.",
                    octaspire_dern_value_helper_get_type_as_c_string(
                        symbolVal->typeTag));
            }

            octaspire_dern_value_t const * const indexVal =
                octaspire_dern_value_as_vector_get_element_at_const(arguments, 1);

            octaspire_helpers_verify_not_null(indexVal);

            if (octaspire_dern_value_as_text_is_equal_to_c_string(
                    symbolVal,
                    "index"))
            {
                if (!octaspire_dern_value_is_integer(indexVal))
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_format(
                        vm,
                        "Builtin 'ln@' expects integer as second argument when indexing a hash "
                        "map with given symbol 'index'. "
                        "Now type '%s' was given.",
                        octaspire_dern_value_helper_get_type_as_c_string(
                            indexVal->typeTag));
                }

                octaspire_map_element_t * const element =
                    octaspire_dern_value_as_hash_map_get_at_index(
                        collectionVal,
                        octaspire_dern_value_as_integer_get_value(indexVal));

                if (!element)
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "Builtin 'ln@' could not find the requested element from hash map.");

                }

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_map_element_get_value(element);
            }
            else if (octaspire_dern_value_as_text_is_equal_to_c_string(
                    symbolVal,
                    "hash"))
            {
                octaspire_map_element_t * const element =
                    octaspire_dern_value_as_hash_map_get(
                        collectionVal,
                        octaspire_dern_value_get_hash(indexVal),
                        indexVal);

                if (!element)
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "Builtin 'ln@' could not find the requested element from hash map.");

                }

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_map_element_get_value(element);
            }
            else
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin 'ln@' expects symbol 'hash' or 'index' as third argument when "
                    "indexing a hash map. "
                    "Now symbol '%s' was given.",
                    octaspire_dern_value_as_text_get_c_string(symbolVal));
            }
        }

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            if (numArgs > 2)
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_from_c_string(
                    vm,
                    "Builtin 'ln@' expects exactly two arguments when used with list.");
            }

            octaspire_dern_value_t const * const indexVal =
                octaspire_dern_value_as_vector_get_element_at_const(arguments, 1);

            octaspire_helpers_verify_not_null(indexVal);

            if (!octaspire_dern_value_is_integer(indexVal))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin 'ln@' expects integer as second argument when indexing a list. "
                    "Now type '%s' was given.",
                    octaspire_dern_value_helper_get_type_as_c_string(
                        indexVal->typeTag));
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_value_as_list_get_element_at(
                collectionVal,
                octaspire_dern_value_as_integer_get_value(indexVal));
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Builtin 'ln@' expects vector, hash map, queue or list as first argument. "
                "Now type '%s' was given.",
                octaspire_dern_value_helper_get_type_as_c_string(collectionVal->typeTag));
        }
    }

    abort();
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_cp_at_sign(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'cp@' expects at least two arguments.");
    }

    octaspire_dern_value_t * const collectionVal =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(collectionVal);

    switch (octaspire_dern_value_get_type(collectionVal))
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            if (numArgs > 2)
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_from_c_string(
                    vm,
                    "Builtin 'cp@' expects exactly two arguments when used with string.");
            }

            octaspire_dern_value_t const * const indexVal =
                octaspire_dern_value_as_vector_get_element_at_const(arguments, 1);

            octaspire_helpers_verify_not_null(indexVal);

            if (!octaspire_dern_value_is_integer(indexVal))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin 'cp@' expects integer as second argument when indexing a string. "
                    "Now type '%s' was given.",
                    octaspire_dern_value_helper_get_type_as_c_string(
                        indexVal->typeTag));
            }

            ptrdiff_t const index =
                (ptrdiff_t)octaspire_dern_value_as_integer_get_value(indexVal);

            if (!octaspire_dern_value_as_string_is_index_valid(
                    collectionVal,
                    index))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Index to builtin 'cp@' is not valid for the given string. "
#ifdef __AROS__
                    "Index '%ld' was given.",
#else
                    "Index '%td' was given.",
#endif
                    index);
            }

            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(vm));

            return octaspire_dern_vm_create_new_value_character_from_uint32t(
                vm,
                octaspire_string_get_ucs_character_at_index(
                    collectionVal->value.string,
                    index));
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            if (numArgs > 2)
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_from_c_string(
                    vm,
                    "Builtin 'cp@' expects exactly two arguments when used with vector.");
            }

            octaspire_dern_value_t const * const indexVal =
                octaspire_dern_value_as_vector_get_element_at_const(arguments, 1);

            octaspire_helpers_verify_not_null(indexVal);

            if (!octaspire_dern_value_is_integer(indexVal))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin 'cp@' expects integer as second argument when indexing a vector. "
                    "Now type '%s' was given.",
                    octaspire_dern_value_helper_get_type_as_c_string(
                        indexVal->typeTag));
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_copy(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(
                        collectionVal,
                        octaspire_dern_value_as_integer_get_value(indexVal)));
        }

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            if (numArgs != 3)
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_from_c_string(
                    vm,
                    "Builtin 'cp@' expects exactly three arguments when used with hash map.");
            }

            octaspire_dern_value_t const * const symbolVal =
                octaspire_dern_value_as_vector_get_element_at_const(arguments, 2);

            octaspire_helpers_verify_not_null(symbolVal);

            if (!octaspire_dern_value_is_symbol(symbolVal))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin 'cp@' expects symbol as third argument when indexing a hash map. "
                    "Now type '%s' was given.",
                    octaspire_dern_value_helper_get_type_as_c_string(
                        symbolVal->typeTag));
            }

            octaspire_dern_value_t const * const indexVal =
                octaspire_dern_value_as_vector_get_element_at_const(arguments, 1);

            octaspire_helpers_verify_not_null(indexVal);

            if (octaspire_dern_value_as_text_is_equal_to_c_string(
                    symbolVal,
                    "index"))
            {
                if (!octaspire_dern_value_is_integer(indexVal))
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_format(
                        vm,
                        "Builtin 'cp@' expects integer as second argument when indexing a hash "
                        "map with given symbol 'index'. Now type '%s' was given.",
                        octaspire_dern_value_helper_get_type_as_c_string(
                            indexVal->typeTag));
                }

                octaspire_map_element_t * const element =
                    octaspire_dern_value_as_hash_map_get_at_index(
                        collectionVal,
                        octaspire_dern_value_as_integer_get_value(indexVal));

                if (!element)
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "Builtin 'cp@' could not find the requested element from hash map.");

                }

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_copy(
                    vm,
                    octaspire_map_element_get_value(element));
            }
            else if (octaspire_dern_value_as_text_is_equal_to_c_string(
                    symbolVal,
                    "hash"))
            {
                octaspire_map_element_t * const element =
                    octaspire_dern_value_as_hash_map_get(
                        collectionVal,
                        octaspire_dern_value_get_hash(indexVal),
                        indexVal);

                if (!element)
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "Builtin 'cp@' could not find the requested element from hash map.");

                }

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_copy(
                    vm,
                    octaspire_map_element_get_value(element));
            }
            else
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin 'cp@' expects symbol 'hash' or 'index' as third argument when "
                    "indexing a hash map. Now symbol '%s' was given.",
                    octaspire_dern_value_as_text_get_c_string(symbolVal));
            }
        }

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            if (numArgs > 2)
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_from_c_string(
                    vm,
                    "Builtin 'cp@' expects exactly two arguments when used with list.");
            }

            octaspire_dern_value_t const * const indexVal =
                octaspire_dern_value_as_vector_get_element_at_const(arguments, 1);

            octaspire_helpers_verify_not_null(indexVal);

            if (!octaspire_dern_value_is_integer(indexVal))
            {
                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin 'cp@' expects integer as second argument when indexing a list. "
                    "Now type '%s' was given.",
                    octaspire_dern_value_helper_get_type_as_c_string(
                        indexVal->typeTag));
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_copy(
                vm,
                octaspire_dern_value_as_list_get_element_at(
                    collectionVal,
                    octaspire_dern_value_as_integer_get_value(indexVal)));
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Builtin 'cp@' expects vector, hash map, queue or list as first argument. "
                "Now type '%s' was given.",
                octaspire_dern_value_helper_get_type_as_c_string(collectionVal->typeTag));
        }
    }

    abort();
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_require(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_dern_value_t *result =
        octaspire_dern_vm_builtin_private_require_is_already_loaded(
            vm,
            arguments,
            environment);

    if (result)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }

    result =
        octaspire_dern_vm_builtin_private_require_source_file(
            vm,
            arguments,
            environment);

    if (result)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }

    result =
        octaspire_dern_vm_builtin_private_require_binary_file(
            vm,
            arguments,
            environment);

    if (result)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }

    octaspire_dern_value_t * const nameVal =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_error_format(
        vm,
        "Builtin 'require': '%s' could not be loaded.",
        octaspire_dern_value_as_symbol_get_c_string(nameVal));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_integer_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'integer?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_integer(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_real_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'real?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_real(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_number_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'number?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_number(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_nil_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'nil?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_nil(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_boolean_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'boolean?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_boolean(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_character_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'character?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_character(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_string_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'string?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_string(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_symbol_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'symbol?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_symbol(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_vector_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'vector?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_vector(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_hash_map_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'hash-map?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_hash_map(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_copy(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs < 1 || numArgs > 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'copy' expects one or two arguments.");
    }

    octaspire_dern_value_t * const collectionVal =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_dern_value_t * predicateVal = 0;

    if (numArgs == 2)
    {
        predicateVal = octaspire_dern_value_as_vector_get_element_at(arguments, 1);
        octaspire_helpers_verify_not_null(predicateVal);

        if (!octaspire_dern_value_is_function(predicateVal))
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Builtin 'copy' expects function (predicate) as second argument. "
                "Now type '%s' was given.",
                octaspire_dern_value_helper_get_type_as_c_string(predicateVal->typeTag));
        }
    }

    switch (collectionVal->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            octaspire_vector_t * const copyVec =
                octaspire_vector_new(
                    sizeof(octaspire_dern_value_t*),
                    true,
                    0,
                    octaspire_dern_vm_get_allocator(vm));

            octaspire_helpers_verify_not_null(copyVec);

            octaspire_dern_value_t * const result =
                octaspire_dern_vm_create_new_value_vector_from_vector(vm, copyVec);

            octaspire_dern_vm_push_value(vm, result);

            for (size_t i = 0; i < octaspire_dern_value_get_length(collectionVal); ++i)
            {
                bool doCopy = true;

                octaspire_dern_value_t * valueThatMightBeCopied =
                    octaspire_dern_value_as_vector_get_element_at(
                        collectionVal,
                        (ptrdiff_t)i);

                if (predicateVal)
                {
                    octaspire_dern_value_t * callVec =
                        octaspire_dern_vm_create_new_value_vector(vm);

                    octaspire_helpers_verify_not_null(callVec);

                    octaspire_dern_vm_push_value(vm, callVec);

                    octaspire_dern_value_as_vector_push_back_element(
                        callVec,
                        &predicateVal);

                    octaspire_dern_value_as_vector_push_back_element(
                        callVec,
                        &valueThatMightBeCopied);

                    octaspire_dern_value_t * const counterVal =
                        octaspire_dern_vm_create_new_value_integer(vm, (int32_t)i);

                    octaspire_dern_value_as_vector_push_back_element(
                        callVec,
                        &counterVal);

                    octaspire_dern_value_t * resultValFromPredicate =
                        octaspire_dern_vm_eval(vm, callVec, environment);

                    octaspire_dern_vm_pop_value(vm, callVec);

                    octaspire_helpers_verify_not_null(resultValFromPredicate);

                    if (!octaspire_dern_value_is_boolean(resultValFromPredicate))
                    {
                        octaspire_dern_vm_pop_value(vm, result);

                        octaspire_helpers_verify_true(stackLength ==
                            octaspire_dern_vm_get_stack_length(vm));

                        return octaspire_dern_vm_create_new_value_error_format(
                            vm,
                            "Second argument to builtin 'copy' must be a function that returns "
                            "boolean value. Now type '%s' was returned.",
                            octaspire_dern_value_helper_get_type_as_c_string(
                                resultValFromPredicate->typeTag));
                    }

                    doCopy = resultValFromPredicate->value.boolean;
                }

                if (doCopy)
                {
                    octaspire_dern_value_t *copyVal =
                        octaspire_dern_vm_create_new_value_copy(
                            vm,
                            valueThatMightBeCopied);

                    octaspire_helpers_verify_true(
                        octaspire_dern_value_as_vector_push_back_element(result, &copyVal));
                }
            }

            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            if (numArgs == 1)
            {
                octaspire_string_t * const copyStr =
                    octaspire_string_new_copy(
                        collectionVal->value.string,
                        octaspire_dern_vm_get_allocator(vm));

                octaspire_helpers_verify_not_null(copyStr);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_string(vm, copyStr);
            }

            octaspire_string_t * const copyStr =
                octaspire_string_new("", octaspire_dern_vm_get_allocator(vm));

            octaspire_helpers_verify_not_null(copyStr);

            for (size_t i = 0; i < octaspire_dern_value_get_length(collectionVal); ++i)
            {
                bool doCopy = true;

                octaspire_dern_value_t * valueThatMightBeCopied =
                    octaspire_dern_vm_create_new_value_character_from_uint32t(
                        vm,
                        octaspire_string_get_ucs_character_at_index(
                            collectionVal->value.string,
                            (ptrdiff_t)i));

                octaspire_helpers_verify_not_null(predicateVal);

                octaspire_dern_vm_push_value(vm, valueThatMightBeCopied);

                octaspire_dern_value_t * callVec =
                    octaspire_dern_vm_create_new_value_vector(vm);

                octaspire_helpers_verify_not_null(callVec);

                octaspire_dern_vm_push_value(vm, callVec);

                octaspire_dern_value_as_vector_push_back_element(
                    callVec,
                    &predicateVal);

                octaspire_dern_value_as_vector_push_back_element(
                    callVec,
                    &valueThatMightBeCopied);

                octaspire_dern_value_t * const counterVal =
                    octaspire_dern_vm_create_new_value_integer(vm, (int32_t)i);

                octaspire_dern_value_as_vector_push_back_element(
                    callVec,
                    &counterVal);

                octaspire_dern_value_t * resultValFromPredicate =
                    octaspire_dern_vm_eval(vm, callVec, environment);

                octaspire_dern_vm_pop_value(vm, callVec);

                octaspire_helpers_verify_not_null(resultValFromPredicate);

                if (!octaspire_dern_value_is_boolean(resultValFromPredicate))
                {
                    octaspire_dern_vm_pop_value(vm, valueThatMightBeCopied);

                    octaspire_helpers_verify_true(stackLength ==
                        octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_format(
                        vm,
                        "Second argument to builtin 'copy' must be a function that returns "
                        "boolean value. Now type '%s' was returned.",
                        octaspire_dern_value_helper_get_type_as_c_string(
                            resultValFromPredicate->typeTag));
                }

                octaspire_dern_vm_pop_value(vm, valueThatMightBeCopied);

                doCopy = resultValFromPredicate->value.boolean;

                if (doCopy)
                {
                    octaspire_helpers_verify_true(
                        octaspire_string_push_back_ucs_character(
                            copyStr,
                            octaspire_string_get_ucs_character_at_index(
                                collectionVal->value.string,
                                (ptrdiff_t)i)));
                }
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_string(vm, copyStr);
        }

        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            if (numArgs == 1)
            {
                octaspire_dern_c_data_t *originalCData =
                    octaspire_dern_value_as_c_data_get_value(collectionVal);

                if (!octaspire_dern_c_data_is_copying_allowed(originalCData))
                {
                    octaspire_string_t *tmpStr =
                        octaspire_dern_c_data_to_string(
                            originalCData,
                            octaspire_dern_vm_get_allocator(vm));

                    octaspire_dern_value_t * const result =
                        octaspire_dern_vm_create_new_value_error_format(
                            vm,
                            "Copying of C data '%s' is not allowed (it forbids copying)",
                            octaspire_string_get_c_string(tmpStr));

                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return result;
                }

                octaspire_dern_c_data_t * const copyCData =
                    octaspire_dern_c_data_new_copy(
                        octaspire_dern_value_as_c_data_get_value(collectionVal),
                        octaspire_dern_vm_get_allocator(vm));

                octaspire_helpers_verify_not_null(copyCData);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_c_data_from_existing(
                    vm,
                    copyCData);
            }

            // TODO XXX
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Builtin 'copy' does not support copying of type '%s' at the moment.",
                octaspire_dern_value_helper_get_type_as_c_string(collectionVal->typeTag));
        }
    }

    abort();
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_host_get_command_line_arguments(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'host-get-command-line-arguments' expects zero arguments. "
            "%zu arguments were given.",
            numArgs);
    }

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_vector(
        vm);

    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 0;
         i < octaspire_dern_vm_get_number_of_command_line_arguments(vm);
         ++i)
    {
        char const * const str =
            octaspire_dern_vm_get_command_line_argument_at(vm, (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(str);

        octaspire_dern_value_t * const value =
            octaspire_dern_vm_create_new_value_string_from_c_string(vm, str);

        octaspire_helpers_verify_not_null(value);

        octaspire_dern_value_as_vector_push_back_element(
            result,
            &value);
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_host_get_environment_variables(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'host-get-environment-variables' expects zero arguments. "
            "%zu arguments were given.",
            numArgs);
    }

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_vector(
        vm);

    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 0;
         i < octaspire_dern_vm_get_number_of_environment_variables(vm);
         ++i)
    {
        char const * const str =
            octaspire_dern_vm_get_environment_variable_at(vm, (ptrdiff_t)i);

        octaspire_helpers_verify_not_null(str);

        octaspire_dern_value_t * const value =
            octaspire_dern_vm_create_new_value_string_from_c_string(vm, str);

        octaspire_helpers_verify_not_null(value);

        octaspire_dern_value_as_vector_push_back_element(
            result,
            &value);
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

bool octaspire_dern_stdlib_private_special_howto_helper(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t * const expectedArgs,
    octaspire_dern_value_t * const expectedtResult,
    octaspire_dern_value_t * const environment,
    octaspire_dern_value_t * const result)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_dern_environment_t * const actualEnv =
        octaspire_dern_value_as_environment_get_value(environment);

    for (size_t i = 0; i < octaspire_dern_environment_get_length(actualEnv); ++i)
    {
        octaspire_map_element_t * const element =
            octaspire_dern_environment_get_at_index(actualEnv, i);

        octaspire_dern_value_t * const value =
            octaspire_map_element_get_value(element);

        if (octaspire_dern_value_is_builtin(value) ||
            octaspire_dern_value_is_special(value) ||
            octaspire_dern_value_is_function(value))
        {
            if (octaspire_dern_value_is_howto_allowed(value))
            {
                // TODO preallocate into correct size to speed things up
                octaspire_dern_value_t * const form =
                    octaspire_dern_vm_create_new_value_vector(vm);

                if (!form)
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    return false;
                }

                octaspire_dern_vm_push_value(vm, form);

                // Add operator into the form
                octaspire_dern_value_as_vector_push_back_element(form, &value);

                // Add arguments into the form
                for (size_t i = 0;
                     i < octaspire_dern_value_as_vector_get_length(expectedArgs);
                     ++i)
                {
                    octaspire_dern_value_t * const tmpArg =
                        octaspire_dern_vm_create_new_value_copy(
                            vm,
                            octaspire_dern_value_as_vector_get_element_at(
                                expectedArgs,
                                i));
                        //octaspire_dern_value_as_vector_get_element_at(expectedArgs, i);

                    octaspire_dern_value_as_vector_push_back_element(form, &tmpArg);
                }

                // TODO Check why 'form' might be modified during evaluation.
                // (howto 1 2 3) works without copying, but (howto [a] [b] [ab])
                // doesn't work if 'form' is not copied before evaluation.
                octaspire_dern_value_t * const evaluatedValue =
                    octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_vm_create_new_value_copy(vm, form), // eval pushes
                        environment);

                octaspire_dern_vm_push_value(vm, evaluatedValue);

                if (octaspire_dern_value_is_error(evaluatedValue))
                {
                    octaspire_dern_vm_pop_value(vm, evaluatedValue);
                    octaspire_dern_vm_pop_value(vm, form);

                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    continue;
                }

                // TODO Check why 'form' might be modified during evaluation.

                octaspire_dern_value_t * const expectedResultEvaluated =
                    octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_vm_create_new_value_copy(
                            vm,
                            expectedtResult), // eval pushes
                        environment);

                octaspire_dern_vm_push_value(vm, expectedResultEvaluated);

                if (octaspire_dern_value_is_error(expectedResultEvaluated))
                {
                    octaspire_dern_vm_pop_value(vm, expectedResultEvaluated);
                    octaspire_dern_vm_pop_value(vm, evaluatedValue);
                    octaspire_dern_vm_pop_value(vm, form);

                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(vm));

                    continue;
                }

                if (octaspire_dern_value_is_equal(
                        expectedResultEvaluated,
                        evaluatedValue))
                {
                    octaspire_dern_value_as_vector_push_back_element(
                        result,
                        &form);
                }

                octaspire_dern_vm_pop_value(vm, expectedResultEvaluated);
                octaspire_dern_vm_pop_value(vm, evaluatedValue);
                octaspire_dern_vm_pop_value(vm, form);
            }
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return true;
}

octaspire_dern_value_t *octaspire_dern_vm_special_howto(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(
        arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_helpers_verify_true(
        environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'howto' expects at least two arguments.");
    }

    octaspire_dern_value_t *result =
        octaspire_dern_vm_create_new_value_vector(vm);

    octaspire_dern_vm_push_value(vm, result);

    octaspire_dern_value_t *exampleArgs =
        octaspire_dern_vm_create_new_value_vector(vm);

    octaspire_dern_vm_push_value(vm, exampleArgs);

    for (size_t i = 0; i < numArgs - 1; ++i)
    {
        octaspire_dern_value_t * const value =
            octaspire_dern_value_as_vector_get_element_at(arguments, i);

        octaspire_dern_value_as_vector_push_back_element(exampleArgs, &value);
    }

    octaspire_dern_value_t * const exampleResult =
        octaspire_dern_value_as_vector_get_element_at(arguments, numArgs - 1);

    octaspire_vector_permutation_iterator_t *iter =
        octaspire_vector_permutation_iterator_new(
            exampleArgs->value.vector,
            octaspire_dern_vm_get_allocator(vm));

    do
    {
        octaspire_dern_stdlib_private_special_howto_helper(
            vm,
            exampleArgs,
            exampleResult,
            environment,
            result);
    }
    while (octaspire_vector_permutation_iterator_next(iter));

    octaspire_vector_permutation_iterator_release(iter);
    iter = 0;

    octaspire_dern_vm_pop_value(vm, exampleArgs);
    octaspire_dern_vm_pop_value(vm, result);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_dern_stdlib.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_dern_value.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif


static char const * const octaspire_dern_value_helper_type_tags_as_c_strings[] =
{
    "illegal",
    "nil",
    "boolean",
    "integer",
    "real",
    "string",
    "character",
    "symbol",
    "error",
    "vector",
    "hash map",
    "queue",
    "list",
    "environment",
    "function",
    "special",
    "builtin",
    "port",
    "C data"
};

static octaspire_string_t *octaspire_dern_function_private_is_string_in_vector(
    octaspire_allocator_t *allocator,
    octaspire_string_t const * const str,
    octaspire_vector_t const * const vec);

static octaspire_string_t *octaspire_dern_private_value_to_string(
    octaspire_dern_value_t const * const self,
    bool const plain,
    octaspire_allocator_t * const allocator);

static int octaspire_dern_value_private_compare_void_pointers(
    void const * const a,
    void const * const b);



octaspire_dern_function_t *octaspire_dern_function_new(
    struct octaspire_dern_value_t *formals,
    struct octaspire_dern_value_t *body,
    struct octaspire_dern_value_t *definitionEnvironment,
    octaspire_allocator_t  *allocator)
{
    octaspire_dern_function_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_function_t));

    if (!self)
    {
        return 0;
    }

    self->name                  = octaspire_string_new("",   allocator);
    self->docstr                = octaspire_string_new("", allocator);
    self->howtoAllowed          = false;
    self->formals               = formals;
    self->body                  = body;
    self->definitionEnvironment = definitionEnvironment;
    self->allocator             = allocator;

    return self;
}

octaspire_dern_function_t *octaspire_dern_function_new_copy(
    octaspire_dern_function_t const * const other,
    octaspire_dern_vm_t * const vm,
    octaspire_allocator_t  *allocator)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_dern_function_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_function_t));

    if (!self)
    {
        octaspire_helpers_verify_true(
            stackLength == octaspire_dern_vm_get_stack_length(vm));

        return 0;
    }

    self->name
        = octaspire_string_new_copy(other->name, allocator);

    self->docstr
        = octaspire_string_new_copy(other->docstr, allocator);

    self->howtoAllowed = other->howtoAllowed;

    self->formals =
        octaspire_dern_vm_create_new_value_copy(vm, other->formals);

    octaspire_dern_vm_push_value(vm, self->formals);

    self->body =
        octaspire_dern_vm_create_new_value_copy(vm, other->body);

    octaspire_dern_vm_push_value(vm, self->body);

    self->definitionEnvironment =
        octaspire_dern_vm_create_new_value_copy(vm, other->definitionEnvironment);

    octaspire_dern_vm_push_value(vm, self->definitionEnvironment);

    self->allocator             = allocator;

    octaspire_dern_vm_pop_value(vm, self->definitionEnvironment);
    octaspire_dern_vm_pop_value(vm, self->body);
    octaspire_dern_vm_pop_value(vm, self->formals);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return self;
}

void octaspire_dern_function_release(octaspire_dern_function_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_string_release(self->name);
    self->name = 0;

    octaspire_string_release(self->docstr);
    self->docstr = 0;

    octaspire_allocator_free(self->allocator, self);
}

bool octaspire_dern_function_is_equal(
    octaspire_dern_function_t const * const self,
    octaspire_dern_function_t const * const other)
{
    return (octaspire_dern_function_compare(self, other) == 0);
}

int octaspire_dern_function_compare(
    octaspire_dern_function_t const * const self,
    octaspire_dern_function_t const * const other)
{
    if (self == other)
    {
        return 0;
    }

    int cmp = octaspire_string_compare(self->name, other->name);

    if (cmp)
    {
        return cmp;
    }

    cmp = octaspire_string_compare(self->docstr, other->docstr);

    if (cmp)
    {
        return cmp;
    }

    cmp = octaspire_dern_value_compare(self->formals, other->formals);

    if (cmp)
    {
        return cmp;
    }

    cmp = octaspire_dern_value_compare(self->body, other->body);

    if (cmp)
    {
        return cmp;
    }

    cmp = octaspire_dern_value_compare(
        self->definitionEnvironment,
        other->definitionEnvironment);

    if (cmp)
    {
        return cmp;
    }

    return (self->howtoAllowed - other->howtoAllowed);
}

bool octaspire_dern_function_set_howto_data(
    octaspire_dern_function_t * const self,
    char const * const name,
    char const * const docstr,
    bool const howtoAllowed)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(self->name);
    octaspire_helpers_verify_not_null(self->docstr);

    if (!octaspire_string_set_from_c_string(self->name, name))
    {
        return false;
    }

    if (!octaspire_string_set_from_c_string(self->docstr, docstr))
    {
        return false;
    }

    self->howtoAllowed  = howtoAllowed;

    return true;
}

size_t octaspire_dern_function_get_number_of_required_arguments(
    octaspire_dern_function_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(self->formals);
    octaspire_helpers_verify_true(self->formals->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    size_t const numFormalArgs = octaspire_vector_get_length(
        self->formals->value.vector);

    size_t numNormalArgs         = 0;

    for (size_t i = 0; i < numFormalArgs; ++i)
    {
        octaspire_dern_value_t *formal = octaspire_vector_get_element_at(
            self->formals->value.vector,
            (ptrdiff_t)i);

        octaspire_helpers_verify_true(formal->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

        octaspire_string_t const * const formalAsStr = formal->value.string;

        if (octaspire_string_is_equal_to_c_string(formalAsStr, "."))
        {
            return numNormalArgs;
        }

        ++numNormalArgs;
    }

    return numNormalArgs;
}

octaspire_string_t *octaspire_dern_function_private_is_string_in_vector(
    octaspire_allocator_t *allocator,
    octaspire_string_t const * const str,
    octaspire_vector_t const * const vec)
{
    octaspire_helpers_verify_true(str && vec);

    // (symbol docstrforit symbol docstrforit symbol docstrforit ...)

    for (size_t i = 0; i < octaspire_vector_get_length(vec); i += 2)
    {
        octaspire_dern_value_t const * const symbol =
            octaspire_vector_get_element_at_const(vec, (ptrdiff_t)i);

        octaspire_helpers_verify_true(symbol && symbol->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

        if (octaspire_string_is_equal(str, symbol->value.symbol))
        {
            if ((i+1) >= octaspire_vector_get_length(vec))
            {
                // No docstring for the formal
                return octaspire_string_new_format(
                    allocator,
                    "formal '%s' doesn't have docstring in docvec",
                    octaspire_string_get_c_string(str));
            }

            octaspire_dern_value_t const * const docstr =
                octaspire_vector_get_element_at_const(
                    vec,
                    (ptrdiff_t)(i + 1));

            if (!docstr)
            {
                abort();
            }
            else if (docstr->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
            {
                return octaspire_string_new_format(
                    allocator,
                    "type of docstring for formal '%s' is not string. It has type %s",
                    octaspire_string_get_c_string(str),
                    octaspire_dern_value_helper_get_type_as_c_string(docstr->typeTag));
            }

            if (octaspire_string_is_equal_to_c_string(symbol->value.symbol, "..."))
            {
                if (!octaspire_string_is_equal_to_c_string(
                    docstr->value.string,
                    "varargs"))
                {
                    return octaspire_string_new_format(
                        allocator,
                        "docstring for ... should be varargs, not it is '%s'",
                        octaspire_string_get_c_string(docstr->value.string));
                }
            }

            return 0;
        }
    }

    return octaspire_string_new_format(
        allocator,
        "formal '%s' is not mentioned in docvec",
        octaspire_string_get_c_string(str));
}

octaspire_string_t *octaspire_dern_function_are_all_formals_mentioned_in_docvec(
    octaspire_dern_function_t const * const self,
    octaspire_dern_value_t const * const docvec)
{
    octaspire_helpers_verify_true(
        docvec &&
        docvec->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_helpers_verify_true(
        self &&
        self->formals && self->formals->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_string_t *result =
        octaspire_string_new("", self->allocator);

    if (!result)
    {
        return octaspire_string_new("Allocation failure", self->allocator);
    }

    for (size_t i = 0; i < octaspire_dern_value_get_length(self->formals); ++i)
    {
        octaspire_dern_value_t const * const formal =
            octaspire_dern_value_as_vector_get_element_at_const(
                self->formals,
                (ptrdiff_t)i);

        octaspire_helpers_verify_true(
            formal &&
            formal->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

        octaspire_string_t *errorString =
            octaspire_dern_function_private_is_string_in_vector(
                self->allocator,
                formal->value.symbol,
                docvec->value.vector);

        if (errorString)
        {
            if (!octaspire_string_concatenate_format(
                result,
                "formal '%s' is not handled correctly in docvec: %s\n",
                octaspire_string_get_c_string(formal->value.symbol),
                octaspire_string_get_c_string(errorString)))
            {
                abort();
            }

            octaspire_string_release(errorString);
            errorString = 0;
        }
    }

    return result;
}



octaspire_dern_special_t *octaspire_dern_special_new(
    octaspire_dern_c_function const cFunction,
    octaspire_allocator_t *allocator,
    char const * const name,
    size_t const numRequiredActualArguments,
    char const * const docstr,
    bool const howtoAllowed)
{
    octaspire_dern_special_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_special_t));

    if (!self)
    {
        return 0;
    }

    self->cFunction                  = cFunction;
    self->allocator                  = allocator;

    self->name                       =
        octaspire_string_new(name, allocator);

    self->numRequiredActualArguments = numRequiredActualArguments;

    self->docstr                     =
        octaspire_string_new(docstr, allocator);

    self->howtoAllowed               = howtoAllowed;

    return self;
}

octaspire_dern_special_t *octaspire_dern_special_new_copy(
    octaspire_dern_special_t * const other,
    octaspire_allocator_t * const allocator)
{
    octaspire_dern_special_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_special_t));

    if (!self)
    {
        return 0;
    }

    self->cFunction                  = other->cFunction;
    self->allocator                  = allocator;

    self->name                       =
        octaspire_string_new_copy(other->name, allocator);

    self->numRequiredActualArguments = other->numRequiredActualArguments;

    self->docstr                     =
        octaspire_string_new_copy(other->docstr, allocator);

    self->howtoAllowed               = other->howtoAllowed;

    return self;
}

void octaspire_dern_special_release(octaspire_dern_special_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_string_release(self->name);
    self->name = 0;

    octaspire_string_release(self->docstr);
    self->docstr = 0;

    octaspire_allocator_free(self->allocator, self);
}

size_t octaspire_dern_special_get_number_of_required_arguments(
    octaspire_dern_special_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->numRequiredActualArguments;
}

bool octaspire_dern_special_is_howto_allowed(
    octaspire_dern_special_t const * const self)
{
    return self->howtoAllowed;
}

octaspire_string_t *octaspire_dern_special_to_string(
    octaspire_dern_special_t const * const self,
    octaspire_allocator_t * const allocator)
{
    /*
    return octaspire_string_new_format(
        allocator,
        "<builtin %s %s>",
        octaspire_string_get_c_string(self->name),
        octaspire_string_get_c_string(self->docstr));
    */

    return octaspire_string_new_format(
        allocator,
        "%s",
        octaspire_string_get_c_string(self->name));
}



octaspire_dern_error_message_t *octaspire_dern_error_message_new(
    octaspire_allocator_t *allocator,
    char const * const message,
    size_t const lineNumber)
{
    octaspire_dern_error_message_t *self =
        octaspire_allocator_malloc(allocator,
                                   sizeof(octaspire_dern_error_message_t));

    if (!self)
    {
        return 0;
    }

    self->allocator  = allocator;
    self->message    = octaspire_string_new(message, allocator);
    self->lineNumber = lineNumber;

    return self;
}

octaspire_dern_error_message_t *octaspire_dern_error_message_new_copy(
    octaspire_dern_error_message_t * const other,
    octaspire_allocator_t * const allocator)
{
    octaspire_dern_error_message_t *self =
        octaspire_allocator_malloc(allocator,
                                   sizeof(octaspire_dern_error_message_t));

    if (!self)
    {
        return 0;
    }

    self->allocator                  = allocator;

    self->message    = octaspire_string_new_copy(other->message, allocator);
    self->lineNumber = other->lineNumber;

    return self;
}

void octaspire_dern_error_message_release(octaspire_dern_error_message_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_string_release(self->message);
    self->message = 0;

    octaspire_allocator_free(self->allocator, self);
}

int octaspire_dern_error_message_compare(
    octaspire_dern_error_message_t const * const self,
    octaspire_dern_error_message_t const * const other)
{
    int const result = octaspire_string_compare(self->message, other->message);

    if (result != 0)
    {
        return result;
    }

    return self->lineNumber - other->lineNumber;
}


octaspire_dern_builtin_t *octaspire_dern_builtin_new(
    octaspire_dern_c_function const cFunction,
    octaspire_allocator_t *allocator,
    char const * const name,
    size_t const numRequiredActualArguments,
    char const * const docstr,
    bool const howtoAllowed)
{
    octaspire_dern_builtin_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_builtin_t));

    if (!self)
    {
        return 0;
    }

    self->cFunction                  = cFunction;
    self->allocator                  = allocator;

    self->name                       =
        octaspire_string_new(name, allocator);

    self->numRequiredActualArguments = numRequiredActualArguments;

    self->docstr                     =
        octaspire_string_new(docstr, allocator);

    self->howtoAllowed               = howtoAllowed;

    return self;
}

octaspire_dern_builtin_t *octaspire_dern_builtin_new_copy(
    octaspire_dern_builtin_t * const other,
    octaspire_allocator_t * const allocator)
{
    octaspire_dern_builtin_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_builtin_t));

    if (!self)
    {
        return 0;
    }

    self->cFunction                  = other->cFunction;
    self->allocator                  = allocator;

    self->name                       =
        octaspire_string_new_copy(other->name, allocator);

    self->numRequiredActualArguments = other->numRequiredActualArguments;

    self->docstr                     =
        octaspire_string_new_copy(other->docstr, allocator);

    self->howtoAllowed               = other->howtoAllowed;

    return self;
}

void octaspire_dern_builtin_release(octaspire_dern_builtin_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_string_release(self->name);
    self->name = 0;

    octaspire_string_release(self->docstr);
    self->docstr = 0;

    octaspire_allocator_free(self->allocator, self);
}

size_t octaspire_dern_builtin_get_number_of_required_arguments(
    octaspire_dern_builtin_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->numRequiredActualArguments;
}

bool octaspire_dern_builtin_is_howto_allowed(
    octaspire_dern_builtin_t const * const self)
{
    return self->howtoAllowed;
}

octaspire_string_t *octaspire_dern_builtin_to_string(
    octaspire_dern_builtin_t const * const self,
    octaspire_allocator_t * const allocator)
{
    /*
    return octaspire_string_new_format(
        allocator,
        "<special %s %s>",
        octaspire_string_get_c_string(self->name),
        octaspire_string_get_c_string(self->docstr));
    */

    return octaspire_string_new_format(
        allocator,
        "%s",
        octaspire_string_get_c_string(self->name));
}



bool octaspire_dern_function_is_howto_allowed(
    octaspire_dern_function_t const * const self)
{
    return self->howtoAllowed;
}

octaspire_string_t *octaspire_dern_function_to_string(
    octaspire_dern_function_t const * const self,
    octaspire_allocator_t * const allocator)
{
    /*
    return octaspire_string_new_format(
        allocator,
        "<function %s %s>",
        octaspire_string_get_c_string(self->name),
        octaspire_string_get_c_string(self->docstr));
    */

    return octaspire_string_new_format(
        allocator,
        "%s",
        octaspire_string_get_c_string(self->name));
}

char const * octaspire_dern_value_helper_get_type_as_c_string(
    octaspire_dern_value_tag_t const typeTag)
{
    octaspire_helpers_verify_true(typeTag <
        (octaspire_dern_value_tag_t)(sizeof(octaspire_dern_value_helper_type_tags_as_c_strings) /
         sizeof(octaspire_dern_value_helper_type_tags_as_c_strings[0])));

    return octaspire_dern_value_helper_type_tags_as_c_strings[typeTag];
}

octaspire_dern_value_tag_t octaspire_dern_value_get_type(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->typeTag;
}

bool octaspire_dern_value_set(
    octaspire_dern_value_t  * const self,
    octaspire_dern_value_t  * const value)
{
    if (self == value)
    {
        return true;
    }

    octaspire_dern_vm_clear_value_to_nil(self->vm, self);

    self->typeTag = value->typeTag;

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        {
            // NOP
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        {
            self->value.boolean = value->value.boolean;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            self->value.integer = value->value.integer;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            self->value.real = value->value.real;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            self->value.string =
                octaspire_string_new_copy(
                    value->value.string,
                    octaspire_dern_vm_get_allocator(self->vm));
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            self->value.character =
                octaspire_string_new_copy(
                    value->value.character,
                    octaspire_dern_vm_get_allocator(self->vm));
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            self->value.symbol =
                octaspire_string_new_copy(
                    value->value.symbol,
                    octaspire_dern_vm_get_allocator(self->vm));
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            self->value.error =
                octaspire_dern_error_message_new_copy(
                    value->value.error,
                    octaspire_dern_vm_get_allocator(self->vm));
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            self->value.vector = octaspire_vector_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                octaspire_dern_vm_get_allocator(self->vm));

            for (size_t i = 0; i < octaspire_vector_get_length(value->value.vector); ++i)
            {
                octaspire_dern_value_t * tmpVal =
                    octaspire_vector_get_element_at(
                        value->value.vector,
                        (ptrdiff_t)i);

                if (octaspire_dern_value_is_atom(tmpVal))
                {
                    tmpVal = octaspire_dern_vm_create_new_value_copy(self->vm, tmpVal);
                }

                octaspire_dern_vm_push_value(self->vm, tmpVal);

                if (!octaspire_vector_push_back_element(self->value.vector, &tmpVal))
                {
                    abort();
                }

                octaspire_dern_vm_pop_value(self->vm, tmpVal);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            self->value.hashMap = octaspire_map_new(
                sizeof(octaspire_dern_value_t*),
                true,
                sizeof(octaspire_dern_value_t*),
                true,
                (octaspire_map_key_compare_function_t)octaspire_dern_value_is_equal,
                (octaspire_map_key_hash_function_t)octaspire_dern_value_get_hash,
                0,
                0,
                octaspire_dern_vm_get_allocator(self->vm));

            for (size_t i = 0;
                 i < octaspire_map_get_number_of_elements(
                     value->value.hashMap);
                 ++i)
            {
                octaspire_map_element_t * const element =
                    octaspire_map_get_at_index(
                        value->value.hashMap,
                        (ptrdiff_t)i);

                octaspire_dern_value_t *key = octaspire_map_element_get_key(element);

                octaspire_dern_value_t *val =
                    octaspire_map_element_get_value(element);

                if (octaspire_dern_value_is_atom(key))
                {
                    key = octaspire_dern_vm_create_new_value_copy(self->vm, key);
                }

                octaspire_dern_vm_push_value(self->vm, key);

                if (octaspire_dern_value_is_atom(val))
                {
                    val = octaspire_dern_vm_create_new_value_copy(self->vm, val);
                }

                octaspire_dern_vm_push_value(self->vm, val);

                // Any previous value must be removed, because hash map
                // can contain multiple values per key, and we must replace, not
                // add the value.
                octaspire_map_remove(
                    self->value.hashMap,
                    octaspire_map_element_get_hash(element),
                    &key);

                if (!octaspire_map_put(
                    self->value.hashMap,
                    octaspire_map_element_get_hash(element),
                    &key,
                    &val))
                {
                    abort();
                }

                octaspire_dern_vm_pop_value(self->vm, val);
                octaspire_dern_vm_pop_value(self->vm, key);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            self->value.queue = octaspire_queue_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                octaspire_dern_vm_get_allocator(self->vm));

            // TODO Add iterator to queue and use it here
            for (size_t i = 0;
                 i < octaspire_queue_get_length(value->value.queue);
                 ++i)
            {
                octaspire_dern_value_t * tmpVal =
                    octaspire_queue_get_at(
                        value->value.queue,
                        (ptrdiff_t)i);

                if (octaspire_dern_value_is_atom(tmpVal))
                {
                    tmpVal = octaspire_dern_vm_create_new_value_copy(self->vm, tmpVal);
                }

                octaspire_dern_vm_push_value(self->vm, tmpVal);

                if (!octaspire_queue_push(self->value.queue, &tmpVal))
                {
                    abort();
                }

                octaspire_dern_vm_pop_value(self->vm, tmpVal);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            self->value.list = octaspire_list_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                octaspire_dern_vm_get_allocator(self->vm));

            // TODO more efficient iteration
            for (size_t i = 0;
                 i < octaspire_list_get_length(value->value.list);
                 ++i)
            {
                octaspire_dern_value_t * tmpVal =
                    octaspire_list_node_get_element(
                        octaspire_list_get_at(
                            value->value.list,
                            (ptrdiff_t)i));

                if (octaspire_dern_value_is_atom(tmpVal))
                {
                    tmpVal = octaspire_dern_vm_create_new_value_copy(self->vm, tmpVal);
                }

                octaspire_dern_vm_push_value(self->vm, tmpVal);

                if (!octaspire_list_push_back(self->value.list, &tmpVal))
                {
                    abort();
                }

                octaspire_dern_vm_pop_value(self->vm, tmpVal);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            if (!octaspire_dern_c_data_is_copying_allowed(value->value.cData))
            {
                return false;
            }

            self->value.cData =
                octaspire_dern_c_data_new_copy(
                    value->value.cData,
                    octaspire_dern_vm_get_allocator(self->vm));
        }
        break;
    }

    if (value->docstr)
    {
        // GC releases old if created
        self->docstr = octaspire_dern_vm_create_new_value_copy(self->vm, value->docstr);
    }

    if (value->docvec)
    {
        // GC releases old if created
        self->docvec = octaspire_dern_vm_create_new_value_copy(self->vm, value->docvec);
    }

    return true;
}

bool octaspire_dern_value_set_collection(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t const * const indexOrKey,
    octaspire_dern_value_t * const value)
{
    octaspire_helpers_verify_true(self && indexOrKey && value);

    if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        if (value->typeTag      != OCTASPIRE_DERN_VALUE_TAG_CHARACTER ||
            indexOrKey->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
        {
            return false;
        }

        return octaspire_string_overwrite_with_string_at(
            self->value.string,
            value->value.character,
            indexOrKey->value.integer);
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR)
    {
        if (indexOrKey->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
        {
            return false;
        }

        //bool const result = octaspire_vector_insert_element_before_the_element_at_index(

        if (indexOrKey->value.integer < 0)
        {
            // TODO index from back?
            return false;
        }

        // TODO XXX is this correct?
        if (octaspire_vector_get_length(self->value.vector) <=
            (size_t)indexOrKey->value.integer)
        {

            // octaspire_vector_insert_element_at cannot be used here, because
            // it fills the missing indices with 0. Now those must be nil-values.

            for (size_t i = octaspire_vector_get_length(self->value.vector);
                 i < (size_t)indexOrKey->value.integer;
                 ++i)
            {
                octaspire_dern_value_t *nilValue = octaspire_dern_vm_get_value_nil(self->vm);

                if (!octaspire_vector_push_back_element(
                    self->value.vector,
                    &nilValue))
                {
                    abort();
                }
            }

            octaspire_dern_value_t * const tmpValueForInsertion =
                octaspire_dern_value_is_atom(value) ?
                    octaspire_dern_vm_create_new_value_copy(self->vm, value) :
                    value;

            return octaspire_vector_push_back_element(
                self->value.vector,
                &tmpValueForInsertion);
        }
        else
        {
            octaspire_dern_value_t * const tmpValueForInsertion =
                octaspire_dern_value_is_atom(value) ?
                    octaspire_dern_vm_create_new_value_copy(self->vm, value) :
                    value;

            return octaspire_vector_replace_element_at(
                self->value.vector,
                indexOrKey->value.integer,
                &tmpValueForInsertion);
        }
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP)
    {
        octaspire_dern_value_t * const tmpValueForInsertion =
            octaspire_dern_value_is_atom(value) ?
            octaspire_dern_vm_create_new_value_copy(self->vm, value) :
            value;

        // Any previous value must be removed, because hash map
        // can contain multiple values per key, and we must replace, not
        // add the value.
        octaspire_map_remove(
            self->value.hashMap,
            octaspire_dern_value_get_hash(indexOrKey),
            &indexOrKey);

        return octaspire_map_put(
            self->value.hashMap,
            octaspire_dern_value_get_hash(indexOrKey),
            &indexOrKey,
            &tmpValueForInsertion);
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE)
    {
        // TODO XXX
        abort();
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST)
    {
        // TODO XXX
        abort();
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
    {
        // TODO XXX Should here a copy of atom be made or not?
        return octaspire_dern_environment_set(
            self->value.environment,
            indexOrKey,
            value);
    }

    return false;
}

uint32_t octaspire_dern_value_get_hash(
    octaspire_dern_value_t const * const self)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
            return octaspire_helpers_calculate_hash_for_bool_argument(false);

        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
            return octaspire_helpers_calculate_hash_for_bool_argument(self->value.boolean);

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            return octaspire_helpers_calculate_hash_for_int32_t_argument(self->value.integer);

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
            return octaspire_helpers_calculate_hash_for_double_argument(self->value.real);

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
            return octaspire_string_get_hash(self->value.string);

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            return octaspire_string_get_hash(self->value.character);

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            return octaspire_string_get_hash(self->value.symbol);

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            return octaspire_string_get_hash(self->value.error->message);

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.vector);

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.hashMap);

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.queue);

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
            return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.list);

        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            return octaspire_helpers_calculate_hash_for_void_pointer_argument(
                self->value.environment);

        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.function);

        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.special);

        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.builtin);

        case OCTASPIRE_DERN_VALUE_TAG_PORT:
            return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.port);

        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.cData);
    }

    return 0;
}

bool octaspire_dern_value_is_equal(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    return (octaspire_dern_value_compare(self, other) == 0);
}

bool octaspire_dern_value_is_less_than(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    return (octaspire_dern_value_compare(self, other) < 0);
}

bool octaspire_dern_value_is_greater_than(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    return (octaspire_dern_value_compare(self, other) > 0);
}

bool octaspire_dern_value_is_less_than_or_equal(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    return (octaspire_dern_value_compare(self, other) <= 0);
}

bool octaspire_dern_value_is_greater_than_or_equal(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    return (octaspire_dern_value_compare(self, other) >= 0);
}

octaspire_string_t *octaspire_dern_private_value_to_string(
    octaspire_dern_value_t const * const self,
    bool const plain,
    octaspire_allocator_t * const allocator)
{
    octaspire_helpers_verify_not_null(self);

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        {
            return octaspire_string_new("nil", allocator);
        }

        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        {
            return octaspire_string_new_format(
                allocator,
                "%s",
                self->value.boolean ? "true" : "false");
        }

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            {
                return octaspire_string_new_format(
                    allocator,
                    "%s%" PRId32 "}",
                    (self->value.integer >= 0) ? "{D+" : "{D",
                    self->value.integer);
            }

            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            {
                return octaspire_string_new_format(
                    allocator,
                    "%s%g}",
                    (self->value.real >= 0) ? "{D+" : "{D",
                    self->value.real);
            }

            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            {
                return octaspire_string_new_format(allocator, plain ? "%s" :"[%s]",
                    octaspire_string_get_c_string(self->value.string));
            }

            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            {
                if (octaspire_string_is_equal_to_c_string(
                    self->value.character,
                    "|"))
                {
                    return octaspire_string_new(plain ? "|" : "|bar|", allocator);
                }
                else if (octaspire_string_is_equal_to_c_string(
                    self->value.character,
                    "\n"))
                {
                    return octaspire_string_new(
                        plain ? "\n" : "|newline|", allocator);
                }
                else if (octaspire_string_is_equal_to_c_string(
                    self->value.character,
                    "\t"))
                {
                    return octaspire_string_new(plain ? "\t" :"|tab|", allocator);
                }
                else
                {
                    return octaspire_string_new_format(
                        allocator,
                        plain ? "%s" : "|%s|",
                        octaspire_string_get_c_string(self->value.character));
                }
            }

            case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            {
                return octaspire_string_new_format(allocator, "%s",
                    octaspire_string_get_c_string(self->value.symbol));
            }

            case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            {
                return octaspire_string_new_format(allocator, "<error>: %s",
                    octaspire_string_get_c_string(self->value.error->message));
            }

            case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            {
                octaspire_string_t *result =
                    octaspire_string_new("(", allocator);

                octaspire_helpers_verify_not_null(result);

                for (size_t i = 0;
                     i < octaspire_vector_get_length(self->value.vector); ++i)
                {
                    octaspire_dern_value_t *tmpValue =
                        octaspire_vector_get_element_at(
                            self->value.vector,
                            (ptrdiff_t)i);

                    octaspire_helpers_verify_not_null(tmpValue);

                    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
                        tmpValue,
                        allocator);

                    octaspire_helpers_verify_not_null(tmpStr);

                    if (!octaspire_string_concatenate_c_string(
                        result,
                        octaspire_string_get_c_string(tmpStr)))
                    {
                        abort();
                    }

                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    if ((i+1) < octaspire_vector_get_length(self->value.vector))
                    {
                        octaspire_string_concatenate_c_string(result, " ");
                    }
                }

                if (!octaspire_string_concatenate_c_string(
                    result,
                    ")"))
                {
                    abort();
                }

                return result;
            }

            case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            {
                octaspire_string_t *result =
                    octaspire_string_new("(hash-map ", allocator);

                octaspire_helpers_verify_not_null(result);

                for (size_t i = 0;
                     i < octaspire_map_get_number_of_elements(
                         self->value.hashMap);
                    ++i)
                {
                    octaspire_map_element_t *element =
                        octaspire_map_get_at_index(
                            self->value.hashMap,
                            (ptrdiff_t)i);

                    // Key
                    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
                        octaspire_map_element_get_key(element),
                        allocator);

                    octaspire_helpers_verify_not_null(tmpStr);

                    if (!octaspire_string_concatenate_c_string(
                        result,
                        octaspire_string_get_c_string(tmpStr)))
                    {
                        abort();
                    }

                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    // " "
                    if (!octaspire_string_concatenate_c_string(
                        result,
                        " "))
                    {
                        abort();
                    }

                    // Value
                    tmpStr = octaspire_dern_value_to_string(
                        octaspire_map_element_get_value(element),
                        allocator);

                    octaspire_helpers_verify_not_null(tmpStr);

                    if (!octaspire_string_concatenate_c_string(
                        result,
                        octaspire_string_get_c_string(tmpStr)))
                    {
                        abort();
                    }

                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    if ((i+1) < octaspire_map_get_number_of_elements(
                        self->value.hashMap))
                    {
                        octaspire_string_concatenate_c_string(
                            result,
                            "\n          ");
                    }
                }

                if (!octaspire_string_concatenate_c_string(
                    result,
                    ")"))
                {
                    abort();
                }

                return result;
            }

            case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            {
                octaspire_string_t *result =
                    octaspire_string_new("(queue ", allocator);

                octaspire_helpers_verify_not_null(result);

                // Add iterator into queue and use it here
                for (size_t i = 0; i < octaspire_queue_get_length(self->value.queue); ++i)
                {
                    octaspire_dern_value_t *tmpValue =
                        octaspire_queue_get_at(
                            self->value.queue,
                            (ptrdiff_t)i);

                    octaspire_helpers_verify_not_null(tmpValue);

                    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
                        tmpValue,
                        allocator);

                    octaspire_helpers_verify_not_null(tmpStr);

                    if (!octaspire_string_concatenate_c_string(
                        result,
                        octaspire_string_get_c_string(tmpStr)))
                    {
                        abort();
                    }

                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    if ((i+1) < octaspire_queue_get_length(self->value.queue))
                    {
                        octaspire_string_concatenate_c_string(result, " ");
                    }
                }

                if (!octaspire_string_concatenate_c_string(
                    result,
                    ")"))
                {
                    abort();
                }

                return result;
            }

            case OCTASPIRE_DERN_VALUE_TAG_LIST:
            {
                octaspire_string_t *result =
                    octaspire_string_new("(list ", allocator);

                octaspire_helpers_verify_not_null(result);

                // More efficient iteration
                for (size_t i = 0; i < octaspire_list_get_length(self->value.list); ++i)
                {
                    octaspire_dern_value_t *tmpValue =
                        octaspire_list_node_get_element(
                            octaspire_list_get_at(
                                self->value.list,
                                (ptrdiff_t)i));

                    octaspire_helpers_verify_not_null(tmpValue);

                    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
                        tmpValue,
                        allocator);

                    octaspire_helpers_verify_not_null(tmpStr);

                    if (!octaspire_string_concatenate_c_string(
                        result,
                        octaspire_string_get_c_string(tmpStr)))
                    {
                        abort();
                    }

                    octaspire_string_release(tmpStr);
                    tmpStr = 0;

                    if ((i+1) < octaspire_list_get_length(self->value.list))
                    {
                        octaspire_string_concatenate_c_string(result, " ");
                    }
                }

                if (!octaspire_string_concatenate_c_string(
                    result,
                    ")"))
                {
                    abort();
                }

                return result;
            }

            case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            {
                return octaspire_dern_function_to_string(self->value.function, allocator);
            }

            case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            {
                return octaspire_dern_builtin_to_string(self->value.builtin, allocator);
            }

            case OCTASPIRE_DERN_VALUE_TAG_PORT:
            {
                return octaspire_dern_port_to_string(self->value.port, allocator);
            }

            case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            {
                return octaspire_dern_c_data_to_string(self->value.cData, allocator);
            }

            case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            {
                return octaspire_dern_special_to_string(self->value.special, allocator);
            }

            case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            {
                octaspire_helpers_verify_not_null(self->value.environment);
                return octaspire_dern_environment_to_string(self->value.environment);
            }
    }

    return 0;
}

octaspire_string_t *octaspire_dern_value_to_string(
octaspire_dern_value_t const * const self,
octaspire_allocator_t * const allocator)
{
    return octaspire_dern_private_value_to_string(self, false, allocator);
}

octaspire_string_t *octaspire_dern_value_to_string_plain(
octaspire_dern_value_t const * const self,
octaspire_allocator_t * const allocator)
{
    return octaspire_dern_private_value_to_string(self, true, allocator);
}

bool octaspire_dern_value_is_integer(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER;
}

bool octaspire_dern_value_is_real(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL;
}

bool octaspire_dern_value_is_number(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER ||
           self->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL;
}

bool octaspire_dern_value_is_nil(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_NIL;
}

bool octaspire_dern_value_is_boolean(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_BOOLEAN;
}

bool octaspire_dern_value_is_character(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER;
}

bool octaspire_dern_value_is_string(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING;
}

bool octaspire_dern_value_is_symbol(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL;
}

bool octaspire_dern_value_is_text(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER ||
           self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING    ||
           self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL;
}

bool octaspire_dern_value_is_vector(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR;
}

bool octaspire_dern_value_is_hash_map(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP;
}

bool octaspire_dern_value_is_queue(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE;
}

bool octaspire_dern_value_is_list(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST;
}

bool octaspire_dern_value_is_port(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_PORT;
}

bool octaspire_dern_value_is_environment(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT;
}

bool octaspire_dern_value_is_error(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR;
}

void octaspire_dern_value_as_error_set_line_number(
    octaspire_dern_value_t const * const self,
    size_t const lineNumber)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR);
    self->value.error->lineNumber = lineNumber;
}

char const *octaspire_dern_value_as_error_get_c_string(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR);
    return octaspire_string_get_c_string(self->value.error->message);
}

octaspire_dern_environment_t *octaspire_dern_value_as_environment_get_value(
    octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);
    return self->value.environment;
}

octaspire_dern_environment_t const *octaspire_dern_value_as_environment_get_value_const(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);
    return self->value.environment;
}

bool octaspire_dern_value_is_function(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_FUNCTION;
}

bool octaspire_dern_value_is_builtin(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_BUILTIN;
}

bool octaspire_dern_value_is_special(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SPECIAL;
}

bool octaspire_dern_value_is_howto_allowed(
    octaspire_dern_value_t const * const self)
{
    // TODO XXX make user functions to support setting
    // howto
    octaspire_helpers_verify_true(
        octaspire_dern_value_is_builtin(self) ||
        octaspire_dern_value_is_special(self) ||
        octaspire_dern_value_is_function(self));

    return self->howtoAllowed;
}

bool octaspire_dern_value_is_c_data(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_C_DATA;
}

octaspire_dern_c_data_t *octaspire_dern_value_as_c_data_get_value(
    octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_C_DATA);
    return self->value.cData;
}

octaspire_dern_c_data_t const *octaspire_dern_value_as_c_data_get_value_const(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_C_DATA);
    return self->value.cData;
}

void octaspire_dern_value_print(
    octaspire_dern_value_t const * const self,
    octaspire_allocator_t *allocator)
{
    octaspire_string_t *str = octaspire_dern_value_to_string(self, allocator);
    printf("%s", octaspire_string_get_c_string(str));
    octaspire_string_release(str);
    str = 0;
}

uintmax_t octaspire_dern_value_get_unique_id(
    octaspire_dern_value_t const * const self)
{
    return self->uniqueId;
}

bool octaspire_dern_value_as_boolean_get_value(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_BOOLEAN);
    return self->value.boolean;
}

int32_t octaspire_dern_value_as_integer_get_value(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER);
    return self->value.integer;
}

void octaspire_dern_value_as_integer_set_value(
    octaspire_dern_value_t * const self,
    int32_t const value)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER);
    self->value.integer = value;
}

double octaspire_dern_value_as_real_get_value(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL);
    return self->value.real;
}

void octaspire_dern_value_as_real_set_value(
    octaspire_dern_value_t * const self,
    double const value)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL);
    self->value.real = value;
}

void octaspire_dern_value_as_number_set_value(
    octaspire_dern_value_t * const self,
    double const value)
{
    octaspire_helpers_verify_true(
        octaspire_dern_value_is_number(self));

    if (octaspire_dern_value_is_real(self))
    {
        self->value.real = value;
    }
    else
    {
        self->value.integer = (int32_t)value;
    }
}

double octaspire_dern_value_as_number_get_value(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(octaspire_dern_value_is_number(self));

    if (octaspire_dern_value_is_integer(self))
    {
        return (double)self->value.integer;
    }

    return self->value.real;
}

bool octaspire_dern_value_as_hash_map_remove(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const keyValue)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);

    return octaspire_map_remove(
        self->value.hashMap,
        octaspire_dern_value_get_hash(keyValue),
        &keyValue);
}

octaspire_dern_function_t *octaspire_dern_value_as_function(
    octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_FUNCTION);
    return self->value.function;
}

bool octaspire_dern_value_as_hash_map_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const toBeAdded1,
    octaspire_dern_value_t * const toBeAdded2)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);

    switch (toBeAdded1->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            octaspire_helpers_verify_null(toBeAdded2);

            return octaspire_map_add_hash_map(
                self->value.hashMap,
                toBeAdded1->value.hashMap);
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            octaspire_helpers_verify_null(toBeAdded2);

            size_t const vecLen = octaspire_dern_value_as_vector_get_length(toBeAdded1);

            if (vecLen % 2 != 0)
            {
                return false;
            }

            bool result = true;
            for (size_t i = 0; i < vecLen; i += 2)
            {
                octaspire_dern_value_t * const key =
                    octaspire_dern_value_as_vector_get_element_at(
                        toBeAdded1,
                        (ptrdiff_t)i);

                octaspire_dern_value_t * const val =
                    octaspire_dern_value_as_vector_get_element_at(
                        toBeAdded1,
                        (ptrdiff_t)(i + 1));

                uint32_t const hash = octaspire_dern_value_get_hash(key);

                if (!octaspire_dern_value_as_hash_map_put(
                        self,
                        hash,
                        key,
                        val))
                {
                    result = false;
                }
            }

            return result;
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            if (!toBeAdded2)
            {
                return false;
            }

            uint32_t const hash = octaspire_dern_value_get_hash(toBeAdded1);

            if (!octaspire_dern_value_as_hash_map_put(
                    self,
                    hash,
                    toBeAdded1,
                    toBeAdded2))
            {
                return false;
            }

            return true;
        }
    }

    return false;
}

bool octaspire_dern_value_as_queue_push(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const toBeAdded)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE);
if (octaspire_dern_value_is_atom(toBeAdded))
    {
        octaspire_dern_value_t * const copyVal =
            octaspire_dern_vm_create_new_value_copy(self->vm, toBeAdded);

        return octaspire_queue_push(self->value.queue, &copyVal);
    }

    return octaspire_queue_push(self->value.queue, &toBeAdded);
}

bool octaspire_dern_value_as_queue_pop(octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE);
    return octaspire_queue_pop(self->value.queue);
}

size_t octaspire_dern_value_as_queue_get_length(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE);
    return octaspire_queue_get_length(self->value.queue);
}

bool octaspire_dern_value_as_list_push_back(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const toBeAdded)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST);

    if (octaspire_dern_value_is_atom(toBeAdded))
    {
        octaspire_dern_value_t * const copyVal =
            octaspire_dern_vm_create_new_value_copy(self->vm, toBeAdded);

        return octaspire_list_push_back(self->value.list, &copyVal);
    }

    return octaspire_list_push_back(self->value.list, &toBeAdded);
}

bool octaspire_dern_value_as_list_pop_back(octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST);
    return octaspire_list_pop_back(self->value.list);
}

bool octaspire_dern_value_as_list_pop_front(octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST);
    return octaspire_list_pop_front(self->value.list);
}

size_t octaspire_dern_value_as_list_get_length(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST);
    return octaspire_list_get_length(self->value.list);
}

bool octaspire_dern_value_as_character_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER);

    switch (other->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        // TODO should adding of char, string and vector be allowed?
        // It could turn this character into a string.

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            uint32_t const charAsInt = octaspire_string_get_ucs_character_at_index(
                self->value.character,
                0);

            octaspire_string_clear(self->value.character);

            octaspire_string_push_back_ucs_character(
                self->value.character,
                (uint32_t)((int32_t)charAsInt + other->value.integer));

            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
           octaspire_string_t *newStr = octaspire_string_new_copy(
                self->value.character,
                octaspire_dern_vm_get_allocator(self->vm));

            octaspire_string_release(self->value.character);
            self->value.character = 0;

            self->value.string = newStr;

            octaspire_string_concatenate(self->value.string, other->value.character);

            self->typeTag = OCTASPIRE_DERN_VALUE_TAG_STRING;

            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            return false;
        }
    }

    abort();
    return false;
}

bool octaspire_dern_value_as_character_subtract(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER);

    switch (other->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            uint32_t const charAsInt =
                octaspire_string_get_ucs_character_at_index(
                    self->value.character,
                    0);

            octaspire_string_clear(self->value.character);

            octaspire_string_push_back_ucs_character(
                self->value.character,
                (uint32_t)((int32_t)charAsInt - other->value.integer));

            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            uint32_t const charAsInt = octaspire_string_get_ucs_character_at_index(
                self->value.character,
                0);

            uint32_t const otherAsInt = octaspire_string_get_ucs_character_at_index(
                other->value.character,
                0);

            octaspire_string_clear(self->value.character);

            octaspire_string_push_back_ucs_character(
                self->value.character,
                charAsInt - otherAsInt);

            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            return false;
        }
    }

    abort();
    return false;
}

bool octaspire_dern_value_as_integer_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER);

    switch (other->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_string_t *chars = octaspire_string_new(
                "-0123456789.",
                octaspire_dern_vm_get_allocator(self->vm));

            if (octaspire_string_contains_only_these_chars(
                other->value.string,
                chars))
            {
                if (octaspire_string_contains_char(
                    other->value.string,
                    (uint32_t)'.'))
                {
                    self->typeTag = OCTASPIRE_DERN_VALUE_TAG_REAL;
                    self->value.real = self->value.integer;

                    self->value.real += octaspire_dern_helpers_atof(
                        octaspire_string_get_c_string(other->value.string),
                        octaspire_dern_vm_get_allocator(self->vm));

                    return true;
                }
                else
                {
                    self->value.integer +=
                        atol(octaspire_string_get_c_string(other->value.string));

                    return true;
                }
            }
            else
            {
                return false;
            }
        }

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            self->value.integer += other->value.integer;
            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            self->typeTag = OCTASPIRE_DERN_VALUE_TAG_REAL;
            self->value.real = self->value.integer;
            self->value.real += other->value.real;
            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            bool result = true;
            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(other); ++i)
            {
                if (!octaspire_dern_value_as_integer_add(
                        self,
                        octaspire_dern_value_as_vector_get_element_at(
                            other,
                            (ptrdiff_t)i)))
                {
                    result = false;
                }
            }

            return result;
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            return false;
        }
    }

    abort();
    return false;
}

bool octaspire_dern_value_as_integer_subtract(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER);

    switch (other->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_string_t *chars = octaspire_string_new(
                "-0123456789.",
                octaspire_dern_vm_get_allocator(self->vm));

            if (octaspire_string_contains_only_these_chars(
                    other->value.string,
                    chars))
            {
                if (octaspire_string_contains_char(
                    other->value.string,
                    (uint32_t)'.'))
                {
                    self->typeTag = OCTASPIRE_DERN_VALUE_TAG_REAL;
                    self->value.real = self->value.integer;

                    self->value.real -= octaspire_dern_helpers_atof(
                        octaspire_string_get_c_string(other->value.string),
                        octaspire_dern_vm_get_allocator(self->vm));

                    return true;
                }
                else
                {
                    self->value.integer -=
                        atol(octaspire_string_get_c_string(other->value.string));

                    return true;
                }
            }
            else
            {
                return false;
            }
        }

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            self->value.integer -= other->value.integer;
            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            self->typeTag = OCTASPIRE_DERN_VALUE_TAG_REAL;
            self->value.real = self->value.integer;
            self->value.real -= other->value.real;
            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            bool result = true;
            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(other); ++i)
            {
                if (!octaspire_dern_value_as_integer_subtract(
                        self,
                        octaspire_dern_value_as_vector_get_element_at(
                            other,
                            (ptrdiff_t)i)))
                {
                    result = false;
                }
            }

            return result;
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            return false;
        }
    }

    return false;
}

bool octaspire_dern_value_as_real_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL);

    switch (other->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_string_t *chars = octaspire_string_new(
                "-0123456789.",
                octaspire_dern_vm_get_allocator(self->vm));

            if (octaspire_string_contains_only_these_chars(
                    other->value.string,
                    chars))
            {
                if (octaspire_string_contains_char(
                        other->value.string,
                        (uint32_t)'.'))
                {
                    self->value.real += octaspire_dern_helpers_atof(
                        octaspire_string_get_c_string(other->value.string),
                        octaspire_dern_vm_get_allocator(self->vm));

                    return true;
                }
                else
                {
                    self->value.real +=
                        atol(octaspire_string_get_c_string(other->value.string));

                    return true;
                }
            }
            else
            {
                return false;
            }
        }

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            self->value.real += other->value.integer;
            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            self->value.real += other->value.real;
            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            bool result = true;
            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(other); ++i)
            {
                if (!octaspire_dern_value_as_real_add(
                        self,
                        octaspire_dern_value_as_vector_get_element_at(
                            other,
                            (ptrdiff_t)i)))
                {
                    result = false;
                }
            }

            return result;
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            return false;
        }
    }

    abort();
    return false;
}

bool octaspire_dern_value_as_real_subtract(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL);

    switch (other->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_string_t *chars = octaspire_string_new(
                "-0123456789.",
                octaspire_dern_vm_get_allocator(self->vm));

            if (octaspire_string_contains_only_these_chars(
                    other->value.string,
                    chars))
            {
                if (octaspire_string_contains_char(
                        other->value.string,
                        (uint32_t)'.'))
                {
                    self->value.real -= octaspire_dern_helpers_atof(
                        octaspire_string_get_c_string(other->value.string),
                        octaspire_dern_vm_get_allocator(self->vm));

                    return true;
                }
                else
                {
                    self->value.real -=
                        atol(octaspire_string_get_c_string(other->value.string));

                    return true;
                }
            }
            else
            {
                return false;
            }
        }

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            self->value.real -= other->value.integer;
            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            self->value.real -= other->value.real;
            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            bool result = true;
            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(other); ++i)
            {
                if (!octaspire_dern_value_as_real_subtract(
                        self,
                        octaspire_dern_value_as_vector_get_element_at(
                            other,
                            (ptrdiff_t)i)))
                {
                    result = false;
                }
            }

            return result;
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            return false;
        }
    }

    abort();
    return 0;
}

char const *octaspire_dern_value_as_character_get_c_string(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER);
    return octaspire_string_get_c_string(self->value.character);
}

bool octaspire_dern_value_as_string_push_back(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const value)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            return octaspire_string_concatenate(
                self->value.string,
                value->value.string);
        }

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            return octaspire_string_concatenate(
                self->value.string,
                value->value.symbol);
        }

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            return octaspire_string_concatenate(
                self->value.string,
                value->value.character);
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            bool result = true;
            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(value); ++i)
            {
                if (!octaspire_dern_value_as_string_push_back(
                        self,
                        octaspire_dern_value_as_vector_get_element_at(
                            value,
                            (ptrdiff_t)i)))
                {
                    result = false;
                }
            }

            return result;
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_string_t *tmpStr =
                octaspire_dern_value_to_string(value, octaspire_dern_vm_get_allocator(self->vm));

            bool result = octaspire_string_concatenate(self->value.string, tmpStr);

            octaspire_string_release(tmpStr);
            tmpStr = 0;

            return result;
        }
    }

    return false;
}

bool octaspire_dern_value_as_symbol_push_back(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const value)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            return octaspire_string_concatenate(
                self->value.symbol,
                value->value.string);
        }

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            return octaspire_string_concatenate(
                self->value.symbol,
                value->value.symbol);
        }

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            return octaspire_string_concatenate(
                self->value.symbol,
                value->value.character);
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            bool result = true;
            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(value); ++i)
            {
                if (!octaspire_dern_value_as_symbol_push_back(
                        self,
                        octaspire_dern_value_as_vector_get_element_at(
                            value,
                            (ptrdiff_t)i)))
                {
                    result = false;
                }
            }

            return result;
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_string_t *tmpStr =
                octaspire_dern_value_to_string(
                    value,
                    octaspire_dern_vm_get_allocator(self->vm));

            bool const result = octaspire_string_concatenate(
                self->value.symbol,
                tmpStr);

            octaspire_string_release(tmpStr);
            tmpStr = 0;

            return result;
        }
    }

    return false;
}

bool octaspire_dern_value_as_symbol_pop_back(
    octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);
    return octaspire_string_pop_back_ucs_character(self->value.symbol);
}

bool octaspire_dern_value_as_symbol_pop_front(
    octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);
    return octaspire_string_pop_front_ucs_character(self->value.symbol);
}

bool octaspire_dern_value_as_string_pop_back_ucs_character(
    octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);

    return octaspire_string_pop_back_ucs_character(self->value.string);
}

bool octaspire_dern_value_as_string_pop_front_ucs_character(
    octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);

    return octaspire_string_pop_front_ucs_character(self->value.string);
}

bool octaspire_dern_value_as_string_remove_all_substrings(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const value)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_string_remove_all_substrings(
                self->value.string,
                value->value.string);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            octaspire_string_remove_all_substrings(
                self->value.string,
                value->value.character);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            return false;
        }
    }

    return true;
}

bool octaspire_dern_value_as_string_is_index_valid(
    octaspire_dern_value_t const * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);

    return octaspire_string_is_index_valid(
        self->value.string,
        possiblyNegativeIndex);
}

char const *octaspire_dern_value_as_string_get_c_string(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);
    return octaspire_string_get_c_string(self->value.string);
}

size_t octaspire_dern_value_as_string_get_length_in_octets(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);
    return octaspire_string_get_length_in_octets(self->value.string);
}

char const *octaspire_dern_value_as_symbol_get_c_string(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);
    return octaspire_string_get_c_string(self->value.symbol);
}

bool octaspire_dern_value_is_symbol_and_equal_to_c_string(
    octaspire_dern_value_t const * const self,
    char const * const str)
{
    if (self->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        return false;
    }

    return octaspire_string_is_equal_to_c_string(self->value.symbol, str);
}

bool octaspire_dern_value_as_symbol_is_equal_to_c_string(
    octaspire_dern_value_t const * const self,
    char const * const str)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);
    return octaspire_string_is_equal_to_c_string(self->value.symbol, str);
}

bool octaspire_dern_value_as_text_is_equal_to_c_string(
    octaspire_dern_value_t const * const self,
    char const * const str)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            return octaspire_string_is_equal_to_c_string(self->value.character, str);
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            return octaspire_string_is_equal_to_c_string(self->value.string, str);
        }

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            return octaspire_string_is_equal_to_c_string(self->value.symbol, str);
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(false);
        }
        break;
    }

    return 0;
}

char const *octaspire_dern_value_as_text_get_c_string(
    octaspire_dern_value_t const * const self)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            return octaspire_string_get_c_string(self->value.character);
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            return octaspire_string_get_c_string(self->value.string);
        }

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            return octaspire_string_get_c_string(self->value.symbol);
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(false);
        }
        break;
    }

    return 0;
}

size_t octaspire_dern_value_as_text_get_length_in_octets(
    octaspire_dern_value_t const * const self)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            return octaspire_string_get_length_in_octets(
                self->value.character);
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            return octaspire_string_get_length_in_octets(
                self->value.string);
        }

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            return octaspire_string_get_length_in_octets(
                self->value.symbol);
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(false);
        }
        break;
    }

    return 0;
}

bool octaspire_dern_value_as_vector_is_index_valid(
    octaspire_dern_value_t const * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    return octaspire_vector_is_valid_index(
        self->value.vector,
        possiblyNegativeIndex);
}

size_t octaspire_dern_value_as_vector_get_length(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    return octaspire_vector_get_length(self->value.vector);
}

bool octaspire_dern_value_as_vector_is_valid_index(
    octaspire_dern_value_t const * const self,
    ptrdiff_t const index)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    return octaspire_vector_is_valid_index(self->value.vector, index);
}

bool octaspire_dern_value_as_vector_push_front_element(
    octaspire_dern_value_t *self,
    void const *element)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_not_null(element);

    return octaspire_vector_push_front_element(self->value.vector, element);
}

bool octaspire_dern_value_as_vector_push_back_element(
    octaspire_dern_value_t *self,
    void const *element)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_not_null(element);

    return octaspire_vector_push_back_element(self->value.vector, element);
}

bool octaspire_dern_value_as_vector_remove_element_at(
    octaspire_dern_value_t *self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    return octaspire_vector_remove_element_at(
        self->value.vector,
        possiblyNegativeIndex);
}

bool octaspire_dern_value_as_vector_pop_back_element(octaspire_dern_value_t *self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    return octaspire_vector_pop_back_element(self->value.vector);
}

bool octaspire_dern_value_as_vector_pop_front_element(octaspire_dern_value_t *self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    return octaspire_vector_pop_front_element(self->value.vector);
}

octaspire_dern_value_t *octaspire_dern_value_as_vector_get_element_at(
    octaspire_dern_value_t * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    return octaspire_vector_get_element_at(
        self->value.vector,
        possiblyNegativeIndex);
}

octaspire_dern_value_t const *octaspire_dern_value_as_vector_get_element_at_const(
    octaspire_dern_value_t const * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    return octaspire_vector_get_element_at_const(
        self->value.vector,
        possiblyNegativeIndex);
}

octaspire_dern_value_t *octaspire_dern_value_as_vector_get_element_of_type_at(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_tag_t const typeTag,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_dern_value_t * result =
        octaspire_dern_value_as_vector_get_element_at(
            self,
            possiblyNegativeIndex);

    octaspire_helpers_verify_not_null(result);

    if (result->typeTag == typeTag)
    {
        return result;
    }

    return 0;
}

octaspire_dern_value_t const *octaspire_dern_value_as_vector_get_element_of_type_at_const(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_tag_t const typeTag,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_dern_value_t const *result =
        octaspire_dern_value_as_vector_get_element_at_const(
            self,
            possiblyNegativeIndex);

    octaspire_helpers_verify_not_null(result);

    if (result->typeTag == typeTag)
    {
        return result;
    }

    return 0;
}

octaspire_dern_value_tag_t octaspire_dern_value_as_vector_get_element_type_at_const(
    octaspire_dern_value_t const * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_dern_value_t const *result =
        octaspire_dern_value_as_vector_get_element_at_const(
            self,
            possiblyNegativeIndex);

    if (!result)
    {
        return OCTASPIRE_DERN_VALUE_TAG_ILLEGAL;
    }

    return result->typeTag;
}

octaspire_dern_value_t *octaspire_dern_value_as_list_get_element_at(
    octaspire_dern_value_t * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST);

    octaspire_list_node_t * const node =
        octaspire_list_get_at(self->value.list, possiblyNegativeIndex);

    if (!node)
    {
        return 0;
    }

    return octaspire_list_node_get_element(node);
}

// TODO how about as_vector, should it have void* replaced with octaspire_dern_value_t*?
bool octaspire_dern_value_as_hash_map_put(
    octaspire_dern_value_t *self,
    uint32_t const hash,
    octaspire_dern_value_t const * const key,
    octaspire_dern_value_t *value)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);
    return octaspire_map_put(self->value.hashMap, hash, &key, &value);
}

size_t octaspire_dern_value_as_hash_map_get_number_of_elements(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);
    return octaspire_map_get_number_of_elements(self->value.hashMap);
}

octaspire_map_element_t *octaspire_dern_value_as_hash_map_get_at_index(
    octaspire_dern_value_t * const self,
    ptrdiff_t const possiblyNegativeIndex)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);

    return octaspire_map_get_at_index(
        self->value.hashMap,
        possiblyNegativeIndex);
}

octaspire_map_element_t *octaspire_dern_value_as_hash_map_get(
    octaspire_dern_value_t * const self,
    uint32_t const hash,
    octaspire_dern_value_t const * const key)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);
    return octaspire_map_get(self->value.hashMap, hash, &key);
}

octaspire_map_element_t const * octaspire_dern_value_as_hash_map_get_const(
    octaspire_dern_value_t const * const self,
    uint32_t const hash,
    octaspire_dern_value_t const * const key)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);
    return octaspire_map_get_const(self->value.hashMap, hash, &key);
}

octaspire_dern_value_t *octaspire_dern_value_as_hash_map_get_value_for_symbol_key_using_c_string(
    octaspire_dern_value_t * const self,
    char const * const keySymbolsContentAsCString)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);

    octaspire_dern_value_t * const key = octaspire_dern_vm_create_new_value_symbol_from_c_string(
        self->vm,
        keySymbolsContentAsCString);

    octaspire_helpers_verify_not_null(key);

    octaspire_map_element_t * const element = octaspire_dern_value_as_hash_map_get(
        self,
        octaspire_dern_value_get_hash(key),
        key);

    if (!element)
    {
        return 0;
    }

    return octaspire_map_element_get_value(element);
}

octaspire_dern_value_t const *
octaspire_dern_value_as_hash_map_get_value_for_symbol_key_using_c_string_const(
    octaspire_dern_value_t const * const self,
    char const * const keySymbolsContentAsCString)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self->vm);
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);

    octaspire_dern_value_t * const key =
        octaspire_dern_vm_create_new_value_symbol_from_c_string(
            self->vm,
            keySymbolsContentAsCString);

    octaspire_helpers_verify_not_null(key);

    octaspire_dern_vm_push_value(self->vm, key);

    octaspire_map_element_t const * const element =
        octaspire_dern_value_as_hash_map_get_const(
            self,
            octaspire_dern_value_get_hash(key),
            key);

    octaspire_dern_vm_pop_value(self->vm, key);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self->vm));

    if (!element)
    {
        return 0;
    }

    return octaspire_map_element_get_value(element);
}

size_t octaspire_dern_value_get_length(
    octaspire_dern_value_t const * const self)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            return 1;
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            return octaspire_string_get_length_in_ucs_characters(
                self->value.string);
        }
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            return octaspire_string_get_length_in_ucs_characters(
                self->value.symbol);
        }
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            return octaspire_string_get_length_in_ucs_characters(
                self->value.error->message);
        }
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            return octaspire_vector_get_length(self->value.vector);
        }
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            return octaspire_map_get_number_of_elements(
                self->value.hashMap);
        }
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            return octaspire_queue_get_length(self->value.queue);
        }
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            return octaspire_list_get_length(self->value.list);
        }
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        {
            return octaspire_dern_environment_get_length(self->value.environment);
        }
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        {
            return octaspire_dern_function_get_number_of_required_arguments(
                self->value.function);
        }
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        {
            return self->value.special->numRequiredActualArguments;
        }
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        {
            return self->value.builtin->numRequiredActualArguments;
        }
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        {
            return (size_t)octaspire_dern_port_get_length_in_octets(self->value.port);
        }
    }

    return 0;
}

bool octaspire_dern_value_mark(octaspire_dern_value_t *self)
{
    if (self->mark)
    {
        return true;
    }

    self->mark = true;

    if (self->docstr)
    {
        if (!octaspire_dern_value_mark(self->docstr))
        {
            return false;
        }
    }

    if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR)
    {
        for (size_t i = 0;
             i < octaspire_vector_get_length(self->value.vector);
             ++i)
        {
            octaspire_dern_value_t * const tmpVal =
                octaspire_vector_get_element_at(
                    self->value.vector,
                    (ptrdiff_t)i);

            octaspire_helpers_verify_not_null(tmpVal);

            if (!octaspire_dern_value_mark(tmpVal))
            {
                return false;
            }
        }
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP)
    {
        octaspire_map_element_iterator_t iter =
            octaspire_map_element_iterator_init(self->value.hashMap);

        while (iter.element)
        {
            if (!octaspire_dern_value_mark(
                    octaspire_map_element_get_key(iter.element)))
            {
                return false;
            }

            if (!octaspire_dern_value_mark(
                    octaspire_map_element_get_value(iter.element)))
            {
                return false;
            }

            octaspire_map_element_iterator_next(&iter);
        }
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE)
    {
        // TODO Add iterator into queue and use it here
        for (size_t i = 0; i < octaspire_queue_get_length(self->value.queue); ++i)
        {
            octaspire_dern_value_t * const tmpVal =
                octaspire_queue_get_at(
                    self->value.queue,
                    (ptrdiff_t)i);

            octaspire_helpers_verify_not_null(tmpVal);

            if (!octaspire_dern_value_mark(tmpVal))
            {
                return false;
            }
        }
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST)
    {
        // TODO More efficient iteration
        for (size_t i = 0;
             i < octaspire_list_get_length(self->value.list);
             ++i)
        {
            octaspire_dern_value_t * const tmpVal =
                octaspire_list_node_get_element(
                    octaspire_list_get_at(
                        self->value.list,
                        (ptrdiff_t)i));

            octaspire_helpers_verify_not_null(tmpVal);

            if (!octaspire_dern_value_mark(tmpVal))
            {
                return false;
            }
        }
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_FUNCTION)
    {
        bool status = true;

        if (!octaspire_dern_value_mark(self->value.function->formals))
        {
            status = false;
        }

        if (!octaspire_dern_value_mark(self->value.function->body))
        {
            status = false;
        }

        if (!octaspire_dern_value_mark(self->value.function->definitionEnvironment))
        {
            status = false;
        }

        return status;
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
    {
        return octaspire_dern_environment_mark(self->value.environment);
    }

    return true;
}

static int octaspire_dern_value_private_compare_void_pointers(
    void const * const a,
    void const * const b)
{
    ptrdiff_t const tmp = (ptrdiff_t)a - (ptrdiff_t)b;

    if (tmp < 0)
    {
        return -1;
    }

    if (tmp > 0)
    {
        return 1;
    }

    return 0;
}

int octaspire_dern_value_compare(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    if (self == other)
    {
        return 0;
    }

    if (octaspire_dern_value_is_number(self))
    {
        if (octaspire_dern_value_is_number(other))
        {
            if (octaspire_dern_value_is_real(self) ||
                octaspire_dern_value_is_real(other))
            {
                double const a = octaspire_dern_value_as_number_get_value(self);
                double const b = octaspire_dern_value_as_number_get_value(other);

                if (a < b)
                {
                    return -1;
                }

                if (a > b)
                {
                    return 1;
                }

                return 0;
            }
            else
            {
                return octaspire_dern_value_as_integer_get_value(self) -
                    octaspire_dern_value_as_integer_get_value(other);
            }
        }
    }

    if (self->typeTag != other->typeTag)
    {
        return (int)(self->typeTag) - (int)(other->typeTag);
    }

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        {
            return 0;
        }
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        {
            return self->value.boolean - other->value.boolean;
        }
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            return self->value.integer - other->value.integer;
        }
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            if (self->value.real < other->value.real)
            {
                return -1;
            }

            if (self->value.real > other->value.real)
            {
                return 1;
            }

            return 0;
        }
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            return octaspire_string_compare(
                self->value.string,
                other->value.string);
        }
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            return octaspire_string_compare(
                self->value.character,
                other->value.character);
        }
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            return octaspire_string_compare(
                self->value.symbol,
                other->value.symbol);
        }
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            return octaspire_dern_error_message_compare(
                self->value.error,
                other->value.error);
        }
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            if (octaspire_dern_value_as_vector_get_length(self) !=
                octaspire_dern_value_as_vector_get_length(other))
            {
                return octaspire_dern_value_as_vector_get_length(self) -
                    octaspire_dern_value_as_vector_get_length(other);
            }

            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(self); ++i)
            {
                octaspire_dern_value_t const * const valA =
                    octaspire_dern_value_as_vector_get_element_at_const(
                        self,
                        i);

                octaspire_dern_value_t const * const valB =
                    octaspire_dern_value_as_vector_get_element_at_const(
                        other,
                        i);

                octaspire_helpers_verify_not_null(valA);
                octaspire_helpers_verify_not_null(valB);

                int const cmp = octaspire_dern_value_compare(valA, valB);

                if (cmp)
                {
                    return cmp;
                }
            }

            return 0;
        }
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            return octaspire_dern_helpers_compare_value_hash_maps(
                self->value.hashMap,
                other->value.hashMap);
        }
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            if (octaspire_dern_value_as_queue_get_length(self) !=
                octaspire_dern_value_as_queue_get_length(other))
            {
                return octaspire_dern_value_as_queue_get_length(self) -
                    octaspire_dern_value_as_queue_get_length(other);
            }

            octaspire_queue_iterator_t myIter =
                octaspire_queue_iterator_init(self->value.queue);

            octaspire_queue_iterator_t otherIter =
                octaspire_queue_iterator_init(other->value.queue);

            while (myIter.iterator.currentNode)
            {
                octaspire_helpers_verify_not_null(otherIter.iterator.currentNode);

                octaspire_dern_value_t const * const myVal =
                    octaspire_list_node_get_element(
                        myIter.iterator.currentNode);

                octaspire_dern_value_t const * const otherVal =
                    octaspire_list_node_get_element(
                        otherIter.iterator.currentNode);

                octaspire_helpers_verify_not_null(myVal);
                octaspire_helpers_verify_not_null(otherVal);

                int const cmp = octaspire_dern_value_compare(myVal, otherVal);

                if (cmp)
                {
                    return cmp;
                }

                octaspire_queue_iterator_next(&myIter);
                octaspire_queue_iterator_next(&otherIter);
            }

            return 0;
        }
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            if (octaspire_dern_value_as_list_get_length(self) !=
                octaspire_dern_value_as_list_get_length(other))
            {
                return octaspire_dern_value_as_list_get_length(self) -
                    octaspire_dern_value_as_list_get_length(other);
            }

            octaspire_list_node_iterator_t myIter =
                octaspire_list_node_iterator_init(self->value.list);

            octaspire_list_node_iterator_t otherIter =
                octaspire_list_node_iterator_init(other->value.list);

            while (myIter.currentNode)
            {
                octaspire_helpers_verify_not_null(otherIter.currentNode);

                octaspire_dern_value_t const * const myVal =
                    octaspire_list_node_get_element(
                        myIter.currentNode);

                octaspire_dern_value_t const * const otherVal =
                    octaspire_list_node_get_element(
                        otherIter.currentNode);

                octaspire_helpers_verify_not_null(myVal);
                octaspire_helpers_verify_not_null(otherVal);

                int const cmp = octaspire_dern_value_compare(myVal, otherVal);

                if (cmp)
                {
                    return cmp;
                }

                octaspire_list_node_iterator_next(&myIter);
                octaspire_list_node_iterator_next(&otherIter);
            }

            return 0;
        }
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        {
            return octaspire_dern_environment_compare(
                    self->value.environment,
                    other->value.environment);
        }
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        {
            return octaspire_dern_function_compare(
                       self->value.function, other->value.function);
        }
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        {
            return octaspire_dern_value_private_compare_void_pointers(
                       self->value.special, other->value.special);
        }
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        {
            return octaspire_dern_value_private_compare_void_pointers(
                       self->value.builtin, other->value.builtin);
        }
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        {
            return octaspire_dern_value_private_compare_void_pointers(
                       self->value.port, other->value.port);
        }
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            return octaspire_dern_c_data_compare(self->value.cData, other->value.cData);
        }
    }

    return 0;
}

bool octaspire_dern_value_is_atom(octaspire_dern_value_t const * const self)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_PORT: // TODO XXX atom or not? Think about renaming this func.
        {
            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            return false;
        }
    }

    abort();
    return false;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_dern_value.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_dern_vm.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif



static void octaspire_dern_vm_private_release_value(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value);

static
octaspire_dern_value_t *octaspire_dern_vm_private_create_new_value_queue_from_queue(
    octaspire_dern_vm_t *self,
    octaspire_queue_t * const queue);

static octaspire_dern_value_t *octaspire_dern_vm_private_create_new_value_list_from_list(
    octaspire_dern_vm_t *self,
    octaspire_list_t * const list);


struct octaspire_dern_vm_t
{
    octaspire_vector_t        *stack;
    octaspire_allocator_t     *allocator;
    octaspire_stdio_t         *stdio;
    octaspire_vector_t        *all;
    octaspire_dern_value_t    *globalEnvironment;
    octaspire_dern_value_t    *valueNil;
    octaspire_dern_value_t    *valueTrue;
    octaspire_dern_value_t    *valueFalse;
    void                      *userData;
    octaspire_dern_value_t    *functionReturn;
    octaspire_map_t           *libraries;
    octaspire_vector_t        *commandLineArguments;
    octaspire_vector_t        *environmentVariables;
    size_t                     numAllocatedWithoutGc;
    size_t                     gcTriggerLimit;
    uintmax_t                  nextFreeUniqueIdForValues;
    int32_t                    exitCode;
    bool                       preventGc;
    bool                       quit;
    octaspire_dern_vm_config_t config;
};

octaspire_dern_value_t *octaspire_dern_vm_private_create_new_value_struct(
    octaspire_dern_vm_t* self,
    octaspire_dern_value_tag_t const typeTag);

bool octaspire_dern_vm_private_mark_all(octaspire_dern_vm_t *self);
bool octaspire_dern_vm_private_mark(octaspire_dern_vm_t *self, octaspire_dern_value_t *value);
bool octaspire_dern_vm_private_sweep(octaspire_dern_vm_t *self);

octaspire_dern_vm_config_t octaspire_dern_vm_config_default(void)
{
    octaspire_dern_vm_config_t result =
    {
        .preLoaderForRequireSrc  = 0,
        .debugModeOn             = false,
        .noDlClose               = false
    };

    return result;
}

octaspire_dern_vm_t *octaspire_dern_vm_new(
    octaspire_allocator_t *allocator,
    octaspire_stdio_t *octaspireStdio)
{
    return octaspire_dern_vm_new_with_config(
        allocator,
        octaspireStdio,
        octaspire_dern_vm_config_default());
}

octaspire_dern_vm_t *octaspire_dern_vm_new_with_config(
    octaspire_allocator_t *allocator,
    octaspire_stdio_t *octaspireStdio,
    octaspire_dern_vm_config_t const config)
{
    octaspire_dern_vm_t *self =
        octaspire_allocator_malloc(allocator, sizeof(octaspire_dern_vm_t));

    if (!self)
    {
        return 0;
    }

    self->allocator                 = allocator;
    self->stdio                     = octaspireStdio;
    self->numAllocatedWithoutGc     = 0;
    self->preventGc                 = false;
    self->gcTriggerLimit            = 1024;
    self->exitCode                  = 0;
    self->quit                      = false;
    self->userData                  = 0;
    self->nextFreeUniqueIdForValues = 0;
    self->functionReturn            = 0;
    self->config                    = config;

    self->libraries =
        octaspire_map_new_with_octaspire_string_keys(
            sizeof(octaspire_dern_lib_t*),
            true,
            (octaspire_map_element_callback_t)
                octaspire_dern_lib_release,
            self->allocator);

    octaspire_helpers_verify_not_null(self->libraries);

    self->commandLineArguments = octaspire_vector_new(
        sizeof(octaspire_string_t*),
        true,
        (octaspire_vector_element_callback_t)
            octaspire_string_release,
        self->allocator);

    octaspire_helpers_verify_not_null(self->commandLineArguments);

    self->environmentVariables = octaspire_vector_new(
        sizeof(octaspire_string_t*),
        true,
        (octaspire_vector_element_callback_t)
            octaspire_string_release,
        self->allocator);

    octaspire_helpers_verify_not_null(self->environmentVariables);

    self->stack = octaspire_vector_new_with_preallocated_elements(
        sizeof(octaspire_dern_value_t*),
        true,
        256,
        0,
        self->allocator);

    if (!self->stack)
    {
        octaspire_dern_vm_release(self);
        self = 0;
        return 0;
    }

    self->all = octaspire_vector_new(
        sizeof(octaspire_dern_value_t*),
        true,
        0,
        self->allocator);

    if (!self->all)
    {
        octaspire_dern_vm_release(self);
        self = 0;
        return 0;
    }

    octaspire_dern_environment_t *env =
        octaspire_dern_environment_new(0, self, self->allocator);

    if (!env)
    {
        octaspire_dern_vm_release(self);
        self = 0;
        return 0;
    }

    self->globalEnvironment =
        octaspire_dern_vm_create_new_value_environment_from_environment(self, env);

    if (!self->globalEnvironment)
    {
        octaspire_dern_vm_release(self);
        self = 0;
        return 0;
    }

    if (!octaspire_dern_vm_push_value(self, self->globalEnvironment))
    {
        abort();
    }

    self->valueNil = octaspire_dern_vm_create_new_value_nil(self);

    if (!octaspire_dern_vm_push_value(self, self->valueNil))
    {
        abort();
    }

    self->valueNil->docstr = octaspire_dern_vm_create_new_value_string_from_c_string(
        self,
        "Represents missing value.");

    if (!octaspire_dern_vm_push_value(self, self->valueNil->docstr))
    {
        abort();
    }

    if (!octaspire_dern_environment_set(
        env,
        octaspire_dern_vm_create_new_value_symbol(self, octaspire_string_new(
            "nil",
            self->allocator)),
        self->valueNil))
    {
        abort();
    }

    if (!octaspire_dern_vm_pop_value(self, self->valueNil->docstr))
    {
        abort();
    }

    if (!octaspire_dern_vm_pop_value(self, self->valueNil))
    {
        abort();
    }

    self->valueTrue = octaspire_dern_vm_create_new_value_boolean(self, true);

    if (!octaspire_dern_vm_push_value(self, self->valueTrue))
    {
        abort();
    }

    self->valueTrue->docstr = octaspire_dern_vm_create_new_value_string_from_c_string(
        self,
        "Boolean true value. Opposite of false.");

    if (!octaspire_dern_vm_push_value(self, self->valueTrue->docstr))
    {
        abort();
    }

    if (!octaspire_dern_environment_set(
        env,
        octaspire_dern_vm_create_new_value_symbol(self, octaspire_string_new(
            "true",
            self->allocator)),
        self->valueTrue))
    {
        abort();
    }

    if (!octaspire_dern_vm_pop_value(self, self->valueTrue->docstr))
    {
        abort();
    }

    if (!octaspire_dern_vm_pop_value(self, self->valueTrue))
    {
        abort();
    }

    self->valueFalse = octaspire_dern_vm_create_new_value_boolean(self, false);

    if (!octaspire_dern_vm_push_value(self, self->valueFalse))
    {
        abort();
    }

    self->valueFalse->docstr = octaspire_dern_vm_create_new_value_string_from_c_string(
        self,
        "Boolean false value. Opposite of true.");

    if (!octaspire_dern_vm_push_value(self, self->valueFalse->docstr))
    {
        abort();
    }

    if (!octaspire_dern_environment_set(
        env,
        octaspire_dern_vm_create_new_value_symbol(self, octaspire_string_new(
            "false",
            self->allocator)),
        self->valueFalse))
    {
        abort();
    }

    if (!octaspire_dern_vm_pop_value(self, self->valueFalse->docstr))
    {
        abort();
    }

    if (!octaspire_dern_vm_pop_value(self, self->valueFalse))
    {
        abort();
    }


    ////////////////////////////////// Builtins and specials /////////////////////////////////////

    //////////////////////////////////////// Builtins ////////////////////////////////////////////

    // host-get-command-line-arguments
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "host-get-command-line-arguments",
        octaspire_dern_vm_builtin_host_get_command_line_arguments,
        0,
        "Get vector containing the host command line arguments",
        false,
        env))
    {
        abort();
    }

    // host-get-environment-variables
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "host-get-environment-variables",
        octaspire_dern_vm_builtin_host_get_environment_variables,
        0,
        "Get vector containing the host environment variables",
        false,
        env))
    {
        abort();
    }

    // ln@
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "ln@",
        octaspire_dern_vm_builtin_ln_at_sign,
        2,
        "Get reference to a value in a given collection at the given index",
        true,
        env))
    {
        abort();
    }

    // cp@
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "cp@",
        octaspire_dern_vm_builtin_cp_at_sign,
        2,
        "Get copy of a value in a given collection at the given index",
        true,
        env))
    {
        abort();
    }

    // require
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "require",
        octaspire_dern_vm_builtin_require,
        1,
        "Ensure that plugin is loaded (if dern is compiled with plugin support)",
        false,
        env))
    {
        abort();
    }

    // input-file-open
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "input-file-open",
        octaspire_dern_vm_builtin_input_file_open,
        1,
        "Open file-port for reading only",
        false,
        env))
    {
        abort();
    }

    // output-file-open
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "output-file-open",
        octaspire_dern_vm_builtin_output_file_open,
        1,
        "Open file-port for writing only",
        false,
        env))
    {
        abort();
    }

    // io-file-open
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "io-file-open",
        octaspire_dern_vm_builtin_io_file_open,
        1,
        "Open file-port for input and output",
        false,
        env))
    {
        abort();
    }

    // port-supports-output?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-supports-output?",
        octaspire_dern_vm_builtin_port_supports_output_question_mark,
        1,
        "Predicate telling whether the given port supports writing or not",
        false,
        env))
    {
        abort();
    }

    // port-supports-input?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-supports-input?",
        octaspire_dern_vm_builtin_port_supports_input_question_mark,
        1,
        "Predicate telling whether the given port supports reading or not",
        false,
        env))
    {
        abort();
    }

    // port-close
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-close",
        octaspire_dern_vm_builtin_port_close,
        1,
        "Close a port",
        false,
        env))
    {
        abort();
    }

    // port-read
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-read",
        octaspire_dern_vm_builtin_port_read,
        1,
        "Read from a port one or a given number of octets",
        false,
        env))
    {
        abort();
    }

    // port-write
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-write",
        octaspire_dern_vm_builtin_port_write,
        1,
        "Write one integer or all integers from a vector to a port supporting writing",
        false,
        env))
    {
        abort();
    }

    // port-seek
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-seek",
        octaspire_dern_vm_builtin_port_seek,
        1,
        "Seek to a position from the beginning (positive integer) or "
        "from the end (negative integer) on ports supporting seeking",
        false,
        env))
    {
        abort();
    }

    // port-dist
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-dist",
        octaspire_dern_vm_builtin_port_dist,
        1,
        "Get distance from the beginning on ports that support it, or minus one",
        false,
        env))
    {
        abort();
    }

    // port-length
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-length",
        octaspire_dern_vm_builtin_port_length,
        1,
        "Get size of port in octets on ports that support this operation, or minus one",
        false,
        env))
    {
        abort();
    }

    // port-flush
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-flush",
        octaspire_dern_vm_builtin_port_flush,
        1,
        "Flush an output port that supports flushing",
        false,
        env))
    {
        abort();
    }

    // not
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "not",
        octaspire_dern_vm_builtin_not,
        1,
        "Reverse boolean value",
        true,
        env))
    {
        abort();
    }

    // abort
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "abort",
        octaspire_dern_vm_builtin_abort,
        1,
        "Quit execution with error message",
        false,
        env))
    {
        abort();
    }

    // return
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "return",
        octaspire_dern_vm_builtin_return,
        1,
        "Return from function early with the given value",
        false,
        env))
    {
        abort();
    }

    // vector
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "vector",
        octaspire_dern_vm_builtin_vector,
        1,
        "Create new vector of the given values.",
        true,
        env))
    {
        abort();
    }

    // and
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "and",
        octaspire_dern_vm_special_and,
        0,
        "Evaluate values until 'false' is found. Any remaining values are not evaluated. "
        "Return the last evaluated value. "
        "If there are no values, then 'true' is returned.",
        true,
        env))
    {
        abort();
    }

    // or
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "or",
        octaspire_dern_vm_special_or,
        0,
        "Evaluate values until 'true' is found. Any remaining values are not evaluated. "
        "Return the last evaluated value. "
        "If there are no values, then 'false' is returned.",
        true,
        env))
    {
        abort();
    }

    // do
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "do",
        octaspire_dern_vm_special_do,
        1,
        "Evaluate sequence of values and return the value of the last evaluation",
        false,
        env))
    {
        abort();
    }

    // starts-with?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "starts-with?",
        octaspire_dern_vm_builtin_starts_with_question_mark,
        1,
        "Does the first value start with the second?",
        true,
        env))
    {
        abort();
    }

    // =
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "=",
        octaspire_dern_vm_builtin_equals,
        1,
        "Set atomic values, or elements of collections (vector, map, string) at the given "
        "index/key",
        false,
        env))
    {
        abort();
    }



    // string-format
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "string-format",
        octaspire_dern_vm_builtin_string_format,
        1,
        "Create new string and allow formatting of value into it using {}",
        true,
        env))
    {
        abort();
    }

    // to-string
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "to-string",
        octaspire_dern_vm_builtin_to_string,
        1,
        "Give value or values as string(s)",
        true,
        env))
    {
        abort();
    }

    // to-integer
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "to-integer",
        octaspire_dern_vm_builtin_to_integer,
        1,
        "Give value or values as integer(s)",
        true,
        env))
    {
        abort();
    }

    // print
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "print",
        octaspire_dern_vm_builtin_print,
        0,
        "Print message for the user",
        false,
        env))
    {
        abort();
    }

    // println
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "println",
        octaspire_dern_vm_builtin_println,
        0,
        "Print message for the user and newline",
        false,
        env))
    {
        abort();
    }

    // env-new
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "env-new",
        octaspire_dern_vm_builtin_env_new,
        0,
        "Create new empty environment",
        false,
        env))
    {
        abort();
    }

    // env-current
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "env-current",
        octaspire_dern_vm_builtin_env_current,
        0,
        "Get the current environment used by the context where this is evaluated",
        false,
        env))
    {
        abort();
    }

    // env-global
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "env-global",
        octaspire_dern_vm_builtin_env_global,
        0,
        "Get the global environment",
        false,
        env))
    {
        abort();
    }

    // -=
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "-=",
        octaspire_dern_vm_builtin_minus_equals,
        1,
        "Subtract value or values from the first argument (modify it)",
        false,
        env))
    {
        abort();
    }

    // -==
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "-==",
        octaspire_dern_vm_builtin_minus_equals_equals,
        1,
        "Remove from supported collection a value that has the same unique id "
        "than the given value. Note that equal values are probably not the same",
        false,
        env))
    {
        abort();
    }

    // pop-back
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "pop-back",
        octaspire_dern_vm_builtin_pop_back,
        1,
        "Remove the last value from supported collection.",
        false,
        env))
    {
        abort();
    }

    // pop-front
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "pop-front",
        octaspire_dern_vm_builtin_pop_front,
        1,
        "Remove the first value from supported collection.",
        false,
        env))
    {
        abort();
    }

    // +=
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "+=",
        octaspire_dern_vm_builtin_plus_equals,
        1,
        "Add value or values into the first argument (modify it)",
        false,
        env))
    {
        abort();
    }

    // ++
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "++",
        octaspire_dern_vm_builtin_plus_plus,
        1,
        "Increase a value or values by one",
        false,
        env))
    {
        abort();
    }

    // --
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "--",
        octaspire_dern_vm_builtin_minus_minus,
        1,
        "Decrease a value or values by one",
        false,
        env))
    {
        abort();
    }

    // mod
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "mod",
        octaspire_dern_vm_builtin_mod,
        1,
        "Calculate modulo of two integers",
        true,
        env))
    {
        abort();
    }

    // /
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "/",
        octaspire_dern_vm_builtin_slash,
        1,
        "Divide number arguments",
        true,
        env))
    {
        abort();
    }

    // *
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "*",
        octaspire_dern_vm_builtin_times,
        1,
        "Multiply number arguments",
        true,
        env))
    {
        abort();
    }

    // +
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "+",
        octaspire_dern_vm_builtin_plus,
        1,
        "Add arguments to create new value",
        true,
        env))
    {
        abort();
    }

    // -
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "-",
        octaspire_dern_vm_builtin_minus,
        1,
        "Subtract number arguments, or negate one argument",
        true,
        env))
    {
        abort();
    }

    // find
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "find",
        octaspire_dern_vm_builtin_find,
        2,
        "Find value from collection",
        true,
        env))
    {
        abort();
    }

    // split
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "split",
        octaspire_dern_vm_builtin_split,
        2,
        "Split a collection by value",
        true,
        env))
    {
        abort();
    }


    // hash-map
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "hash-map",
        octaspire_dern_vm_builtin_hash_map,
        0,
        "Create new hash map",
        true,
        env))
     {
        abort();
     }

    // queue
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "queue",
        octaspire_dern_vm_builtin_queue,
        0,
        "Create new queue",
        true,
        env))
    {
        abort();
    }

    // queue-with-max-length
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "queue-with-max-length",
        octaspire_dern_vm_builtin_queue_with_max_length,
        0,
        "Create new queue with maximum length",
        true,
        env))
    {
        abort();
    }

    // list
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "list",
        octaspire_dern_vm_builtin_list,
        0,
        "Create new list",
        true,
        env))
    {
        abort();
    }

    // exit
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "exit",
        octaspire_dern_vm_builtin_exit,
        0,
        "Quit and exit the vm execution or REPL",
        false,
        env))
    {
        abort();
    }

    // doc
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "doc",
        octaspire_dern_vm_builtin_doc,
        1,
        "Get documentation string of a value or values",
        true,
        env))
    {
        abort();
    }

    // len
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "len",
        octaspire_dern_vm_builtin_len,
        1,
        "Get length of a value or values",
        true,
        env))
    {
        abort();
    }

    // read-and-eval-path
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "read-and-eval-path",
        octaspire_dern_vm_builtin_read_and_eval_path,
        1,
        "Read and evaluate a file from the given path",
        false,
        env))
    {
        abort();
    }

    // read-and-eval-string
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "read-and-eval-string",
        octaspire_dern_vm_builtin_read_and_eval_string,
        1,
        "Read and evaluate the given string",
        true,
        env))
    {
        abort();
    }

    // copy
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "copy",
        octaspire_dern_vm_builtin_copy,
        1,
        "Create full or partial copy of a value",
        true,
        env))
    {
        abort();
    }



    //////////////////////////////////////// Specials ////////////////////////////////////////////


    // define
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "define",
        octaspire_dern_vm_special_define,
        3,
        "Bind value to name and document the binding",
        false,
        env))
    {
        abort();
    }

    // eval
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "eval",
        octaspire_dern_vm_special_eval,
        1,
        "Evaluate a value (first argument) in global environment or, if given, in then "
        "given environment",
        true,
        env))
    {
        abort();
    }

    // quote
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "quote",
        octaspire_dern_vm_special_quote,
        1,
        "Quote a value",
        true,
        env))
    {
        abort();
    }

    // select
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "select",
        octaspire_dern_vm_special_select,
        1,
        "Select one of values, default, or no value and evaluate it according to boolean test",
        true,
        env))
    {
        abort();
    }

    // if
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "if",
        octaspire_dern_vm_special_if,
        1,
        "Select value or no value and evaluate it according to boolean test",
        true,
        env))
    {
        abort();
    }

    // while
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "while",
        octaspire_dern_vm_special_while,
        2,
        "Evaluate values repeatedly as long as predicate is true",
        true,
        env))
    {
        abort();
    }

    // for
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "for",
        octaspire_dern_vm_special_for,
        3, // or 5
        "Evaluate values repeatedly over a numeric range or container",
        true,
        env))
    {
        abort();
    }

    // ==
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "==",
        octaspire_dern_vm_special_equals_equals,
        1,
        "Predicate telling whether all the given values are equal. "
        "Takes 2..n arguments. Evaluates arguments only as long as those are equal. "
        "Does not evaluate rest of the arguments if one is not equal",
        true,
        env))
    {
        abort();
    }

    // ===
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "===",
        octaspire_dern_vm_special_equals_equals_equals,
        2,
        "Predicate telling whether all the given values are the same. "
        "Two values that are equal might not be the same value. "
        "Takes 2..n arguments. Evaluates arguments only as long as those are the same. "
        "Does not evaluate rest of the arguments if one is not the same",
        true,
        env))
    {
        abort();
    }

    // !=
    if (!octaspire_dern_vm_create_and_register_new_special( self,
        "!=",
        octaspire_dern_vm_special_exclamation_equals,
        1,
        "Predicate telling whether all the given values are not equal. "
        "Takes 2..n arguments. Evaluates arguments only as long as unequal is not found. "
        "Does not evaluate rest of the arguments if one is unequal",
        true,
        env))
    {
        abort();
    }

    // <
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "<",
        octaspire_dern_vm_special_less_than,
        1,
        "Predicate telling whether the arguments are less than the previous argument. "
        "Takes 2..n arguments. Evaluates arguments only as long as those are less than the "
        "previous. Does not evaluate rest of the arguments if one is larger or equal",
        true,
        env))
    {
        abort();
    }

    // >
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        ">",
        octaspire_dern_vm_special_greater_than,
        1,
        "Predicate telling whether the arguments are greater than the previous argument. "
        "Takes 2..n arguments. Evaluates arguments only as long as those are greater than the "
        "previous. Does not evaluate rest of the arguments if one is smaller or equal",
        true,
        env))
    {
        abort();
    }

    // <=
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "<=",
        octaspire_dern_vm_special_less_than_or_equal,
        1,
        "Predicate telling whether the arguments are equal or less than the previous argument. "
        "Takes 2..n arguments. Evaluates arguments only as long as those are equal or less than "
        "the previous. Does not evaluate rest of the arguments if one is larger",
        true,
        env))
    {
        abort();
    }

    // >=
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        ">=",
        octaspire_dern_vm_special_greater_than_or_equal,
        1,
        "Predicate telling whether the arguments are equal or greater than the previous argument. "
        "Takes 2..n arguments. Evaluates arguments only as long as those are equal or greater than "
        "the previous. Does not evaluate rest of the arguments if one is smaller",
        true,
        env))
    {
        abort();
    }

    // fn
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "fn",
        octaspire_dern_vm_special_fn,
        2,
        "Create new anonymous function",
        true,
        env))
    {
        abort();
    }

    // uid
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "uid",
        octaspire_dern_vm_builtin_uid,
        2,
        "Get unique id of a value",
        false,
        env))
    {
        abort();
    }

    // integer?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "integer?",
        octaspire_dern_vm_builtin_integer_question_mark,
        1,
        "Predicate telling whether the argument is an integer",
        true,
        env))
    {
        abort();
    }

    // real?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "real?",
        octaspire_dern_vm_builtin_real_question_mark,
        1,
        "Predicate telling whether the argument is a real",
        true,
        env))
    {
        abort();
    }

    // number?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "number?",
        octaspire_dern_vm_builtin_number_question_mark,
        1,
        "Predicate telling whether the argument is a number (integer or real)",
        true,
        env))
    {
        abort();
    }

    // nil?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "nil?",
        octaspire_dern_vm_builtin_nil_question_mark,
        1,
        "Predicate telling whether the argument is nil",
        true,
        env))
    {
        abort();
    }

    // boolean?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "boolean?",
        octaspire_dern_vm_builtin_boolean_question_mark,
        1,
        "Predicate telling whether the argument is a boolean",
        true,
        env))
    {
        abort();
    }

    // character?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "character?",
        octaspire_dern_vm_builtin_character_question_mark,
        1,
        "Predicate telling whether the argument is a character",
        true,
        env))
    {
        abort();
    }

    // string?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "string?",
        octaspire_dern_vm_builtin_string_question_mark,
        1,
        "Predicate telling whether the argument is a string",
        true,
        env))
    {
        abort();
    }

    // symbol?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "symbol?",
        octaspire_dern_vm_builtin_symbol_question_mark,
        1,
        "Predicate telling whether the argument is a symbol",
        true,
        env))
    {
        abort();
    }

    // vector?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "vector?",
        octaspire_dern_vm_builtin_vector_question_mark,
        1,
        "Predicate telling whether the argument is a vector",
        true,
        env))
    {
        abort();
    }

    // hash-map?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "hash-map?",
        octaspire_dern_vm_builtin_hash_map_question_mark,
        1,
        "Predicate telling whether the argument is a hash map",
        true,
        env))
    {
        abort();
    }

    // TODO move to specials
    // howto
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "howto",
        octaspire_dern_vm_special_howto,
        1,
        "Suggest functions by giving arguments and expected result",
        true,
        env))
    {
        abort();
    }

    return self;
}

void octaspire_dern_vm_release(octaspire_dern_vm_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_map_release(self->libraries);
    self->libraries = 0;

    octaspire_vector_release(self->commandLineArguments);
    self->commandLineArguments = 0;

    octaspire_vector_release(self->environmentVariables);
    self->environmentVariables = 0;

    // At this point stack had nil and self->globalEnvironment was tried to remove
    //octaspire_dern_vm_pop_value(self, self->globalEnvironment);

    octaspire_vector_clear(self->stack);
    octaspire_dern_vm_gc(self);

    octaspire_vector_release(self->stack);

    octaspire_vector_release(self->all);

    octaspire_allocator_free(self->allocator, self);
}

bool octaspire_dern_vm_push_value(octaspire_dern_vm_t *self, octaspire_dern_value_t *value)
{
    return octaspire_vector_push_back_element(self->stack, &value);
}

bool octaspire_dern_vm_pop_value(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *valueForBalanceCheck)
{
    if (octaspire_vector_peek_back_element(self->stack) != valueForBalanceCheck)
    {
        printf(
            "\n\n ----- STACK UNBALANCED! -----\n (real top)%p != (user says is top)%p\n\n",
            (void*)octaspire_vector_peek_back_element(self->stack),
            (void*)valueForBalanceCheck);

        printf("REAL TOP IS:\n");

        octaspire_dern_value_print(
            octaspire_vector_peek_back_element(self->stack), self->allocator);

        printf("USER SAYS THIS IS TOP:\n");
        octaspire_dern_value_print(valueForBalanceCheck, self->allocator);
    }

    if (octaspire_vector_peek_back_element(self->stack) != valueForBalanceCheck)
    {
        abort();
    }

    return octaspire_vector_pop_back_element(self->stack);
}

void const * octaspire_dern_vm_get_top_value(octaspire_dern_vm_t const * const self)
{
    return octaspire_vector_peek_back_element(self->stack);
}

octaspire_dern_value_t *octaspire_dern_vm_peek_value(octaspire_dern_vm_t *self)
{
    return octaspire_vector_peek_back_element(self->stack);
}

octaspire_dern_value_t *octaspire_dern_vm_private_create_new_value_struct(
    octaspire_dern_vm_t* self,
    octaspire_dern_value_tag_t const typeTag)
{
    if (self->numAllocatedWithoutGc >= self->gcTriggerLimit && !self->preventGc)
    {
        octaspire_dern_vm_gc(self);
        self->numAllocatedWithoutGc = 0;
    }
    else
    {
        ++(self->numAllocatedWithoutGc);
    }

    octaspire_dern_value_t *result =
        octaspire_allocator_malloc(self->allocator, sizeof(octaspire_dern_value_t));

    if (!result)
    {
        octaspire_helpers_verify_not_null(false);
        return 0;
    }

    octaspire_vector_push_back_element(self->all, &result);

    result->typeTag      = typeTag;
    result->mark         = false;
    result->docstr       = 0;
    result->vm           = self;
    result->uniqueId     = self->nextFreeUniqueIdForValues;
    result->howtoAllowed = false;

    if (self->nextFreeUniqueIdForValues == UINTMAX_MAX)
    {
        abort();
    }

    ++(self->nextFreeUniqueIdForValues);

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_copy(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *valueToBeCopied)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        valueToBeCopied->typeTag);

    octaspire_dern_vm_push_value(self, result);

    switch (result->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        {
            // NOP
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        {
            result->value.boolean = valueToBeCopied->value.boolean;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            result->value.integer = valueToBeCopied->value.integer;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            result->value.real = valueToBeCopied->value.real;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            result->value.string = octaspire_string_new_copy(
                valueToBeCopied->value.string,
                self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            result->value.character = octaspire_string_new_copy(
                valueToBeCopied->value.character,
                self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            result->value.symbol = octaspire_string_new_copy(
                valueToBeCopied->value.symbol,
                self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            result->value.error = octaspire_dern_error_message_new_copy(
                valueToBeCopied->value.error,
                self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            result->value.vector = octaspire_vector_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                self->allocator);

            for (size_t i = 0;
                 i < octaspire_vector_get_length(valueToBeCopied->value.vector); ++i)
            {
                octaspire_dern_value_t * const tmpValToCopy =
                    octaspire_vector_get_element_at(
                        valueToBeCopied->value.vector,
                        (ptrdiff_t)i);

                assert(tmpValToCopy);

                octaspire_dern_value_t * const tmpValCopied =
                    octaspire_dern_vm_create_new_value_copy(self, tmpValToCopy);

                if (!octaspire_vector_push_back_element(
                    result->value.vector,
                    &tmpValCopied))
                {
                    abort();
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            result->value.queue = octaspire_queue_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                self->allocator);

            for (size_t i = 0;
                 i < octaspire_queue_get_length(valueToBeCopied->value.queue);
                 ++i)
            {
                octaspire_dern_value_t * const tmpValToCopy =
                    octaspire_queue_get_at(
                        valueToBeCopied->value.queue,
                        (ptrdiff_t)i);

                assert(tmpValToCopy);

                octaspire_dern_value_t * const tmpValCopied =
                    octaspire_dern_vm_create_new_value_copy(self, tmpValToCopy);

                if (!octaspire_queue_push(
                    result->value.queue,
                    &tmpValCopied))
                {
                    abort();
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            result->value.list = octaspire_list_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                self->allocator);

            // TODO more efficient iteration
            for (size_t i = 0;
                 i < octaspire_list_get_length(valueToBeCopied->value.list);
                 ++i)
            {
                octaspire_dern_value_t * const tmpValToCopy =
                    octaspire_list_node_get_element(
                        octaspire_list_get_at(
                            valueToBeCopied->value.list,
                            (ptrdiff_t)i));

                assert(tmpValToCopy);

                octaspire_dern_value_t * const tmpValCopied =
                    octaspire_dern_vm_create_new_value_copy(self, tmpValToCopy);

                if (!octaspire_list_push_back(
                    result->value.list,
                    &tmpValCopied))
                {
                    abort();
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            result->value.hashMap = octaspire_map_new(
                sizeof(octaspire_dern_value_t*),
                true,
                sizeof(octaspire_dern_value_t*),
                true,
                (octaspire_map_key_compare_function_t)
                    octaspire_dern_value_is_equal,
                (octaspire_map_key_hash_function_t)
                    octaspire_dern_value_get_hash,
                0,
                0,
                self->allocator);

            octaspire_map_element_iterator_t iter =
                octaspire_map_element_iterator_init(
                    valueToBeCopied->value.hashMap);
            do
            {
                if (iter.element)
                {
                    octaspire_dern_value_t * const keyToCopy =
                        octaspire_map_element_get_key(iter.element);

                    octaspire_dern_value_t * const valToCopy =
                        octaspire_map_element_get_value(iter.element);

                    octaspire_helpers_verify_not_null(keyToCopy);
                    octaspire_helpers_verify_not_null(valToCopy);



                    octaspire_dern_value_t * const copyOfKeyVal =
                        octaspire_dern_vm_create_new_value_copy(self, keyToCopy);

                    octaspire_helpers_verify_not_null(copyOfKeyVal);

                    octaspire_dern_vm_push_value(self, copyOfKeyVal);



                    octaspire_dern_value_t * const copyOfValVal =
                        octaspire_dern_vm_create_new_value_copy(self, valToCopy);

                    octaspire_helpers_verify_not_null(copyOfValVal);

                    octaspire_dern_vm_push_value(self, copyOfValVal);



                    if (!octaspire_map_put(
                            result->value.hashMap,
                            octaspire_dern_value_get_hash(copyOfKeyVal),
                            &copyOfKeyVal,
                            &copyOfValVal))
                    {
                        abort();
                    }

                    octaspire_dern_vm_pop_value(self, copyOfValVal);
                    octaspire_dern_vm_pop_value(self, copyOfKeyVal);
                }
            }
            while (octaspire_map_element_iterator_next(&iter));
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        {
            result->value.environment = octaspire_dern_environment_new_copy(
                valueToBeCopied->value.environment,
                self,
                self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        {
            result->value.function = octaspire_dern_function_new_copy(
                valueToBeCopied->value.function,
                self,
                self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        {
            result->value.special = octaspire_dern_special_new_copy(
                valueToBeCopied->value.special,
                self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        {
            result->value.builtin = octaspire_dern_builtin_new_copy(
                valueToBeCopied->value.builtin,
                self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        {
            result->value.port =
                octaspire_dern_port_new_copy(valueToBeCopied->value.port, self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            if (!octaspire_dern_c_data_is_copying_allowed(valueToBeCopied->value.cData))
            {
                octaspire_dern_vm_pop_value(self, result);

                octaspire_string_t *str =
                    octaspire_dern_c_data_to_string(valueToBeCopied->value.cData, self->allocator);

                octaspire_helpers_verify_not_null(str);

                octaspire_dern_value_t * const errorVal =
                    octaspire_dern_vm_create_new_value_error_format(
                        self,
                        "C data '%s' cannot be copied.",
                        octaspire_string_get_c_string(str));

                octaspire_helpers_verify_not_null(errorVal);

                octaspire_string_release(str);
                str = 0;

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(self));

                return errorVal;
            }

            result->value.cData =
                octaspire_dern_c_data_new_copy(valueToBeCopied->value.cData, self->allocator);
        }
        break;
    }

    if (valueToBeCopied->docstr)
    {
        result->docstr = octaspire_dern_vm_create_new_value_copy(self, valueToBeCopied->docstr);
    }

    if (valueToBeCopied->docvec)
    {
        result->docvec = octaspire_dern_vm_create_new_value_copy(self, valueToBeCopied->docvec);
    }

    octaspire_dern_vm_pop_value(self, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_input_file(
    octaspire_dern_vm_t *self,
    char const * const path)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_PORT);

    result->value.port = octaspire_dern_port_new_input_file(path, self->allocator);
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_output_file(
    octaspire_dern_vm_t *self,
    char const * const path)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_PORT);

    result->value.port = octaspire_dern_port_new_output_file(path, self->allocator);
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_io_file(
    octaspire_dern_vm_t *self,
    char const * const path)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_PORT);

    result->value.port = octaspire_dern_port_new_io_file(path, self->allocator);
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_nil(octaspire_dern_vm_t *self)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_NIL);

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_boolean(
    octaspire_dern_vm_t *self,
    bool const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_BOOLEAN);

    result->value.boolean = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_integer(
    octaspire_dern_vm_t *self,
    int32_t const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_INTEGER);

    result->value.integer = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_real(
    octaspire_dern_vm_t *self,
    double const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_REAL);

    result->value.real = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_string(
    octaspire_dern_vm_t *self,
    octaspire_string_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_STRING);

    result->value.string = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_string_format(
    octaspire_dern_vm_t *self,
    char const * const fmt,
    ...)
{
    va_list arguments;
    va_start(arguments, fmt);

    octaspire_string_t *str = octaspire_string_new_vformat(
        self->allocator,
        fmt,
        arguments);

    va_end(arguments);

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_string(self, str);

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_string_from_c_string(
    octaspire_dern_vm_t *self,
    char const * const value)
{
    return octaspire_dern_vm_create_new_value_string(
        self,
        octaspire_string_new(value, self->allocator));
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_character(
    octaspire_dern_vm_t *self,
    octaspire_string_t * const value)
{
    octaspire_dern_value_t *result =
        octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_CHARACTER);

    result->value.character = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_character_from_uint32t(
    octaspire_dern_vm_t *self,
    uint32_t const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_CHARACTER);

    result->value.character = octaspire_string_new("", self->allocator);
    octaspire_string_push_back_ucs_character(result->value.character, value);
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_symbol(
    octaspire_dern_vm_t *self,
    octaspire_string_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

    result->value.symbol = value;
    return result;
}

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_symbol_from_c_string(
    octaspire_dern_vm_t *self,
    char const * const value)
{
    return octaspire_dern_vm_create_new_value_symbol(
        self,
        octaspire_string_new(value, self->allocator));
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_error(
    octaspire_dern_vm_t *self,
    octaspire_string_t * value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_ERROR);

    octaspire_dern_error_message_t * const message =
        octaspire_dern_error_message_new(
            octaspire_dern_vm_get_allocator(self),
            octaspire_string_get_c_string(value),
            0);

    result->value.error = message;

    octaspire_string_release(value);
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_error_format(
    octaspire_dern_vm_t *self,
    char const * const fmt,
    ...)
{
    va_list arguments;
    va_start(arguments, fmt);

    octaspire_string_t *str = octaspire_string_new_vformat(
        self->allocator,
        fmt,
        arguments);

    va_end(arguments);

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error(self, str);

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_error_from_c_string(
    octaspire_dern_vm_t *self,
    char const * const value)
{
    return octaspire_dern_vm_create_new_value_error(
        self,
        octaspire_string_new(value, self->allocator));
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_vector_from_vector(
    octaspire_dern_vm_t *self,
    octaspire_vector_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    result->value.vector = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_vector_from_values(
    octaspire_dern_vm_t *self,
    size_t const numArgs,
    ...)
{
    // TODO preallocate numArgs elements?
    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_vector(self);

    va_list arguments;
    va_start(arguments, numArgs);

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *value = va_arg(arguments, octaspire_dern_value_t*);
        octaspire_dern_value_as_vector_push_back_element(result, &value);
    }

    va_end(arguments);

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_vector(octaspire_dern_vm_t *self)
{
    octaspire_vector_t *vec = octaspire_vector_new(
        sizeof(octaspire_dern_value_t*),
        true,
        0,
        self->allocator);

    return octaspire_dern_vm_create_new_value_vector_from_vector(self, vec);
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_hash_map_from_hash_map(
    octaspire_dern_vm_t *self,
    octaspire_map_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);

    result->value.hashMap = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_private_create_new_value_queue_from_queue(
    octaspire_dern_vm_t *self,
    octaspire_queue_t * const queue)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_QUEUE);

    result->value.queue = queue;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_private_create_new_value_list_from_list(
    octaspire_dern_vm_t *self,
    octaspire_list_t * const list)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_LIST);

    result->value.list = list;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_hash_map(octaspire_dern_vm_t *self)
{
    octaspire_map_t *hashMap = octaspire_map_new(
        sizeof(octaspire_dern_value_t*),
        true,
        sizeof(octaspire_dern_value_t*),
        true,
        (octaspire_map_key_compare_function_t)octaspire_dern_value_is_equal,
        (octaspire_map_key_hash_function_t)octaspire_dern_value_get_hash,
        0,
        0,
        self->allocator);

    return octaspire_dern_vm_create_new_value_hash_map_from_hash_map(self, hashMap);
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_queue(octaspire_dern_vm_t *self)
{
    octaspire_queue_t *queue = octaspire_queue_new(
        sizeof(octaspire_dern_value_t*),
        true,
        0,
        self->allocator);

    return octaspire_dern_vm_private_create_new_value_queue_from_queue(self, queue);
}

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_queue_with_max_length (
        octaspire_dern_vm_t * const self,
        size_t const maxLength)
{
    octaspire_queue_t * const queue = octaspire_queue_new_with_max_length(
        maxLength,
        sizeof(octaspire_dern_value_t*),
        true,
        0,
        self->allocator);

    return octaspire_dern_vm_private_create_new_value_queue_from_queue(self, queue);
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_list(octaspire_dern_vm_t *self)
{
    octaspire_list_t *list = octaspire_list_new(
        sizeof(octaspire_dern_value_t*),
        true,
        0,
        self->allocator);

    return octaspire_dern_vm_private_create_new_value_list_from_list(self, list);
}

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_environment(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *enclosing)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    result->value.environment =
        octaspire_dern_environment_new(enclosing, self, self->allocator);

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_environment_from_environment(
    octaspire_dern_vm_t *self,
    octaspire_dern_environment_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    result->value.environment = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_function(
    octaspire_dern_vm_t *self,
    octaspire_dern_function_t * const value,
    char const * const docstr,
    octaspire_vector_t *docVec)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t *result =
        octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_FUNCTION);

    octaspire_dern_vm_push_value(self, result);

    result->value.function = value;

    result->docstr = octaspire_dern_vm_create_new_value_string_from_c_string(self, docstr);

    result->docvec =
        docVec ? octaspire_dern_vm_create_new_value_vector_from_vector(self, docVec) : 0;

    octaspire_dern_vm_pop_value(self, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_special(
    octaspire_dern_vm_t *self,
    octaspire_dern_special_t * const value,
    char const * const docstr)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_SPECIAL);

    result->value.special = value;
    result->howtoAllowed = octaspire_dern_special_is_howto_allowed(value);

    octaspire_dern_vm_push_value(self, result);

    result->docstr = octaspire_dern_vm_create_new_value_string_from_c_string(self, docstr);

    octaspire_dern_vm_pop_value(self, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_builtin(
    octaspire_dern_vm_t *self,
    octaspire_dern_builtin_t * const value,
    char const * const docstr)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_BUILTIN);

    result->value.builtin = value;
    result->howtoAllowed = octaspire_dern_builtin_is_howto_allowed(value);

    octaspire_dern_vm_push_value(self, result);

    result->docstr = octaspire_dern_vm_create_new_value_string_from_c_string(self, docstr);

    octaspire_dern_vm_pop_value(self, result);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_c_data(
    octaspire_dern_vm_t * const self,
    char const * const pluginName,
    char const * const typeNameForPayload,
    char const * const cleanUpCallbackName,
    char const * const stdLibLenCallbackName,
    char const * const stdLibLinkAtCallbackName,
    char const * const stdLibCopyAtCallbackName,
    bool const copyingAllowed,
    void * const payload)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t * const result =
        octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_C_DATA);

    result->value.cData = octaspire_dern_c_data_new(
        pluginName,
        typeNameForPayload,
        payload,
        cleanUpCallbackName,
        stdLibLenCallbackName,
        stdLibLinkAtCallbackName,
        stdLibCopyAtCallbackName,
        copyingAllowed,
        self->allocator);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_c_data_from_existing(
    octaspire_dern_vm_t * const self,
    octaspire_dern_c_data_t * const cData)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t * const result =
        octaspire_dern_vm_private_create_new_value_struct(
            self,
            OCTASPIRE_DERN_VALUE_TAG_C_DATA);

    result->value.cData = cData;

    octaspire_helpers_verify_true(
        stackLength == octaspire_dern_vm_get_stack_length(self));

    return result;
}

void octaspire_dern_vm_clear_value_to_nil(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(self);

    if (!value)
    {
        return;
    }

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:         break;
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:     break;
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:     break;
        case OCTASPIRE_DERN_VALUE_TAG_REAL:        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_string_release(value->value.string);
            value->value.string = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            octaspire_string_release(value->value.character);
            value->value.character = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            octaspire_string_release(value->value.symbol);
            value->value.symbol = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            octaspire_dern_error_message_release(value->value.error);
            value->value.error = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            // Elements are NOT released here, because it would lead to double free.
            // GC releases the elements (those are stored in the all-vector also).
            octaspire_vector_clear(value->value.vector);
            octaspire_vector_release(value->value.vector);
            value->value.vector = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            // Elements are NOT released here, because it would lead to double free.
            // GC releases the elements (those are stored in the all-vector also).
            octaspire_map_clear(value->value.hashMap);
            octaspire_map_release(value->value.hashMap);
            value->value.hashMap = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            // Elements are NOT released here, because it would lead to double free.
            // GC releases the elements (those are stored in the all-vector also).
            octaspire_queue_clear(value->value.queue);
            octaspire_queue_release(value->value.queue);
            value->value.queue = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            // Elements are NOT released here, because it would lead to double free.
            // GC releases the elements (those are stored in the all-vector also).
            octaspire_list_clear(value->value.list);
            octaspire_list_release(value->value.list);
            value->value.list = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        {
            octaspire_dern_environment_release(value->value.environment);
            value->value.environment = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        {
            octaspire_dern_function_release(value->value.function);
            value->value.function = 0;

            //octaspire_dern_vm_private_release_value(self, fun->formals);
            //octaspire_dern_vm_private_release_value(self, fun->body);
            //octaspire_dern_vm_private_release_value(self, fun->definitionEnvironment);
            //fun->definitionEnvironment = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        {
            octaspire_dern_special_release(value->value.special);
            value->value.special = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        {
            octaspire_dern_builtin_release(value->value.builtin);
            value->value.builtin = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        {
            octaspire_dern_port_release(value->value.port);
            value->value.port = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_dern_c_data_release(value->value.cData);
            value->value.cData = 0;
        }
        break;
    }

    value->typeTag = OCTASPIRE_DERN_VALUE_TAG_NIL;
}

static void octaspire_dern_vm_private_release_value(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value)
{
    if (!value)
    {
        return;
    }

    octaspire_dern_vm_clear_value_to_nil(self, value);
    value->typeTag = OCTASPIRE_DERN_VALUE_TAG_ILLEGAL;

    octaspire_allocator_free(self->allocator, value);
}

bool octaspire_dern_vm_gc(octaspire_dern_vm_t *self)
{
    if (!octaspire_dern_vm_private_mark_all(self))
    {
        return false;
    }

    return octaspire_dern_vm_private_sweep(self);
}

bool octaspire_dern_vm_private_mark_all(octaspire_dern_vm_t *self)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    for (size_t i = 0; i < octaspire_vector_get_length(self->stack); ++i)
    {
        octaspire_dern_value_t * const value =
            octaspire_vector_get_element_at(
                self->stack,
                (ptrdiff_t)i);

        if (!octaspire_dern_vm_private_mark(self, value))
        {
            octaspire_helpers_verify_true(
                stackLength == octaspire_dern_vm_get_stack_length(self));

            octaspire_helpers_verify_not_null(false);
            return false;
        }
    }

    if (self->libraries)
    {
        octaspire_map_element_iterator_t iterator =
            octaspire_map_element_iterator_init(self->libraries);

        while (iterator.element)
        {
            octaspire_dern_lib_mark_all(
                ((octaspire_dern_lib_t*)octaspire_map_element_get_value(
                    iterator.element)));

            octaspire_map_element_iterator_next(&iterator);
        }
    }

    octaspire_helpers_verify_true(
        stackLength == octaspire_dern_vm_get_stack_length(self));

    return true;
}

bool octaspire_dern_vm_private_mark(octaspire_dern_vm_t *self, octaspire_dern_value_t *value)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(self);
    return octaspire_dern_value_mark(value);
}

bool octaspire_dern_vm_private_sweep(octaspire_dern_vm_t *self)
{
    for (size_t i = 0; i < octaspire_vector_get_length(self->all); /* NOP */ )
    {
        octaspire_dern_value_t * const value =
            octaspire_vector_get_element_at(
                self->all,
                (ptrdiff_t)i);

        if (value->mark)
        {
            value->mark = false;

            ++i;
        }
        else
        {
            octaspire_dern_vm_private_release_value(self, value);

            octaspire_dern_value_t *value2 =
                octaspire_vector_get_element_at(
                    self->all,
                    (ptrdiff_t)i);

            octaspire_helpers_verify_true(value == value2);

            if (!octaspire_vector_remove_element_at(
                    self->all,
                    (ptrdiff_t)i))
            {
                abort();
            }
        }
    }

    return true;
}

octaspire_dern_value_t *octaspire_dern_vm_parse_token(
    octaspire_dern_vm_t * const self,
    octaspire_dern_lexer_token_t const * const token,
    octaspire_input_t *input)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t *result = 0;

    if (!token)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
        return result;
    }

    switch (octaspire_dern_lexer_token_get_type_tag(token))
    {
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN:
        {
            octaspire_vector_t *vec = octaspire_vector_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                self->allocator);

            if (!vec)
            {
                result = octaspire_dern_vm_create_new_value_error(
                    self,
                    octaspire_string_new(
                        "Allocation failure in private parse_token", self->allocator));
            }
            else
            {
                result = octaspire_dern_vm_create_new_value_vector_from_vector(self, vec);

                // Protect result (and all values inside it) from the garbage collector during
                // this phase.
                octaspire_dern_vm_push_value(self, result);

                //bool error = false;
                octaspire_dern_lexer_token_t *token2 = 0;
                while (true)
                {
                    octaspire_dern_lexer_token_release(token2);
                    token2 = 0;
                    octaspire_helpers_verify_true(token2 == 0);

                    token2 = octaspire_dern_lexer_pop_next_token(input, self->allocator);

                    if (!token2)
                    {
                        // No more input
                        octaspire_dern_vm_pop_value(self, result);

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(self));

                        return 0;
                    }
                    else if (
                        octaspire_dern_lexer_token_get_type_tag(token2) ==
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR)
                    {
                        //error = true;
                        octaspire_dern_vm_pop_value(self, result);

                        result = octaspire_dern_vm_create_new_value_error(
                            self,
                            octaspire_string_new(
                                octaspire_dern_lexer_token_get_error_value_as_c_string(
                                    token2),
                                self->allocator));

                        octaspire_helpers_verify_not_null(result);

                        octaspire_dern_lexer_token_release(token2);
                        token2 = 0;

                        octaspire_helpers_verify_true(
                            stackLength == octaspire_dern_vm_get_stack_length(self));

                        return result;
                    }
                    else
                    {
                        if (octaspire_dern_lexer_token_get_type_tag(token2) ==
                            OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN)
                        {
                            octaspire_dern_vm_pop_value(self, result);

                            octaspire_dern_lexer_token_release(token2);
                            token2 = 0;

                            octaspire_helpers_verify_true(
                                stackLength == octaspire_dern_vm_get_stack_length(self));

                            return result;
                        }
                        else
                        {
                            octaspire_dern_value_t *element =
                                octaspire_dern_vm_parse_token(self, token2, input);

                            //octaspire_helpers_verify_not_null(element);

                            octaspire_dern_lexer_token_release(token2);
                            token2 = 0;

                            if (!element)
                            {
                                octaspire_dern_vm_pop_value(self, result);

                                octaspire_helpers_verify_true(
                                    stackLength == octaspire_dern_vm_get_stack_length(self));

                                return element;
                            }

                            if (element->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                            {
                                octaspire_dern_vm_pop_value(self, result);

                                octaspire_helpers_verify_true(
                                    stackLength == octaspire_dern_vm_get_stack_length(self));

                                return element;
                            }

                            // TODO report allocation error instead of asserting
                            if (!octaspire_vector_push_back_element(
                                result->value.vector,
                                &element))
                            {
                                abort();
                            }
                        }
                    }
                }

                /*
                Clang says this code is never executed
                if (!error)
                {
                    octaspire_dern_vm_pop_value(self, result);
                }

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(self));

                return result;
                */
            }
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE:
        {
            result = octaspire_dern_vm_create_new_value_vector(self);

            if (!result)
            {
                result = octaspire_dern_vm_create_new_value_error_from_c_string(
                    self,
                    "Allocation failure");
            }
            else
            {
                octaspire_dern_vm_push_value(self, result);

                octaspire_dern_value_t *quoteSym =
                    octaspire_dern_vm_create_new_value_symbol_from_c_string(self, "quote");

                octaspire_helpers_verify_not_null(quoteSym);

                if (!octaspire_dern_value_as_vector_push_back_element(result, &quoteSym))
                {
                    abort();
                }

                octaspire_dern_value_t *quotedValue = octaspire_dern_vm_parse(
                    self,
                    input);

                if (!quotedValue || quotedValue->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_dern_vm_pop_value(self, result);
                    result = quotedValue; // report error to caller
                }
                else
                {
                    if (!octaspire_dern_value_as_vector_push_back_element(
                        result,
                        &quotedValue))
                    {
                        abort();
                    }

                    octaspire_dern_vm_pop_value(self, result);
                }
            }
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE:
        {
            result = octaspire_dern_vm_get_value_true(self);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE:
        {
            result = octaspire_dern_vm_get_value_false(self);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL:
        {
            result = octaspire_dern_vm_get_value_nil(self);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER:
        {
            result = octaspire_dern_vm_create_new_value_integer(
                self,
                octaspire_dern_lexer_token_get_integer_value(token));
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL:
        {
            result = octaspire_dern_vm_create_new_value_real(
                self,
                octaspire_dern_lexer_token_get_real_value(token));
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING:
        {
            result = octaspire_dern_vm_create_new_value_string(
                self,
                octaspire_string_new(
                    octaspire_dern_lexer_token_get_string_value_as_c_string(token),
                    self->allocator));
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER:
        {
            result = octaspire_dern_vm_create_new_value_character(
                self,
                octaspire_string_new(
                    octaspire_dern_lexer_token_get_character_value_as_c_string(token),
                    self->allocator));
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL:
        {
            result = octaspire_dern_vm_create_new_value_symbol(
                self,
                octaspire_string_new(
                    octaspire_dern_lexer_token_get_symbol_value_as_c_string(token),
                    self->allocator));
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR:
        {
            result = octaspire_dern_vm_create_new_value_error(
                self,
                octaspire_string_new(
                    octaspire_dern_lexer_token_get_error_value_as_c_string(token),
                    self->allocator));
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED:
        {
            return 0;
        }

        default:
        {
            octaspire_string_t *str =
                octaspire_dern_lexer_token_to_string(token);

            octaspire_helpers_verify_not_null(str);

            result = octaspire_dern_vm_create_new_value_error_format(
                self,
                "unexpected %s",
                octaspire_string_get_c_string(str));

            octaspire_string_release(str);
            str = 0;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_parse(
    octaspire_dern_vm_t *self,
    octaspire_input_t *input)
{
    octaspire_dern_lexer_token_t *token =
        octaspire_dern_lexer_pop_next_token(input, self->allocator);

    octaspire_dern_value_t *result =
        octaspire_dern_vm_parse_token(self, token, input);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value)
{
    return octaspire_dern_vm_eval(self, value, self->globalEnvironment);
}

octaspire_dern_value_t *octaspire_dern_vm_call_lambda(
    octaspire_dern_vm_t * const self,
    octaspire_dern_function_t const * const function,
    octaspire_dern_value_t * const arguments,
    octaspire_dern_value_t * const environment)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(environment);

    octaspire_dern_value_t * result = 0;

    octaspire_helpers_verify_not_null(function);
    octaspire_helpers_verify_not_null(function->formals);
    octaspire_helpers_verify_not_null(function->formals->value.vector);
    octaspire_helpers_verify_not_null(function->body);
    octaspire_helpers_verify_not_null(function->body->value.vector);
    octaspire_helpers_verify_not_null(function->definitionEnvironment);

    octaspire_helpers_verify_not_null(
        function->definitionEnvironment->value.environment);

    octaspire_dern_environment_t *extendedEnvironment =
        octaspire_dern_environment_new(
            function->definitionEnvironment,
            self,
            self->allocator);

    octaspire_helpers_verify_not_null(extendedEnvironment);

    octaspire_dern_value_t *extendedEnvVal =
        octaspire_dern_vm_create_new_value_environment_from_environment(
            self,
            extendedEnvironment);

    octaspire_helpers_verify_not_null(extendedEnvVal);

    octaspire_dern_vm_push_value(self, extendedEnvVal);

    octaspire_dern_value_t *error = octaspire_dern_environment_extend(
        extendedEnvironment,
        function->formals,
        arguments);

    if (error)
    {
        octaspire_dern_vm_pop_value(self, extendedEnvVal);
        return error;
    }

    octaspire_helpers_verify_true(
        function->body->typeTag ==
        OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_helpers_verify_not_null(
        function->body->value.vector);

    for (size_t i = 0;
         i < octaspire_vector_get_length(
             function->body->value.vector);
         ++i)
    {
        octaspire_dern_value_t *toBeEvaluated =
            octaspire_vector_get_element_at(
                function->body->value.vector,
                (ptrdiff_t)i);

        octaspire_dern_vm_push_value(self, toBeEvaluated);

        result = octaspire_dern_vm_eval(
            self,
            toBeEvaluated,
            extendedEnvVal);

        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_string_t *tmpStr =
                octaspire_dern_value_to_string(toBeEvaluated, self->allocator);

            octaspire_string_concatenate_format(
                result->value.error->message,
                "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                octaspire_string_get_c_string(tmpStr));

            octaspire_string_release(tmpStr);
            tmpStr = 0;

            octaspire_dern_vm_pop_value(self, toBeEvaluated);
            octaspire_dern_vm_pop_value(self, extendedEnvVal);
            return result;
        }

        octaspire_dern_vm_pop_value(self, toBeEvaluated);

        if (self->functionReturn)
        {
            result = self->functionReturn;
            self->functionReturn = 0;
            break;
        }
    }

    octaspire_dern_vm_pop_value(self, extendedEnvVal);

    octaspire_helpers_verify_not_null(result);
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_eval(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    if (octaspire_dern_vm_is_quit(self))
    {
        return octaspire_dern_vm_create_new_value_nil(self);
    }

    if (self->config.debugModeOn)
    {
        octaspire_string_t *str =
            octaspire_dern_value_to_string(
                value,
                octaspire_dern_vm_get_allocator(self));

        fprintf(stderr,
            "[:::DEBUG:::] %s\n",
            octaspire_string_get_c_string(str));

        octaspire_string_release(str);
        str = 0;
    }

    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (!value)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
        //return self->valueNil;
        return 0;
    }

    octaspire_dern_vm_push_value(self, value);
    octaspire_dern_vm_push_value(self, environment);

    octaspire_dern_value_t *result = 0;

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        // How about these? Self evaluating or not?
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        {
            result = value;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            result = octaspire_dern_environment_get(
                environment->value.environment,
                value);

            if (!result)
            {
                octaspire_string_t* str = octaspire_dern_value_to_string(
                    value,
                    self->allocator);

                result = octaspire_dern_vm_create_new_value_error(
                        self,
                        octaspire_string_new_format(
                            self->allocator,
                            "Unbound symbol '%s'",
                            octaspire_string_get_c_string(str)));

                octaspire_string_release(str);
                str = 0;
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            octaspire_vector_t *vec = value->value.vector;

            if (octaspire_vector_is_empty(vec))
            {
                octaspire_dern_vm_pop_value(self, environment);
                octaspire_dern_vm_pop_value(self, value);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(self));

                return octaspire_dern_vm_create_new_value_error(
                    self,
                    octaspire_string_new(
                        "Cannot evaluate empty vector '()'",
                        self->allocator));
            }

            octaspire_dern_value_t *removeMe = octaspire_vector_get_element_at(vec, 0);

            octaspire_dern_value_t *operator = octaspire_dern_vm_eval(
                self,
                removeMe,
                environment);

            if (!operator)
            {
                octaspire_dern_vm_pop_value(self, environment);
                octaspire_dern_vm_pop_value(self, value);

                octaspire_helpers_verify_true(
                    stackLength == octaspire_dern_vm_get_stack_length(self));

                return 0;
            }

            octaspire_dern_vm_push_value(self, operator);

            switch (operator->typeTag)
            {
                case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
                {
                    abort();
                }

                case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
                {
                    octaspire_vector_t *argVec =
                        octaspire_vector_new_with_preallocated_elements(
                            sizeof(octaspire_dern_value_t*),
                            true,
                            octaspire_vector_get_length(vec) - 1,
                            0,
                            self->allocator);

                    octaspire_dern_value_t *arguments =
                        octaspire_dern_vm_create_new_value_vector_from_vector(
                            self,
                            argVec);

                    octaspire_dern_vm_push_value(self, arguments);

                    for (size_t i = 1;
                         i < octaspire_vector_get_length(vec);
                         ++i)
                    {
                        octaspire_dern_value_t * const tmpPtr =
                            octaspire_vector_get_element_at(
                                vec,
                                (ptrdiff_t)i);

                        if (tmpPtr->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                        {
                            result = tmpPtr;
                            break;
                        }

                        octaspire_vector_push_back_element(argVec, &tmpPtr);
                    }

                    if (!result)
                    {
                        result = (operator->value.special->cFunction)(
                            self,
                            arguments,
                            environment);

                        // TODO XXX add this error annotation to other places too
                        // (for example builtin and function calls)
                        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                        {
                            octaspire_string_t *tmpStr =
                                octaspire_dern_value_to_string(value, self->allocator);

                            octaspire_string_concatenate_format(
                                result->value.error->message,
                                "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                                octaspire_string_get_c_string(tmpStr));

                            octaspire_string_release(tmpStr);
                            tmpStr = 0;
                        }
                    }

                    octaspire_dern_vm_pop_value(self, arguments);
                }
                break;

                case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
                {
                    octaspire_vector_t *argVec =
                        octaspire_vector_new_with_preallocated_elements(
                            sizeof(octaspire_dern_value_t*),
                            true,
                            octaspire_vector_get_length(vec) - 1,
                            0,
                            self->allocator);

                    octaspire_dern_value_t *arguments =
                        octaspire_dern_vm_create_new_value_vector_from_vector(
                            self,
                            argVec);

                    octaspire_dern_vm_push_value(self, arguments);

                    for (size_t i = 1;
                         i < octaspire_vector_get_length(vec);
                         ++i)
                    {
                        octaspire_dern_value_t *evaluated = octaspire_dern_vm_eval(
                            self,
                            octaspire_vector_get_element_at(
                                vec,
                                (ptrdiff_t)i),
                            environment);

                        if (evaluated->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                        {
                            result = evaluated;


                            // TODO XXX add this error annotation to other places too
                            // (for example builtin and function calls)
                            octaspire_string_t *tmpStr =
                                octaspire_dern_value_to_string(value, self->allocator);

                            octaspire_string_concatenate_format(
                                result->value.error->message,
                                "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                                octaspire_string_get_c_string(tmpStr));

                            octaspire_string_release(tmpStr);
                            tmpStr = 0;


                            break;
                        }

                        octaspire_vector_push_back_element(argVec, &evaluated);
                    }

                    if (!result)
                    {
                        result = (operator->value.builtin->cFunction)(
                            self,
                            arguments,
                            environment);

                        // TODO XXX add this error annotation to other places too
                        // (for example builtin and function calls)
                        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                        {
                            octaspire_string_t *tmpStr =
                                octaspire_dern_value_to_string(value, self->allocator);

                            octaspire_string_concatenate_format(
                                result->value.error->message,
                                "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                                octaspire_string_get_c_string(tmpStr));

                            octaspire_string_release(tmpStr);
                            tmpStr = 0;
                        }


                        if (operator->value.builtin->cFunction == octaspire_dern_vm_builtin_return)
                        {
                            //octaspire_helpers_verify_true(self->functionReturn == 0);
                            self->functionReturn = result;
                        }
                    }

                    octaspire_dern_vm_pop_value(self, arguments);
                }
                break;

                case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
                {
                    octaspire_vector_t *argVec =
                        octaspire_vector_new_with_preallocated_elements(
                            sizeof(octaspire_dern_value_t*),
                            true,
                            octaspire_vector_get_length(vec) - 1,
                            0,
                            self->allocator);

                    octaspire_dern_value_t *arguments =
                        octaspire_dern_vm_create_new_value_vector_from_vector(self, argVec);

                    octaspire_dern_vm_push_value(self, arguments);

                    for (size_t i = 1;
                         i < octaspire_vector_get_length(vec);
                         ++i)
                    {
                        octaspire_dern_value_t *evaluated = octaspire_dern_vm_eval(
                            self,
                            octaspire_vector_get_element_at(
                                vec,
                                (ptrdiff_t)i),
                            environment);


                        if (evaluated->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                        {
                            result = evaluated;

                            // TODO XXX add this error annotation to other places too
                            // (for example builtin and function calls)
                            octaspire_string_t *tmpStr =
                                octaspire_dern_value_to_string(value, self->allocator);

                            octaspire_string_concatenate_format(
                                result->value.error->message,
                                "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                                octaspire_string_get_c_string(tmpStr));

                            octaspire_string_release(tmpStr);
                            tmpStr = 0;


                            break;
                        }

                        octaspire_dern_value_as_vector_push_back_element(arguments, &evaluated);
                    }

                    if (!result)
                    {
                        octaspire_dern_function_t *function = operator->value.function;

                        octaspire_helpers_verify_not_null(function);
                        octaspire_helpers_verify_not_null(function->formals);
                        // Invalid read of size 4 below
                        octaspire_helpers_verify_not_null(function->formals->value.vector);
                        octaspire_helpers_verify_not_null(function->body);
                        octaspire_helpers_verify_not_null(function->body->value.vector);
                        octaspire_helpers_verify_not_null(function->definitionEnvironment);

                        octaspire_helpers_verify_not_null(
                            function->definitionEnvironment->value.environment);

                        octaspire_dern_environment_t *extendedEnvironment =
                            octaspire_dern_environment_new(
                                function->definitionEnvironment,
                                self,
                                self->allocator);

                        octaspire_helpers_verify_not_null(extendedEnvironment);

                        octaspire_dern_value_t *extendedEnvVal =
                            octaspire_dern_vm_create_new_value_environment_from_environment(
                                self,
                                extendedEnvironment);

                        octaspire_helpers_verify_not_null(extendedEnvVal);

                        octaspire_dern_vm_push_value(self, extendedEnvVal);

                        octaspire_dern_value_t *error = octaspire_dern_environment_extend(
                            extendedEnvironment,
                            function->formals,
                            arguments);

                        if (error)
                        {
                            result = error;
                        }
                        else
                        {
                            // TODO push function->body?

                            octaspire_helpers_verify_true(
                                function->body->typeTag ==
                                OCTASPIRE_DERN_VALUE_TAG_VECTOR);

                            octaspire_helpers_verify_not_null(
                                function->body->value.vector);

                            for (size_t i = 0;
                                 i < octaspire_vector_get_length(
                                     function->body->value.vector);
                                 ++i)
                            {
                                octaspire_dern_value_t *toBeEvaluated =
                                    octaspire_vector_get_element_at(
                                        function->body->value.vector,
                                        (ptrdiff_t)i);

                                octaspire_dern_vm_push_value(self, toBeEvaluated);

                                result = octaspire_dern_vm_eval(
                                    self,
                                    toBeEvaluated,
                                    extendedEnvVal);

                                if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                                {
                                    // TODO XXX add this error annotation to other places too
                                    // (for example builtin and function calls)
                                    octaspire_string_t *tmpStr =
                                        octaspire_dern_value_to_string(value, self->allocator);

                                    octaspire_string_concatenate_format(
                                        result->value.error->message,
                                        "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                                        octaspire_string_get_c_string(tmpStr));

                                    octaspire_string_release(tmpStr);
                                    tmpStr = 0;


                                    octaspire_dern_vm_pop_value(self, toBeEvaluated);
                                    break;
                                }

                                octaspire_dern_vm_pop_value(self, toBeEvaluated);

                                if (self->functionReturn)
                                {
                                    result = self->functionReturn;
                                    self->functionReturn = 0;
                                    break;
                                }
                            }
                        }

                        // TODO pop function->body?

                        octaspire_dern_vm_pop_value(self, extendedEnvVal);
                        octaspire_dern_vm_pop_value(self, arguments);
                    }
                    else
                    {
                        octaspire_dern_vm_pop_value(self, arguments);
                    }
                }
                break;

                case OCTASPIRE_DERN_VALUE_TAG_NIL:
                case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
                case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
                case OCTASPIRE_DERN_VALUE_TAG_REAL:
                case OCTASPIRE_DERN_VALUE_TAG_STRING:
                case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
                case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
                case OCTASPIRE_DERN_VALUE_TAG_ERROR:
                case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
                case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
                case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
                case OCTASPIRE_DERN_VALUE_TAG_LIST:
                case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
                case OCTASPIRE_DERN_VALUE_TAG_PORT:
                case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
                {
                    octaspire_string_t *str = octaspire_dern_value_to_string(
                        operator,
                        self->allocator);

                    result = octaspire_dern_vm_create_new_value_error(
                        self,
                        octaspire_string_new_format(
                            self->allocator,
                            "Cannot evaluate operator of type '%s' (%s)",
                            octaspire_dern_value_helper_get_type_as_c_string(operator->typeTag),
                            octaspire_string_get_c_string(str)));

                    octaspire_string_release(str);
                    str = 0;
                }
                break;
            }

            octaspire_dern_vm_pop_value(self, operator);
        }
        break;

        // TODO XXX add rest of types
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            result = octaspire_dern_vm_create_new_value_error(
                self,
                octaspire_string_new_format(
                    self->allocator,
                    "Cannot evaluate unknown type %i",
                    (int)value->typeTag));
        }
        break;
    }

    octaspire_dern_vm_pop_value(self, environment);
    octaspire_dern_vm_pop_value(self, value);


    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_read_from_octaspire_input_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    octaspire_input_t * const input)
{
    if (!input || !octaspire_input_is_good(input))
    {
        return octaspire_dern_vm_create_new_value_error_from_c_string(self, "No input");
    }

    octaspire_dern_value_t *lastGoodResult = 0;
    octaspire_dern_value_t *result = 0;

    while (octaspire_input_is_good(input))
    {
        result = octaspire_dern_vm_eval_in_global_environment(
            self,
            octaspire_dern_vm_parse(self, input));

        if (!result)
        {
            break;
        }

        lastGoodResult = result;

        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_dern_value_as_error_set_line_number(
                result,
                octaspire_input_get_line_number(input));

            break;
        }
    }

    //octaspire_input_release(input);
    //input = 0;

    if (!result && lastGoodResult)
    {
        return lastGoodResult;
    }

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    char const * const str)
{
    if (!str)
    {
        return octaspire_dern_vm_create_new_value_error_from_c_string(self, "No input");
    }

    // TODO should more efficient version without strlen be used?
    return octaspire_dern_vm_read_from_buffer_and_eval_in_global_environment(
        self,
        str,
        strlen(str));
}

octaspire_dern_value_t *octaspire_dern_vm_read_from_buffer_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    char const * const buffer,
    size_t const lengthInOctets)
{
    if (!buffer || lengthInOctets == 0)
    {
        return octaspire_dern_vm_create_new_value_error_from_c_string(self, "No input");
    }

    octaspire_input_t *input =
        octaspire_input_new_from_buffer(buffer, lengthInOctets, self->allocator);

    if (!input)
    {
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            self,
            "Allocation failure of input");
    }

    octaspire_dern_value_t * const result =
        octaspire_dern_vm_read_from_octaspire_input_and_eval_in_global_environment(self, input);

    octaspire_input_release(input);
    input = 0;

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_read_from_path_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    char const * const path)
{
    size_t bufLen = 0;
    char *buffer = octaspire_helpers_path_to_buffer(path, &bufLen, self->allocator, self->stdio);

    if (!buffer || !bufLen)
    {
        return octaspire_dern_vm_create_new_value_error_from_c_string(self, "No input");
    }

    octaspire_dern_value_t *result =
        octaspire_dern_vm_read_from_buffer_and_eval_in_global_environment(self, buffer, bufLen);

    octaspire_allocator_free(self->allocator, buffer);
    buffer = 0;
    bufLen = 0;

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_get_value_nil(
    octaspire_dern_vm_t *self)
{
    //return self->valueNil;
    return octaspire_dern_vm_create_new_value_copy(self, self->valueNil);
}

octaspire_dern_value_t *octaspire_dern_vm_get_value_true(
    octaspire_dern_vm_t *self)
{
    //return self->valueTrue;
    return octaspire_dern_vm_create_new_value_copy(self, self->valueTrue);
}

octaspire_dern_value_t *octaspire_dern_vm_get_value_false(
    octaspire_dern_vm_t *self)
{
    //return self->valueFalse;
    return octaspire_dern_vm_create_new_value_copy(self, self->valueFalse);
}

octaspire_allocator_t *octaspire_dern_vm_get_allocator(
    octaspire_dern_vm_t *self)
{
    return self->allocator;
}

void octaspire_dern_vm_set_exit_code(
    octaspire_dern_vm_t *self,
    int32_t const code)
{
    self->exitCode = code;
}

int32_t octaspire_dern_vm_get_exit_code(
    octaspire_dern_vm_t const * const self)
{
    return self->exitCode;
}

bool octaspire_dern_vm_is_quit(
    octaspire_dern_vm_t const * const self)
{
    return self->quit;
}

void octaspire_dern_vm_quit(
    octaspire_dern_vm_t *self)
{
    self->quit = true;
}

// Create some helper methods.

bool octaspire_dern_vm_create_and_register_new_builtin(
    octaspire_dern_vm_t * const self,
    char const * const name,
    octaspire_dern_c_function const funcPointer,
    size_t const numRequiredActualArguments,
    char const * const docStr,
    bool const howtoAllowed,
    octaspire_dern_environment_t * const targetEnv)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(targetEnv);

    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_builtin_t * const builtin = octaspire_dern_builtin_new(
        funcPointer,
        self->allocator,
        name,
        numRequiredActualArguments,
        docStr,
        howtoAllowed);

    if (!builtin)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
        return false;
    }

    octaspire_dern_value_t * const symbol =
        octaspire_dern_vm_create_new_value_symbol_from_c_string(self, name);

    octaspire_dern_vm_push_value(self, symbol);

    octaspire_dern_value_t * const builtinVal =
        octaspire_dern_vm_create_new_value_builtin(self, builtin, docStr);

    octaspire_dern_vm_push_value(self, builtinVal);

    if (!octaspire_dern_environment_set(targetEnv, symbol, builtinVal))
    {
        octaspire_dern_vm_pop_value(self, builtinVal);
        octaspire_dern_vm_pop_value(self, symbol);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
        return false;
    }

    octaspire_dern_vm_pop_value(self, builtinVal);
    octaspire_dern_vm_pop_value(self, symbol);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));

    return true;
}

bool octaspire_dern_vm_create_and_register_new_special(
    octaspire_dern_vm_t * const self,
    char const * const name,
    octaspire_dern_c_function const funcPointer,
    size_t const numRequiredActualArguments,
    char const * const docStr,
    bool const howtoAllowed,
    octaspire_dern_environment_t * const targetEnv)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_special_t * const special = octaspire_dern_special_new(
        funcPointer,
        self->allocator,
        name,
        numRequiredActualArguments,
        docStr,
        howtoAllowed);

    if (!special)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
        return false;
    }

    octaspire_dern_value_t * const symbol =
        octaspire_dern_vm_create_new_value_symbol_from_c_string(self, name);

    octaspire_dern_vm_push_value(self, symbol);

    octaspire_dern_value_t * const specialVal =
        octaspire_dern_vm_create_new_value_special(self, special, docStr);

    octaspire_dern_vm_push_value(self, specialVal);

    if (!octaspire_dern_environment_set(targetEnv, symbol, specialVal))
    {
        octaspire_dern_vm_pop_value(self, specialVal);
        octaspire_dern_vm_pop_value(self, symbol);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
        return false;
    }

    octaspire_dern_vm_pop_value(self, specialVal);
    octaspire_dern_vm_pop_value(self, symbol);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return true;
}

bool octaspire_dern_vm_create_and_define_new_integer(
    octaspire_dern_vm_t * const self,
    char const * const name,
    char const * const docstr,
    int32_t const value)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(self);

    octaspire_helpers_verify_true(strlen(name) > 0);
    octaspire_helpers_verify_true(strlen(docstr) > 0);

    octaspire_string_t *str = octaspire_string_new_format(
        octaspire_dern_vm_get_allocator(self),
        "(define %s [%s] %" PRId32 ")",
        name,
        docstr,
        value);

    octaspire_helpers_verify_not_null(str);

    octaspire_dern_value_t *result =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            self,
            octaspire_string_get_c_string(str));

    octaspire_helpers_verify_not_null(result);

    octaspire_string_release(str);
    str = 0;

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));

    if (octaspire_dern_value_is_boolean(result) &&
        octaspire_dern_value_as_boolean_get_value(result))
    {
        return true;
    }

    return false;
}

size_t octaspire_dern_vm_get_stack_length(
    octaspire_dern_vm_t const * const self)
{
    return octaspire_vector_get_length(self->stack);
}

void octaspire_dern_vm_print_stack(
    octaspire_dern_vm_t const * const self)
{
    if (octaspire_vector_is_empty(self->stack))
    {
        printf("\n\n-- STACK IS EMPTY --\n\n");
        return;
    }

    printf("Stack has %zu elements\n", octaspire_vector_get_length(self->stack));
    for (ptrdiff_t i = (ptrdiff_t)octaspire_vector_get_length(self->stack) - 1;
         i >= 0; --i)
    {
#ifdef __AROS__
        printf("--------------------------- #%ld ------------------------\n", (long)i);
#else
        printf("--------------------------- #%td ------------------------\n", i);
#endif
        octaspire_dern_value_print(
            octaspire_vector_get_element_at(self->stack, i),
            self->allocator);
        printf("--------------------------- end ------------------------\n\n");
    }
}


octaspire_dern_value_t *
octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
    octaspire_dern_vm_t * const self,
    octaspire_vector_t const * const vectorContainingSizeTs)
{
    octaspire_helpers_verify_true(
        self &&
        vectorContainingSizeTs &&
        sizeof(size_t) == octaspire_vector_get_element_size_in_octets(
            vectorContainingSizeTs));

    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t * const result = octaspire_dern_vm_create_new_value_vector(self);
    if (!octaspire_dern_vm_push_value(self, result))
    {
        abort();
    }

    for (size_t i = 0; i < octaspire_vector_get_length(vectorContainingSizeTs); ++i)
    {
        size_t const idx =
            *(size_t const * const)octaspire_vector_get_element_at_const(
                vectorContainingSizeTs,
                (ptrdiff_t)i);

        octaspire_dern_value_t *tmpVal =
            octaspire_dern_vm_create_new_value_integer(self, (int32_t)idx);

        octaspire_helpers_verify_not_null(tmpVal);

        if (!octaspire_dern_value_as_vector_push_back_element(
                result,
                &tmpVal))
        {
            abort();
        }
    }

    if (!octaspire_dern_vm_pop_value(self, result))
    {
        abort();
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_find_from_value(
    octaspire_dern_vm_t * const self,
    octaspire_dern_value_t * const value,
    octaspire_dern_value_t const * const key)
{
    octaspire_helpers_verify_true(self && value && key);
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER)
            {
                octaspire_vector_t *foundIndices =
                    octaspire_string_find_char(
                        value->value.string,
                        key->value.character,
                        0);

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING)
            {
                octaspire_vector_t *foundIndices = octaspire_string_find_string(
                    value->value.string,
                    key->value.string,
                    0,
                    octaspire_string_get_length_in_ucs_characters(key->value.string));

                if (!foundIndices)
                {
                    octaspire_helpers_verify_true(
                        stackLength == octaspire_dern_vm_get_stack_length(self));

                    return octaspire_dern_vm_create_new_value_vector(self);
                }

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
            {
                octaspire_vector_t *foundIndices = octaspire_string_find_string(
                    value->value.string,
                    key->value.symbol,
                    0,
                    octaspire_string_get_length_in_ucs_characters(key->value.symbol));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER)
            {
                octaspire_string_t *tmpStr =
                    octaspire_string_new_format(
                        self->allocator,
                        "%" PRId32 "",
                        key->value.integer);

                octaspire_vector_t *foundIndices = octaspire_string_find_string(
                    value->value.string,
                    tmpStr,
                    0,
                    octaspire_string_get_length_in_ucs_characters(tmpStr));

                octaspire_string_release(tmpStr);
                tmpStr = 0;

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL)
            {
                octaspire_string_t *tmpStr =
                    octaspire_string_new_format(
                        self->allocator,
                        "%g",
                        key->value.real);

                octaspire_vector_t *foundIndices = octaspire_string_find_string(
                    value->value.string,
                    tmpStr,
                    0,
                    octaspire_string_get_length_in_ucs_characters(tmpStr));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_string_release(tmpStr);
                tmpStr = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return octaspire_dern_vm_create_new_value_error_format(
                    self,
                    "Type '%s' cannot be searched from type 'string'",
                    octaspire_dern_value_helper_get_type_as_c_string(key->typeTag));
            }
        }

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER)
            {
                octaspire_vector_t *foundIndices = octaspire_string_find_char(
                    value->value.symbol,
                    key->value.character,
                    0);

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING)
            {
                octaspire_vector_t *foundIndices = octaspire_string_find_string(
                    value->value.symbol,
                    key->value.string,
                    0,
                    octaspire_string_get_length_in_ucs_characters(key->value.string));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
            {
                octaspire_vector_t *foundIndices = octaspire_string_find_string(
                    value->value.symbol,
                    key->value.symbol,
                    0,
                    octaspire_string_get_length_in_ucs_characters(key->value.symbol));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER)
            {
                octaspire_string_t *tmpStr =
                    octaspire_string_new_format(
                        self->allocator,
                        "%" PRId32 "",
                        key->value.integer);

                octaspire_vector_t *foundIndices = octaspire_string_find_string(
                    value->value.symbol,
                    tmpStr,
                    0,
                    octaspire_string_get_length_in_ucs_characters(tmpStr));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_string_release(tmpStr);
                tmpStr = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL)
            {
                octaspire_string_t *tmpStr =
                    octaspire_string_new_format(
                        self->allocator,
                        "%g",
                        key->value.real);

                octaspire_vector_t *foundIndices = octaspire_string_find_string(
                    value->value.symbol,
                    tmpStr,
                    0,
                    octaspire_string_get_length_in_ucs_characters(tmpStr));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_string_release(tmpStr);
                tmpStr = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return octaspire_dern_vm_create_new_value_error_format(
                    self,
                    "Type '%s' cannot be searched from type 'symbol'",
                    octaspire_dern_value_helper_get_type_as_c_string(key->typeTag));
            }
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_vector(self);

            octaspire_dern_vm_push_value(self, result);

            for (size_t i = 0; i < octaspire_vector_get_length(value->value.vector); ++i)
            {
                octaspire_dern_value_t * const element =
                    octaspire_vector_get_element_at(
                        value->value.vector,
                        (ptrdiff_t)i);

                if (octaspire_dern_value_is_equal(element, key))
                {
                    octaspire_dern_value_t * const tmpVal =
                        octaspire_dern_vm_create_new_value_integer(self, (int32_t)i);

                    octaspire_dern_value_as_vector_push_back_element(result, &tmpVal);
                }
            }

            octaspire_dern_vm_pop_value(self, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
            return result;
        }

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            uint32_t const hash = octaspire_dern_value_get_hash(key);

            octaspire_map_element_t * const element =
                octaspire_map_get(value->value.hashMap, hash, &key);

            if (element)
            {
                octaspire_dern_value_t * const resVal =
                    octaspire_map_element_get_value(element);

                if (resVal)
                {
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                    return resVal;
                }
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
            return octaspire_dern_vm_get_value_nil(self);
        }

        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        {
            octaspire_dern_value_t *result =
                octaspire_dern_environment_get(value->value.environment, key);

            if (result)
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
            return octaspire_dern_vm_get_value_nil(self);
        }

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
            return octaspire_dern_vm_create_new_value_error_format(
                self,
                "'find' doesn't support search from type '%s'",
                octaspire_dern_value_helper_get_type_as_c_string(value->typeTag));
        }
    }

    abort();
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_get_global_environment(
    octaspire_dern_vm_t *self)
{
    return self->globalEnvironment;
}

octaspire_dern_value_t const *octaspire_dern_vm_get_global_environment_const(
    octaspire_dern_vm_t const * const self)
{
    return self->globalEnvironment;
}

void  octaspire_dern_vm_set_user_data(octaspire_dern_vm_t * const self, void *userData)
{
    self->userData = userData;
}

void *octaspire_dern_vm_get_user_data(octaspire_dern_vm_t const * const self)
{
    return self->userData;
}

octaspire_dern_value_t *octaspire_dern_vm_get_function_return(
    octaspire_dern_vm_t * const self)
{
    return self->functionReturn;
}

void octaspire_dern_vm_set_function_return(
    octaspire_dern_vm_t * const self,
    octaspire_dern_value_t * const value)
{
    if (!value)
    {
        // Only VM is allowed to set functionReturn to NULL
        abort();
    }

    self->functionReturn = value;
}

void octaspire_dern_vm_set_prevent_gc(octaspire_dern_vm_t * const self, bool const prevent)
{
    self->preventGc = prevent;
}

void octaspire_dern_vm_set_gc_trigger_limit(octaspire_dern_vm_t * const self, size_t const numAllocs)
{
    self->gcTriggerLimit = numAllocs;
}

octaspire_dern_vm_custom_require_source_file_loader_t
octaspire_dern_vm_get_custom_require_source_file_pre_loader(
        octaspire_dern_vm_t * const self)

{
    return self->config.preLoaderForRequireSrc;
}

bool octaspire_dern_vm_add_library(
    octaspire_dern_vm_t *self,
    char const * const name,
    octaspire_dern_lib_t *library)
{
    if (octaspire_dern_vm_has_library(self, name))
    {
        return false;
    }

    octaspire_string_t *str =
        octaspire_string_new(name, self->allocator);

    return octaspire_map_put(
        self->libraries,
        octaspire_string_get_hash(str),
        &str,
        &library);
}

bool octaspire_dern_vm_has_library(
    octaspire_dern_vm_t const * const self,
    char const * const name)
{
    octaspire_string_t *str = octaspire_string_new(
        name,
        self->allocator);

    octaspire_helpers_verify_not_null(str);

    bool const result = (octaspire_map_get(
            self->libraries,
            octaspire_string_get_hash(str),
            &str) != 0);

    octaspire_string_release(str);
    str = 0;

    return result;
}

octaspire_dern_lib_t *octaspire_dern_vm_get_library(
    octaspire_dern_vm_t * const self,
    char const * const name)
{
    octaspire_string_t *str = octaspire_string_new(
        name,
        self->allocator);

    octaspire_helpers_verify_not_null(str);

    octaspire_map_element_t *element = octaspire_map_get(
        self->libraries,
        octaspire_string_get_hash(str),
        &str);

    octaspire_string_release(str);
    str = 0;

    if (!element)
    {
        return 0;
    }

    return octaspire_map_element_get_value(element);
}

octaspire_stdio_t *octaspire_dern_vm_get_stdio(octaspire_dern_vm_t * const self)
{
    return self->stdio;
}

bool octaspire_dern_vm_add_command_line_argument(
    octaspire_dern_vm_t * const self,
    char const * const argument)
{
    octaspire_string_t *str =
        octaspire_string_new(
            argument,
            self->allocator);

    if (!str)
    {
        return false;
    }

    const bool result = octaspire_vector_push_back_element(
        self->commandLineArguments,
        &str);

    if (!result)
    {
        octaspire_string_release(str);
        str = 0;
    }

    return result;
}

bool octaspire_dern_vm_add_environment_variable(
    octaspire_dern_vm_t * const self,
    char const * const variable)
{
    octaspire_string_t *str =
        octaspire_string_new(
            variable,
            self->allocator);

    if (!str)
    {
        return false;
    }

    const bool result = octaspire_vector_push_back_element(
        self->environmentVariables,
        &str);

    if (!result)
    {
        octaspire_string_release(str);
        str = 0;
    }

    return result;
}

size_t octaspire_dern_vm_get_number_of_command_line_arguments(
    octaspire_dern_vm_t const * const self)
{
    return octaspire_vector_get_length(
        self->commandLineArguments);
}

char const *octaspire_dern_vm_get_command_line_argument_at(
    octaspire_dern_vm_t const * const self,
    ptrdiff_t const index)
{
    octaspire_string_t *str =
        octaspire_vector_get_element_at(
            self->commandLineArguments, index);

    if (!str)
    {
        return 0;
    }

    return octaspire_string_get_c_string(str);
}

size_t octaspire_dern_vm_get_number_of_environment_variables(
    octaspire_dern_vm_t const * const self)
{
    return octaspire_vector_get_length(
        self->environmentVariables);
}

char const *octaspire_dern_vm_get_environment_variable_at(
    octaspire_dern_vm_t const * const self,
    ptrdiff_t const index)
{
    octaspire_string_t *str =
        octaspire_vector_get_element_at(
            self->environmentVariables, index);

    if (!str)
    {
        return 0;
    }

    return octaspire_string_get_c_string(str);
}

octaspire_dern_vm_config_t const * octaspire_dern_vm_get_config_const(
    octaspire_dern_vm_t const * const self)
{
    return &(self->config);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_dern_vm.c
//////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif

#endif // OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION
#ifdef OCTASPIRE_DERN_AMALGAMATED_REPL_IMPLEMENTATION

#ifndef OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION
#define OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION 1
#endif
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/external/octaspire_dern_banner_color.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/*-----------------------------------------------------------------------------
 * This banner is generated with toilet using font standard.flf and by
 * coloring the result with lolcat. The header of font standard.flf is:
 *
    ===============================================================================
    flf2a$ 6 5 16 15 11 0 24463 229
    Standard by Glenn Chappell & Ian Chai 3/93 -- based on Frank's .sig
    Includes ISO Latin-1
    figlet release 2.1 -- 12 Aug 1994
    Modified for figlet 2.2 by John Cowan <cowan@ccil.org>
      to add Latin-{2,3,4,5} support (Unicode U+0100-017F).
    Permission is hereby given to modify this font, as long as the
    modifier's name is placed on a comment line.

    Modified by Paul Burton <solution@earthlink.net> 12/96 to include new parameter
    supported by FIGlet and FIGWin.  May also be slightly modified for better use
    of new full-width/kern/smush alternatives, but default output is NOT changed.
    ===============================================================================


    This file is part of Octaspire Dern and is licensed with:

    *******************************************************************************
    Octaspire Dern - Programming language
    Copyright 2017 www.octaspire.com

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    ******************************************************************************
-----------------------------------------------------------------------------*/
extern unsigned char octaspire_dern_banner_color[];
extern unsigned int octaspire_dern_banner_color_len;

unsigned char octaspire_dern_banner_color[] = {
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x39, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x39, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x33, 0x6d, 0x5f, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x34, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x0d, 0x0a, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x2f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x36, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5c, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x39, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x7c, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d,
  0x28, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x29, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x33, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x34, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x38, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x0d, 0x0a, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36,
  0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36,
  0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x39, 0x6d, 0x2f,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33,
  0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x7c,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33,
  0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x2f,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33,
  0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x60, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33,
  0x39, 0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33,
  0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x27, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x5f,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x34, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x27, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x34, 0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5f,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x7c,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x7c,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x38, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x2f, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5c, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x38, 0x6d, 0x27, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x7c,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38,
  0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x38, 0x33, 0x6d, 0x27, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38,
  0x33, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x0d, 0x0a,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x7c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x36, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x39, 0x6d, 0x7c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x28, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x28, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39,
  0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39,
  0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x5c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x29, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x7c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5f, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38,
  0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38,
  0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x38, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x7c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x0d, 0x0a, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x39, 0x6d, 0x5c, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x2f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x33, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x39, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d,
  0x2c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d,
  0x2e, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x2f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d,
  0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d,
  0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5c, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x7c, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x38, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d,
  0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x38, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d,
  0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x38, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x38, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x7c, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x38, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x31, 0x31, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x31, 0x31, 0x38, 0x6d, 0x7c,
  0x1b, 0x5b, 0x30, 0x6d, 0x0d, 0x0a, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x77, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x77, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x77, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x2e, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x6f, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x63, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x74, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x61, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x73, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39,
  0x6d, 0x70, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x69, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x72, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x65, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39,
  0x6d, 0x2e, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x63, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x6f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x6d, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x64, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x65, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x72, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x6e, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x52, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x45, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x33, 0x6d, 0x50, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x4c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x66, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x6f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x72, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x74, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x68, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x65, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x44, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x65, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x72, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38,
  0x6d, 0x6e, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x50, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x72, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38,
  0x6d, 0x6f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x67, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x38, 0x34, 0x6d, 0x72, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x61, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x38, 0x33, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x69, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x6e, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x67, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x4c, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x61, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x6e, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x38, 0x33, 0x6d, 0x67, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x31, 0x31, 0x39, 0x6d, 0x75, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x31, 0x31, 0x38, 0x6d,
  0x61, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x31, 0x31, 0x38, 0x6d, 0x67, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x31, 0x31, 0x38, 0x6d, 0x65, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x31, 0x31, 0x38, 0x6d,
  0x2e, 0x1b, 0x5b, 0x30, 0x6d, 0x0d, 0x0a
};
unsigned int octaspire_dern_banner_color_len = 5959;
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/external/octaspire_dern_banner_color.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/external/octaspire_dern_banner_white.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/*-----------------------------------------------------------------------------
 * This banner is generated with toilet using font standard.flf.
 * The header of font standard.flf is:
 *
    ===============================================================================
    flf2a$ 6 5 16 15 11 0 24463 229
    Standard by Glenn Chappell & Ian Chai 3/93 -- based on Frank's .sig
    Includes ISO Latin-1
    figlet release 2.1 -- 12 Aug 1994
    Modified for figlet 2.2 by John Cowan <cowan@ccil.org>
      to add Latin-{2,3,4,5} support (Unicode U+0100-017F).
    Permission is hereby given to modify this font, as long as the
    modifier's name is placed on a comment line.

    Modified by Paul Burton <solution@earthlink.net> 12/96 to include new parameter
    supported by FIGlet and FIGWin.  May also be slightly modified for better use
    of new full-width/kern/smush alternatives, but default output is NOT changed.
    ===============================================================================


    This file is part of Octaspire Dern and is licensed with:

    *******************************************************************************
    Octaspire Dern - Programming language
    Copyright 2017 www.octaspire.com

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    ******************************************************************************
-----------------------------------------------------------------------------*/
extern unsigned char octaspire_dern_banner_white[];
extern unsigned int octaspire_dern_banner_white_len;

unsigned char octaspire_dern_banner_white[] = {
  0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x5f,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x2f, 0x20, 0x5f, 0x20,
  0x5c, 0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x7c, 0x20, 0x7c, 0x5f, 0x20, 0x5f,
  0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f,
  0x20, 0x28, 0x5f, 0x29, 0x5f, 0x20, 0x5f, 0x5f, 0x20, 0x5f, 0x5f, 0x5f,
  0x20, 0x20, 0x7c, 0x20, 0x20, 0x5f, 0x20, 0x5c, 0x20, 0x20, 0x5f, 0x5f,
  0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x20,
  0x20, 0x0a, 0x7c, 0x20, 0x7c, 0x20, 0x7c, 0x20, 0x7c, 0x2f, 0x20, 0x5f,
  0x5f, 0x7c, 0x20, 0x5f, 0x5f, 0x2f, 0x20, 0x5f, 0x60, 0x20, 0x2f, 0x20,
  0x5f, 0x5f, 0x7c, 0x20, 0x27, 0x5f, 0x20, 0x5c, 0x7c, 0x20, 0x7c, 0x20,
  0x27, 0x5f, 0x5f, 0x2f, 0x20, 0x5f, 0x20, 0x5c, 0x20, 0x7c, 0x20, 0x7c,
  0x20, 0x7c, 0x20, 0x7c, 0x2f, 0x20, 0x5f, 0x20, 0x5c, 0x20, 0x27, 0x5f,
  0x5f, 0x7c, 0x20, 0x27, 0x5f, 0x20, 0x5c, 0x20, 0x0a, 0x7c, 0x20, 0x7c,
  0x5f, 0x7c, 0x20, 0x7c, 0x20, 0x28, 0x5f, 0x5f, 0x7c, 0x20, 0x7c, 0x7c,
  0x20, 0x28, 0x5f, 0x7c, 0x20, 0x5c, 0x5f, 0x5f, 0x20, 0x5c, 0x20, 0x7c,
  0x5f, 0x29, 0x20, 0x7c, 0x20, 0x7c, 0x20, 0x7c, 0x20, 0x7c, 0x20, 0x20,
  0x5f, 0x5f, 0x2f, 0x20, 0x7c, 0x20, 0x7c, 0x5f, 0x7c, 0x20, 0x7c, 0x20,
  0x20, 0x5f, 0x5f, 0x2f, 0x20, 0x7c, 0x20, 0x20, 0x7c, 0x20, 0x7c, 0x20,
  0x7c, 0x20, 0x7c, 0x0a, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x2f, 0x20, 0x5c,
  0x5f, 0x5f, 0x5f, 0x7c, 0x5c, 0x5f, 0x5f, 0x5c, 0x5f, 0x5f, 0x2c, 0x5f,
  0x7c, 0x5f, 0x5f, 0x5f, 0x2f, 0x20, 0x2e, 0x5f, 0x5f, 0x2f, 0x7c, 0x5f,
  0x7c, 0x5f, 0x7c, 0x20, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x7c, 0x20, 0x7c,
  0x5f, 0x5f, 0x5f, 0x5f, 0x2f, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x7c, 0x5f,
  0x7c, 0x20, 0x20, 0x7c, 0x5f, 0x7c, 0x20, 0x7c, 0x5f, 0x7c, 0x0a, 0x20,
  0x20, 0x77, 0x77, 0x77, 0x2e, 0x6f, 0x63, 0x74, 0x61, 0x73, 0x70, 0x69,
  0x72, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x64, 0x65, 0x72, 0x6e, 0x7c,
  0x5f, 0x7c, 0x52, 0x45, 0x50, 0x4c, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74,
  0x68, 0x65, 0x20, 0x44, 0x65, 0x72, 0x6e, 0x20, 0x50, 0x72, 0x6f, 0x67,
  0x72, 0x61, 0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x20, 0x4c, 0x61, 0x6e, 0x67,
  0x75, 0x61, 0x67, 0x65, 0x2e, 0x0a
};
unsigned int octaspire_dern_banner_white_len = 402;
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/external/octaspire_dern_banner_white.h
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/src/octaspire_dern_repl.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifndef OCTASPIRE_DERN_DO_NOT_USE_AMALGAMATED_CORE
#else
#endif


#define ANSI_COLOR_RED    "\x1B[31m"
#define ANSI_COLOR_GREEN  "\x1B[32m"
#define ANSI_COLOR_YELLOW "\x1B[33m"
#define ANSI_COLOR_DGRAY  "\x1B[1;30m"
#define ANSI_COLOR_RESET  "\x1B[0m"

typedef enum
{
    OCTASPIRE_DERN_REPL_MESSAGE_INFO,
    OCTASPIRE_DERN_REPL_MESSAGE_OUTPUT,
    OCTASPIRE_DERN_REPL_MESSAGE_ERROR,
    OCTASPIRE_DERN_REPL_MESSAGE_FATAL
}
octaspire_dern_repl_message_t;

static void octaspire_dern_repl_print_message_c_str(
    char const * const message,
    octaspire_dern_repl_message_t const messageType,
    bool const useColors);

static void octaspire_dern_repl_print_message(
    octaspire_string_t const * const message,
    octaspire_dern_repl_message_t const messageType,
    bool const useColors);

static void octaspire_dern_repl_print_version(bool const useColors);

static void octaspire_dern_repl_print_banner(bool const useColors);

static void octaspire_dern_repl_print_usage(
    char const * const binaryName,
    bool const useColors);



static void octaspire_dern_repl_print_message_c_str(
    char const * const message,
    octaspire_dern_repl_message_t const messageType,
    bool const useColors)
{
    if (useColors)
    {
        switch (messageType)
        {
            case OCTASPIRE_DERN_REPL_MESSAGE_INFO:
            {
                printf(ANSI_COLOR_DGRAY);
            }
            break;

            case OCTASPIRE_DERN_REPL_MESSAGE_OUTPUT:
            {
                printf(ANSI_COLOR_GREEN);
            }
            break;

            case OCTASPIRE_DERN_REPL_MESSAGE_ERROR:
            {
                printf(ANSI_COLOR_RED);
            }
            break;

            case OCTASPIRE_DERN_REPL_MESSAGE_FATAL:
            {
                printf(ANSI_COLOR_YELLOW);
            }
            break;
        }
    }

    printf("%s", message);

    if (useColors)
    {
        printf(ANSI_COLOR_RESET);
    }
}

void octaspire_dern_repl_print_message(
    octaspire_string_t const * const message,
    octaspire_dern_repl_message_t const messageType,
    bool const useColors)
{
    octaspire_dern_repl_print_message_c_str(
        octaspire_string_get_c_string(message),
        messageType,
        useColors);
}

void octaspire_dern_repl_print_version(bool const useColors)
{
    printf("  ");
    octaspire_dern_repl_print_message_c_str(
        OCTASPIRE_DERN_CONFIG_VERSION_STR,
        OCTASPIRE_DERN_REPL_MESSAGE_INFO,
        useColors);

    printf("\n");
}

void octaspire_dern_repl_print_banner(bool const useColors)
{
    printf("\n");
    if (useColors)
    {
        for (size_t i = 0; i < octaspire_dern_banner_color_len; ++i)
        {
            putchar(octaspire_dern_banner_color[i]);
        }
    }
    else
    {
        for (size_t i = 0; i < octaspire_dern_banner_white_len; ++i)
        {
            putchar(octaspire_dern_banner_white[i]);
        }
    }

    octaspire_dern_repl_print_message_c_str(
        "  \n"
        "  Licensed under the Apache License, Version 2.0. Distributed on\n"
        "  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND.\n\n",
        OCTASPIRE_DERN_REPL_MESSAGE_INFO, useColors);
}

void octaspire_dern_repl_print_usage(char const * const binaryName, bool const useColors)
{
    octaspire_dern_repl_print_banner(useColors);
    octaspire_dern_repl_print_version(useColors);
    printf("\nusage: %s [option] ... [file] ...\n", binaryName);

    char const * const str =
        "\nwhere [option] is one of the values listed below and every\n"
        "[file] is loaded and evaluated before the REPL is started or closed.\n"
        "If any of -e string or [file] is used, REPL is not started unless -i is used.\n\n"
        "-c        --color-diagnostics : use colors on unix like systems\n"
        "-i        --interactive       : start REPL after any -e string or [file]s are evaluated\n"
        "-e string --evaluate string   : evaluate a string without entering the REPL (see -i)\n"
        "-v        --version           : print version information and exit\n"
        "-h        --help              : print this help message and exit\n"
        "-g        --debug             : print every form to stderr before it is evaluated\n"
        "-d        --no-dlclose        : do not close dynamic libraries;\n"
        "                                useful when searching memory leaks from plugins\n"
        "                                using Valgrind\n";

    printf("%s", str);
}


// Globals for the REPL. ////////////////////////////
static octaspire_vector_t      *stringsToBeEvaluated = 0;
static octaspire_allocator_t      *allocatorBootOnly    = 0;
static octaspire_string_t *line                 = 0;
static octaspire_stdio_t                 *stdio                = 0;
static octaspire_input_t                 *input                = 0;
static octaspire_dern_vm_t               *vm                   = 0;
static octaspire_allocator_t      *allocator            = 0;

static void octaspire_dern_repl_private_cleanup(void)
{
    octaspire_vector_release(stringsToBeEvaluated);
    stringsToBeEvaluated = 0;

    octaspire_allocator_release(allocatorBootOnly);
    allocatorBootOnly = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_stdio_release(stdio);
    stdio = 0;

    octaspire_allocator_release(allocator);
    allocator = 0;
}

#ifdef OCTASPIRE_PLAN9_IMPLEMENTATION
void main(int argc, char *argv[])
#else
    #ifdef _WIN32
    int main(int argc, char *argv[], char *environ[])
    #elif __amigaos__
    int main(int argc, char *argv[], char *environ[])
    #else
    int main(int argc, char *argv[])
    #endif
#endif
{
#ifndef OCTASPIRE_PLAN9_IMPLEMENTATION
    setlocale(LC_ALL, "");
#endif
    bool useColors               = false;
    int  userFilesStartIdx       = -1;
    bool enterReplAlways         = false;
    bool evaluate                = false;

    octaspire_dern_vm_config_t vmConfig = octaspire_dern_vm_config_default();

#ifdef OCTASPIRE_PLAN9_IMPLEMENTATION
    if (atexit(octaspire_dern_repl_private_cleanup) == 0)
#else
    if (atexit(octaspire_dern_repl_private_cleanup) != 0)
#endif
    {
        octaspire_dern_repl_print_message_c_str(
            "Cannot register the 'atexit' function",
            OCTASPIRE_DERN_REPL_MESSAGE_FATAL,
            useColors);

        exit(EXIT_FAILURE);
    }

    allocatorBootOnly = octaspire_allocator_new(0);

    if (!allocatorBootOnly)
    {
        octaspire_dern_repl_print_message_c_str(
            "Cannot create boot allocator",
            OCTASPIRE_DERN_REPL_MESSAGE_FATAL,
            useColors);

        exit(EXIT_FAILURE);
    }

    stringsToBeEvaluated = octaspire_vector_new(
        sizeof(octaspire_string_t*),
        true,
        (octaspire_vector_element_callback_t)octaspire_string_release,
        allocatorBootOnly);

    if (!stringsToBeEvaluated)
    {
        octaspire_dern_repl_print_message_c_str(
            "Cannot create evaluation vector",
            OCTASPIRE_DERN_REPL_MESSAGE_FATAL,
            useColors);

        exit(EXIT_FAILURE);
    }

    if (argc > 1)
    {
        for (int i = 1; i < argc; ++i)
        {
            if (evaluate)
            {
                evaluate = false;

                octaspire_string_t *tmp = octaspire_string_new(
                    argv[i],
                    allocatorBootOnly);

                if (!tmp)
                {
                    octaspire_dern_repl_print_message_c_str(
                        "Cannot create string to be evaluated",
                        OCTASPIRE_DERN_REPL_MESSAGE_FATAL,
                        useColors);

                    exit(EXIT_FAILURE);
                }

                octaspire_vector_push_back_element(stringsToBeEvaluated, &tmp);
            }
            else if (strcmp(argv[i], "-c") == 0 || strcmp(argv[i], "--color-diagnostics") == 0)
            {
                useColors = true;
            }
            else if (strcmp(argv[i], "-i") == 0 || strcmp(argv[i], "--interactive") == 0)
            {
                enterReplAlways = true;
            }
            else if (strcmp(argv[i], "-e") == 0 || strcmp(argv[i], "--evaluate") == 0)
            {
                evaluate = true;
            }
            else if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--version") == 0)
            {
                octaspire_dern_repl_print_version(useColors);
                exit(EXIT_SUCCESS);
            }
            else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0)
            {
                octaspire_dern_repl_print_usage(argv[0], useColors);
                exit(EXIT_SUCCESS);
            }
            else if (strcmp(argv[i], "-g") == 0 || strcmp(argv[i], "--debug") == 0)
            {
                vmConfig.debugModeOn = true;
            }
            else if (strcmp(argv[i], "-d") == 0 || strcmp(argv[i], "--no-dlclose") == 0)
            {
                vmConfig.noDlClose = true;
            }
            else
            {
                if (argv[i][0] == '-')
                {
                    printf("Unknown argument %s\n\n", argv[i]);
                    octaspire_dern_repl_print_usage(argv[0], useColors);
                    exit(EXIT_FAILURE);
                }
                else
                {
                    if (userFilesStartIdx < 0)
                    {
                        userFilesStartIdx = i;
                        break;
                    }
                }
            }
        }
    }

    allocator = octaspire_allocator_new(0);

    if (!allocator)
    {
        octaspire_dern_repl_print_message_c_str(
            "Allocation failure\n",
            OCTASPIRE_DERN_REPL_MESSAGE_FATAL,
            useColors);

        exit(EXIT_FAILURE);
    }

    line  = 0;
    stdio = octaspire_stdio_new(allocator);
    input = octaspire_input_new_from_c_string("", allocator);
    vm    = octaspire_dern_vm_new_with_config(allocator, stdio, vmConfig);

#ifndef OCTASPIRE_PLAN9_IMPLEMENTATION
#ifndef _WIN32
    #ifndef __amigaos__
    extern char **environ;
    #endif
#endif

    for (char **var = environ; *var; ++var)
    {
        octaspire_dern_vm_add_environment_variable(vm, *var);
    }
#endif

    // Eval all files given as cmdline args
    for (size_t i = 0; i < octaspire_vector_get_length(stringsToBeEvaluated); ++i)
    {
        octaspire_string_t const * const str =
            octaspire_vector_get_element_at_const(
                stringsToBeEvaluated,
                (ptrdiff_t)i);

        octaspire_dern_value_t *value =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
                vm,
                octaspire_string_get_c_string(str));

        octaspire_helpers_verify_not_null(value);

        if (value->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_string_t *tmpStr =
                octaspire_dern_value_to_string(value, allocator);

            octaspire_dern_repl_print_message(tmpStr, OCTASPIRE_DERN_REPL_MESSAGE_ERROR, useColors);

            printf("\n");

            octaspire_string_release(tmpStr);
            tmpStr = 0;

            exit(EXIT_FAILURE);
        }
    }

    if (userFilesStartIdx >= 0)
    {
        for (int i = userFilesStartIdx + 1; i < argc; ++i)
        {
            octaspire_dern_vm_add_command_line_argument(vm, argv[i]);
        }

        octaspire_dern_value_t *value =
            octaspire_dern_vm_read_from_path_and_eval_in_global_environment(
                vm,
                argv[userFilesStartIdx]);

        octaspire_helpers_verify_not_null(value);

        if (value->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_string_t *str =
                octaspire_dern_value_to_string(value, allocator);

            octaspire_dern_repl_print_message(str, OCTASPIRE_DERN_REPL_MESSAGE_ERROR, useColors);

            printf("\n");

            octaspire_string_release(str);
            str = 0;

            exit(EXIT_FAILURE);
        }
    }

    if (octaspire_vector_get_length(stringsToBeEvaluated) > 0 || userFilesStartIdx >= 0)
    {
        if (!enterReplAlways)
        {
            goto octaspire_dern_repl_cleanup;
        }
    }

    octaspire_dern_repl_print_banner(useColors);
    octaspire_dern_repl_print_version(useColors);

    octaspire_dern_repl_print_message_c_str(
        "\n  Quit by pressing CTRL-d on empty line\n"
        "  or by writing (exit) and then enter.\n\n",
        OCTASPIRE_DERN_REPL_MESSAGE_INFO, useColors);

    do
    {
        octaspire_dern_repl_print_message_c_str(
            "> ",
            OCTASPIRE_DERN_REPL_MESSAGE_INFO, useColors);
moreInput:
        line = octaspire_stdio_read_line(stdio, stdin);

        if (!line)
        {
            break;
        }

        if (line && octaspire_string_get_length_in_ucs_characters(line) > 0)
        {
            octaspire_input_push_back_from_string(input, line);

            octaspire_dern_lexer_token_t *token =
                octaspire_dern_lexer_pop_next_token(input, allocator);

            if (!token)
            {
                goto noToken;
            }

            octaspire_dern_value_t *parsedValue =
                octaspire_dern_vm_parse_token(vm, token, input);

            octaspire_dern_lexer_token_release(token);
            token = 0;

            if (!parsedValue)
            {
                octaspire_input_rewind(input);

                octaspire_dern_repl_print_message_c_str(
                    "| ",
                    OCTASPIRE_DERN_REPL_MESSAGE_INFO, useColors);

                goto moreInput;
            }

            octaspire_dern_vm_push_value(vm, parsedValue);

            octaspire_dern_value_t *evaluatedValue =
                octaspire_dern_vm_eval_in_global_environment(vm, parsedValue);

            if (!evaluatedValue)
            {
                octaspire_input_rewind(input);

                octaspire_dern_repl_print_message_c_str(
                    "| ",
                    OCTASPIRE_DERN_REPL_MESSAGE_INFO, useColors);

                octaspire_dern_vm_pop_value(vm, parsedValue);
                goto moreInput;
            }

            octaspire_string_t *str =
                octaspire_dern_value_to_string(evaluatedValue, allocator);

            octaspire_dern_repl_print_message(
                str,
                (parsedValue->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    ? OCTASPIRE_DERN_REPL_MESSAGE_ERROR
                    : OCTASPIRE_DERN_REPL_MESSAGE_OUTPUT,
                useColors);

            octaspire_dern_vm_pop_value(vm, parsedValue);

        noToken:
            printf("\n");

            octaspire_string_release(str);
            str = 0;

            octaspire_input_clear(input);
        }

        octaspire_string_release(line);
        line = 0;
    }
    while (!octaspire_dern_vm_is_quit(vm));


octaspire_dern_repl_cleanup:
    // A label can only be part of a statement
    for (size_t i = 0; i < 1; ++i)
    {
    }

    int32_t exitCode = EXIT_FAILURE;

    if (vm)
    {
        exitCode = octaspire_dern_vm_get_exit_code(vm);
    }

    octaspire_dern_repl_private_cleanup();

#ifdef OCTASPIRE_PLAN9_IMPLEMENTATION
    exits(exitCode == EXIT_SUCCESS ? "" : "error");
#else
    return exitCode;
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/src/octaspire_dern_repl.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/etc/amalgamation_impl_unit_test_head.c
//////////////////////////////////////////////////////////////////////////////////////////////////
#endif // OCTASPIRE_DERN_AMALGAMATED_REPL_IMPLEMENTATION

#ifdef OCTASPIRE_DERN_AMALGAMATED_UNIT_TEST_IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/etc/amalgamation_impl_unit_test_head.c
//////////////////////////////////////////////////////////////////////////////////////////////////
// This file is modified by www.octaspire.com. The original copyright is:

/*
 * Copyright (c) 2011-2016 Scott Vokes <vokes.s@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

// Modifications are released under similar license:

/*
 * Copyright (c) 2017 www.octaspire.com
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef GREATEST_H
#define GREATEST_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef GREATEST_ENABLE_ANSI_COLORS
#define GREATEST_ANSI_COLOR_RED    "\x1B[31m"
#define GREATEST_ANSI_COLOR_GREEN  "\x1B[32m"
#define GREATEST_ANSI_COLOR_YELLOW "\x1B[33m"
#define GREATEST_ANSI_COLOR_DGRAY  "\x1B[1;30m"
#define GREATEST_ANSI_COLOR_RESET  "\x1B[0m"
#else
#define GREATEST_ANSI_COLOR_RED    ""
#define GREATEST_ANSI_COLOR_GREEN  ""
#define GREATEST_ANSI_COLOR_YELLOW ""
#define GREATEST_ANSI_COLOR_DGRAY  ""
#define GREATEST_ANSI_COLOR_RESET  ""
#endif

/* 1.2.2 */
#define GREATEST_VERSION_MAJOR 1
#define GREATEST_VERSION_MINOR 2
#define GREATEST_VERSION_PATCH 2

/* A unit testing system for C, contained in 1 file.
 * It doesn't use dynamic allocation or depend on anything
 * beyond ANSI C89.
 *
 * An up-to-date version can be found at:
 *     https://github.com/silentbicycle/greatest/
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/***********
 * Options *
 ***********/

/* Default column width for non-verbose output. */
#ifndef GREATEST_DEFAULT_WIDTH
#define GREATEST_DEFAULT_WIDTH 72
#endif

/* FILE *, for test logging. */
#ifndef GREATEST_STDOUT
#define GREATEST_STDOUT stdout
#endif

/* Remove GREATEST_ prefix from most commonly used symbols? */
#ifndef GREATEST_USE_ABBREVS
#define GREATEST_USE_ABBREVS 1
#endif

/* Set to 0 to disable all use of setjmp/longjmp. */
#ifndef GREATEST_USE_LONGJMP
#define GREATEST_USE_LONGJMP 1
#endif

#ifdef GREATEST_USE_LONGJMP
#include <setjmp.h>
#endif

/* Set to 0 to disable all use of time.h / clock(). */
#ifndef GREATEST_USE_TIME
#define GREATEST_USE_TIME 1
#endif

#ifdef GREATEST_USE_TIME
#include <time.h>
#endif

/* Floating point type, for ASSERT_IN_RANGE. */
#ifndef GREATEST_FLOAT
#define GREATEST_FLOAT double
#define GREATEST_FLOAT_FMT "%g"
#endif

/*********
 * Types *
 *********/

/* Info for the current running suite. */
typedef struct greatest_suite_info {
    unsigned int tests_run;
    unsigned int passed;
    unsigned int failed;
    unsigned int skipped;

#ifdef GREATEST_USE_TIME
    /* timers, pre/post running suite and individual tests */
    clock_t pre_suite;
    clock_t post_suite;
    clock_t pre_test;
    clock_t post_test;
#endif
} greatest_suite_info;

/* Type for a suite function. */
typedef void (greatest_suite_cb)(void);

/* Types for setup/teardown callbacks. If non-NULL, these will be run
 * and passed the pointer to their additional data. */
typedef void (greatest_setup_cb)(void *udata);
typedef void (greatest_teardown_cb)(void *udata);

/* Type for an equality comparison between two pointers of the same type.
 * Should return non-0 if equal, otherwise 0.
 * UDATA is a closure value, passed through from ASSERT_EQUAL_T[m]. */
typedef int greatest_equal_cb(const void *exp, const void *got, void *udata);

/* Type for a callback that prints a value pointed to by T.
 * Return value has the same meaning as printf's.
 * UDATA is a closure value, passed through from ASSERT_EQUAL_T[m]. */
typedef int greatest_printf_cb(const void *t, void *udata);

/* Callbacks for an arbitrary type; needed for type-specific
 * comparisons via GREATEST_ASSERT_EQUAL_T[m].*/
typedef struct greatest_type_info {
    greatest_equal_cb *equal;
    greatest_printf_cb *print;
} greatest_type_info;

typedef struct greatest_memory_cmp_env {
    const unsigned char *exp;
    const unsigned char *got;
    size_t size;
} greatest_memory_cmp_env;

/* Callbacks for string and raw memory types. */
extern greatest_type_info greatest_type_info_string;
extern greatest_type_info greatest_type_info_memory;

typedef enum {
    GREATEST_FLAG_FIRST_FAIL = 0x01,
    GREATEST_FLAG_LIST_ONLY = 0x02
} greatest_flag_t;

/* Struct containing all test runner state. */
typedef struct greatest_run_info {
    unsigned char flags;
    unsigned char verbosity;
    unsigned char pad_0[2];

    unsigned int tests_run;     /* total test count */

    /* currently running test suite */
    greatest_suite_info suite;

    /* overall pass/fail/skip counts */
    unsigned int passed;
    unsigned int failed;
    unsigned int skipped;
    unsigned int assertions;

    /* info to print about the most recent failure */
    unsigned int fail_line;
    unsigned int pad_1;
    const char *fail_file;
    const char *msg;

    /* current setup/teardown hooks and userdata */
    greatest_setup_cb *setup;
    void *setup_udata;
    greatest_teardown_cb *teardown;
    void *teardown_udata;

    /* formatting info for ".....s...F"-style output */
    unsigned int col;
    unsigned int width;

    /* only run a specific suite or test */
    const char *suite_filter;
    const char *test_filter;

#ifdef GREATEST_USE_TIME
    /* overall timers */
    clock_t begin;
    clock_t end;
#endif

#ifdef GREATEST_USE_LONGJMP
    int pad_jmp_buf;
    char octaspire_padding[4];
    jmp_buf jump_dest;
#endif
} greatest_run_info;

struct greatest_report_t {
    /* overall pass/fail/skip counts */
    unsigned int passed;
    unsigned int failed;
    unsigned int skipped;
    unsigned int assertions;
};

/* Global var for the current testing context.
 * Initialized by GREATEST_MAIN_DEFS(). */
extern greatest_run_info greatest_info;

/* Type for ASSERT_ENUM_EQ's ENUM_STR argument. */
typedef const char *greatest_enum_str_fun(int value);

/**********************
 * Exported functions *
 **********************/

/* These are used internally by greatest. */
void greatest_do_pass(const char *name);
void greatest_do_fail(const char *name);
void greatest_do_skip(const char *name);
int greatest_pre_test(const char *name);
void greatest_post_test(const char *name, int res);
void greatest_usage(const char *name);
int greatest_do_assert_equal_t(const void *exp, const void *got,
    greatest_type_info *type_info, void *udata);

/* These are part of the public greatest API. */
void GREATEST_SET_SETUP_CB(greatest_setup_cb *cb, void *udata);
void GREATEST_SET_TEARDOWN_CB(greatest_teardown_cb *cb, void *udata);
int greatest_all_passed(void);
void greatest_set_test_filter(const char *name);
void greatest_set_suite_filter(const char *name);
void greatest_get_report(struct greatest_report_t *report);
unsigned int greatest_get_verbosity(void);
void greatest_set_verbosity(unsigned int verbosity);
void greatest_set_flag(greatest_flag_t flag);


/********************
* Language Support *
********************/

/**********
 * Macros *
 **********/

/* Define a suite. */
#define GREATEST_SUITE(NAME) void NAME(void); void NAME(void)

/* Declare a suite, provided by another compilation unit. */
#define GREATEST_SUITE_EXTERN(NAME) void NAME(void)

/* Start defining a test function.
 * The arguments are not included, to allow parametric testing. */
#define GREATEST_TEST static enum greatest_test_res

/* PASS/FAIL/SKIP result from a test. Used internally. */
typedef enum greatest_test_res {
    GREATEST_TEST_RES_PASS = 0,
    GREATEST_TEST_RES_FAIL = -1,
    GREATEST_TEST_RES_SKIP = 1
} greatest_test_res;

/* Run a suite. */
#define GREATEST_RUN_SUITE(S_NAME) greatest_run_suite(S_NAME, #S_NAME)

/* Run a test in the current suite. */
#define GREATEST_RUN_TEST(TEST)                                         \
    do {                                                                \
        if (greatest_pre_test(#TEST) == 1) {                            \
            enum greatest_test_res res = GREATEST_SAVE_CONTEXT();       \
            if (res == GREATEST_TEST_RES_PASS) {                        \
                res = TEST();                                           \
            }                                                           \
            greatest_post_test(#TEST, res);                             \
        } else if (GREATEST_LIST_ONLY()) {                              \
            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
        }                                                               \
    } while (0)

/* Ignore a test, don't warn about it being unused. */
#define GREATEST_IGNORE_TEST(TEST) (void)TEST

/* Run a test in the current suite with one void * argument,
 * which can be a pointer to a struct with multiple arguments. */
#define GREATEST_RUN_TEST1(TEST, ENV)                                   \
    do {                                                                \
        if (greatest_pre_test(#TEST) == 1) {                            \
            int res = TEST(ENV);                                        \
            greatest_post_test(#TEST, res);                             \
        } else if (GREATEST_LIST_ONLY()) {                              \
            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
        }                                                               \
    } while (0)

#ifdef GREATEST_VA_ARGS
#define GREATEST_RUN_TESTp(TEST, ...)                                   \
    do {                                                                \
        if (greatest_pre_test(#TEST) == 1) {                            \
            int res = TEST(__VA_ARGS__);                                \
            greatest_post_test(#TEST, res);                             \
        } else if (GREATEST_LIST_ONLY()) {                              \
            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
        }                                                               \
    } while (0)
#endif


/* Check if the test runner is in verbose mode. */
#define GREATEST_IS_VERBOSE() ((greatest_info.verbosity) > 0)
#define GREATEST_LIST_ONLY()                                            \
    (greatest_info.flags & GREATEST_FLAG_LIST_ONLY)
#define GREATEST_FIRST_FAIL()                                           \
    (greatest_info.flags & GREATEST_FLAG_FIRST_FAIL)
#define GREATEST_FAILURE_ABORT()                                        \
    (greatest_info.suite.failed > 0 && GREATEST_FIRST_FAIL())

/* Message-less forms of tests defined below. */
#define GREATEST_PASS() GREATEST_PASSm(NULL)
#define GREATEST_FAIL() GREATEST_FAILm(NULL)
#define GREATEST_SKIP() GREATEST_SKIPm(NULL)
#define GREATEST_ASSERT(COND)                                           \
    GREATEST_ASSERTm(#COND, COND)
#define GREATEST_ASSERT_OR_LONGJMP(COND)                                \
    GREATEST_ASSERT_OR_LONGJMPm(#COND, COND)
#define GREATEST_ASSERT_FALSE(COND)                                     \
    GREATEST_ASSERT_FALSEm(#COND, COND)
#define GREATEST_ASSERT_EQ(EXP, GOT)                                    \
    GREATEST_ASSERT_EQm(#EXP " != " #GOT, EXP, GOT)
#define GREATEST_ASSERT_EQ_FMT(EXP, GOT, FMT)                           \
    GREATEST_ASSERT_EQ_FMTm(#EXP " != " #GOT, EXP, GOT, FMT)
#define GREATEST_ASSERT_IN_RANGE(EXP, GOT, TOL)                         \
    GREATEST_ASSERT_IN_RANGEm(#EXP " != " #GOT " +/- " #TOL, EXP, GOT, TOL)
#define GREATEST_ASSERT_EQUAL_T(EXP, GOT, TYPE_INFO, UDATA)             \
    GREATEST_ASSERT_EQUAL_Tm(#EXP " != " #GOT, EXP, GOT, TYPE_INFO, UDATA)
#define GREATEST_ASSERT_STR_EQ(EXP, GOT)                                \
    GREATEST_ASSERT_STR_EQm(#EXP " != " #GOT, EXP, GOT)
#define GREATEST_ASSERT_STRN_EQ(EXP, GOT, SIZE)                         \
    GREATEST_ASSERT_STRN_EQm(#EXP " != " #GOT, EXP, GOT, SIZE)
#define GREATEST_ASSERT_MEM_EQ(EXP, GOT, SIZE)                          \
    GREATEST_ASSERT_MEM_EQm(#EXP " != " #GOT, EXP, GOT, SIZE)
#define GREATEST_ASSERT_ENUM_EQ(EXP, GOT, ENUM_STR)                     \
    GREATEST_ASSERT_ENUM_EQm(#EXP " != " #GOT, EXP, GOT, ENUM_STR)

/* The following forms take an additional message argument first,
 * to be displayed by the test runner. */

/* Fail if a condition is not true, with message. */
#define GREATEST_ASSERTm(MSG, COND)                                     \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if (!(COND)) { GREATEST_FAILm(MSG); }                           \
    } while (0)

/* Fail if a condition is not true, longjmping out of test. */
#define GREATEST_ASSERT_OR_LONGJMPm(MSG, COND)                          \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if (!(COND)) { GREATEST_FAIL_WITH_LONGJMPm(MSG); }              \
    } while (0)

/* Fail if a condition is not false, with message. */
#define GREATEST_ASSERT_FALSEm(MSG, COND)                               \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if ((COND)) { GREATEST_FAILm(MSG); }                            \
    } while (0)

/* Fail if EXP != GOT (equality comparison by ==). */
#define GREATEST_ASSERT_EQm(MSG, EXP, GOT)                              \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if ((EXP) != (GOT)) { GREATEST_FAILm(MSG); }                    \
    } while (0)

/* Fail if EXP != GOT (equality comparison by ==).
 * Warning: FMT, EXP, and GOT will be evaluated more
 * than once on failure. */
#define GREATEST_ASSERT_EQ_FMTm(MSG, EXP, GOT, FMT)                     \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if ((EXP) != (GOT)) {                                           \
            fprintf(GREATEST_STDOUT, "\nExpected: ");                   \
            fprintf(GREATEST_STDOUT, FMT, EXP);                         \
            fprintf(GREATEST_STDOUT, "\n     Got: ");                   \
            fprintf(GREATEST_STDOUT, FMT, GOT);                         \
            fprintf(GREATEST_STDOUT, "\n");                             \
            GREATEST_FAILm(MSG);                                        \
        }                                                               \
    } while (0)

/* Fail if EXP is not equal to GOT, printing enum IDs. */
#define GREATEST_ASSERT_ENUM_EQm(MSG, EXP, GOT, ENUM_STR)               \
    do {                                                                \
        int greatest_EXP = (int)(EXP);                                  \
        int greatest_GOT = (int)(GOT);                                  \
        greatest_enum_str_fun *greatest_ENUM_STR = ENUM_STR;            \
        if (greatest_EXP != greatest_GOT) {                             \
            fprintf(GREATEST_STDOUT, "\nExpected: %s",                  \
                greatest_ENUM_STR(greatest_EXP));                       \
            fprintf(GREATEST_STDOUT, "\n     Got: %s\n",                \
                greatest_ENUM_STR(greatest_GOT));                       \
            GREATEST_FAILm(MSG);                                        \
        }                                                               \
    } while (0)                                                         \

/* Fail if GOT not in range of EXP +|- TOL. */
#define GREATEST_ASSERT_IN_RANGEm(MSG, EXP, GOT, TOL)                   \
    do {                                                                \
        GREATEST_FLOAT greatest_EXP = (EXP);                            \
        GREATEST_FLOAT greatest_GOT = (GOT);                            \
        GREATEST_FLOAT greatest_TOL = (TOL);                            \
        greatest_info.assertions++;                                     \
        if ((greatest_EXP > greatest_GOT &&                             \
                greatest_EXP - greatest_GOT > greatest_TOL) ||          \
            (greatest_EXP < greatest_GOT &&                             \
                greatest_GOT - greatest_EXP > greatest_TOL)) {          \
            fprintf(GREATEST_STDOUT,                                    \
                "\nExpected: " GREATEST_FLOAT_FMT                       \
                " +/- " GREATEST_FLOAT_FMT                              \
                "\n     Got: " GREATEST_FLOAT_FMT                       \
                "\n",                                                   \
                greatest_EXP, greatest_TOL, greatest_GOT);              \
            GREATEST_FAILm(MSG);                                        \
        }                                                               \
    } while (0)

/* Fail if EXP is not equal to GOT, according to strcmp. */
#define GREATEST_ASSERT_STR_EQm(MSG, EXP, GOT)                          \
    do {                                                                \
        GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT,                         \
            &greatest_type_info_string, NULL);                          \
    } while (0)                                                         \

/* Fail if EXP is not equal to GOT, according to strcmp. */
#define GREATEST_ASSERT_STRN_EQm(MSG, EXP, GOT, SIZE)                   \
    do {                                                                \
        size_t size = SIZE;                                             \
        GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT,                         \
            &greatest_type_info_string, &size);                         \
    } while (0)                                                         \

/* Fail if EXP is not equal to GOT, according to memcmp. */
#define GREATEST_ASSERT_MEM_EQm(MSG, EXP, GOT, SIZE)                    \
    do {                                                                \
        greatest_memory_cmp_env env;                                    \
        env.exp = (const unsigned char *)EXP;                           \
        env.got = (const unsigned char *)GOT;                           \
        env.size = SIZE;                                                \
        GREATEST_ASSERT_EQUAL_Tm(MSG, env.exp, env.got,                 \
            &greatest_type_info_memory, &env);                          \
    } while (0)                                                         \

/* Fail if EXP is not equal to GOT, according to a comparison
 * callback in TYPE_INFO. If they are not equal, optionally use a
 * print callback in TYPE_INFO to print them. */
#define GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT, TYPE_INFO, UDATA)       \
    do {                                                                \
        greatest_type_info *type_info = (TYPE_INFO);                    \
        greatest_info.assertions++;                                     \
        if (!greatest_do_assert_equal_t(EXP, GOT,                       \
                type_info, UDATA)) {                                    \
            if (type_info == NULL || type_info->equal == NULL) {        \
                GREATEST_FAILm("type_info->equal callback missing!");   \
            } else {                                                    \
                GREATEST_FAILm(MSG);                                    \
            }                                                           \
        }                                                               \
    } while (0)                                                         \

/* Pass. */
#define GREATEST_PASSm(MSG)                                             \
    do {                                                                \
        greatest_info.msg = MSG;                                        \
        return GREATEST_TEST_RES_PASS;                                  \
    } while (0)

/* Fail. */
#define GREATEST_FAILm(MSG)                                             \
    do {                                                                \
        greatest_info.fail_file = __FILE__;                             \
        greatest_info.fail_line = __LINE__;                             \
        greatest_info.msg = MSG;                                        \
        return GREATEST_TEST_RES_FAIL;                                  \
    } while (0)

/* Optional GREATEST_FAILm variant that longjmps. */
#ifdef GREATEST_USE_LONGJMP
#define GREATEST_FAIL_WITH_LONGJMP() GREATEST_FAIL_WITH_LONGJMPm(NULL)
#define GREATEST_FAIL_WITH_LONGJMPm(MSG)                                \
    do {                                                                \
        greatest_info.fail_file = __FILE__;                             \
        greatest_info.fail_line = __LINE__;                             \
        greatest_info.msg = MSG;                                        \
        longjmp(greatest_info.jump_dest, GREATEST_TEST_RES_FAIL);       \
    } while (0)
#endif

/* Skip the current test. */
#define GREATEST_SKIPm(MSG)                                             \
    do {                                                                \
        greatest_info.msg = MSG;                                        \
        return GREATEST_TEST_RES_SKIP;                                  \
    } while (0)

/* Check the result of a subfunction using ASSERT, etc. */
#define GREATEST_CHECK_CALL(RES)                                        \
    do {                                                                \
        enum greatest_test_res greatest_RES = RES;                      \
        if (greatest_RES != GREATEST_TEST_RES_PASS) {                   \
            return greatest_RES;                                        \
        }                                                               \
    } while (0)                                                         \

#ifdef GREATEST_USE_TIME
#define GREATEST_SET_TIME(NAME)                                         \
    NAME = clock();                                                     \
    if (NAME == (clock_t) -1) {                                         \
        fprintf(GREATEST_STDOUT,                                        \
            "clock error: %s\n", #NAME);                                \
        exit(EXIT_FAILURE);                                             \
    }

#define GREATEST_CLOCK_DIFF(C1, C2)                                     \
    fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_DGRAY " (%lu ticks, %.3f sec)" GREATEST_ANSI_COLOR_RESET, \
        (long unsigned int) (C2) - (long unsigned int)(C1),             \
        (double)((C2) - (C1)) / (1.0 * (double)CLOCKS_PER_SEC))
#else
#define GREATEST_SET_TIME(UNUSED)
#define GREATEST_CLOCK_DIFF(UNUSED1, UNUSED2)
#endif

#ifdef GREATEST_USE_LONGJMP
#define GREATEST_SAVE_CONTEXT()                                         \
        /* setjmp returns 0 (GREATEST_TEST_RES_PASS) on first call */   \
        /* so the test runs, then RES_FAIL from FAIL_WITH_LONGJMP. */   \
        ((enum greatest_test_res)(setjmp(greatest_info.jump_dest)))
#else
#define GREATEST_SAVE_CONTEXT()                                         \
    /*a no-op, since setjmp/longjmp aren't being used */                \
    GREATEST_TEST_RES_PASS
#endif

/* Include several function definitions in the main test file. */
#define GREATEST_MAIN_DEFS()                                            \
                                                                        \
/* Is FILTER a subset of NAME? */                                       \
static int greatest_name_match(const char *name,                        \
    const char *filter) {                                               \
    size_t offset = 0;                                                  \
    size_t filter_len = strlen(filter);                                 \
    while (name[offset] != '\0') {                                      \
        if (name[offset] == filter[0]) {                                \
            if (0 == strncmp(&name[offset], filter, filter_len)) {      \
                return 1;                                               \
            }                                                           \
        }                                                               \
        offset++;                                                       \
    }                                                                   \
                                                                        \
    return 0;                                                           \
}                                                                       \
                                                                        \
int greatest_pre_test(const char *name) {                               \
    if (!GREATEST_LIST_ONLY()                                           \
        && (!GREATEST_FIRST_FAIL() || greatest_info.suite.failed == 0)  \
        && (greatest_info.test_filter == NULL ||                        \
            greatest_name_match(name, greatest_info.test_filter))) {    \
        GREATEST_SET_TIME(greatest_info.suite.pre_test);                \
        if (greatest_info.setup) {                                      \
            greatest_info.setup(greatest_info.setup_udata);             \
        }                                                               \
        return 1;               /* test should be run */                \
    } else {                                                            \
        return 0;               /* skipped */                           \
    }                                                                   \
}                                                                       \
                                                                        \
void greatest_post_test(const char *name, int res) {                    \
    GREATEST_SET_TIME(greatest_info.suite.post_test);                   \
    if (greatest_info.teardown) {                                       \
        void *udata = greatest_info.teardown_udata;                     \
        greatest_info.teardown(udata);                                  \
    }                                                                   \
                                                                        \
    if (res <= GREATEST_TEST_RES_FAIL) {                                \
        greatest_do_fail(name);                                         \
    } else if (res >= GREATEST_TEST_RES_SKIP) {                         \
        greatest_do_skip(name);                                         \
    } else if (res == GREATEST_TEST_RES_PASS) {                         \
        greatest_do_pass(name);                                         \
    }                                                                   \
    greatest_info.suite.tests_run++;                                    \
    greatest_info.col++;                                                \
    if (GREATEST_IS_VERBOSE()) {                                        \
        GREATEST_CLOCK_DIFF(greatest_info.suite.pre_test,               \
            greatest_info.suite.post_test);                             \
        fprintf(GREATEST_STDOUT, "\n");                                 \
    } else if (greatest_info.col % greatest_info.width == 0) {          \
        fprintf(GREATEST_STDOUT, "\n");                                 \
        greatest_info.col = 0;                                          \
    }                                                                   \
    fflush(GREATEST_STDOUT);                                            \
}                                                                       \
                                                                        \
static void report_suite(void) {                                        \
    if (greatest_info.suite.tests_run > 0) {                            \
        fprintf(GREATEST_STDOUT,                                        \
            "\n%u test%s - %u passed, %u failed, %u skipped",           \
            greatest_info.suite.tests_run,                              \
            greatest_info.suite.tests_run == 1 ? "" : "s",              \
            greatest_info.suite.passed,                                 \
            greatest_info.suite.failed,                                 \
            greatest_info.suite.skipped);                               \
        GREATEST_CLOCK_DIFF(greatest_info.suite.pre_suite,              \
            greatest_info.suite.post_suite);                            \
        fprintf(GREATEST_STDOUT, "\n");                                 \
    }                                                                   \
}                                                                       \
                                                                        \
static void update_counts_and_reset_suite(void) {                       \
    greatest_info.setup = NULL;                                         \
    greatest_info.setup_udata = NULL;                                   \
    greatest_info.teardown = NULL;                                      \
    greatest_info.teardown_udata = NULL;                                \
    greatest_info.passed += greatest_info.suite.passed;                 \
    greatest_info.failed += greatest_info.suite.failed;                 \
    greatest_info.skipped += greatest_info.suite.skipped;               \
    greatest_info.tests_run += greatest_info.suite.tests_run;           \
    memset(&greatest_info.suite, 0, sizeof(greatest_info.suite));       \
    greatest_info.col = 0;                                              \
}                                                                       \
                                                                        \
static void greatest_run_suite(greatest_suite_cb *suite_cb,             \
                               const char *suite_name) {                \
    if (greatest_info.suite_filter &&                                   \
        !greatest_name_match(suite_name, greatest_info.suite_filter)) { \
        return;                                                         \
    }                                                                   \
    update_counts_and_reset_suite();                                    \
    if (GREATEST_FIRST_FAIL() && greatest_info.failed > 0) { return; }  \
    fprintf(GREATEST_STDOUT, "\n" GREATEST_ANSI_COLOR_YELLOW "* Suite %s:" GREATEST_ANSI_COLOR_RESET "\n", suite_name);  \
    GREATEST_SET_TIME(greatest_info.suite.pre_suite);                   \
    suite_cb();                                                         \
    GREATEST_SET_TIME(greatest_info.suite.post_suite);                  \
    report_suite();                                                     \
}                                                                       \
                                                                        \
void greatest_do_pass(const char *name) {                               \
    if (GREATEST_IS_VERBOSE()) {                                        \
        fprintf(GREATEST_STDOUT, "PASS %s: %s",                         \
            name, greatest_info.msg ? greatest_info.msg : "");          \
    } else {                                                            \
        fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_GREEN "." GREATEST_ANSI_COLOR_RESET);  \
    }                                                                   \
    greatest_info.suite.passed++;                                       \
}                                                                       \
                                                                        \
void greatest_do_fail(const char *name) {                               \
    if (GREATEST_IS_VERBOSE()) {                                        \
        fprintf(GREATEST_STDOUT,                                        \
            "FAIL %s: %s (%s:%u)",                                      \
            name, greatest_info.msg ? greatest_info.msg : "",           \
            greatest_info.fail_file, greatest_info.fail_line);          \
    } else {                                                            \
        fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_RED "F" GREATEST_ANSI_COLOR_RESET);    \
        greatest_info.col++;                                            \
        /* add linebreak if in line of '.'s */                          \
        if (greatest_info.col != 0) {                                   \
            fprintf(GREATEST_STDOUT, "\n");                             \
            greatest_info.col = 0;                                      \
        }                                                               \
        fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_RED "FAIL" GREATEST_ANSI_COLOR_RESET " %s: %s (%s:%u)\n",  \
            name,                                                       \
            greatest_info.msg ? greatest_info.msg : "",                 \
            greatest_info.fail_file, greatest_info.fail_line);          \
    }                                                                   \
    greatest_info.suite.failed++;                                       \
}                                                                       \
                                                                        \
void greatest_do_skip(const char *name) {                               \
    if (GREATEST_IS_VERBOSE()) {                                        \
        fprintf(GREATEST_STDOUT, "SKIP %s: %s",                         \
            name,                                                       \
            greatest_info.msg ?                                         \
            greatest_info.msg : "" );                                   \
    } else {                                                            \
        fprintf(GREATEST_STDOUT, "s");                                  \
    }                                                                   \
    greatest_info.suite.skipped++;                                      \
}                                                                       \
                                                                        \
int greatest_do_assert_equal_t(const void *exp, const void *got,        \
        greatest_type_info *type_info, void *udata) {                   \
    int eq = 0;                                                         \
    if (type_info == NULL || type_info->equal == NULL) {                \
        return 0;                                                       \
    }                                                                   \
    eq = type_info->equal(exp, got, udata);                             \
    if (!eq) {                                                          \
        if (type_info->print != NULL) {                                 \
            fprintf(GREATEST_STDOUT, "\nExpected: ");                   \
            (void)type_info->print(exp, udata);                         \
            fprintf(GREATEST_STDOUT, "\n     Got: ");                   \
            (void)type_info->print(got, udata);                         \
            fprintf(GREATEST_STDOUT, "\n");                             \
        } else {                                                        \
            fprintf(GREATEST_STDOUT,                                    \
                "GREATEST_ASSERT_EQUAL_T failure at %s:%u\n",           \
                greatest_info.fail_file,                                \
                greatest_info.fail_line);                               \
        }                                                               \
    }                                                                   \
    return eq;                                                          \
}                                                                       \
                                                                        \
void greatest_usage(const char *name) {                                 \
    fprintf(GREATEST_STDOUT,                                            \
        "Usage: %s [-hlfv] [-s SUITE] [-t TEST]\n"                      \
        "  -h, --help  print this Help\n"                               \
        "  -l          List suites and their tests, then exit\n"        \
        "  -f          Stop runner after first failure\n"               \
        "  -v          Verbose output\n"                                \
        "  -s SUITE    only run suites containing string SUITE\n"       \
        "  -t TEST     only run tests containing string TEST\n",        \
        name);                                                          \
}                                                                       \
                                                                        \
static void greatest_parse_args(int argc, char **argv) {                \
    int i = 0;                                                          \
    for (i = 1; i < argc; i++) {                                        \
        if (0 == strncmp("-t", argv[i], 2)) {                           \
            if (argc <= i + 1) {                                        \
                greatest_usage(argv[0]);                                \
                exit(EXIT_FAILURE);                                     \
            }                                                           \
            greatest_info.test_filter = argv[i+1];                      \
            i++;                                                        \
        } else if (0 == strncmp("-s", argv[i], 2)) {                    \
            if (argc <= i + 1) {                                        \
                greatest_usage(argv[0]);                                \
                exit(EXIT_FAILURE);                                     \
            }                                                           \
            greatest_info.suite_filter = argv[i+1];                     \
            i++;                                                        \
        } else if (0 == strncmp("-f", argv[i], 2)) {                    \
            greatest_info.flags |= GREATEST_FLAG_FIRST_FAIL;            \
        } else if (0 == strncmp("-v", argv[i], 2)) {                    \
            greatest_info.verbosity++;                                  \
        } else if (0 == strncmp("-l", argv[i], 2)) {                    \
            greatest_info.flags |= GREATEST_FLAG_LIST_ONLY;             \
        } else if (0 == strncmp("-h", argv[i], 2) ||                    \
                   0 == strncmp("--help", argv[i], 6)) {                \
            greatest_usage(argv[0]);                                    \
            exit(EXIT_SUCCESS);                                         \
        } else if (0 == strncmp("--", argv[i], 2)) {                    \
            break;                                                      \
        } else {                                                        \
            fprintf(GREATEST_STDOUT,                                    \
                "Unknown argument '%s'\n", argv[i]);                    \
            greatest_usage(argv[0]);                                    \
            exit(EXIT_FAILURE);                                         \
        }                                                               \
    }                                                                   \
}                                                                       \
                                                                        \
int greatest_all_passed(void) { return (greatest_info.failed == 0); }   \
                                                                        \
void greatest_set_test_filter(const char *name) {                       \
    greatest_info.test_filter = name;                                   \
}                                                                       \
                                                                        \
void greatest_set_suite_filter(const char *name) {                      \
    greatest_info.suite_filter = name;                                  \
}                                                                       \
                                                                        \
void greatest_get_report(struct greatest_report_t *report) {            \
    if (report) {                                                       \
        report->passed = greatest_info.passed;                          \
        report->failed = greatest_info.failed;                          \
        report->skipped = greatest_info.skipped;                        \
        report->assertions = greatest_info.assertions;                  \
    }                                                                   \
}                                                                       \
                                                                        \
unsigned int greatest_get_verbosity(void) {                             \
    return greatest_info.verbosity;                                     \
}                                                                       \
                                                                        \
void greatest_set_verbosity(unsigned int verbosity) {                   \
    greatest_info.verbosity = (unsigned char)verbosity;                 \
}                                                                       \
                                                                        \
void greatest_set_flag(greatest_flag_t flag) {                          \
    greatest_info.flags |= flag;                                        \
}                                                                       \
                                                                        \
void GREATEST_SET_SETUP_CB(greatest_setup_cb *cb, void *udata) {        \
    greatest_info.setup = cb;                                           \
    greatest_info.setup_udata = udata;                                  \
}                                                                       \
                                                                        \
void GREATEST_SET_TEARDOWN_CB(greatest_teardown_cb *cb,                 \
                                    void *udata) {                      \
    greatest_info.teardown = cb;                                        \
    greatest_info.teardown_udata = udata;                               \
}                                                                       \
                                                                        \
static int greatest_string_equal_cb(const void *exp, const void *got,   \
    void *udata) {                                                      \
    size_t *size = (size_t *)udata;                                     \
    return (size != NULL                                                \
        ? (0 == strncmp((const char *)exp, (const char *)got, *size))   \
        : (0 == strcmp((const char *)exp, (const char *)got)));         \
}                                                                       \
                                                                        \
static int greatest_string_printf_cb(const void *t, void *udata) {      \
    (void)udata; /* note: does not check \0 termination. */             \
    return fprintf(GREATEST_STDOUT, "%s", (const char *)t);             \
}                                                                       \
                                                                        \
greatest_type_info greatest_type_info_string = {                        \
    greatest_string_equal_cb,                                           \
    greatest_string_printf_cb,                                          \
};                                                                      \
                                                                        \
static int greatest_memory_equal_cb(const void *exp, const void *got,   \
    void *udata) {                                                      \
    greatest_memory_cmp_env *env = (greatest_memory_cmp_env *)udata;    \
    return (0 == memcmp(exp, got, env->size));                          \
}                                                                       \
                                                                        \
static int greatest_memory_printf_cb(const void *t, void *udata) {      \
    greatest_memory_cmp_env *env = (greatest_memory_cmp_env *)udata;    \
    const unsigned char *buf = (const unsigned char *)t;                \
    unsigned char diff_mark = ' ';                                      \
    FILE *out = GREATEST_STDOUT;                                        \
    size_t i, line_i, line_len = 0;                                     \
    int len = 0;   /* format hexdump with differences highlighted */    \
    for (i = 0; i < env->size; i+= line_len) {                          \
        diff_mark = ' ';                                                \
        line_len = env->size - i;                                       \
        if (line_len > 16) { line_len = 16; }                           \
        for (line_i = i; line_i < i + line_len; line_i++) {             \
            if (env->exp[line_i] != env->got[line_i]) diff_mark = 'X';  \
        }                                                               \
        len += fprintf(out, "\n%04x %c ", (unsigned int)i, diff_mark);  \
        for (line_i = i; line_i < i + line_len; line_i++) {             \
            int m = env->exp[line_i] == env->got[line_i]; /* match? */  \
            len += fprintf(out, "%02x%c", buf[line_i], m ? ' ' : '<');  \
        }                                                               \
        for (line_i = 0; line_i < 16 - line_len; line_i++) {            \
            len += fprintf(out, "   ");                                 \
        }                                                               \
        fprintf(out, " ");                                              \
        for (line_i = i; line_i < i + line_len; line_i++) {             \
            unsigned char c = buf[line_i];                              \
            len += fprintf(out, "%c", isprint(c) ? c : '.');            \
        }                                                               \
    }                                                                   \
    len += fprintf(out, "\n");                                          \
    return len;                                                         \
}                                                                       \
                                                                        \
greatest_type_info greatest_type_info_memory = {                        \
    greatest_memory_equal_cb,                                           \
    greatest_memory_printf_cb,                                          \
};                                                                      \
                                                                        \
greatest_run_info greatest_info

/* Init internals. */
#define GREATEST_INIT()                                                 \
    do {                                                                \
        /* Suppress unused function warning if features aren't used */  \
        (void)greatest_run_suite;                                       \
        (void)greatest_parse_args;                                      \
                                                                        \
        memset(&greatest_info, 0, sizeof(greatest_info));               \
        greatest_info.width = GREATEST_DEFAULT_WIDTH;                   \
        GREATEST_SET_TIME(greatest_info.begin);                         \
    } while (0)                                                         \

/* Handle command-line arguments, etc. */
#define GREATEST_MAIN_BEGIN()                                           \
    do {                                                                \
        GREATEST_INIT();                                                \
        greatest_parse_args(argc, argv);                                \
    } while (0)

/* Report passes, failures, skipped tests, the number of
 * assertions, and the overall run time. */
#define GREATEST_PRINT_REPORT()                                         \
    do {                                                                \
        if (!GREATEST_LIST_ONLY()) {                                    \
            update_counts_and_reset_suite();                            \
            GREATEST_SET_TIME(greatest_info.end);                       \
            fprintf(GREATEST_STDOUT,                                    \
                "\nTotal: %u test%s",                                   \
                greatest_info.tests_run,                                \
                greatest_info.tests_run == 1 ? "" : "s");               \
            GREATEST_CLOCK_DIFF(greatest_info.begin,                    \
                greatest_info.end);                                     \
            fprintf(GREATEST_STDOUT, ", %u assertion%s\n",              \
                greatest_info.assertions,                               \
                greatest_info.assertions == 1 ? "" : "s");              \
            fprintf(GREATEST_STDOUT,                                    \
                GREATEST_ANSI_COLOR_GREEN "Pass: %u, fail: %u, skip: %u.\n" GREATEST_ANSI_COLOR_RESET,  \
                greatest_info.passed,                                   \
                greatest_info.failed, greatest_info.skipped);           \
        }                                                               \
    } while (0)

/* Report results, exit with exit status based on results. */
#define GREATEST_MAIN_END()                                             \
    do {                                                                \
        GREATEST_PRINT_REPORT();                                        \
        return (greatest_all_passed() ? EXIT_SUCCESS : EXIT_FAILURE);   \
    } while (0)

/* Make abbreviations without the GREATEST_ prefix for the
 * most commonly used symbols. */
#ifdef GREATEST_USE_ABBREVS
#define TEST           GREATEST_TEST
#define SUITE          GREATEST_SUITE
#define SUITE_EXTERN   GREATEST_SUITE_EXTERN
#define RUN_TEST       GREATEST_RUN_TEST
#define RUN_TEST1      GREATEST_RUN_TEST1
#define RUN_SUITE      GREATEST_RUN_SUITE
#define IGNORE_TEST    GREATEST_IGNORE_TEST
#define ASSERT         GREATEST_ASSERT
#define ASSERTm        GREATEST_ASSERTm
#define ASSERT_FALSE   GREATEST_ASSERT_FALSE
#define ASSERT_EQ      GREATEST_ASSERT_EQ
#define ASSERT_EQ_FMT  GREATEST_ASSERT_EQ_FMT
#define ASSERT_IN_RANGE GREATEST_ASSERT_IN_RANGE
#define ASSERT_EQUAL_T GREATEST_ASSERT_EQUAL_T
#define ASSERT_STR_EQ  GREATEST_ASSERT_STR_EQ
#define ASSERT_STRN_EQ GREATEST_ASSERT_STRN_EQ
#define ASSERT_MEM_EQ  GREATEST_ASSERT_MEM_EQ
#define ASSERT_ENUM_EQ GREATEST_ASSERT_ENUM_EQ
#define ASSERT_FALSEm  GREATEST_ASSERT_FALSEm
#define ASSERT_EQm     GREATEST_ASSERT_EQm
#define ASSERT_EQ_FMTm GREATEST_ASSERT_EQ_FMTm
#define ASSERT_IN_RANGEm GREATEST_ASSERT_IN_RANGEm
#define ASSERT_EQUAL_Tm GREATEST_ASSERT_EQUAL_Tm
#define ASSERT_STR_EQm GREATEST_ASSERT_STR_EQm
#define ASSERT_STRN_EQm GREATEST_ASSERT_STRN_EQm
#define ASSERT_MEM_EQm GREATEST_ASSERT_MEM_EQm
#define ASSERT_ENUM_EQm GREATEST_ASSERT_ENUM_EQm
#define PASS           GREATEST_PASS
#define FAIL           GREATEST_FAIL
#define SKIP           GREATEST_SKIP
#define PASSm          GREATEST_PASSm
#define FAILm          GREATEST_FAILm
#define SKIPm          GREATEST_SKIPm
#define SET_SETUP      GREATEST_SET_SETUP_CB
#define SET_TEARDOWN   GREATEST_SET_TEARDOWN_CB
#define CHECK_CALL     GREATEST_CHECK_CALL

#ifdef GREATEST_VA_ARGS
#define RUN_TESTp      GREATEST_RUN_TESTp
#endif

#ifdef GREATEST_USE_LONGJMP
#define ASSERT_OR_LONGJMP  GREATEST_ASSERT_OR_LONGJMP
#define ASSERT_OR_LONGJMPm GREATEST_ASSERT_OR_LONGJMPm
#define FAIL_WITH_LONGJMP  GREATEST_FAIL_WITH_LONGJMP
#define FAIL_WITH_LONGJMPm GREATEST_FAIL_WITH_LONGJMPm
#endif

#endif /* USE_ABBREVS */

#ifdef __cplusplus
}
#endif

#endif
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_dern_lexer.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireDernLexerTestAllocator = 0;

TEST octaspire_dern_lexer_token_new_test(void)
{
    octaspire_dern_lexer_token_tag_t       const expectedTypeTag  = OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN;
    octaspire_dern_lexer_token_position_t  const expectedLine     = {987, 987};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {123, 123};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {300, 300};

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        expectedTypeTag,
        0,
        expectedLine,
        expectedColumn,
        expectedUcsIndex,
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT_EQ     (expectedTypeTag,  token->typeTag);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ     (octaspireDernLexerTestAllocator,        token->allocator);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_new_allocation_failure_on_first_allocation_test(void)
{
    octaspire_dern_lexer_token_tag_t       const expectedTypeTag  = OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN;
    octaspire_dern_lexer_token_position_t  const expectedLine     = {987, 987};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {123, 123};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {300, 300};

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator));

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        expectedTypeTag,
        0,
        expectedLine,
        expectedColumn,
        expectedUcsIndex,
        octaspireDernLexerTestAllocator);

    ASSERT_FALSE(token);

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_new_allocation_failure_on_second_allocation_when_tag_is_string_test(void)
{
    octaspire_dern_lexer_token_tag_t       const expectedTypeTag  = OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING;
    octaspire_dern_lexer_token_position_t  const expectedLine     = {987, 987};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {123, 123};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {300, 300};

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator));

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        expectedTypeTag,
        "some text",
        expectedLine,
        expectedColumn,
        expectedUcsIndex,
        octaspireDernLexerTestAllocator);

    ASSERT_FALSE(token);

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_new_allocation_failure_on_second_allocation_when_tag_is_error_test(void)
{
    octaspire_dern_lexer_token_tag_t      const expectedTypeTag  = OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR;
    octaspire_dern_lexer_token_position_t const expectedLine     = {987, 987};
    octaspire_dern_lexer_token_position_t const expectedColumn   = {123, 123};
    octaspire_dern_lexer_token_position_t const expectedUcsIndex = {300, 300};

    octaspire_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator));

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        expectedTypeTag,
        "some text",
        expectedLine,
        expectedColumn,
        expectedUcsIndex,
        octaspireDernLexerTestAllocator);

    ASSERT_FALSE(token);

    ASSERT_EQ(0, octaspire_allocator_get_number_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_get_type_tag_test(void)
{
    octaspire_dern_lexer_token_tag_t      const expectedTypeTag  = OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN;

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        expectedTypeTag,
        0,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT_EQ(expectedTypeTag, octaspire_dern_lexer_token_get_type_tag(token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_get_type_tag_as_c_string_test(void)
{
    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
        0,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT_STR_EQ("OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN", octaspire_dern_lexer_token_get_type_tag_as_c_string(token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_get_integer_value_test(void)
{
    int32_t const expected = 765;

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER,
        &expected,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT_EQ(expected, octaspire_dern_lexer_token_get_integer_value(token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_get_line_test(void)
{
    octaspire_dern_lexer_token_position_t  const expectedLine     = {32003, 32004};

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
        0,
        expectedLine,
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_position_is_equal(
        &expectedLine,
        octaspire_dern_lexer_token_get_position_line(token)));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_get_column_test(void)
{
    octaspire_dern_lexer_token_position_t  const expectedColumn     = {32003, 32004};

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
        0,
        octaspire_dern_lexer_token_position_init(123, 123),
        expectedColumn,
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_position_is_equal(
        &expectedColumn,
        octaspire_dern_lexer_token_get_position_column(token)));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_to_string_with_lparen_token_test(void)
{
    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
        0,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    octaspire_string_t *str = octaspire_dern_lexer_token_to_string(token);

    ASSERT(str);

    char const * const expected =
        "token: line=987,987 column=123,123 ucsIndex=300,300 "
        "type=OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN value=left parenthesis";

    ASSERT_STR_EQ(expected, octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_to_string_with_rparen_token_test(void)
{
    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN,
        0,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    octaspire_string_t *str = octaspire_dern_lexer_token_to_string(token);

    ASSERT(str);

    char const * const expected =
        "token: line=987,987 column=123,123 ucsIndex=300,300 "
        "type=OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN value=right parenthesis";

    ASSERT_STR_EQ(expected, octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_to_string_with_integer_token_test(void)
{
    int32_t const expected = 16987;

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER,
        &expected,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    octaspire_string_t *str = octaspire_dern_lexer_token_to_string(token);

    ASSERT(str);

    ASSERT_STR_EQ(
        "token: line=987,987 column=123,123 ucsIndex=300,300 "
        "type=OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER value=integer 16987",
        octaspire_string_get_c_string(str));

    octaspire_string_release(str);
    str = 0;

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_to_string_with_error_token_test(void)
{
    char const * const value = "some error";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        "some error",
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_left_parenthesis_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
        0,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(0, 0),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "(",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_right_parenthesis_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN,
        0,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(0, 0),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        ")",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_left_parenthesis_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
        0,
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(5, 5),
        octaspire_dern_lexer_token_position_init(6, 6),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t  (   \n \t  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_right_parenthesis_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN,
        0,
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(5, 5),
        octaspire_dern_lexer_token_position_init(6, 6),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t  )   \n \t  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_quote_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE,
        0,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(0, 0),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "'",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_quote_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE,
        0,
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(5, 5),
        octaspire_dern_lexer_token_position_init(6, 6),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t  '   \n \t  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_true_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE,
        0,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 4),
        octaspire_dern_lexer_token_position_init(0, 3),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "true",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_true_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE,
        0,
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(5, 8),
        octaspire_dern_lexer_token_position_init(6, 9),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t  true   \n \t  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_nil_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL,
        0,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 3),
        octaspire_dern_lexer_token_position_init(0, 2),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "nil",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_nil_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL,
        0,
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(5, 7),
        octaspire_dern_lexer_token_position_init(6, 8),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t  nil   \n \t  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_symbol_length_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL,
        "length",
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 6),
        octaspire_dern_lexer_token_position_init(0, 5),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "length",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_symbol_length_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL,
        "length",
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(5, 10),
        octaspire_dern_lexer_token_position_init(6, 11),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t  length   \n \t  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}


TEST octaspire_dern_lexer_pop_next_token_integer_12_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "{D+12}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 6};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {0, 5};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(12,                                     token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_12_dot_3_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "{D+12.3}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 8};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {0, 7};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(12.3, token->value.real, 0.000001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_759_after_whitespace_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "   \t   {D+759}", // 3 spaces + 1 tab + 3 spaces
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {8, 14};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {7, 13};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(759,                                    token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_binary_10011_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "{B+10011}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(
        input,
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 9};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {0, 8};

    ASSERT_EQ(octaspireDernLexerTestAllocator, token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(19,                                     token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_binary_negative_10011_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "{B-10011}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(
        input,
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 9};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {0, 8};

    ASSERT_EQ(octaspireDernLexerTestAllocator, token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(-19,                                    token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_759_dot_2_after_whitespace_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "   \t   {D+759.2}", // 3 spaces + 1 tab + 3 spaces
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {8, 16};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {7, 15};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(759.2, token->value.real, 0.00001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_759_amid_whitespace_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "   \t   {D+759}   \t   ", // 3 spaces + 1 tab + 3 spaces
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {8, 14};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {7, 13};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(759,                                    token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_759_dot_2_amid_whitespace_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "   \t   {D+759.2}   \t   ", // 3 spaces + 1 tab + 3 spaces
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {8, 16};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {7, 15};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(759.2, token->value.real, 0.00001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_multiline_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  #! here is comment\n 1024!#  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT_EQ(0, token);

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_multiline_comment_more_input_required_two_chars_missing_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  #! here is comment\n 1024",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {2, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {3, 5};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {5, 28};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED, token->typeTag);
    ASSERT_STR_EQ(
        "Multiline comment that is not closed with !#",
        octaspire_string_get_c_string(token->value.moreInputRequired));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_multiline_comment_more_input_required_one_char_missing_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  #! here is comment\n 1024!",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {2, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {3, 6};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {5, 29};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED, token->typeTag);
    ASSERT_STR_EQ(
        "Number sign '#' expected after '!' to close multiline comment",
        octaspire_string_get_c_string(token->value.moreInputRequired));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_1024_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n{D+1024}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 8};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 30};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(1024,                                   token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_1024_dot_987_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n{D+1024.987}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 12};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 34};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(1024.987, token->value.real, 0.0001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_0_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n{D+0}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 5};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 27};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(0,                                   token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_0_dot_0_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n{D+0.0}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 7};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 29};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(0.0, token->value.real, 0.0000001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_minus_1024_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n{D-1024}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 8};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 30};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(-1024,                                  token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_minus_1024_dot_987_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n{D-1024.987}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3,  3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1,  12};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 34};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(-1024.987, token->value.real, 0.0001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_1234567890_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n{D+1234567890}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3,  3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1,  14};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 36};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(1234567890,                            token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_minus_1234567890_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n{D-1234567890}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3,  3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1,  14};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 36};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(-1234567890,                            token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_12345_dot_67890_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n{D+12345.67890}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3,  3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1,  15};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 37};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(12345.67890, token->value.real, 0.000001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_minus_12345_dot_67890_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n{D-12345.67890}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3,  3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1,  15};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 37};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(-12345.67890, token->value.real, 0.000001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_five_integers_11_22_33_44_55_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "{D+11} {D+22} {D+33} {D+44} {D+55}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < 5; ++i)
    {
        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
        ASSERT(token);

        octaspire_dern_lexer_token_position_t const expectedLine     = {1,           1};
        octaspire_dern_lexer_token_position_t const expectedColumn   = {1 + (i * 7), 6 + (i * 7)};
        octaspire_dern_lexer_token_position_t const expectedUcsIndex = {0 + (i * 7), 5 + (i * 7)};

        ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

        ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
        ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
        ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

        ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
        ASSERT_EQ(((int32_t)i + 1) * 11,                           token->value.integer);

        octaspire_dern_lexer_token_release(token);
        token = 0;
    }

    ASSERT_FALSE(octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_five_reals_11_dot_1_22_dot_2_33_dot_3_44_dot_4_55_dot_5_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "{D+11.1} {D+22.2} {D+33.3} {D+44.4} {D+55.5}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < 5; ++i)
    {
        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
        ASSERT(token);

        octaspire_dern_lexer_token_position_t const expectedLine     = {1,           1};
        octaspire_dern_lexer_token_position_t const expectedColumn   = {1 + (i * 9), 8 + (i * 9)};
        octaspire_dern_lexer_token_position_t const expectedUcsIndex = {0 + (i * 9), 7 + (i * 9)};

        ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

        ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
        ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
        ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

        ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
        ASSERT_IN_RANGE(((double)i + 1.0) * 11.1,      token->value.real, 0.0000001);

        octaspire_dern_lexer_token_release(token);
        token = 0;
    }

    for (size_t i = 0; i < 5; ++i)
    {
        ASSERT_FALSE(octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator));
    }

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_failure_on_integer_12_with_character_a_after_test(void)
{
    char const * const value = "Decimal number can contain only digits '0' - '9'.";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 6),
        octaspire_dern_lexer_token_position_init(0, 5),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "{D+12a}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_failure_on_illegal_real_12_dot_2_dot_2_test(void)
{
    char const * const value = "Number can contain only one '.' character";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 8),
        octaspire_dern_lexer_token_position_init(0, 7),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "{D+12.2.2}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_failure_on_illegal_integer_minus_12_minus_22_test(void)
{
    char const * const value = "Number cannot contain character '-'";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 6),
        octaspire_dern_lexer_token_position_init(0, 5),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "{D-12-22}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_failure_on_illegal_real_minus_12_dot_22_minus_33_test(void)
{
    char const * const value = "Number cannot contain character '-'";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 9),
        octaspire_dern_lexer_token_position_init(0, 8),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "{D-12.22-33}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_failure_on_illegal_integer_12_minus_22_test(void)
{
    char const * const value = "Number cannot contain character '-'";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 6),
        octaspire_dern_lexer_token_position_init(0, 5),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "{D+12-22}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_failure_on_illegal_integer_12_dot_22_minus_22_test(void)
{
    char const * const value = "Number cannot contain character '-'";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 9),
        octaspire_dern_lexer_token_position_init(0, 8),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "{D+12.22-22}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_string_cat_and_dog_test(void)
{
    char const * const value = "Cat and dog.";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 14),
        octaspire_dern_lexer_token_position_init(0, 13),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "[Cat and dog.]",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_character_a_test(void)
{
    char const * const value = "a";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 3),
        octaspire_dern_lexer_token_position_init(0, 2),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|a|",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_character_vertical_line_test(void)
{
    char const * const value = "|";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 5),
        octaspire_dern_lexer_token_position_init(0, 4),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|bar|",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_character_newline_test(void)
{
    char const * const value = "\n";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 9),
        octaspire_dern_lexer_token_position_init(0, 8),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|newline|",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_character_tabulator_test(void)
{
    char const * const value = "\t";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 5),
        octaspire_dern_lexer_token_position_init(0, 4),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|tab|",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_character_a_amid_whitespace_test(void)
{
    char const * const value = "a";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
        value,
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(6, 8),
        octaspire_dern_lexer_token_position_init(7, 9),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t \t |a| \n \t ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_five_characters_a_b_c_d_e_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected[5];

    for (size_t i = 0; i < 5; ++i)
    {
        char const value[2] = {(char)((char)97 + (char)i) , '\0'};

        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                value,
                octaspire_dern_lexer_token_position_init(2, 2),
                octaspire_dern_lexer_token_position_init(1 + (i * 4), 3 + (i * 4)),
                octaspire_dern_lexer_token_position_init(1 + (i * 4), 3 + (i * 4)),
                octaspireDernLexerTestAllocator);

        expected[i] = token;

        ASSERT(expected[i]);
    }

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "\n|a| |b| |c| |d| |e|  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < 5; ++i)
    {
        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
        ASSERT(token);

        ASSERT(octaspire_dern_lexer_token_is_equal(expected[i], token));

        octaspire_dern_lexer_token_release(token);
        token = 0;
    }

    octaspire_input_release(input);
    input = 0;

    for (size_t i = 0; i < 5; ++i)
    {
        octaspire_dern_lexer_token_release(expected[i]);
        expected[i] = 0;
    }

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_five_characters_a_b_c_d_e_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected[5];

    for (size_t i = 0; i < 5; ++i)
    {
        char const value[2] = {(char)((char)97 + (char)i) , '\0'};

        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                value,
                octaspire_dern_lexer_token_position_init(1, 1),
                octaspire_dern_lexer_token_position_init(1 + (i * 3), 3 + (i * 3)),
                octaspire_dern_lexer_token_position_init(0 + (i * 3), 2 + (i * 3)),
                octaspireDernLexerTestAllocator);

        expected[i] = token;

        ASSERT(expected[i]);
    }

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|a||b||c||d||e|",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < 5; ++i)
    {
        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
        ASSERT(token);

        ASSERT(octaspire_dern_lexer_token_is_equal(expected[i], token));

        octaspire_dern_lexer_token_release(token);
        token = 0;
    }

    octaspire_input_release(input);
    input = 0;

    for (size_t i = 0; i < 5; ++i)
    {
        octaspire_dern_lexer_token_release(expected[i]);
        expected[i] = 0;
    }

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_character_a_end_of_input_before_end_delimiter_returns_null_token_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|a",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT_FALSE(token);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_illegal_character_constant_now_line_no_whitespace_test(void)
{
    char const * const value = "Unknown character constant |now line|";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 10),
        octaspire_dern_lexer_token_position_init(0, 9),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|now line|",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_illegal_character_empty_character_test(void)
{
    char const * const value = "Character cannot be empty: ||";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 2),
        octaspire_dern_lexer_token_position_init(0, 1),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "||",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_all_token_types_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected[12];

    uint32_t const     integerVal = 123;
    double const       realVal    = 987.456;
    char const * const strVal     = "here is a string";
    char const * const charVal    = "+";
    char const * const symbolVal  = "here_is_a_symbol";
    char const * const errorVal   = "Decimal number can contain only digits '0' - '9'.";

    void const * const values[12] =
    {
        0,
        0,
        0,
        0,
        0,
        0,
        &integerVal,
        &realVal,
        strVal,
        charVal,
        symbolVal,
        errorVal
    };

    octaspire_dern_lexer_token_position_t linePositions[12] =
    {
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1}
    };

    octaspire_dern_lexer_token_position_t columnPositions[12] =
    {
        {1, 1},
        {3, 3},
        {5, 5},
        {7, 10},
        {12, 16},
        {18, 20},
        {22, 28},
        {30, 40},
        {42, 59},
        {61, 63},
        {65, 80},
        {82, 87}
    };

    // + 6
    octaspire_dern_lexer_token_position_t ucsIndexPositions[12] =
    {
        {0, 0},
        {2, 2},
        {4, 4},
        {6, 9},
        {11, 15},
        {17, 19},
        {21, 27},
        {29, 39},
        {41, 58},
        {60, 62},
        {64, 79},
        {81, 86}
    };

    ASSERT((sizeof(expected) / sizeof(expected[0])) == (sizeof(values) / sizeof(values[0])));
    ASSERT((sizeof(expected) / sizeof(expected[0])) == (sizeof(linePositions) / sizeof(linePositions[0])));
    ASSERT((sizeof(expected) / sizeof(expected[0])) == (sizeof(columnPositions) / sizeof(columnPositions[0])));
    ASSERT((sizeof(expected) / sizeof(expected[0])) == (sizeof(ucsIndexPositions) / sizeof(ucsIndexPositions[0])));

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
            (octaspire_dern_lexer_token_tag_t)i,
            values[i],
            linePositions[i],
            columnPositions[i],
            ucsIndexPositions[i],
            octaspireDernLexerTestAllocator);

        expected[i] = token;

        ASSERT(expected[i]);
    }

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "( ) ' true false nil {D+123} {D+987.456} [here is a string] |+| here_is_a_symbol {D+12a}",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
        ASSERT(token);

        ASSERT(octaspire_dern_lexer_token_is_equal(expected[i], token));

        octaspire_dern_lexer_token_release(token);
        token = 0;
    }

    octaspire_input_release(input);
    input = 0;

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_lexer_token_release(expected[i]);
        expected[i] = 0;
    }

    PASS();
}

GREATEST_SUITE(octaspire_dern_lexer_suite)
{
    octaspireDernLexerTestAllocator = octaspire_allocator_new(0);
    assert(octaspireDernLexerTestAllocator);

    RUN_TEST(octaspire_dern_lexer_token_new_test);
    RUN_TEST(octaspire_dern_lexer_token_new_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_dern_lexer_token_new_allocation_failure_on_second_allocation_when_tag_is_string_test);
    RUN_TEST(octaspire_dern_lexer_token_new_allocation_failure_on_second_allocation_when_tag_is_error_test);
    RUN_TEST(octaspire_dern_lexer_token_get_type_tag_test);
    RUN_TEST(octaspire_dern_lexer_token_get_type_tag_as_c_string_test);
    RUN_TEST(octaspire_dern_lexer_token_get_integer_value_test);
    RUN_TEST(octaspire_dern_lexer_token_get_line_test);
    RUN_TEST(octaspire_dern_lexer_token_get_column_test);
    RUN_TEST(octaspire_dern_lexer_token_to_string_with_lparen_token_test);
    RUN_TEST(octaspire_dern_lexer_token_to_string_with_rparen_token_test);
    RUN_TEST(octaspire_dern_lexer_token_to_string_with_integer_token_test);
    RUN_TEST(octaspire_dern_lexer_token_to_string_with_error_token_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_left_parenthesis_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_right_parenthesis_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_left_parenthesis_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_right_parenthesis_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_quote_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_quote_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_true_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_true_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_nil_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_nil_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_symbol_length_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_symbol_length_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_12_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_12_dot_3_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_759_after_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_binary_10011_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_binary_negative_10011_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_759_dot_2_after_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_759_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_759_dot_2_amid_whitespace_test);

    RUN_TEST(octaspire_dern_lexer_pop_next_token_multiline_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_multiline_comment_more_input_required_two_chars_missing_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_multiline_comment_more_input_required_one_char_missing_test);

    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_1024_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_1024_dot_987_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_0_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_0_dot_0_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_minus_1024_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_minus_1024_dot_987_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_minus_1234567890_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_1234567890_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_12345_dot_67890_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_minus_12345_dot_67890_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_five_integers_11_22_33_44_55_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_five_reals_11_dot_1_22_dot_2_33_dot_3_44_dot_4_55_dot_5_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_failure_on_integer_12_with_character_a_after_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_failure_on_illegal_real_12_dot_2_dot_2_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_failure_on_illegal_integer_minus_12_minus_22_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_failure_on_illegal_real_minus_12_dot_22_minus_33_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_failure_on_illegal_integer_12_minus_22_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_failure_on_illegal_integer_12_dot_22_minus_22_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_string_cat_and_dog_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_character_a_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_character_vertical_line_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_character_newline_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_character_tabulator_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_character_a_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_five_characters_a_b_c_d_e_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_five_characters_a_b_c_d_e_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_character_a_end_of_input_before_end_delimiter_returns_null_token_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_illegal_character_constant_now_line_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_illegal_character_empty_character_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_all_token_types_amid_whitespace_test);

    octaspire_allocator_release(octaspireDernLexerTestAllocator);
    octaspireDernLexerTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_dern_lexer.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/test/test_dern_vm.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_allocator_t *octaspireDernVmTestAllocator = 0;
static octaspire_stdio_t            *octaspireDernVmTestStdio     = 0;

TEST octaspire_dern_vm_new_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    ASSERT(vm->stack);
    ASSERT_EQ(octaspireDernVmTestAllocator, vm->allocator);
    ASSERT(vm->all);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_create_new_value_boolean_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    for (size_t i = 0; i < 256; ++i)
    {
        octaspire_dern_value_t *value = octaspire_dern_vm_create_new_value_boolean(vm, i % 2);

        ASSERT(value);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, value->typeTag);
        ASSERT_EQ(i % 2, value->value.boolean);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_create_new_value_integer_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    for (int32_t i = 0; i < 256; ++i)
    {
        octaspire_dern_value_t *value = octaspire_dern_vm_create_new_value_integer(vm, i);

        ASSERT(value);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, value->typeTag);
        ASSERT_EQ(i, value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_create_new_value_boolean_and_push_one_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *pushedValue = 0;

    for (size_t i = 0; i < 256; ++i)
    {
        octaspire_dern_value_t *value =
            octaspire_dern_vm_create_new_value_boolean(vm, i % 2);

        if (i == 10)
        {
            ASSERT(octaspire_dern_vm_push_value(vm, value));
            pushedValue = value;
        }
    }

    // Make sure we can use the pushed value (it is not freed)
    ASSERT(pushedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, pushedValue->typeTag);
    ASSERT_EQ(10 % 2, pushedValue->value.boolean);
    //ASSERT(octaspire_dern_value_get_hash(pushedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_vm_parse_and_eval_true_amid_whitespace_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string("  \t \n  \t true  ", octaspireDernVmTestAllocator);

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_environment_t *wrappedEnv = octaspire_dern_environment_new(0, vm, octaspireDernVmTestAllocator);

    octaspire_dern_value_t *environment =
        octaspire_dern_vm_create_new_value_environment_from_environment(vm, wrappedEnv);

    ASSERT(environment);

    ASSERT(octaspire_dern_vm_push_value(vm, environment));

    octaspire_dern_value_t *parsedValue = octaspire_dern_vm_parse(vm, input);

    ASSERT(parsedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, parsedValue->typeTag);
    ASSERT_EQ(true,                             parsedValue->value.boolean);

    ASSERT(octaspire_dern_vm_push_value(vm, parsedValue));

    octaspire_dern_value_t *evaluatedValue = octaspire_dern_vm_eval(vm, parsedValue, environment);

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    ASSERT(octaspire_dern_vm_push_value(vm, evaluatedValue));

    ASSERT_EQ(evaluatedValue, octaspire_dern_vm_peek_value(vm));
    octaspire_dern_vm_pop_value(vm, evaluatedValue);

    ASSERT_EQ(parsedValue, octaspire_dern_vm_peek_value(vm));
    octaspire_dern_vm_pop_value(vm, parsedValue);

    ASSERT_EQ(environment, octaspire_dern_vm_peek_value(vm));
    octaspire_dern_vm_pop_value(vm, environment);

    octaspire_dern_vm_release(vm);
    vm = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_vm_special_if_two_elements_false_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if false true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_if_two_elements_true_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if true |g|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("g", octaspire_dern_value_as_character_get_c_string(evaluatedValue)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    
    PASS();
}

TEST octaspire_dern_vm_special_if_three_elements_false_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if false |r| |g|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("g", octaspire_dern_value_as_character_get_c_string(evaluatedValue)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    
    PASS();
}

TEST octaspire_dern_vm_special_if_three_elements_true_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if true |r| |g|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("r", octaspire_dern_value_as_character_get_c_string(evaluatedValue)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    
    PASS();
}

TEST octaspire_dern_vm_special_if_three_elements_with_function_resulting_true_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if (fn () true) |r| |g|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("r", octaspire_dern_value_as_character_get_c_string(evaluatedValue)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_if_three_elements_with_function_call_resulting_true_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if ((fn () true)) |r| |g|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("r", octaspire_dern_value_as_character_get_c_string(evaluatedValue)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_if_called_with_one_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'if' expects two or three arguments. 1 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(if true)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_if_called_with_integer_as_the_first_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if {D+10} true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "First argument to special 'if' must evaluate into boolean value. Now it evaluated "
        "into type integer.\n"
        "\tAt form: >>>>>>>>>>(if {D+10} true)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_one_true_selector_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select true [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_one_false_selector_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select false [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_one_default_selector_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select default [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_one_false_and_one_default_selectors_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select false [p] default [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_one_false_and_one_true_and_one_default_selectors_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select false [p] true [a] default [b])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_one_false_and_one_true_selectors_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select false [p] true [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_function_selectors_evaluating_into_false_and_true_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f1 as (fn () false) [f1] '() howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define t1 as (fn () true) [t1] '() howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select (f1) [p] (t1) [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_function_selectors_failure_on_unknown_symbol_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f1 as (fn () false) [f1] '() howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define t1 as (fn () true) [t1] '() howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select (f1) [p] (f2) [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Cannot evaluate operator of type 'error' (<error>: Unbound symbol 'f2')\n"
        "\tAt form: >>>>>>>>>>(select (f1) [p] (f2) [a])<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_called_with_zero_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'select' expects at least two arguments and the number of arguments must be "
        "multiple of two. Now 0 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(select)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_called_with_one_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'select' expects at least two arguments and the number of arguments must be "
        "multiple of two. Now 1 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(select true)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_called_with_three_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select true [a] default)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'select' expects at least two arguments and the number of arguments must be "
        "multiple of two. Now 3 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(select true [a] default)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_called_non_boolean_selector_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select {D+1} [a] {D+2} [b])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Selectors of special 'select' must evaluate into booleans. Type 'integer' was given.\n"
        "\tAt form: >>>>>>>>>>(select {D+1} [a] {D+2} [b])<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_called_with_default_as_first_selector_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select default [a] 2 [b])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "'default' must be the last selector in special 'select'.\n"
        "\tAt form: >>>>>>>>>>(select default [a] 2 [b])<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_integer_value_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "(define x as {D+10} [test])",
        octaspireDernVmTestAllocator);

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *parsedValue = octaspire_dern_vm_parse(vm, input);

    ASSERT(parsedValue);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_eval_in_global_environment(vm, parsedValue);

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "x");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(10,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_integer_value_with_explicit_target_global_env_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10} [test] in (env-global))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "x");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(10,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(doc x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("test", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_my_inc_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define my-inc as (fn (value) (++ value)) [my own inc-function] '(value [the value to increase]) howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(doc my-inc)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "my own inc-function\n"
        "Arguments are:\n"
        "value -> the value to increase",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(my-inc {D+111})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(112,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_factorial_function_with_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define factorial as (fn (n) (if (== n {D+0}) {D+1} (* n (factorial (- n {D+1}))))) [factorial function] '(n [calculate n!]) howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(doc factorial)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "factorial function\n"
        "Arguments are:\n"
        "n -> calculate n!",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    int32_t const expected[] = {1, 1, 2, 6, 24, 120, 720, 5040};

    char const * const input[] =
    {
        "(factorial {D+0})",
        "(factorial {D+1})",
        "(factorial {D+2})",
        "(factorial {D+3})",
        "(factorial {D+4})",
        "(factorial {D+5})",
        "(factorial {D+6})",
        "(factorial {D+7})",
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, input[i]);

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(expected[i],                      evaluatedValue->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_factorial_function_with_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define factorial as (fn (n) (if (<= n {D+0.0}) {D+1.0} (* n (factorial (- n {D+1}))))) [factorial function] '(n [calculate n!]) howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(doc factorial)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "factorial function\n"
        "Arguments are:\n"
        "n -> calculate n!",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    double const expected[] = {1, 1, 2, 6, 24, 120, 720, 5040};

    char const * const input[] =
    {
        "(factorial {D+0.0})",
        "(factorial {D+1.0})",
        "(factorial {D+2.0})",
        "(factorial {D+3.0})",
        "(factorial {D+4.0})",
        "(factorial {D+5.0})",
        "(factorial {D+6.0})",
        "(factorial {D+7.0})",
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, input[i]);

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
        ASSERT_IN_RANGE(expected[i],             evaluatedValue->value.real, 0.000001);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_three_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define' expects four, six or eight arguments. "
        "3 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(define x as {D+10})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_eight_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define myEnv as (env-new) [myEnv])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () {D+128}) [f] '() in myEnv howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Make sure f is NOT defined in global environment
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "f");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Unbound symbol 'f'",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    // Make sure f IS defined in myEnv-environment
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval f myEnv)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_FUNCTION, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval (f) myEnv)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(128,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_four_arguments_first_being_value_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define {D+10} as x [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The first argument of special 'define' is a vector but doesn't evaluate into "
        "a symbol. It evaluates into '{D+10}'.\n"
        "\tAt form: >>>>>>>>>>(define {D+10} as x [x])<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_eight_arguments_first_being_integer_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define myEnv as (env-new) [myEnv])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define {D+10} as (fn () {D+128}) [f] '() in myEnv howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The first argument of special 'define' is a vector but doesn't evaluate into "
        "a symbol. It evaluates into '{D+10}'.\n"
        "\tAt form: >>>>>>>>>>(define {D+10} as (fn () {D+128}) [f] (quote ()) in myEnv howto-ok)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_four_arguments_error_at_first_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as (noSuchFuNcTion) [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Cannot evaluate operator of type 'error' (<error>: Unbound symbol 'noSuchFuNcTion')\n"
        "\tAt form: >>>>>>>>>>(define x as (noSuchFuNcTion) [x])<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_four_arguments_with_docstring_being_integer_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10} {D+20})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define' expects documentation string as the fourth argument "
        "in this context. Value '{D+20}' was given.\n"
        "\tAt form: >>>>>>>>>>(define x as {D+10} {D+20})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_four_arguments_name_evaluates_into_integer_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define {D+20} as (fn () {D+10}) [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The first argument of special 'define' is a vector but doesn't evaluate into "
        "a symbol. It evaluates into '{D+20}'.\n"
        "\tAt form: >>>>>>>>>>(define {D+20} as (fn () {D+10}) [x])<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_six_arguments_docstring_is_integer_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () 'x) {D+20} '() howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define' expects documentation string as the fourth argument in this "
        "context. Value '{D+20}' was given.\n"
        "\tAt form: >>>>>>>>>>(define f as (fn () (quote x)) {D+20} (quote ()) howto-ok)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_eight_arguments_error_in_environment_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () 'x) [f] '() in (noSuchFuNcTion) howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define' expects environment as the seventh argument in this "
        "context. Value '<error>: Cannot evaluate operator of type 'error' (<error>: "
        "Unbound symbol 'noSuchFuNcTion')' was given.\n"
        "\tAt form: >>>>>>>>>>(define f as (fn () (quote x)) [f] (quote ()) in (noSuchFuNcTion) howto-ok)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_four_arguments_integer_as_docstring_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+20} {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define' expects documentation string as the fourth argument "
        "in this context. Value '{D+10}' was given.\n"
        "\tAt form: >>>>>>>>>>(define x as {D+20} {D+10})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_quote_called_without_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(quote)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'quote' expects one argument. 0 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(quote)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_plus_integer_value_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10} [test])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (int32_t i = 0; i < 100; ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(++ x)");

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(10 + 1 + i,                       evaluatedValue->value.integer);
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "x");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(110,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_doc_for_integer_value_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10} [x-coordinate])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(doc x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "x-coordinate",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_read_and_eval_path_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    // TODO what about the path separator? Cross platform?
    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(read-and-eval-path [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_read_and_eval_path_test.dern])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(200,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_read_and_eval_string_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(read-and-eval-string [(++ {D+10})])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(11,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_1_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ {D+1})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(1, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_10_2_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ {D+10} {D+2} {D+2})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(2.5, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_0_2_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ {D+0} {D+2} {D+2})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(0, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_100_10_0dot5_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ {D+100} {D+10} {D+0.5})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(20, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_100_minus10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ {D+100} {D-10})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(-10, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin '/' expects at least one numeric argument (integer or real).\n"
        "\tAt form: >>>>>>>>>>(/)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_0_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ {D+0})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "First argument to builtin '/' cannot be zero. It would cause division by zero.\n"
        "\tAt form: >>>>>>>>>>(/ {D+0})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_10_2_0_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ {D+10} {D+2} {D+0})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Argument number 3 to builtin '/' cannot be zero. It would cause division by zero.\n"
        "\tAt form: >>>>>>>>>>(/ {D+10} {D+2} {D+0})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_10_2_character_a_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ {D+10} {D+2} |a|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin '/' expects numeric arguments (integer or real). 3th argument has type character.\n"
        "\tAt form: >>>>>>>>>>(/ {D+10} {D+2} |a|)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_mod_5_mod_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(mod {D+5} {D+3})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_mod_0_mod_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(mod {D+0} {D+3})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_mod_3_mod_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(mod {D+3} {D+3})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_mod_4_mod_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(mod {D+4} {D+3})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_mod_4_mod_0_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(mod {D+4} {D+0})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The second argument to builtin 'mod' cannot be zero. "
        "It would cause division by zero.\n"
        "\tAt form: >>>>>>>>>>(mod {D+4} {D+0})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_1_2_3_4_minus_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ {D+1} {D+2} {D+3} {D+4} {D-2})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(8,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_1_2_3_4_minus_2_2dot5_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ {D+1} {D+2} {D+3} {D+4} {D-2} {D+2.5})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_EQ(10.5,                          evaluatedValue->value.real);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_string_cat_dog_and_string_space_and_string_zebra_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ [cat, dog] [ ] [and zebra])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "cat, dog and zebra",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_string_ca_and_character_t_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ [ca] |t|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "cat",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_empty_string_and_characters_k_i_t_t_e_n_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ [] |k| |i| |t| |t| |e| |n|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "kitten",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_vector_1_2_3_and_4_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ '({D+1} {D+2} {D+3}) {D+4})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "({D+1} {D+2} {D+3} {D+4})",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_vector_1_2_3_and_4_and_a_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ '({D+1} {D+2} {D+3}) {D+4} |a|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "({D+1} {D+2} {D+3} {D+4} |a|)",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_empty_vector_and_1_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ '() {D+1})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "({D+1})",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_empty_vector_and_empty_vector_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ '() '())");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "(())",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_empty_vector_and_empty_vector_and_empty_vector_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ '() '() '())");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "(() ())",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_empty_hash_map_and_1_and_a_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ (hash-map) {D+1} |a|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "(hash-map {D+1} |a|)",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_hash_map_1_a_and_2_and_b_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ (hash-map {D+1} |a|) {D+2} |b|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "(hash-map {D+2} |b|\n          {D+1} |a|)",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_hash_map_1_a_and_2_and_b_and_3_and_c_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ (hash-map {D+1} |a|)   {D+2} |b|   {D+3} |c|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "(hash-map {D+2} |b|\n          {D+3} |c|\n          {D+1} |a|)",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_string_cat_dog_cat_and_string_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(- [cat dog cat] [cat])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(" dog ", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_string_abcabcabc_and_character_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(- [abcabcabc] |a|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("bcbcbc", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_string_abcabcabc_and_character_a_and_character_b_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(- [abcabcabc] |a| |b|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("ccc", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_string_abcabcabc_and_character_a_and_character_b_and_caharacter_c_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(- [abcabcabc] |a| |b| |c|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_1_2_3_4_minus_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(- {D+1} {D+2} {D+3} {D+4} {D-2})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(-6,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_1_2_3_4_minus_2_2dot5_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(- {D+1} {D+2} {D+3} {D+4} {D-2} {D+2.5})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(-8.5, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_abcdeaaba_character_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [abcdeaaba] |a|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 5, 6, 8};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_abcdeaaba_character_y_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [abcdeaaba] |y|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_string_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [cat dog cat zebra cat] [cat])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 8, 18};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_string_parrot_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [cat dog cat zebra cat] [parrot])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_quoted_symbol_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [cat dog cat zebra cat] 'cat)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 8, 18};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_quoted_symbol_parrot_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [cat dog cat zebra cat] 'parrot)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_123_124_abc_123_99_123_integer_123_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [123 124 abc 123 99 123] {D+123})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 12, 19};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_123_124_abc_123_99_123_integer_777_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [123 124 abc 123 99 123] {D+777})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_3dot14_abc_3dot13_3dot14_3dot146_3dot14_real_3dot14_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [3.14 abc 3.13 3.14 3.146 3.14] {D+3.14})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 14, 19, 25};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_3dot14_abc_3dot13_3dot14_3dot146_3dot14_real_7dot11_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [3.14 abc 3.13 3.14 3.146 3.14] {D+7.11})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_abc_def_aaxa_char_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'abc_def_aaxa |a|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 8, 9, 11};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_abc_def_aaxa_char_y_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'abc_def_aaxa |y|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_string_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_dog_cat_cat_zebra_cat [cat])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 8, 12, 22};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_string_parrot_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_dog_cat_cat_zebra_cat [parrot])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_symbol_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_dog_cat_cat_zebra_cat 'cat)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 8, 12, 22};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_symbol_parrot_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_dog_cat_cat_zebra_cat 'parrot)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_123_dog_cat_123_123_cat_zebra_123_integer_123_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_123_dog_cat_123_123_cat_zebra_123 {D+123})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {4, 16, 20, 34};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_321_dog_cat_321_321_cat_zebra_321_integer_123_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_321_dog_cat_321_321_cat_zebra_321 {D+123})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_3dot14_dog_cat_3dot14_3dot14_cat_zebra_3dot14_real_3dot14_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_3.14_dog_cat_3.14_3.14_cat_zebra_3.14 {D+3.14})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {4, 17, 22, 37};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_3dot14_dog_cat_3dot14_3dot14_cat_zebra_3dot14_real_4dot14_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_3.14_dog_cat_3.14_3.14_cat_zebra_3.14 {D+4.14})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_vector_of_chars_a_b_c_a_a_g_u_a_char_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find '(|a| |b| |c| |a| |a| |g| |u| |a|) |a|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 3, 4, 7};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_vector_of_chars_a_b_c_a_a_g_u_a_char_x_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find '(|a| |b| |c| |a| |a| |g| |u| |a|) |x|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_vector_of_strings_cat_dog_cat_zebra_parrot_cat_string_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find '([cat] [dog] [cat] [zebra] [parrot] [cat]) [cat])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 2, 5};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_vector_of_strings_cat_dog_cat_zebra_parrot_cat_string_kitten_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find '([cat] [dog] [cat] [zebra] [parrot] [cat]) [kitten])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_vector_of_symbols_cat_dog_cat_zebra_parrot_cat_symbol_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find '(cat dog cat zebra parrot cat) 'cat)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 2, 5};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_vector_of_symbols_cat_dog_cat_zebra_parrot_cat_symbol_mouse_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find '(cat dog cat zebra parrot cat) 'mouse)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_chars_a_b_c_d_char_c_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map |a| {D+1} |b| {D+2} |c| {D+3} |d| {D+4}) |c|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_chars_a_b_c_d_char_x_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map |a| {D+1} |b| {D+2} |c| {D+3} |d| {D+4}) |x|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_chars_a_b_c_d_char_b_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map |a| true |b| false |c| nil |d| {D+4}) |b|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_strings_cat_dog_zebra_kitten_string_zebra_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map [cat] |a| [dog] |b| [zebra] |c| [kitten] |d|) [zebra])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("c", octaspire_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_strings_cat_dog_zebra_kitten_string_parrot_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map [cat] |a| [dog] |b| [zebra] |c| [kitten] |d|) [parrot])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_integers_1_2_3_4_integer_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map {D+1} [cat] {D+2} [dog] {D+3} [zebra] {D+4} [kitten]) {D+2})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("dog", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_integers_1_2_3_4_integer_5_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map {D+1} [cat] {D+2} [dog] {D+3} [zebra] {D+4} [kitten]) {D+5})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_reals_2dot1_2dot2_2dot3_2dot4_real_2dot2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map {D+2.1} {D+1}   {D+2.2} {D+2}   {D+2.3} {D+3}   {D+2.4} {D+4}) {D+2.2})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_reals_2dot1_2dot2_2dot3_2dot4_real_2dot5_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map {D+2.1} {D+1}   {D+2.2} {D+2}   {D+2.3} {D+3}   {D+2.4} {D+4}) {D+2.5})");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_global_environment_symbol_find_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (env-global) 'find)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BUILTIN, evaluatedValue->typeTag);
    ASSERT_EQ(octaspire_dern_vm_builtin_find,   evaluatedValue->value.builtin->cFunction);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_global_environment_defined_symbol_xyz_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define xyz as '({D+1} {D+2} {D+3}) [xyz] )");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (env-global) 'xyz)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (int32_t i = 0; i < 3; ++i)
    {
        octaspire_dern_value_t const * const tmp =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(tmp);
        ASSERT_EQ(i + 1, tmp->value.integer);
    }


    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_global_environment_symbol_notfound_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (env-global) 'notfound)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_while_with_one_value_to_repeat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define i as {D+0} [i])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(while (<= i {D+100}) (++ i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(101,                              evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "i");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(101,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_while_with_two_values_to_repeat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define i as {D+0} [i])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define j as {D+1000} [j])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(while (<= i {D+100}) (++ i) (-- j))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(101,                              evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "i");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(101,                              evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "j");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(899,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_while_called_with_one_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(while true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'while' expects at least two arguments. 1 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(while true)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_while_called_with_integer_as_first_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+0} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(while {D+1} (++ x))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "First argument to special 'while' must evaluate into boolean value. Now it evaluated "
        "into type integer.\n"
        "\tAt form: >>>>>>>>>>(while {D+1} (++ x))<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_hash_map_empty_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(hash-map)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_hash_map_one_element_symbol_one_1_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(hash-map 'one {D+1})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_map_element_t *element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 0);

    ASSERT(element);

    evaluatedValue = octaspire_map_element_get_key(element);
    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);
    ASSERT_STR_EQ("one", octaspire_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue = octaspire_map_element_get_value(element);
    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1, evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_hash_map_one_element_1_symbol_one_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(hash-map {D+1} 'one)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_map_element_t *element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 0);

    ASSERT(element);

    evaluatedValue = octaspire_map_element_get_key(element);
    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1, evaluatedValue->value.integer);

    evaluatedValue = octaspire_map_element_get_value(element);
    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);
    ASSERT_STR_EQ("one", octaspire_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_hash_map_two_elements_strings_dog_barks_and_sun_shines_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(hash-map [dog] [barks] [sun] [shines])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(2, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    ASSERT(octaspire_dern_vm_push_value(vm, evaluatedValue));

    char const * const keys[] =
    {
        "dog",
        "sun"
    };

    char const * const expected[] =
    {
        "barks",
        "shines"
    };

    ASSERT_EQ(sizeof(keys) / sizeof(keys[0]), sizeof(expected) / sizeof(expected[0]));

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t *keyValue = octaspire_dern_vm_create_new_value_string_from_c_string(
            vm,
            keys[i]);

        ASSERT(keyValue);

        octaspire_map_element_t *element = octaspire_dern_value_as_hash_map_get(
            evaluatedValue,
            octaspire_dern_value_get_hash(keyValue),
            keyValue);

        ASSERT(element);

        octaspire_dern_value_t *valueValue = octaspire_map_element_get_value(element);
        ASSERT(valueValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, valueValue->typeTag);
        ASSERT_STR_EQ(expected[i], octaspire_string_get_c_string(valueValue->value.string));
    }

    ASSERT(octaspire_dern_vm_pop_value(vm, evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_characters_t_bar_newline_tab_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[ca|t||bar|dog and parrot |newline||tab| 123]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "cat|dog and parrot \n\t 123",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_characters_c_a_t__a_n_d__d_o_g_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|c||a||t|| ||a||n||d|| ||d||o||g|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "cat and dog",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_newline_failure_on_missing_end_delimiter_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|newline]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Problem with a character embedded in string: (character is not complete)",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_yy_failure_on_unknown_char_constant_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|yy|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Problem with a character embedded in string: (Unknown character constant |yy|)",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_in_hex_A9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|A9|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_in_hex_a9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|a9|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|a|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "a",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_in_hex_0x10000_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|10000|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_in_hex_failure_on_too_many_hex_digits_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|123456789|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Problem with a character embedded in string: (Number of hex digits (9) in character definition may not be larger than eight)",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_empty_vector_of_strings_and_integer_10_and_string_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '() [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "v");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0,                               octaspire_dern_value_as_vector_get_length(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= v {D+10} [cat])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(11,                              octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(evaluatedValue); ++i)
    {
        octaspire_dern_value_t const * const element =
            octaspire_dern_value_as_vector_get_element_at_const(
                evaluatedValue,
                (ptrdiff_t)i);

        ASSERT(element);

        if (octaspire_dern_value_as_vector_is_valid_index(
                evaluatedValue,
                (ptrdiff_t)(i + 1)))
        {
            ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, element->typeTag);
        }
        else
        {
            ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, element->typeTag);

            ASSERT_STR_EQ(
                "cat",
                octaspire_string_get_c_string(element->value.string));
        }
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_vector_of_strings_and_integer_1_and_string_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '([first] [second] [third]) [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "v");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3,                               octaspire_dern_value_as_vector_get_length(evaluatedValue));

    octaspire_dern_value_t const *vecElemVal =
        octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 0);

    ASSERT(vecElemVal);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, vecElemVal->typeTag);
    ASSERT_STR_EQ("first", octaspire_dern_value_as_string_get_c_string(vecElemVal));

    vecElemVal = octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 1);
    ASSERT(vecElemVal);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, vecElemVal->typeTag);
    ASSERT_STR_EQ("second", octaspire_dern_value_as_string_get_c_string(vecElemVal));

    vecElemVal = octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 2);
    ASSERT(vecElemVal);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, vecElemVal->typeTag);
    ASSERT_STR_EQ("third", octaspire_dern_value_as_string_get_c_string(vecElemVal));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= v {D+1} [cat])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3,                               octaspire_dern_value_as_vector_get_length(evaluatedValue));

    vecElemVal = octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 0);
    ASSERT(vecElemVal);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, vecElemVal->typeTag);
    ASSERT_STR_EQ("first", octaspire_dern_value_as_string_get_c_string(vecElemVal));

    vecElemVal = octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 1);
    ASSERT(vecElemVal);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, vecElemVal->typeTag);
    ASSERT_STR_EQ("cat", octaspire_dern_value_as_string_get_c_string(vecElemVal));

    vecElemVal = octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 2);
    ASSERT(vecElemVal);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, vecElemVal->typeTag);
    ASSERT_STR_EQ("third", octaspire_dern_value_as_string_get_c_string(vecElemVal));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_hash_map_and_same_key_inserted_multiple_times_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define target as (hash-map |a| {D+1}) [target])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    // First addition
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= target |a| {D+2})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "target");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    octaspire_map_t * hashMap = evaluatedValue->value.hashMap;

    ASSERT_EQ(1, octaspire_map_get_number_of_elements(hashMap));

    octaspire_map_element_t *element =
        octaspire_map_get_at_index(hashMap, 0);

    ASSERT(element);

    octaspire_dern_value_t *key = octaspire_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, key->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(key->value.string));

    octaspire_dern_value_t *value = octaspire_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, value->typeTag);
    ASSERT_EQ(2,                                 value->value.integer);



    // Second addition
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= target |a| {D+3})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "target");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    hashMap = evaluatedValue->value.hashMap;

    ASSERT_EQ(1, octaspire_map_get_number_of_elements(hashMap));

    element =
        octaspire_map_get_at_index(hashMap, 0);

    ASSERT(element);

    key = octaspire_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, key->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(key->value.string));

    value = octaspire_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, value->typeTag);
    ASSERT_EQ(3,                                 value->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_hash_map_and_hash_map_with_elements_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define target as (hash-map) [target])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define source as (hash-map {D+1} |a| {D+2} |b|) [source])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= target source)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "target");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    octaspire_map_t * const hashMap = evaluatedValue->value.hashMap;

    ASSERT_EQ(2, octaspire_map_get_number_of_elements(hashMap));

    octaspire_map_element_t *element =
        octaspire_map_get_at_index(hashMap, 1);

    ASSERT(element);

    octaspire_dern_value_t *key = octaspire_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, key->typeTag);
    ASSERT_EQ(1,                                key->value.integer);

    octaspire_dern_value_t *value = octaspire_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(value->value.character));

    element =
        octaspire_map_get_at_index(hashMap, 0);

    ASSERT(element);

    key = octaspire_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, key->typeTag);
    ASSERT_EQ(2,                                key->value.integer);

    value = octaspire_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("b", octaspire_string_get_c_string(value->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_hash_map_and_empty_hash_map_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define target as (hash-map {D+1} |a|) [target])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define source as (hash-map) [source])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= target source)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "target");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    octaspire_map_t * const hashMap = evaluatedValue->value.hashMap;

    ASSERT_EQ(0, octaspire_map_get_number_of_elements(hashMap));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_vector_and_vector_with_elements_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define target as '() [target])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define source as '({D+1} |a|) [source])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= target source)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "target");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    ASSERT_EQ(2, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    octaspire_dern_value_t const * value =
        octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 0);

    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, value->typeTag);
    ASSERT_EQ(1,                                value->value.integer);

    value =
        octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 1);

    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(value->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_vector_and_empty_vector_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define target as '({D+1} {D+2} {D+3}) [target])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define source as '() [source])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= target source)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "target");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    ASSERT_EQ(0, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_string_and_index_and_character_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [Pong] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= s {D+1} ||)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("Png", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("Png", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_character_x_and_integer_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define c as |x| [c])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= c {D+2})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("v", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_character_x_and_character_exclamation_mark_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define c as |x| [c])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= c |!|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("W", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_real_3_dot_14_and_reals_1_dot_0_and_zero_dot_14_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define r as {D+3.14} [r])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= r {D+1.0} {D+0.14})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(2.0, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_integer_10_and_integers_1_and_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define i as {D+10} [i])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= i {D+1} {D+2})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(7, evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_vector_1_1_2_2_2_3_and_values_1_and_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '({D+1} {D+1} {D+2} {D+2} {D+2} {D+3}) [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= v {D+1} {D+2})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    octaspire_dern_value_t const * const value = octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 0);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER,  value->typeTag);
    ASSERT_EQ(3,                                 value->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_string_abcd_and_characters_a_and_b_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abcd] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= s |a| |b|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("cd", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_hash_map_1_a_2_b_3_c_and_value_1_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h as (hash-map {D+1} |a| {D+2} |b| {D+3} |c|) [h])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= h {D+2} {D+3})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_map_element_t const * const element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 0);

    ASSERT(element);

    octaspire_dern_value_t const * const key = octaspire_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER,  key->typeTag);
    ASSERT_EQ(1,                                 key->value.integer);

    octaspire_dern_value_t const * const value = octaspire_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(value->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_vector_1_2_3_3_and_ln_at_v_minus_1_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '({D+1} {D+2} {D+3} {D+3}) [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= v (ln@ v {D-1}))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "({D+1} {D+2})",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_equals_with_vector_1_2_3_3_and_ln_at_v_minus_1_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '({D+1} {D+2} {D+3} {D+3}) [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-== v (ln@ v {D-1}))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "({D+1} {D+2} {D+3})",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}



TEST octaspire_dern_vm_builtin_pop_front_with_vector_1_2_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '({D+1} {D+2} {D+3}) [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    char const * const expected[] =
    {
        "({D+2} {D+3})",
        "({D+3})",
        "()",
        "()",
        "()"
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
                vm,
                "(pop-front v)");

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

        octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
            evaluatedValue,
            octaspire_dern_vm_get_allocator(vm));

        ASSERT_STR_EQ(
            expected[i],
            octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(len v)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_pop_front_with_string_abc_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abc] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    char const * const expected[] =
    {
        "[bc]",
        "[c]",
        "[]",
        "[]",
        "[]"
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
                vm,
                "(pop-front s)");

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

        octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
            evaluatedValue,
            octaspire_dern_vm_get_allocator(vm));

        ASSERT_STR_EQ(
            expected[i],
            octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(len s)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_pop_front_with_symbol_abc_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as 'abc [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    char const * const expected[] =
    {
        "bc",
        "c",
        "",
        "",
        ""
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
                vm,
                "(pop-front s)");

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

        octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
            evaluatedValue,
            octaspire_dern_vm_get_allocator(vm));

        ASSERT_STR_EQ(
            expected[i],
            octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(len s)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_pop_front_with_list_1_2_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define l as (list {D+1} {D+2} {D+3}) [l])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    char const * const expected[] =
    {
        "(list {D+2} {D+3})",
        "(list {D+3})",
        "(list )",
        "(list )",
        "(list )"
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
                vm,
                "(pop-front l)");

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_LIST, evaluatedValue->typeTag);

        octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
            evaluatedValue,
            octaspire_dern_vm_get_allocator(vm));

        ASSERT_STR_EQ(
            expected[i],
            octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(len l)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_pop_front_with_integer_10_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(pop-front {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR,  evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "First argument to builtin 'pop-front' cannot be of type 'integer'.\n"
        "\tAt form: >>>>>>>>>>(pop-front {D+10})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}




TEST octaspire_dern_vm_builtin_pop_back_with_vector_1_2_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '({D+1} {D+2} {D+3}) [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    char const * const expected[] =
    {
        "({D+1} {D+2})",
        "({D+1})",
        "()",
        "()",
        "()"
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
                vm,
                "(pop-back v)");

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

        octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
            evaluatedValue,
            octaspire_dern_vm_get_allocator(vm));

        ASSERT_STR_EQ(
            expected[i],
            octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(len v)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_pop_back_with_string_abc_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abc] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    char const * const expected[] =
    {
        "[ab]",
        "[a]",
        "[]",
        "[]",
        "[]"
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
                vm,
                "(pop-back s)");

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

        octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
            evaluatedValue,
            octaspire_dern_vm_get_allocator(vm));

        ASSERT_STR_EQ(
            expected[i],
            octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(len s)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_pop_back_with_symbol_abc_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as 'abc [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    char const * const expected[] =
    {
        "ab",
        "a",
        "",
        "",
        ""
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
                vm,
                "(pop-back s)");

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

        octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
            evaluatedValue,
            octaspire_dern_vm_get_allocator(vm));

        ASSERT_STR_EQ(
            expected[i],
            octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(len s)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_pop_back_with_list_1_2_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define l as (list {D+1} {D+2} {D+3}) [l])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    char const * const expected[] =
    {
        "(list {D+1} {D+2})",
        "(list {D+1})",
        "(list )",
        "(list )",
        "(list )"
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
                vm,
                "(pop-back l)");

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_LIST, evaluatedValue->typeTag);

        octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
            evaluatedValue,
            octaspire_dern_vm_get_allocator(vm));

        ASSERT_STR_EQ(
            expected[i],
            octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(len l)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_pop_back_with_queue_1_2_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q as (queue {D+1} {D+2} {D+3}) [q])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    char const * const expected[] =
    {
        "(queue {D+2} {D+3})",
        "(queue {D+3})",
        "(queue )",
        "(queue )",
        "(queue )"
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
                vm,
                "(pop-back q)");

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

        octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
            evaluatedValue,
            octaspire_dern_vm_get_allocator(vm));

        ASSERT_STR_EQ(
            expected[i],
            octaspire_string_get_c_string(tmpStr));

        octaspire_string_release(tmpStr);
        tmpStr = 0;
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(len q)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_pop_back_with_integer_10_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(pop-back {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR,  evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "First argument to builtin 'pop-back' cannot be of type 'integer'.\n"
        "\tAt form: >>>>>>>>>>(pop-back {D+10})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_hash_map_and_hash_map_1_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h as (hash-map)[h])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= h (hash-map {D+1} |a|))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_map_element_t const * const element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 0);

    ASSERT(element);

    octaspire_dern_value_t const * const key = octaspire_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER,  key->typeTag);
    ASSERT_EQ(1,                                 key->value.integer);

    octaspire_dern_value_t const * const value = octaspire_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(value->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_hash_map_and_1_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h as (hash-map) [h])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= h {D+1} |a|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_map_element_t const * const element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 0);

    ASSERT(element);

    octaspire_dern_value_t const * const key = octaspire_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER,  key->typeTag);
    ASSERT_EQ(1,                                 key->value.integer);

    octaspire_dern_value_t const * const value = octaspire_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(value->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_hash_map_and_list_1_a_2_b_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h as (hash-map) [h])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= h '({D+1} |a| {D+2} |b|))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(2, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_map_element_t const * element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 1);

    ASSERT(element);

    octaspire_dern_value_t const * key = octaspire_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER,  key->typeTag);
    ASSERT_EQ(1,                                 key->value.integer);

    octaspire_dern_value_t const * value = octaspire_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(value->value.character));

    element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 0);

    ASSERT(element);

    key = octaspire_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER,  key->typeTag);
    ASSERT_EQ(2,                                 key->value.integer);

    value = octaspire_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("b", octaspire_string_get_c_string(value->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_vector_1_2_3_and_4_5_6_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '({D+1} {D+2} {D+3}) [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= v {D+4} {D+5} {D+6})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(6,                               octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(evaluatedValue); ++i)
    {
        octaspire_dern_value_t const * const element =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                (ptrdiff_t)i);

        ASSERT   (element);
        ASSERT_EQ((int32_t)(i+1), element->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_string_def_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abc] [target string])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s [def])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abcdef";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_symbol_def_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abc] [target string])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s 'def)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abcdef";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_character_d_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abc] [target string])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s |d|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abcd";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_vector_of_strings_def_ghi_jkl_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abc] [target string])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s '([def] [ghi] [jkl]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abcdefghijkl";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_nil_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abc] [target string])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s nil)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abcnil";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_booleans_true_and_false_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abc] [target string])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s true false)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abctruefalse";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_integer_128_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abc] [target string])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s {D+128})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abc{D+128}";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_real_3dot14_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abc] [target string])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s {D+3.14})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abc{D+3.14}";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}





TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_string_def_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as 'abc [target symbol])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s [def])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abcdef";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_symbol_def_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as 'abc [target symbol])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s 'def)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abcdef";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_character_d_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as 'abc [target symbol])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s |d|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abcd";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_vector_of_strings_def_ghi_jkl_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as 'abc [target symbol])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s '([def] [ghi] [jkl]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abcdefghijkl";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_nil_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as 'abc [target symbol])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s nil)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abcnil";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_booleans_true_and_false_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as 'abc [target symbol])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s true false)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abctruefalse";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_integer_128_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as 'abc [target symbol])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s {D+128})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abc{D+128}";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_real_3dot14_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as 'abc [target symbol])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s {D+3.14})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abc{D+3.14}";

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}










TEST octaspire_dern_vm_builtin_plus_equals_with_bad_input_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= (hash-map {D+1} a|) (hash-map {D+2} |b|))");
    // bad input here      ^^^

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR,  evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Unknown character constant |) (hash-map {D+2} |",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_run_user_factorial_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_path_and_eval_in_global_environment(
            vm,
            OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_dern_vm_run_user_factorial_function_test.dern");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(101,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_from_0_to_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '() [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i from {D+0} to {D+10} (+= v i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(11,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "v");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(11, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (int32_t i = 0; i < 11; ++i)
    {
        octaspire_dern_value_t const * const tmp =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(tmp);
        ASSERT_EQ(i, tmp->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_from_0_to_10_with_step_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '() [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i from {D+0} to {D+10} step {D+2} (+= v i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(6,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "v");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(6, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (int32_t i = 0, cmp = 0; i < 6; ++i, cmp += 2)
    {
        octaspire_dern_value_t const * const tmp =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(tmp);
        ASSERT_EQ(cmp, tmp->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_from_0_to_10_with_step_minus_2_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '() [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i from {D+0} to {D+10} step {D-2} (+= v i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The 'step' of special 'for' must be larger than zero. Now it is {D-2}.\n"
        "\tAt form: >>>>>>>>>>(for i from {D+0} to {D+10} step {D-2} (+= v i))<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_from_10_to_0_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '() [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i from {D+10} to {D+0} (+= v i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(11,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "v");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(11, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (int32_t i = 0; i < 11; ++i)
    {
        octaspire_dern_value_t const * const tmp =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(tmp);
        ASSERT_EQ(10 - i, tmp->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_from_10_to_0_with_step_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '() [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i from {D+10} to {D+0} step {D+2} (+= v i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(6,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "v");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(6, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (int32_t i = 0, cmp = 0; i < 6; ++i, cmp += 2)
    {
        octaspire_dern_value_t const * const tmp =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(tmp);
        ASSERT_EQ(10 - cmp, tmp->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_from_10_to_0_with_step_minus_2_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '() [v])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i from {D+10} to {D+0} step {D-2} (+= v i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "The 'step' of special 'for' must be larger than zero. Now it is {D-2}.\n"
        "\tAt form: >>>>>>>>>>(for i from {D+10} to {D+0} step {D-2} (+= v i))<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}


TEST octaspire_dern_vm_special_for_in_with_string_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define n as [abc] [n])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in n (+= s i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "abc",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_string_step_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define n as [abc] [n])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in n step {D+2} (+= s i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "ac",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_string_step_minus_2_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define n as [abc] [n])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in n step {D-2} (+= s i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The 'step' of special 'for' must be larger than zero. Now it is {D-2}.\n"
        "\tAt form: >>>>>>>>>>(for i in n step {D-2} (+= s i))<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_vector_of_strings_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define n as '([John] [Mike] [Ellie]) [n])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in n (+= s i [ ]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "John Mike Ellie ",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_vector_of_strings_step_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define n as '([John] [Mike] [Ellie]) [n])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in n step {D+2} (+= s i [ ]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "John Ellie ",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_vector_of_strings_step_minus_2_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define n as '([John] [Mike] [Ellie]) [n])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in n step {D-2} (+= s i [ ]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "The 'step' of special 'for' must be larger than zero. Now it is {D-2}.\n"
        "\tAt form: >>>>>>>>>>(for i in n step {D-2} (+= s i [ ]))<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_environment_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e as (env-new) [e])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 as (env-new) [e2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    // a is 1
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as {D+1} [a] in e)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // b is 2
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define b as {D+2} [b] in e)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // c is 3
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define c as {D+3} [c] in e)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in e (define (ln@ i {D+0}) as (ln@ i {D+1}) [-] in e2))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string e2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "---------- environment ----------\n"
        "a -> {D+1}\n"
        "b -> {D+2}\n"
        "c -> {D+3}\n"
        "---------------------------------\n",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_environment_step_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e as (env-new) [e])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 as (env-new) [e2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    // a is 1
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as {D+1} [a] in e)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // b is 2
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define b as {D+2} [b] in e)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // c is 3
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define c as {D+3} [c] in e)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in e step {D+2} (define (ln@ i {D+0}) as (ln@ i {D+1}) [-] in e2))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    // octaspire_map_t is not ordered map, so we cannot know for sure which
    // two values are the first ones in the map.

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_environment_step_minus_2_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e as (env-new) [e])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 as (env-new) [e2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    // a is 1
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as {D+1} [a] in e)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // b is 2
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define b as {D+2} [b] in e)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // c is 3
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define c as {D+3} [c] in e)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in e step {D-2} (define (ln@ i {D+0}) as (ln@ i {D+1}) [-] in e2))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "The 'step' of special 'for' must be larger than zero. Now it is {D-2}.\n"
        "\tAt form: >>>>>>>>>>(for i in e step {D-2} (define (ln@ i {D+0}) as (ln@ i {D+1}) [-] in e2))<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_hash_map_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h as (hash-map 'a {D+1} 'b {D+2} 'c {D+3}) [h])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e as (env-new) [e])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in h (define (ln@ i {D+0}) as (ln@ i {D+1}) [-] in e))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string e)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "---------- environment ----------\n"
        "a -> {D+1}\n"
        "b -> {D+2}\n"
        "c -> {D+3}\n"
        "---------------------------------\n",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_hash_map_step_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h as (hash-map 'a {D+1} 'b {D+2} 'c {D+3}) [h])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e as (env-new) [e])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in h step {D+2} (define (ln@ i {D+0}) as (ln@ i {D+1}) [-] in e))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    // octaspire_map_t is not ordered map, so we cannot know for sure which
    // two values are the first ones in the map.

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_hash_map_step_minus_2_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h as (hash-map 'a {D+1} 'b {D+2} 'c {D+3}) [h])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e as (env-new) [e])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in h step {D-2} (define (ln@ i {D+0}) as (ln@ i {D+1}) [-] in e))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The 'step' of special 'for' must be larger than zero. Now it is {D-2}.\n"
        "\tAt form: >>>>>>>>>>(for i in h step {D-2} (define (ln@ i {D+0}) as (ln@ i {D+1}) [-] in e))<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_called_without_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'for' expects at least four (for iterating container or port) or five (for "
        "iterating numeric range) arguments. 0 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(for)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_called_with_one_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'for' expects at least four (for iterating container or port) or five (for "
        "iterating numeric range) arguments. 1 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(for i)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_second_argument_not_symbol_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i {D+10} {D+0} to {D+20} true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Second argument to special 'for' must be symbol 'in' or 'from'. Now it has type integer.\n"
        "\tAt form: >>>>>>>>>>(for i {D+10} {D+0} to {D+20} true)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_called_with_integer_as_first_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for {D+1} from {D+0} to {D+10} true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "First argument to special 'for' must be symbol value. Now it has type integer.\n"
        "\tAt form: >>>>>>>>>>(for {D+1} from {D+0} to {D+10} true)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_error_in_function_body_is_reported_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (NoSuchFunction x)) [f] '(x [x]) howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f {D+1})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    // TODO type of 'error' or 'vector'?
    ASSERT_STR_EQ(
        "Cannot evaluate operator of type 'error' (<error>: Unbound symbol 'NoSuchFunction')\n"
        "\tAt form: >>>>>>>>>>(f {D+1})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_cp_at_sign_called_with_0_and_string_abc_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(cp@ [abc] {D+0})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "a",
        octaspire_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_cp_at_sign_called_with_1_and_string_abc_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(cp@ [abc] {D+1})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "b",
        octaspire_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_cp_at_sign_called_with_2_and_string_abc_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(cp@ [abc] {D+2})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "c",
        octaspire_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_cp_at_sign_called_with_3_and_string_abc_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(cp@ [abc] {D+3})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Index to builtin 'cp@' is not valid for the given string. "
        "Index '3' was given.\n"
        "\tAt form: >>>>>>>>>>(cp@ [abc] {D+3})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_ln_at_sign_called_with_0_and_vector_1_2_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(ln@ '({D+1} {D+2} {D+3}) {D+0})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_ln_at_sign_called_with_1_and_vector_1_2_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(ln@ '({D+1} {D+2} {D+3}) {D+1})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_ln_at_sign_called_with_2_and_vector_1_2_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(ln@ '({D+1} {D+2} {D+3}) {D+2})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_ln_at_sign_called_with_3_and_vector_1_2_3_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(ln@ '({D+1} {D+2} {D+3}) {D+3})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Index to builtin 'ln@' is not valid for the given vector. "
        "Index '3' was given.\n"
        "\tAt form: >>>>>>>>>>(ln@ (quote ({D+1} {D+2} {D+3})) {D+3})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_ln_at_sign_called_with_0_and_index_and_hash_map_1a_2b_3c_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(ln@ (hash-map {D+1} |a| {D+2} |b| {D+3} |c|) {D+0} 'index)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "b",
        octaspire_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_ln_at_sign_called_with_1_and_index_and_hash_map_1a_2b_3c_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(ln@ (hash-map {D+1} |a| {D+2} |b| {D+3} |c|) {D+1} 'index)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "c",
        octaspire_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_ln_at_sign_called_with_2_and_index_and_hash_map_1a_2b_3c_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(ln@ (hash-map {D+1} |a| {D+2} |b| {D+3} |c|) {D+2} 'index)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "a",
        octaspire_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_ln_at_sign_called_with_3_and_index_and_hash_map_1a_2b_3c_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(ln@ (hash-map {D+1} |a| {D+2} |b| {D+3} |c|) {D+3} 'index)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'ln@' could not find the requested element from hash map.\n"
        "\tAt form: >>>>>>>>>>(ln@ (hash-map {D+1} |a| {D+2} |b| {D+3} |c|) {D+3} (quote index))<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_ln_at_sign_called_with_2_and_hash_and_hash_map_1a_2b_3c_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(ln@ (hash-map {D+1} |a| {D+2} |b| {D+3} |c|) {D+2} 'hash)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "b",
        octaspire_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_changing_atom_doesnt_change_another_defined_from_it_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define original as {D+10} [original])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define copied as original [copied])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= original {D+999})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(999,                              evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "copied");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(10,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_in_special_do_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter as {D+0} [counter])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () (do (++ counter) (return {D+99}) (++ counter))) [f] '() howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_do_error_stops_evaluation_and_is_reported_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter as {D+0} [counter])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(do (++ counter))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(do (++ counter) (NoSuchFunction) (++ counter))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Cannot evaluate operator of type 'error' (<error>: Unbound symbol 'NoSuchFunction')\n"
        "\tAt form: >>>>>>>>>>(NoSuchFunction)<<<<<<<<<<\n\n"
        "\tAt form: >>>>>>>>>>(do (++ counter) (NoSuchFunction) (++ counter))<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_fn_in_env_howto_no_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+ x x)) [f] '(x [x]) in (env-global) howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "f");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_FUNCTION, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->howtoAllowed);
    ASSERT_EQ(false, evaluatedValue->value.function->howtoAllowed);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_fn_in_env_howto_ok_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+ x x)) [f] '(x [x]) in (env-global) howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "f");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_FUNCTION, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->howtoAllowed);
    ASSERT_EQ(true, evaluatedValue->value.function->howtoAllowed);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter as {D+0} [counter])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () (++ counter) (return {D+99}) (++ counter)) [f] '() howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_in_special_for_with_numeric_range_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter as {D+0} [counter])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () (for i from {D+0} to {D+10} (++ counter) (if (== i {D+5}) (return {D+99})))) [f] '() howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(6,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_in_special_for_with_collection_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter as {D+0} [counter])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () (for i in '({D+1} {D+2} {D+3} {D+4} {D+5} {D+6}) (+= counter i) (if (== i {D+4}) (return {D+99})))) [f] '() howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(10,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_in_special_for_with_string_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter as {D+0} [counter])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () (for i in [abcdef] (+= counter {D+1}) (if (== i |d|) (return {D+99})))) [f] '() howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(4,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_in_special_for_with_environment_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter as {D+0} [counter])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () (define a as {D+1} [a]) (define b as {D+2} [b]) (define c as {D+3} [c]) (for i in (env-current) (+= counter {D+1}) (if (== counter {D+1}) (return {D+99})))) [f] '() howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_in_special_for_with_hash_map_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter as {D+0} [counter])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () (for i in (hash-map |a| {D+1} |b| {D+2} |c| {D+3}) (+= counter {D+1}) (if (== counter {D+1}) (return {D+99})))) [f] '() howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

// TODO XXX add new test that is similar to above, but uses (for i in container ...
// TODO XXX other loops and other functions need to handle return?

TEST octaspire_dern_vm_builtin_return_in_special_while_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter as {D+0} [counter])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () (while (< counter {D+100}) (++ counter) (return {D+99}))) [f] '() howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_called_without_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter as {D+0} [counter])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () (while (< counter {D+100}) (++ counter) (return))) [f] '() howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_called_with_two_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter as {D+0} [counter])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () (while (< counter {D+100}) (++ counter) (return {D+1} {D+2}))) [f] '() howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'return' expects zero or one arguments. 2 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(return {D+1} {D+2})<<<<<<<<<<\n"
        "\n"
        "\tAt form: >>>>>>>>>>(while (< counter {D+100}) (++ counter) (return {D+1} {D+2}))<<<<<<<<<<\n"
        "\n"
        "\tAt form: >>>>>>>>>>(f)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_function_taking_one_regular_and_varargs_called_with_four_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x y ...)\n"
            "(define result as [] [result])\n"
            "(+= result (string-format x)) (+= result (string-format y))\n"
            "result) "
            "[f] '(x [x] y [rest of the args] ... [varargs]) howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f {D+1} {D+2} {D+3} {D+4})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "{D+1}({D+2} {D+3} {D+4})",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_function_taking_one_regular_and_varargs_called_with_one_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x y ...)\n"
            "(define result as [] [result])\n"
            "(+= result (string-format x)) (+= result (string-format y))\n"
            "result) "
            "[f] '(x [x] y [rest of the args] ... [varargs]) howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f {D+1})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "{D+1}()",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_function_taking_one_regular_and_varargs_called_with_zero_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x y ...)\n"
            "(define result [result] [])\n"
            "(+= result (string-format x)) (+= result (string-format y))\n"
            "result) "
            "[f] '(x [x] y [rest of the args] ... [varargs]) howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Function expects 1 arguments. Now 0 arguments were given.",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_newly_created_function_returned_from_another_function_and_used_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define creator as (fn () (fn (val) (+ {D+11} val))) [creator] '() howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "((creator) {D+7})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(18,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_recursive_function_used_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as (fn (x) (if (< x {D+10}) (a (+ x {D+1})) x)) [a] '(x [x]) howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(a {D+1})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(10,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_mutually_recursive_functions_used_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as (fn (val) (b (+ val {D+1}))) [a] '(val [val]) howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define b as (fn (x) (if (< x {D+10}) (a x) x)) [b] '(x [x]) howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(b {D+1})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(10,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_and_called_without_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(and)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_or_called_without_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(or)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_not_called_without_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(not)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Builtin 'not' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(not)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_and_called_with_one_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(and x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(9,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_or_called_with_one_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(and x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(9,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_and_called_with_one_false_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as false [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(and x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_or_called_with_one_false_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as false [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(or x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_not_called_with_one_false_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as false [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(not x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_not_called_with_one_true_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as true [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(not x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_not_called_with_one_integer_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+0} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(not x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'not' expects boolean argument.\n"
        "\tAt form: >>>>>>>>>>(not x)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_not_called_with_two_boolean_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as false [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define y as true [y])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(not x y)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'not' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(not x y)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_and_called_with_three_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+= s x) x) [f] '(x [x]) howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(and (f [a]) (f [b]) (f [c]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("c", octaspire_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("abc", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_or_called_with_three_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+= s x) (if (== x [c]) x false)) [f] '(x [x]) howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(or (f [a]) (f [b]) (f [c]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("c", octaspire_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("abc", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_and_called_with_three_arguments_with_false_as_second_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+= s x) x) [f] '(x [x]) howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(and (f [a]) false (f [c]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_or_called_with_three_arguments_with_true_as_second_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [] [s])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+= s x) false) [f] '(x [x]) howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(or (f [a]) true (f [c]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_called_with_two_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10.02} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> x {D+10.01})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_called_with_two_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> x {D+9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_called_with_integer_10_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> x {D+9.9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_called_with_integer_9_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> x {D+9.9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_called_with_real_9dot9_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9.9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_called_with_real_10dot1_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10.1} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}






TEST octaspire_dern_vm_special_greater_than_or_equal_called_with_two_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10.02} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x {D+10.01})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x {D+10.02})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x {D+10.03})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_or_equal_called_with_two_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x {D+9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x {D+11})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_or_equal_called_with_integer_10_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x {D+9.9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_or_equal_called_with_integer_9_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x {D+9.9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_or_equal_called_with_real_9dot9_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9.9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_or_equal_called_with_real_10dot1_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10.1} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

















TEST octaspire_dern_vm_special_less_than_called_with_two_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10.01} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< x {D+10.02})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_called_with_two_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_called_with_integer_9_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< x {D+9.9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_called_with_integer_10_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< x {D+9.9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_called_with_real_10dot1_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10.1} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_called_with_real_9dot9_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9.9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}












TEST octaspire_dern_vm_special_less_than_or_equal_called_with_two_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10.01} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x {D+10.02})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x {D+10.01})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x {D+10.0})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_or_equal_called_with_two_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x {D+9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x {D+8})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_or_equal_called_with_integer_9_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x {D+9.9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_or_equal_called_with_integer_10_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x {D+9.9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_or_equal_called_with_real_10dot1_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10.1} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_or_equal_called_with_real_9dot9_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9.9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_queues_of_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q1 as (queue {D+1} {D+2} {D+3} {D+4} {D+5}) [q1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q2 as (queue {D+1} {D+2} {D+3} {D+4} {D+5}) [q2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== q1 q2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== q2 q1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_queues_of_vectors_of_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q1 as (queue '({D+1} {D+2} {D+3}) '({D+4} {D+5} {D+6})) [q1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q2 as (queue '({D+1} {D+2} {D+3}) '({D+4} {D+5} {D+6})) [q2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== q1 q2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== q2 q1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_queues_of_vectors_of_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q1 as (queue '({D+1} {D+2} {D+3}) '({D+4} {D+5} {D+6})) [q1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q2 as (queue '({D+1} {D+2} {D+3}) '({D+4} {D+5} {D+7})) [q2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== q1 q2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== q2 q1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_queues_of_integers_with_different_lengths_of_5_and_6_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q1 as (queue {D+1} {D+2} {D+3} {D+4} {D+5}) [q1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q2 as (queue {D+1} {D+2} {D+3} {D+4} {D+5} {D+6}) [q2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== q1 q2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== q2 q1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_queues_of_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q1 as (queue {D+1} {D+2} {D+3} {D+4} {D+5}) [q1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q2 as (queue {D+1} {D+2} {D+3} {D+4} {D+6}) [q2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== q1 q2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== q2 q1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_lists_of_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define l1 as (list {D+1} {D+2} {D+3} {D+4} {D+5}) [l1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define l2 as (list {D+1} {D+2} {D+3} {D+4} {D+5}) [l2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== l1 l2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== l2 l1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_lists_of_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define l1 as (list {D+1} {D+2} {D+3} {D+4} {D+5}) [l1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define l2 as (list {D+1} {D+2} {D+3} {D+4} {D+6}) [l2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== l1 l2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== l2 l1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_vectors_of_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v1 as '({D+1} {D+2} {D+3} {D+4} {D+5}) [v1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v2 as '({D+1} {D+2} {D+3} {D+4} {D+5}) [v2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v1 v2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v2 v1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_vectors_of_vectors_of_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v1 as '(({D+1} {D+2} {D+3}) ({D+4} {D+5} {D+6})) [v1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v2 as '(({D+1} {D+2} {D+3}) ({D+4} {D+5} {D+6})) [v2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v1 v2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v2 v1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_hash_maps_of_vectors_of_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v1 as (hash-map |a| '({D+1} {D+2} {D+3}) |b| '({D+4} {D+5} {D+6})) [v1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v2 as (hash-map |a| '({D+1} {D+2} {D+3}) |b| '({D+4} {D+5} {D+6})) [v2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v1 v2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v2 v1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_hash_maps_of_vectors_of_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v1 as (hash-map |a| '({D+1} {D+2} {D+3}) |b| '({D+4} {D+5} {D+6})) [v1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v2 as (hash-map |a| '({D+1} {D+2} {D+3}) |b| '({D+4} {D+5} {D+7})) [v2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v1 v2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v2 v1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_environments_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e1 as (env-new) [e1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 as (env-new) [e2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Compare empty environments
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== e1 e2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== e2 e1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Add some content to environments
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as {D+1} [a] in e1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as {D+1} [a] in e2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Compare environments with one value
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== e1 e2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== e2 e1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_environments_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e1 as (env-new) [e1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 as (env-new) [e2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Add some differing content to environments
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as {D+1} [a] in e1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as {D+2} [a] in e2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Compare environments with one value
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== e1 e2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== e2 e1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_functions_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e1 as (env-new) [e1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 as (env-new) [e2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // First function
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+ x x)) [f] '(x [x]) in e1 howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Second function
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+ x x)) [f] '(x [x]) in e2 howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Compare functions
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (find e1 'f) (find e2 'f))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (find e2 'f) (find e1 'f))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_functions_formal_name_differs_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e1 as (env-new) [e1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 as (env-new) [e2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // First function
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+ x x)) [f] '(x [x]) in e1 howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Second function
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (y) (+ y y)) [f] '(y [x]) in e2 howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Compare functions
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (find e1 'f) (find e2 'f))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (find e2 'f) (find e1 'f))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_functions_name_differs_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e1 as (env-new) [e1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 as (env-new) [e2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // First function
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+ x x)) [f] '(x [x]) in e1 howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Second function
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f2 as (fn (x) (+ x x)) [f] '(x [x]) in e2 howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Compare functions
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (find e1 'f) (find e2 'f2))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (find e2 'f2) (find e1 'f))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_functions_docstr_differs_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e1 as (env-new) [e1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 as (env-new) [e2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // First function
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+ x x)) [f] '(x [x]) in e1 howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Second function
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+ x x)) [f2] '(x [x]) in e2 howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Compare functions
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (find e1 'f) (find e2 'f))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (find e2 'f) (find e1 'f))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_functions_howto_differs_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e1 as (env-new) [e1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 as (env-new) [e2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // First function
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+ x x)) [f] '(x [x]) in e1 howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Second function
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn (x) (+ x x)) [f] '(x [x]) in e2 howto-no)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Compare functions
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (find e1 'f) (find e2 'f))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (find e2 'f) (find e1 'f))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_vectors_of_vectors_of_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v1 as '(({D+1} {D+2} {D+3}) ({D+4} {D+5} {D+6})) [v1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v2 as '(({D+1} {D+2} {D+3}) ({D+4} {D+5} {D+7})) [v2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v1 v2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v2 v1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_vectors_of_integers_with_different_lengths_5_and_6_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v1 as '({D+1} {D+2} {D+3} {D+4} {D+5}) [v1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v2 as '({D+1} {D+2} {D+3} {D+4} {D+5} {D+6}) [v2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v1 v2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v2 v1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_vectors_of_integers_with_different_elements_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v1 as '({D+1} {D+2} {D+3} {D+4} {D+5}) [v1])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v2 as '({D+1} {D+2} {D+3} {D+4} {D+6}) [v2])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v1 v2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== v2 v1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10.01} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x {D+10.01})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x {D+10.02})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x {D+9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_buildin_equals_equals_called_with_integer_9_and_reals_9dot1_and_9dot0_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x {D+9.1})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x {D+9.0})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals__called_with_integer_10_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x {D+9.9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_real_10dot1_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10.1} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_real_9dot9_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9.9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}







TEST octaspire_dern_vm_builtin_exclamation_equals_called_with_two_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10.01} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x {D+10.02})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x {D+10.01})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_exclamation_equals_called_with_two_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x {D+9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_buildin_exclamation_equals_called_with_integer_9_and_reals_9dot1_and_9dot0_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x {D+9.1})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x {D+9.0})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_exclamation_equals_called_with_integer_10_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x {D+9.9})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_exclamation_equals_called_with_real_10dot1_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+10.1} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_exclamation_equals_called_with_real_9dot9_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x as {D+9.9} [x])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_error_during_user_function_call_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () (NoSuchFunction)) [my function] '() howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Cannot evaluate operator of type 'error' (<error>: Unbound symbol 'NoSuchFunction')\n"
        "\tAt form: >>>>>>>>>>(f)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_error_during_builtin_call_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(++)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Builtin '++' expects at least one argument.\n"
        "\tAt form: >>>>>>>>>>(++)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_error_during_special_call_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Special '<' expects at least two arguments.\n"
        "\tAt form: >>>>>>>>>>(<)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_error_during_special_call_during_user_function_call_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (fn () (<)) [f] '() howto-ok)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Special '<' expects at least two arguments.\n"
        "\tAt form: >>>>>>>>>>(<)<<<<<<<<<<\n"
        "\n"
        "\tAt form: >>>>>>>>>>(f)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_plus_1_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval (+ {D+1} {D+2}))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_plus_1_2_in_given_global_env_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval (+ {D+1} {D+2}) (env-global))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_value_from_given_local_env_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define myEnv as (env-new) [myEnv])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define myVal as {D+128} [myVal] in myEnv)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval myVal myEnv)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(128,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_eval_eval_f_1_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define myFn as + [myFn])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval ((eval myFn) {D+1} {D+2}))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_failure_on_integer_on_second_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval (+ {D+1} {D+1}) {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Second argument to special 'eval' must evaluate into environment value.\n"
        "Now it evaluated into type integer.\n"
        "\tAt form: >>>>>>>>>>(eval (+ {D+1} {D+1}) {D+10})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_failure_on_unbound_symbol_on_second_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval (+ {D+1} {D+1}) pi)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Unbound symbol 'pi'\n"
        "\tAt form: >>>>>>>>>>(eval (+ {D+1} {D+1}) pi)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_called_with_three_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval (+ {D+1} {D+1}) (env-global) {D+10})");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'eval' expects one or two arguments. 3 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(eval (+ {D+1} {D+1}) (env-global) {D+10})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_create_new_value_copy_called_with_vector_value_of_int_values_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t * const originalVal = octaspire_dern_vm_create_new_value_vector(vm);

    octaspire_dern_vm_push_value(vm, originalVal);

    for (int32_t i = 0; i < 10; ++i)
    {
        octaspire_dern_value_t *tmpVal = octaspire_dern_vm_create_new_value_integer(vm, i);

        ASSERT(octaspire_dern_value_as_vector_push_back_element(originalVal, &tmpVal));
    }

    octaspire_dern_value_t * const copiedVal =
        octaspire_dern_vm_create_new_value_copy(vm, originalVal);

    octaspire_dern_vm_push_value(vm, copiedVal);

    ASSERT(copiedVal);
    ASSERT(originalVal != copiedVal);

    ASSERT_EQ(
        octaspire_dern_value_as_vector_get_length(originalVal),
        octaspire_dern_value_as_vector_get_length(copiedVal));

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(copiedVal); ++i)
    {
        octaspire_dern_value_t const * const original =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                originalVal,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                0);

        octaspire_dern_value_t const * const copied =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                copiedVal,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                0);

        ASSERT(original && copied);
        ASSERT(original != copied);
        ASSERT_EQ(original->value.integer, copied->value.integer);
    }

    octaspire_dern_vm_pop_value(vm, copiedVal);
    octaspire_dern_vm_pop_value(vm, originalVal);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_comment_alone_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "; comment");

    ASSERT_EQ(0, evaluatedValue);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_comment_after_integer_1_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "{D+1} ;comment");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1, evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_comment_before_integer_123_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            ";comment\n{D+123}");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(123, evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_multiline_comment_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "#!/bin/octaspire-dern-repl\n!#");

    ASSERT_EQ(0, evaluatedValue);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_multiline_comment_in_vector_1_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(len (vector {D+1} {D+2} #! comment !# {D+3} #!abc!# {D+4} #!!# {D+5}))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(5, evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (vector {D+1} {D+2} #! comment !# {D+3} #!abc!# {D+4} #!!# {D+5}))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "({D+1} {D+2} {D+3} {D+4} {D+5})",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_multiline_comment_before_integer_123_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(
        octaspireDernVmTestAllocator,
        octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "#!comment!#\n{D+123}");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(123, evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_multiline_comment_missing_chars_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "#!/bin/octaspire-dern-repl\n!");

    ASSERT_EQ(0, evaluatedValue);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "#!/bin/octaspire-dern-repl\n");

    ASSERT_EQ(0, evaluatedValue);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_io_file_open_success_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_input_file_open_success_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (input-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_output_file_open_success_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (output-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_input_question_mark_called_with_output_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (output-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-input? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_input_question_mark_called_with_input_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (input-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-input? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_input_question_mark_called_with_io_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-input? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_input_question_mark_called_with_integer_failure_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as {D+10} [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-input? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'port-supports-input?' expects port argument.\n"
        "\tAt form: >>>>>>>>>>(port-supports-input? f)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_input_question_mark_called_without_arguments_failure_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-input?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'port-supports-input?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(port-supports-input?)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_output_question_mark_called_with_input_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (input-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-output? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_output_question_mark_called_with_output_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (output-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-output? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_output_question_mark_called_with_io_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-output? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_output_question_mark_called_with_integer_failure_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as {D+10} [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-output? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'port-supports-output?' expects port argument.\n"
        "\tAt form: >>>>>>>>>>(port-supports-output? f)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_output_question_mark_called_without_arguments_failure_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-output?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'port-supports-output?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(port-supports-output?)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_close_called_with_io_file_port_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "<input-output-port:" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt (7 octets)>",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    // Close port
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-close f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Check the closed port
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "<NOT-OPEN-port:" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt (-1 octets)>",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    // Check that reading from closed file port fails
    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
        ASSERT_STR_EQ(
            "Builtin 'port-read' failed to read the requested one octet.\n"
            "\tAt form: >>>>>>>>>>(port-read f)<<<<<<<<<<\n",
            octaspire_string_get_c_string(evaluatedValue->value.error->message));
    }

    // Check that closing again fails
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-close f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_dist_called_with_a_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    int32_t dist = 0;

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-dist f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(dist,                             evaluatedValue->value.integer);

        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);

        ++dist;
    }

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-dist f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(dist,                             evaluatedValue->value.integer);

        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);

        ++dist;
    }

    // Close port
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-close f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-dist f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ((int32_t)-1,                      evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_seek_called_with_a_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    // From beginning
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-seek f {D+0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-dist f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0,                                evaluatedValue->value.integer);



    // From end
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-seek f {D-1})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-dist f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(7,                                evaluatedValue->value.integer);



    // Backward from current pos
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-seek f {D-1} 'from-current)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-dist f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(6,                                evaluatedValue->value.integer);


    // Forward from current pos
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-seek f {D+1} 'from-current)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-dist f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(7,                                evaluatedValue->value.integer);

    // Close port
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-close f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-seek f {D+0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_input_file_open_with_file_system_access_allowed_failure_on_missing_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (input-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "no-such-file.nono]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "<NOT-OPEN-port:" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "no-such-file.nono (-1 octets)>",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_write_failure_on_input_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (input-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "f");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_PORT, evaluatedValue->typeTag);

    int32_t const fileLengthInOctets =
        (int32_t)octaspire_dern_port_get_length_in_octets(evaluatedValue->value.port);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-write f {D+70})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The first argument to builtin 'port-write' must be a port supporting writing.\n"
        "\tAt form: >>>>>>>>>>(port-write f {D+70})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    // Make sure that the file has still the same size as before the write attempt
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "f");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_PORT, evaluatedValue->typeTag);

    ASSERT_EQ(
        fileLengthInOctets,
        octaspire_dern_port_get_length_in_octets(evaluatedValue->value.port));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_length_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f as (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]) [f])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-length f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(7,                                evaluatedValue->value.integer);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-close f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-length f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(-1,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_integer_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(integer? {D+0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? {D+10})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? {D-1})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? {D-1.0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? {D+0.0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? {D+10.0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? |0|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? [0])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'integer?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(integer?)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? {D+1} {D+2})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'integer?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(integer? {D+1} {D+2})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_real_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(real? {D+0.0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? {D+10.0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? {D-1.1})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? {D-1})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? {D+0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? {D+10})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? |0|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? [0.0])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'real?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(real?)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? {D+1.1} {D+1.2})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'real?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(real? {D+1.1} {D+1.2})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_number_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(number? {D+0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? {D+0.0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? {D-1.1})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? {D-1})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? {D+2048})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? {D-100})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? |0|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? [0.0])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'number?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(number?)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? {D+1.1} {D+1.2})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'number?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(number? {D+1.1} {D+1.2})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_nil_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nil? nil)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? {D+0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? [nil])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? {D-1})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? {D+2048})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? |a|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define myNil as nil [myNil])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? myNil)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'nil?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(nil?)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? {D+1.1} {D+1.2})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'nil?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(nil? {D+1.1} {D+1.2})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_boolean_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(boolean? true)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? false)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? [true])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? {D-1})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? {D+2048})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? |a|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define myBool as true [myBool])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? myBool)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'boolean?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(boolean?)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? true true)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'boolean?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(boolean? true true)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_character_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(character? |a|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? |0|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? [true])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? |newline|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? {D+2048})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? {D+0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define myChar as |a| [myChar])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? myChar)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'character?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(character?)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? |a| |b|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'character?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(character? |a| |b|)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(string? [])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? [0])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? |a|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? |newline|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? {D+2048})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? {D+0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define myStr as [abc] [myStr])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? myStr)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'string?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(string?)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? [a] [b])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'string?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(string? [a] [b])<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_symbol_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(symbol? 'a)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? 'abc123)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? |a|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? |newline|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? {D+2048})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? {D+0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define mySym as {D+10} [mySym])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? 'mySym)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'symbol?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(symbol?)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? 'a 'b)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'symbol?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(symbol? (quote a) (quote b))<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_vector_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(vector? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? '({D+1}))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? '({D+1} {D+2} {D+3}))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? |newline|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? {D+2048})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? {D+0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define mySym as '({D+99} {D+98} {D+97} {D+96}) [mySym])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? mySym)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? (hash-map))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'vector?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(vector?)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? '() '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'vector?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(vector? (quote ()) (quote ()))<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_hash_map_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(hash-map? (hash-map))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? (hash-map {D+0} |a|))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? (hash-map {D+0} |a| {D+1} [abc]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? |newline|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? {D+2048})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? {D+0})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define myHashMap as (hash-map |a| {D+0}) [myHashMap])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? myHashMap)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'hash-map?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(hash-map?)<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? (hash-map) (hash-map))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'hash-map?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(hash-map? (hash-map) (hash-map))<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_queue_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q as (queue) [queue])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(len q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0,                                evaluatedValue->value.integer);



    // 1. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 1])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1])",
        octaspire_string_get_c_string(evaluatedValue->value.string));



    // 2. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 2])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1] [line 2])",
        octaspire_string_get_c_string(evaluatedValue->value.string));



    // 3. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 3])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1] [line 2] [line 3])",
        octaspire_string_get_c_string(evaluatedValue->value.string));



    // 4. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 4])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1] [line 2] [line 3] [line 4])",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_queue_with_max_length_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q as (queue-with-max-length {D+3}) [queue])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(len q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0,                                evaluatedValue->value.integer);



    // 1. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 1])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1])",
        octaspire_string_get_c_string(evaluatedValue->value.string));



    // 2. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 2])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1] [line 2])",
        octaspire_string_get_c_string(evaluatedValue->value.string));



    // 3. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 3])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1] [line 2] [line 3])",
        octaspire_string_get_c_string(evaluatedValue->value.string));



    // 4. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 4])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 2] [line 3] [line 4])",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_list_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define l as (list) [list])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(len l)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0,                                evaluatedValue->value.integer);



    // 1. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= l [line 1])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_LIST, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string l)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(list [line 1])",
        octaspire_string_get_c_string(evaluatedValue->value.string));



    // 2. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= l [line 2])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_LIST, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string l)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(list [line 1] [line 2])",
        octaspire_string_get_c_string(evaluatedValue->value.string));



    // 3. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= l [line 3])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_LIST, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string l)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(list [line 1] [line 2] [line 3])",
        octaspire_string_get_c_string(evaluatedValue->value.string));



    // 4. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= l [line 4])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_LIST, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string l)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(list [line 1] [line 2] [line 3] [line 4])",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_copy_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (copy '({D+1} {D+2} {D+3})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("({D+1} {D+2} {D+3})", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (copy '({D+1} {D+2} {D+3}) (fn (v i) (< i {D+2}))))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("({D+1} {D+2})", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (copy '({D+1} {D+2} {D+3}) (fn (v i) (== v {D+2}))))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("({D+2})", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (copy [abc] (fn (v i) (< i {D+2}))))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("[ab]", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (copy [abc] (fn (v i) (== v |b|))))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("[b]", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}


TEST octaspire_dern_vm_split_called_with_string_and_char_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(split [here is some text] | |)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    size_t const expectedNumOfElems = 4;

    ASSERT_EQ(expectedNumOfElems, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    char const * const expected[] = {"here", "is", "some", "text" };

    for (size_t i = 0; i < expectedNumOfElems; ++i)
    {
        ASSERT_STR_EQ(
            expected[i],
            octaspire_dern_value_as_string_get_c_string(
                octaspire_dern_value_as_vector_get_element_at_const(
                    evaluatedValue,
                    (ptrdiff_t)i)));
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}




TEST octaspire_dern_vm_cp_at_sign_with_vector_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '({D+1} {D+2} {D+3}) [v])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (int32_t i = 0; i < 10; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(++ (cp@ v {D+1}))");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(3,                               evaluatedValue->value.integer);
    }

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string v)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "({D+1} {D+2} {D+3})",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_cp_at_sign_with_string_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abc] [s])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (int32_t i = 0; i < 10; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= (cp@ s {D+1}) {D+2})");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

        ASSERT_STR_EQ(
            "d",
            octaspire_string_get_c_string(
                evaluatedValue->value.character));
    }

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "s");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "abc",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_cp_at_sign_with_hash_map_of_size_one_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h as (hash-map [a] {D+2}) [h])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (int32_t i = 0; i < 5; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(++ (cp@ h {D+0} 'index))");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(3,                                evaluatedValue->value.integer);
    }

    for (int32_t i = 0; i < 5; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(++ (cp@ h [a] 'hash))");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(3,                                evaluatedValue->value.integer);
    }

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string h)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "(hash-map [a] {D+2})",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_cp_at_sign_with_hash_map_of_size_three_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h as (hash-map [a] {D+1}   [b] {D+2}   [c] {D+3}) [h])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (int32_t i = 0; i < 10; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(++ (cp@ h [b] 'hash))");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(3,                                evaluatedValue->value.integer);
    }

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(find h [a])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(find h [b])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(find h [c])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}






TEST octaspire_dern_vm_ln_at_sign_with_vector_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v as '({D+1} {D+2} {D+3}) [v])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (int32_t i = 0; i < 10; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(++ (ln@ v {D+1}))");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(3 + i,                            evaluatedValue->value.integer);
    }

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string v)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "({D+1} {D+12} {D+3})",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_ln_at_sign_with_string_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s as [abc] [s])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(ln@ [abc] {D+1})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'ln@' cannot be used with strings. Use 'cp@' instead.\n"
        "\tAt form: >>>>>>>>>>(ln@ [abc] {D+1})<<<<<<<<<<\n",
        octaspire_string_get_c_string(evaluatedValue->value.error->message)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_ln_at_sign_with_hash_map_of_size_one_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h as (hash-map [a] {D+2}) [h])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (int32_t i = 0; i < 5; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(++ (ln@ h {D+0} 'index))");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(3 + i,                            evaluatedValue->value.integer);
    }

    for (int32_t i = 0; i < 5; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(++ (ln@ h [a] 'hash))");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(3 + 5 + i,                        evaluatedValue->value.integer);
    }

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string h)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "(hash-map [a] {D+12})",
        octaspire_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_ln_at_sign_with_hash_map_of_size_three_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h as (hash-map [a] {D+1}   [b] {D+2}   [c] {D+3}) [h])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (int32_t i = 0; i < 10; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(++ (ln@ h [b] 'hash))");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(3 + i,                            evaluatedValue->value.integer);
    }

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(find h [a])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(find h [b])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(12, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(find h [c])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_host_command_line_arguments_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    // Test with missing command line arguments
    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (host-get-command-line-arguments))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "()",
        octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    // Test with existing command line arguments
    char const * const expected[] =
    {
        "a",
        "\"this is 2. argument\"",
        "--do-something",
        "1234",
        "-c"
    };

    for (size_t i = 0; i < 5; ++i)
    {
        ASSERT(octaspire_dern_vm_add_command_line_argument(vm, expected[i]));
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (host-get-command-line-arguments))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "([a] [\"this is 2. argument\"] [--do-something] [1234] [-c])",
        octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_host_environment_variables_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    // Test with missing environment variables
    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (host-get-environment-variables))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "()",
        octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    // Test with existing environment variables
    char const * const expected[] =
    {
        "a=0",
        "LD_LIBRARY_PATH=/some_path/xyz",
        "b=1",
        "LANGUAGE=en_US:en",
        "_=/usr/bin/env"
    };

    for (size_t i = 0; i < 5; ++i)
    {
        ASSERT(octaspire_dern_vm_add_environment_variable(vm, expected[i]));
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (host-get-environment-variables))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "([a=0] [LD_LIBRARY_PATH=/some_path/xyz] [b=1] "
        "[LANGUAGE=en_US:en] [_=/usr/bin/env])",
        octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

static char const * const octaspireDernVmTestCreateNewUserDataTestPluginName =
    "octaspireDernUnitTestPluginName";

static char const * const octaspireDernVmTestCreateNewUserDataTestPayloadTypeName =
    "payloadTypeName";

static char const * const octaspireDernVmTestCreateNewUserDataTestPayload =
    "This is the payload...";

octaspire_dern_value_t *octaspire_dern_test_dern_vm_create_new_user_data(
    octaspire_dern_vm_t * const vm,
    octaspire_dern_value_t * const arguments,
    octaspire_dern_value_t * const environment)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(arguments);
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(environment);

    return octaspire_dern_vm_create_new_value_c_data(
            vm,
            octaspireDernVmTestCreateNewUserDataTestPluginName,
            octaspireDernVmTestCreateNewUserDataTestPayloadTypeName,
            "",
            "",
            "",
            "",
            true,
            (void*)octaspireDernVmTestCreateNewUserDataTestPayload);
}

TEST octaspire_dern_vm_create_user_data_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    ASSERT(octaspire_dern_vm_create_and_register_new_builtin(
            vm,
            "octaspire-dern-test-dern-vm-create-new-user-data",
            octaspire_dern_test_dern_vm_create_new_user_data,
            0,
            "...",
            false,
            octaspire_dern_value_as_environment_get_value(
                octaspire_dern_vm_get_global_environment(vm))));

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(octaspire-dern-test-dern-vm-create-new-user-data)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_C_DATA, evaluatedValue->typeTag);

    octaspire_dern_c_data_t const * const cData =
        octaspire_dern_value_as_c_data_get_value(evaluatedValue);

    ASSERT_STR_EQ(
        octaspireDernVmTestCreateNewUserDataTestPluginName,
        octaspire_dern_c_data_get_plugin_name(cData));

    ASSERT_STR_EQ(
        octaspireDernVmTestCreateNewUserDataTestPayloadTypeName,
        octaspire_dern_c_data_get_payload_typename(cData));

    ASSERT_EQ(
        octaspireDernVmTestCreateNewUserDataTestPayload,
        octaspire_dern_c_data_get_payload(cData));

    ASSERT_STR_EQ(
        (char const * const)octaspireDernVmTestCreateNewUserDataTestPayload,
        (char const * const)octaspire_dern_c_data_get_payload(cData));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_copy_user_data_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    ASSERT(octaspire_dern_vm_create_and_register_new_builtin(
            vm,
            "octaspire-dern-test-dern-vm-create-new-user-data",
            octaspire_dern_test_dern_vm_create_new_user_data,
            0,
            "...",
            false,
            octaspire_dern_value_as_environment_get_value(
                octaspire_dern_vm_get_global_environment(vm))));

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as (octaspire-dern-test-dern-vm-create-new-user-data) [a])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, octaspire_dern_value_as_boolean_get_value(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define b as (copy a) [b])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, octaspire_dern_value_as_boolean_get_value(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= a {D+1})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "b");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_C_DATA, evaluatedValue->typeTag);

    octaspire_dern_c_data_t const * const cData =
        octaspire_dern_value_as_c_data_get_value(evaluatedValue);

    ASSERT_STR_EQ(
        octaspireDernVmTestCreateNewUserDataTestPluginName,
        octaspire_dern_c_data_get_plugin_name(cData));

    ASSERT_STR_EQ(
        octaspireDernVmTestCreateNewUserDataTestPayloadTypeName,
        octaspire_dern_c_data_get_payload_typename(cData));

    ASSERT_EQ(
        octaspireDernVmTestCreateNewUserDataTestPayload,
        octaspire_dern_c_data_get_payload(cData));

    ASSERT_STR_EQ(
        (char const * const)octaspireDernVmTestCreateNewUserDataTestPayload,
        (char const * const)octaspire_dern_c_data_get_payload(cData));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

octaspire_input_t *octaspire_test_dern_vm_custom_require_file_loader(
    char const * const name,
    octaspire_allocator_t * const allocator)
{
    if (strcmp("test1.dern", name) == 0)
    {
        return octaspire_input_new_from_c_string(
            "(define f1 as (fn (a b) (+ a b)) [f1] '(a [a] b [b]) howto-ok)",
            allocator);
    }
    else if (strcmp("test2.dern", name) == 0)
    {
        return octaspire_input_new_from_c_string(
            "(define f2 as (fn (a b) (* a b)) [f2] '(a [a] b [b]) howto-ok)",
            allocator);
    }

    return 0;
}

TEST octaspire_dern_vm_require_a_source_library_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.preLoaderForRequireSrc = octaspire_test_dern_vm_custom_require_file_loader;

    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new_with_config(
            octaspireDernVmTestAllocator,
            octaspireDernVmTestStdio,
            config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(require 'test1)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "test1.dern",
        octaspire_dern_value_as_string_get_c_string(evaluatedValue));



    // Test function from the 'test1' library
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f1 {D+2} {D+10})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(12, octaspire_dern_value_as_integer_get_value(evaluatedValue));



    // Load 'test2' library
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(require 'test2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "test2.dern",
        octaspire_dern_value_as_string_get_c_string(evaluatedValue));



    // Test function from the 'test2' library
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f2 {D+2} {D+10})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(20, octaspire_dern_value_as_integer_get_value(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_howto_1_2_3_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(howto {D+1} {D+2} {D+3})");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "((+ {D+1} {D+2}) (+ {D+2} {D+1}))",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_howto_strings_a_b_ab_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(howto [a] [b] [ab])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "((+ [a] [b]))",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_howto_chars_a_b_string_ab_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(howto |a| |b| [ab])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "((+ |a| |b|))",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_howto_symbols_a_b_ab_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(howto 'a 'b 'ab)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "((+ (quote a) (quote b)))",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_howto_hash_map_1_a_and_2_b_and_hash_map_1_a_2_b_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(howto (hash-map {D+1} |a|) {D+2} |b| (hash-map {D+1} |a| {D+2} |b|))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    octaspire_string_t *tmpStr = octaspire_dern_value_to_string(
        evaluatedValue,
        octaspire_dern_vm_get_allocator(vm));

    ASSERT_STR_EQ(
        "((+ (hash-map {D+1} |a|) {D+2} |b|))",
        octaspire_string_get_c_string(tmpStr));

    octaspire_string_release(tmpStr);
    tmpStr = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_vectors_of_integers_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '({D+1} {D+2} {D+3}) '({D+1} {D+2} {D+4}))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '({D+1} {D+2} {D+3}) '({D+1} {D+2} {D+4}))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '({D+1} {D+2} {D+3}) '({D+1} {D+2} {D+3}))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '({D+1} {D+2} {D+3}) '({D+1} {D+2} {D+3}))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== '({D+1} {D+2} {D+3}) '({D+1} {D+2} {D+3}))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '({D+1} {D+2} {D+3}) '({D+1} {D+2} {D+3}))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '({D+1} {D+2} {D+3}) '({D+1} {D+2} {D+4}))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> '({D+1} {D+2} {D+3}) '({D+1} {D+2} {D+3}))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= '({D+1} {D+2} {D+3}) '({D+1} {D+2} {D+3}))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_vectors_of_vectors_of_integers_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '(({D+1} {D+2}) ({D+3} {D+4})) '(({D+1} {D+2}) ({D+3} {D+5})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '(({D+1} {D+2}) ({D+3} {D+4})) '(({D+1} {D+2}) ({D+3} {D+5})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '(({D+1} {D+2}) ({D+3} {D+4})) '(({D+1} {D+2}) ({D+3} {D+4})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '(({D+1} {D+2}) ({D+3} {D+4})) '(({D+1} {D+2}) ({D+3} {D+4})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== '(({D+1} {D+2}) ({D+3} {D+4})) '(({D+1} {D+2}) ({D+3} {D+4})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '(({D+1} {D+2}) ({D+3} {D+4})) '(({D+1} {D+2}) ({D+3} {D+4})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '(({D+1} {D+2}) ({D+3} {D+4})) '(({D+1} {D+2}) ({D+3} {D+5})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> '(({D+1} {D+2}) ({D+3} {D+4})) '(({D+1} {D+2}) ({D+3} {D+4})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= '(({D+1} {D+2}) ({D+3} {D+4})) '(({D+1} {D+2}) ({D+3} {D+4})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_vectors_of_vectors_of_reals_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0001})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0001})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0001})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_vectors_of_vectors_of_integers_and_reals_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '(({D+1.0} {D+2.0}) ({D+3.0} {D+4})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0001})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '(({D+1.0} {D+2.0}) ({D+3.0} {D+4})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0001})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '(({D+1.0} {D+2.0}) ({D+3.0} {D+4})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '(({D+1.0} {D+2.0}) ({D+3.0} {D+4})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== '(({D+1.0} {D+2.0}) ({D+3.0} {D+4})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '(({D+1.0} {D+2.0}) ({D+3.0} {D+4})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '(({D+1.0} {D+2.0}) ({D+3.0} {D+4})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0001})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> '(({D+1.0} {D+2.0}) ({D+3.0} {D+4})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= '(({D+1.0} {D+2.0}) ({D+3.0} {D+4})) '(({D+1.0} {D+2.0}) ({D+3.0} {D+4.0})))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_vectors_of_vectors_of_strings_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '(([a] [b]) ([c] [d])) '(([a] [b]) ([c] [e])))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '(([a] [b]) ([c] [d])) '(([a] [b]) ([c] [e])))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '(([a] [b]) ([c] [d])) '(([a] [b]) ([c] [d])))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '(([a] [b]) ([c] [d])) '(([a] [b]) ([c] [d])))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== '(([a] [b]) ([c] [d])) '(([a] [b]) ([c] [d])))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '(([a] [b]) ([c] [d])) '(([a] [b]) ([c] [d])))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '(([a] [b]) ([c] [d])) '(([a] [b]) ([c] [e])))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> '(([a] [b]) ([c] [d])) '(([a] [b]) ([c] [d])))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= '(([a] [b]) ([c] [d])) '(([a] [b]) ([c] [d])))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_vectors_of_vectors_of_chars_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '((|a| |b|) (|c| |d|)) '((|a| |b|) (|c| |e|)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '((|a| |b|) (|c| |d|)) '((|a| |b|) (|c| |e|)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '((|a| |b|) (|c| |d|)) '((|a| |b|) (|c| |d|)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '((|a| |b|) (|c| |d|)) '((|a| |b|) (|c| |d|)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== '((|a| |b|) (|c| |d|)) '((|a| |b|) (|c| |d|)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '((|a| |b|) (|c| |d|)) '((|a| |b|) (|c| |d|)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '((|a| |b|) (|c| |d|)) '((|a| |b|) (|c| |e|)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> '((|a| |b|) (|c| |d|)) '((|a| |b|) (|c| |d|)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= '((|a| |b|) (|c| |d|)) '((|a| |b|) (|c| |d|)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_vectors_of_vectors_of_misc_types_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '((1 |a|) ([b] c)) '((1 |a|) ([b] d)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '((1 |a|) ([b] c)) '((1 |a|) ([b] d)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= '((1 |a|) ([b] c)) '((1 |a|) ([b] c)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< '((1 |a|) ([b] c)) '((1 |a|) ([b] c)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== '((1 |a|) ([b] c)) '((1 |a|) ([b] c)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '((1 |a|) ([b] c)) '((1 |a|) ([b] c)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= '((1 |a|) ([b] c)) '((1 |a|) ([b] d)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> '((1 |a|) ([b] c)) '((1 |a|) ([b] c)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= '((1 |a|) ([b] c)) '((1 |a|) ([b] c)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_functions_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< (fn (a) (+ a a)) (fn (b) (+ b b)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= (fn (a) (+ a a)) (fn (b) (+ b b)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= (fn (a) (+ a a)) (fn (a) (+ a a)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< (fn (a) (+ a a)) (fn (a) (+ a a)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (fn (a) (+ a a)) (fn (a) (+ a a)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= (fn (a) (+ a a)) (fn (a) (+ a a)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= (fn (a) (+ a a)) (fn (b) (+ b b)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> (fn (a) (+ a a)) (fn (a) (+ a a)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= (fn (a) (+ a a)) (fn (a) (+ a a)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_hash_maps_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< (hash-map 1 |a|) (hash-map 1 |b|))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= (hash-map 1 |a|) (hash-map 1 |b|))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= (hash-map 1 |a|) (hash-map 1 |a|))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< (hash-map 1 |a|) (hash-map 1 |a|))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (hash-map 1 |a|) (hash-map 1 |a|))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= (hash-map 1 |a|) (hash-map 1 |a|))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= (hash-map 1 |a|) (hash-map 1 |b|))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> (hash-map 1 |a|) (hash-map 1 |a|))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= (hash-map 1 |a|) (hash-map 1 |a|))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_hash_maps_of_vectors_of_integers_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< (hash-map 1 '(1 2 3)) (hash-map 1 '(1 2 4)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= (hash-map 1 '(1 2 3)) (hash-map 1 '(1 2 4)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= (hash-map 1 '(1 2 3)) (hash-map 1 '(1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< (hash-map 1 '(1 2 3)) (hash-map 1 '(1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (hash-map 1 '(1 2 3)) (hash-map 1 '(1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= (hash-map 1 '(1 2 3)) (hash-map 1 '(1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= (hash-map 1 '(1 2 3)) (hash-map 1 '(1 2 4)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> (hash-map 1 '(1 2 3)) (hash-map 1 '(1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= (hash-map 1 '(1 2 3)) (hash-map 1 '(1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_hash_maps_of_lists_of_integers_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< (hash-map 1 (list 1 2 3)) (hash-map 1 (list 1 2 4)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= (hash-map 1 (list 1 2 3)) (hash-map 1 (list 1 2 4)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= (hash-map 1 (list 1 2 3)) (hash-map 1 (list 1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< (hash-map 1 (list 1 2 3)) (hash-map 1 (list 1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (hash-map 1 (list 1 2 3)) (hash-map 1 (list 1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= (hash-map 1 (list 1 2 3)) (hash-map 1 (list 1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= (hash-map 1 (list 1 2 3)) (hash-map 1 (list 1 2 4)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> (hash-map 1 (list 1 2 3)) (hash-map 1 (list 1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= (hash-map 1 (list 1 2 3)) (hash-map 1 (list 1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_hash_maps_of_queues_of_integers_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< (hash-map 1 (queue 1 2 3)) (hash-map 1 (queue 1 2 4)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= (hash-map 1 (queue 1 2 3)) (hash-map 1 (queue 1 2 4)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= (hash-map 1 (queue 1 2 3)) (hash-map 1 (queue 1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< (hash-map 1 (queue 1 2 3)) (hash-map 1 (queue 1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== (hash-map 1 (queue 1 2 3)) (hash-map 1 (queue 1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= (hash-map 1 (queue 1 2 3)) (hash-map 1 (queue 1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= (hash-map 1 (queue 1 2 3)) (hash-map 1 (queue 1 2 4)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> (hash-map 1 (queue 1 2 3)) (hash-map 1 (queue 1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= (hash-map 1 (queue 1 2 3)) (hash-map 1 (queue 1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_compare_environments_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    // Create environments
    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e1 as (env-new) [e1])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 as (env-new) [e2])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    // Add values to environments
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as {D+1} [a] in e1)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as {D+2} [a] in e2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    // Compare environments
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< e1 e2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= e1 e2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    // Change environment e2
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as {D+1} [a] in e2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= e1 e2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< e1 e2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== e1 e2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= e1 e2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    // Change environment e1
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as {D+0} [a] in e1)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= e1 e2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> e1 e2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false, evaluatedValue->value.boolean);

    // Change environment e2
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a as {D-1000} [a] in e2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= e1 e2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true, evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_eval_empty_vector_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "()");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Cannot evaluate empty vector '()'",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_eval_vector_containing_empty_vector_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(())");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Cannot evaluate operator of type 'error' (<error>: Cannot evaluate "
        "empty vector '()')",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_eval_right_parenthesis_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            ")");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "unexpected token: line=1,1 column=1,1 ucsIndex=0,0 type=OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN value=right parenthesis",
        octaspire_string_get_c_string(evaluatedValue->value.error->message));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

GREATEST_SUITE(octaspire_dern_vm_suite)
{
    octaspireDernVmTestAllocator = octaspire_allocator_new(0);
    octaspireDernVmTestStdio     = octaspire_stdio_new(octaspireDernVmTestAllocator);

    assert(octaspireDernVmTestAllocator);
    assert(octaspireDernVmTestStdio);

    RUN_TEST(octaspire_dern_vm_new_test);
    RUN_TEST(octaspire_dern_vm_create_new_value_boolean_test);
    RUN_TEST(octaspire_dern_vm_create_new_value_integer_test);
    RUN_TEST(octaspire_dern_vm_create_new_value_boolean_and_push_one_test);
    RUN_TEST(octaspire_dern_vm_vm_parse_and_eval_true_amid_whitespace_test);

    RUN_TEST(octaspire_dern_vm_special_if_two_elements_false_test);
    RUN_TEST(octaspire_dern_vm_special_if_two_elements_true_test);
    RUN_TEST(octaspire_dern_vm_special_if_three_elements_false_test);
    RUN_TEST(octaspire_dern_vm_special_if_three_elements_true_test);
    RUN_TEST(octaspire_dern_vm_special_if_three_elements_with_function_resulting_true_test);
    RUN_TEST(octaspire_dern_vm_special_if_three_elements_with_function_call_resulting_true_test);
    RUN_TEST(octaspire_dern_vm_special_if_called_with_one_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_special_if_called_with_integer_as_the_first_argument_failure_test);

    RUN_TEST(octaspire_dern_vm_special_select_one_true_selector_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_one_false_selector_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_one_default_selector_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_one_false_and_one_default_selectors_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_one_false_and_one_true_and_one_default_selectors_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_one_false_and_one_true_selectors_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_function_selectors_evaluating_into_false_and_true_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_function_selectors_failure_on_unknown_symbol_test);
    RUN_TEST(octaspire_dern_vm_special_select_called_with_zero_arguments_failure_test);
    RUN_TEST(octaspire_dern_vm_special_select_called_with_one_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_special_select_called_with_three_arguments_failure_test);
    RUN_TEST(octaspire_dern_vm_special_select_called_non_boolean_selector_failure_test);
    RUN_TEST(octaspire_dern_vm_special_select_called_with_default_as_first_selector_failure_test);

    RUN_TEST(octaspire_dern_vm_special_define_integer_value_test);
    RUN_TEST(octaspire_dern_vm_special_define_integer_value_with_explicit_target_global_env_test);
    RUN_TEST(octaspire_dern_vm_special_define_my_inc_function_test);
    RUN_TEST(octaspire_dern_vm_special_define_factorial_function_with_integers_test);
    RUN_TEST(octaspire_dern_vm_special_define_factorial_function_with_reals_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_three_arguments_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_eight_arguments_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_four_arguments_first_being_value_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_eight_arguments_first_being_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_four_arguments_error_at_first_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_four_arguments_with_docstring_being_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_four_arguments_name_evaluates_into_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_six_arguments_docstring_is_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_eight_arguments_error_in_environment_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_four_arguments_integer_as_docstring_failure_test);

    RUN_TEST(octaspire_dern_vm_special_quote_called_without_arguments_failure_test);

    RUN_TEST(octaspire_dern_vm_builtin_plus_plus_integer_value_test);
    RUN_TEST(octaspire_dern_vm_builtin_doc_for_integer_value_test);
    RUN_TEST(octaspire_dern_vm_builtin_read_and_eval_path_test);
    RUN_TEST(octaspire_dern_vm_builtin_read_and_eval_string_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_1_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_10_2_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_0_2_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_100_10_0dot5_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_100_minus10_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_0_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_10_2_0_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_10_2_character_a_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_mod_5_mod_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_mod_0_mod_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_mod_3_mod_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_mod_4_mod_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_mod_4_mod_0_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_1_2_3_4_minus_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_1_2_3_4_minus_2_2dot5_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_string_cat_dog_and_string_space_and_string_zebra_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_string_ca_and_character_t_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_empty_string_and_characters_k_i_t_t_e_n_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_vector_1_2_3_and_4_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_vector_1_2_3_and_4_and_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_empty_vector_and_1_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_empty_vector_and_empty_vector_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_empty_vector_and_empty_vector_and_empty_vector_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_empty_hash_map_and_1_and_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_hash_map_1_a_and_2_and_b_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_hash_map_1_a_and_2_and_b_and_3_and_c_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_string_cat_dog_cat_and_string_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_string_abcabcabc_and_character_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_string_abcabcabc_and_character_a_and_character_b_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_string_abcabcabc_and_character_a_and_character_b_and_caharacter_c_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_1_2_3_4_minus_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_1_2_3_4_minus_2_2dot5_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_abcdeaaba_character_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_abcdeaaba_character_y_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_string_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_string_parrot_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_quoted_symbol_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_quoted_symbol_parrot_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_123_124_abc_123_99_123_integer_123_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_123_124_abc_123_99_123_integer_777_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_3dot14_abc_3dot13_3dot14_3dot146_3dot14_real_3dot14_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_3dot14_abc_3dot13_3dot14_3dot146_3dot14_real_7dot11_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_abc_def_aaxa_char_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_abc_def_aaxa_char_y_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_string_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_string_parrot_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_symbol_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_symbol_parrot_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_123_dog_cat_123_123_cat_zebra_123_integer_123_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_321_dog_cat_321_321_cat_zebra_321_integer_123_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_3dot14_dog_cat_3dot14_3dot14_cat_zebra_3dot14_real_3dot14_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_3dot14_dog_cat_3dot14_3dot14_cat_zebra_3dot14_real_4dot14_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_vector_of_chars_a_b_c_a_a_g_u_a_char_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_vector_of_chars_a_b_c_a_a_g_u_a_char_x_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_vector_of_strings_cat_dog_cat_zebra_parrot_cat_string_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_vector_of_strings_cat_dog_cat_zebra_parrot_cat_string_kitten_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_vector_of_symbols_cat_dog_cat_zebra_parrot_cat_symbol_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_vector_of_symbols_cat_dog_cat_zebra_parrot_cat_symbol_mouse_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_chars_a_b_c_d_char_c_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_chars_a_b_c_d_char_x_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_chars_a_b_c_d_char_b_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_strings_cat_dog_zebra_kitten_string_zebra_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_strings_cat_dog_zebra_kitten_string_parrot_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_integers_1_2_3_4_integer_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_integers_1_2_3_4_integer_5_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_reals_2dot1_2dot2_2dot3_2dot4_real_2dot2_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_reals_2dot1_2dot2_2dot3_2dot4_real_2dot5_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_global_environment_symbol_find_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_global_environment_defined_symbol_xyz_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_global_environment_symbol_notfound_test);

    RUN_TEST(octaspire_dern_vm_special_while_with_one_value_to_repeat_test);
    RUN_TEST(octaspire_dern_vm_special_while_with_two_values_to_repeat_test);
    RUN_TEST(octaspire_dern_vm_special_while_called_with_one_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_special_while_called_with_integer_as_first_argument_failure_test);

    RUN_TEST(octaspire_dern_vm_builtin_hash_map_empty_test);
    RUN_TEST(octaspire_dern_vm_builtin_hash_map_one_element_symbol_one_1_test);
    RUN_TEST(octaspire_dern_vm_builtin_hash_map_one_element_1_symbol_one_test);
    RUN_TEST(octaspire_dern_vm_builtin_hash_map_two_elements_strings_dog_barks_and_sun_shines_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_characters_t_bar_newline_tab_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_characters_c_a_t__a_n_d__d_o_g_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_newline_failure_on_missing_end_delimiter_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_yy_failure_on_unknown_char_constant_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_in_hex_A9_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_in_hex_a9_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_a_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_in_hex_0x10000_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_in_hex_failure_on_too_many_hex_digits_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_empty_vector_of_strings_and_integer_10_and_string_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_vector_of_strings_and_integer_1_and_string_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_hash_map_and_same_key_inserted_multiple_times_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_hash_map_and_hash_map_with_elements_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_hash_map_and_empty_hash_map_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_vector_and_vector_with_elements_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_vector_and_empty_vector_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_string_and_index_and_character_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_character_x_and_integer_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_character_x_and_character_exclamation_mark_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_real_3_dot_14_and_reals_1_dot_0_and_zero_dot_14_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_integer_10_and_integers_1_and_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_vector_1_1_2_2_2_3_and_values_1_and_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_string_abcd_and_characters_a_and_b_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_hash_map_1_a_2_b_3_c_and_value_1_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_vector_1_2_3_3_and_ln_at_v_minus_1_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_equals_with_vector_1_2_3_3_and_ln_at_v_minus_1_test);

    RUN_TEST(octaspire_dern_vm_builtin_pop_front_with_vector_1_2_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_pop_front_with_string_abc_test);
    RUN_TEST(octaspire_dern_vm_builtin_pop_front_with_symbol_abc_test);
    RUN_TEST(octaspire_dern_vm_builtin_pop_front_with_list_1_2_3_test);
    // No pop front for queue
    RUN_TEST(octaspire_dern_vm_builtin_pop_front_with_integer_10_failure_test);

    RUN_TEST(octaspire_dern_vm_builtin_pop_back_with_vector_1_2_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_pop_back_with_string_abc_test);
    RUN_TEST(octaspire_dern_vm_builtin_pop_back_with_symbol_abc_test);
    RUN_TEST(octaspire_dern_vm_builtin_pop_back_with_list_1_2_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_pop_back_with_queue_1_2_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_pop_back_with_integer_10_failure_test);

    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_hash_map_and_hash_map_1_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_hash_map_and_1_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_hash_map_and_list_1_a_2_b_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_vector_1_2_3_and_4_5_6_test);

    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_string_def_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_symbol_def_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_character_d_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_vector_of_strings_def_ghi_jkl_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_nil_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_booleans_true_and_false_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_integer_128_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_real_3dot14_test);

    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_string_def_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_symbol_def_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_character_d_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_vector_of_strings_def_ghi_jkl_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_nil_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_booleans_true_and_false_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_integer_128_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_real_3dot14_test);


    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_bad_input_test);
    RUN_TEST(octaspire_dern_vm_run_user_factorial_function_test);

    RUN_TEST(octaspire_dern_vm_special_for_from_0_to_10_test);
    RUN_TEST(octaspire_dern_vm_special_for_from_0_to_10_with_step_2_test);
    RUN_TEST(octaspire_dern_vm_special_for_from_0_to_10_with_step_minus_2_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_from_10_to_0_test);
    RUN_TEST(octaspire_dern_vm_special_for_from_10_to_0_with_step_2_test);
    RUN_TEST(octaspire_dern_vm_special_for_from_10_to_0_with_step_minus_2_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_string_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_string_step_2_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_string_step_minus_2_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_vector_of_strings_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_vector_of_strings_step_2_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_vector_of_strings_step_minus_2_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_environment_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_environment_step_2_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_environment_step_minus_2_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_hash_map_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_hash_map_step_2_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_hash_map_step_minus_2_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_called_without_arguments_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_called_with_one_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_second_argument_not_symbol_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_called_with_integer_as_first_argument_failure_test);


    RUN_TEST(octaspire_dern_vm_error_in_function_body_is_reported_test);
    RUN_TEST(octaspire_dern_vm_builtin_cp_at_sign_called_with_0_and_string_abc_test);
    RUN_TEST(octaspire_dern_vm_builtin_cp_at_sign_called_with_1_and_string_abc_test);
    RUN_TEST(octaspire_dern_vm_builtin_cp_at_sign_called_with_2_and_string_abc_test);
    RUN_TEST(octaspire_dern_vm_builtin_cp_at_sign_called_with_3_and_string_abc_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_ln_at_sign_called_with_0_and_vector_1_2_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_ln_at_sign_called_with_1_and_vector_1_2_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_ln_at_sign_called_with_2_and_vector_1_2_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_ln_at_sign_called_with_3_and_vector_1_2_3_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_ln_at_sign_called_with_0_and_index_and_hash_map_1a_2b_3c_test);
    RUN_TEST(octaspire_dern_vm_builtin_ln_at_sign_called_with_1_and_index_and_hash_map_1a_2b_3c_test);
    RUN_TEST(octaspire_dern_vm_builtin_ln_at_sign_called_with_2_and_index_and_hash_map_1a_2b_3c_test);
    RUN_TEST(octaspire_dern_vm_builtin_ln_at_sign_called_with_3_and_index_and_hash_map_1a_2b_3c_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_ln_at_sign_called_with_2_and_hash_and_hash_map_1a_2b_3c_test);
    RUN_TEST(octaspire_dern_vm_changing_atom_doesnt_change_another_defined_from_it_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_do_inside_function_test);
    RUN_TEST(octaspire_dern_vm_special_do_error_stops_evaluation_and_is_reported_test);
    RUN_TEST(octaspire_dern_vm_special_fn_in_env_howto_no_test);
    RUN_TEST(octaspire_dern_vm_special_fn_in_env_howto_ok_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_for_with_numeric_range_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_for_with_collection_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_for_with_string_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_for_with_environment_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_for_with_hash_map_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_while_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_called_without_argument_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_called_with_two_arguments_failure_test);
    RUN_TEST(octaspire_dern_vm_function_taking_one_regular_and_varargs_called_with_four_arguments_test);
    RUN_TEST(octaspire_dern_vm_function_taking_one_regular_and_varargs_called_with_one_argument_test);
    RUN_TEST(octaspire_dern_vm_function_taking_one_regular_and_varargs_called_with_zero_arguments_test);

    RUN_TEST(octaspire_dern_vm_newly_created_function_returned_from_another_function_and_used_test);
    RUN_TEST(octaspire_dern_vm_recursive_function_used_test);
    RUN_TEST(octaspire_dern_vm_mutually_recursive_functions_used_test);

    RUN_TEST(octaspire_dern_vm_special_and_called_without_arguments_test);
    RUN_TEST(octaspire_dern_vm_special_or_called_without_arguments_test);
    RUN_TEST(octaspire_dern_vm_builtin_not_called_without_arguments_failure_test);

    RUN_TEST(octaspire_dern_vm_special_and_called_with_one_argument_test);
    RUN_TEST(octaspire_dern_vm_special_or_called_with_one_argument_test);

    RUN_TEST(octaspire_dern_vm_special_and_called_with_one_false_argument_test);
    RUN_TEST(octaspire_dern_vm_special_or_called_with_one_false_argument_test);
    RUN_TEST(octaspire_dern_vm_builtin_not_called_with_one_false_argument_test);
    RUN_TEST(octaspire_dern_vm_builtin_not_called_with_one_true_argument_test);
    RUN_TEST(octaspire_dern_vm_builtin_not_called_with_one_integer_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_not_called_with_two_boolean_arguments_failure_test);

    RUN_TEST(octaspire_dern_vm_special_and_called_with_three_arguments_test);
    RUN_TEST(octaspire_dern_vm_special_or_called_with_three_arguments_test);

    RUN_TEST(octaspire_dern_vm_special_and_called_with_three_arguments_with_false_as_second_test);
    RUN_TEST(octaspire_dern_vm_special_or_called_with_three_arguments_with_true_as_second_test);

    RUN_TEST(octaspire_dern_vm_special_greater_than_called_with_two_reals_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_called_with_two_integers_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_called_with_integer_10_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_called_with_integer_9_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_called_with_real_9dot9_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_called_with_real_10dot1_and_integer_10_test);

    RUN_TEST(octaspire_dern_vm_special_greater_than_or_equal_called_with_two_reals_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_or_equal_called_with_two_integers_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_or_equal_called_with_integer_10_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_or_equal_called_with_integer_9_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_or_equal_called_with_real_9dot9_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_or_equal_called_with_real_10dot1_and_integer_10_test);

    RUN_TEST(octaspire_dern_vm_special_less_than_called_with_two_reals_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_called_with_two_integers_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_called_with_integer_9_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_called_with_integer_10_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_called_with_real_10dot1_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_called_with_real_9dot9_and_integer_10_test);

    RUN_TEST(octaspire_dern_vm_special_less_than_or_equal_called_with_two_reals_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_or_equal_called_with_two_integers_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_or_equal_called_with_integer_9_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_or_equal_called_with_integer_10_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_or_equal_called_with_real_10dot1_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_or_equal_called_with_real_9dot9_and_integer_10_test);

    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_lists_of_integers_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_lists_of_integers_test);

    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_vectors_of_integers_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_queues_of_integers_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_queues_of_vectors_of_integers_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_queues_of_vectors_of_integers_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_queues_of_integers_with_different_lengths_of_5_and_6_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_queues_of_integers_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_vectors_of_vectors_of_integers_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_hash_maps_of_vectors_of_integers_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_hash_maps_of_vectors_of_integers_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_environments_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_environments_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_equal_functions_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_functions_formal_name_differs_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_functions_name_differs_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_functions_docstr_differs_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_functions_howto_differs_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_vectors_of_vectors_of_integers_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_vectors_of_integers_with_different_lengths_5_and_6_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_unequal_vectors_of_integers_with_different_elements_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_reals_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_integers_test);
    RUN_TEST(octaspire_dern_vm_buildin_equals_equals_called_with_integer_9_and_reals_9dot1_and_9dot0_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals__called_with_integer_10_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_real_10dot1_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_real_9dot9_and_integer_10_test);

    RUN_TEST(octaspire_dern_vm_builtin_exclamation_equals_called_with_two_reals_test);
    RUN_TEST(octaspire_dern_vm_builtin_exclamation_equals_called_with_two_integers_test);
    RUN_TEST(octaspire_dern_vm_buildin_exclamation_equals_called_with_integer_9_and_reals_9dot1_and_9dot0_test);
    RUN_TEST(octaspire_dern_vm_builtin_exclamation_equals_called_with_integer_10_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_builtin_exclamation_equals_called_with_real_10dot1_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_builtin_exclamation_equals_called_with_real_9dot9_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_error_during_user_function_call_test);
    RUN_TEST(octaspire_dern_vm_error_during_builtin_call_test);
    RUN_TEST(octaspire_dern_vm_error_during_special_call_test);
    RUN_TEST(octaspire_dern_vm_error_during_special_call_during_user_function_call_test);
    RUN_TEST(octaspire_dern_vm_special_eval_plus_1_2_test);
    RUN_TEST(octaspire_dern_vm_special_eval_plus_1_2_in_given_global_env_test);
    RUN_TEST(octaspire_dern_vm_special_eval_value_from_given_local_env_test);
    RUN_TEST(octaspire_dern_vm_special_eval_eval_eval_f_1_2_test);
    RUN_TEST(octaspire_dern_vm_special_eval_failure_on_integer_on_second_argument_test);
    RUN_TEST(octaspire_dern_vm_special_eval_failure_on_unbound_symbol_on_second_argument_test);
    RUN_TEST(octaspire_dern_vm_special_eval_called_with_three_arguments_failure_test);

    RUN_TEST(octaspire_dern_vm_create_new_value_copy_called_with_vector_value_of_int_values_test);

    RUN_TEST(octaspire_dern_vm_comment_alone_test);
    RUN_TEST(octaspire_dern_vm_comment_after_integer_1_test);
    RUN_TEST(octaspire_dern_vm_comment_before_integer_123_test);

    RUN_TEST(octaspire_dern_vm_multiline_comment_test);
    RUN_TEST(octaspire_dern_vm_multiline_comment_in_vector_1_2_test);
    RUN_TEST(octaspire_dern_vm_multiline_comment_before_integer_123_test);
    RUN_TEST(octaspire_dern_vm_multiline_comment_missing_chars_test);

    RUN_TEST(octaspire_dern_vm_io_file_open_success_test);
    RUN_TEST(octaspire_dern_vm_input_file_open_success_test);
    RUN_TEST(octaspire_dern_vm_output_file_open_success_test);

    RUN_TEST(octaspire_dern_vm_port_supports_input_question_mark_called_with_output_file_test);
    RUN_TEST(octaspire_dern_vm_port_supports_input_question_mark_called_with_input_file_test);
    RUN_TEST(octaspire_dern_vm_port_supports_input_question_mark_called_with_io_file_test);
    RUN_TEST(octaspire_dern_vm_port_supports_input_question_mark_called_with_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_port_supports_input_question_mark_called_without_arguments_failure_test);

    RUN_TEST(octaspire_dern_vm_port_supports_output_question_mark_called_with_input_file_test);
    RUN_TEST(octaspire_dern_vm_port_supports_output_question_mark_called_with_output_file_test);
    RUN_TEST(octaspire_dern_vm_port_supports_output_question_mark_called_with_io_file_test);
    RUN_TEST(octaspire_dern_vm_port_supports_output_question_mark_called_with_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_port_supports_output_question_mark_called_without_arguments_failure_test);

    RUN_TEST(octaspire_dern_vm_port_close_called_with_io_file_port_test);
    RUN_TEST(octaspire_dern_vm_port_dist_called_with_a_file_test);
    RUN_TEST(octaspire_dern_vm_port_seek_called_with_a_file_test);

    RUN_TEST(octaspire_dern_vm_input_file_open_with_file_system_access_allowed_failure_on_missing_file_test);
    RUN_TEST(octaspire_dern_vm_port_write_failure_on_input_file_test);
    RUN_TEST(octaspire_dern_vm_port_length_test);

    RUN_TEST(octaspire_dern_vm_integer_question_mark_test);
    RUN_TEST(octaspire_dern_vm_real_question_mark_test);
    RUN_TEST(octaspire_dern_vm_number_question_mark_test);
    RUN_TEST(octaspire_dern_vm_nil_question_mark_test);
    RUN_TEST(octaspire_dern_vm_boolean_question_mark_test);
    RUN_TEST(octaspire_dern_vm_character_question_mark_test);
    RUN_TEST(octaspire_dern_vm_string_question_mark_test);
    RUN_TEST(octaspire_dern_vm_symbol_question_mark_test);
    RUN_TEST(octaspire_dern_vm_vector_question_mark_test);
    RUN_TEST(octaspire_dern_vm_hash_map_question_mark_test);

    RUN_TEST(octaspire_dern_vm_queue_test);
    RUN_TEST(octaspire_dern_vm_queue_with_max_length_test);
    RUN_TEST(octaspire_dern_vm_list_test);

    RUN_TEST(octaspire_dern_vm_copy_test);

    RUN_TEST(octaspire_dern_vm_split_called_with_string_and_char_test);

    RUN_TEST(octaspire_dern_vm_cp_at_sign_with_vector_test);
    RUN_TEST(octaspire_dern_vm_cp_at_sign_with_string_test);
    RUN_TEST(octaspire_dern_vm_cp_at_sign_with_hash_map_of_size_one_test);
    RUN_TEST(octaspire_dern_vm_cp_at_sign_with_hash_map_of_size_three_test);

    RUN_TEST(octaspire_dern_vm_ln_at_sign_with_vector_test);
    RUN_TEST(octaspire_dern_vm_ln_at_sign_with_string_test);
    RUN_TEST(octaspire_dern_vm_ln_at_sign_with_hash_map_of_size_one_test);
    RUN_TEST(octaspire_dern_vm_ln_at_sign_with_hash_map_of_size_three_test);

    RUN_TEST(octaspire_dern_vm_host_command_line_arguments_test);
    RUN_TEST(octaspire_dern_vm_host_environment_variables_test);

    RUN_TEST(octaspire_dern_vm_create_user_data_test);
    RUN_TEST(octaspire_dern_vm_copy_user_data_test);

    RUN_TEST(octaspire_dern_vm_require_a_source_library_test);

    RUN_TEST(octaspire_dern_vm_special_howto_1_2_3_test);
    RUN_TEST(octaspire_dern_vm_special_howto_strings_a_b_ab_test);
    RUN_TEST(octaspire_dern_vm_special_howto_chars_a_b_string_ab_test);
    RUN_TEST(octaspire_dern_vm_special_howto_symbols_a_b_ab_test);
    RUN_TEST(octaspire_dern_vm_special_howto_hash_map_1_a_and_2_b_and_hash_map_1_a_2_b_test);

    RUN_TEST(octaspire_dern_vm_compare_vectors_of_integers_test);
    RUN_TEST(octaspire_dern_vm_compare_vectors_of_vectors_of_integers_test);
    RUN_TEST(octaspire_dern_vm_compare_vectors_of_vectors_of_reals_test);
    RUN_TEST(octaspire_dern_vm_compare_vectors_of_vectors_of_integers_and_reals_test);
    RUN_TEST(octaspire_dern_vm_compare_vectors_of_vectors_of_strings_test);
    RUN_TEST(octaspire_dern_vm_compare_vectors_of_vectors_of_chars_test);
    RUN_TEST(octaspire_dern_vm_compare_vectors_of_vectors_of_misc_types_test);
    RUN_TEST(octaspire_dern_vm_compare_functions_test);
    RUN_TEST(octaspire_dern_vm_compare_hash_maps_test);
    RUN_TEST(octaspire_dern_vm_compare_hash_maps_of_vectors_of_integers_test);
    RUN_TEST(octaspire_dern_vm_compare_hash_maps_of_lists_of_integers_test);
    RUN_TEST(octaspire_dern_vm_compare_hash_maps_of_queues_of_integers_test);
    RUN_TEST(octaspire_dern_vm_compare_environments_test);

    RUN_TEST(octaspire_dern_vm_eval_empty_vector_test);
    RUN_TEST(octaspire_dern_vm_eval_vector_containing_empty_vector_test);
    RUN_TEST(octaspire_dern_vm_eval_right_parenthesis_test);

    octaspire_stdio_release(octaspireDernVmTestStdio);
    octaspireDernVmTestStdio = 0;

    octaspire_allocator_release(octaspireDernVmTestAllocator);
    octaspireDernVmTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/test/test_dern_vm.c
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        dev/etc/amalgamation_impl_unit_test_tail.c
//////////////////////////////////////////////////////////////////////////////////////////////////
void octaspire_dern_amalgamated_write_test_file(
    char const * const name,
    char const * const buffer)
{
    FILE *stream = fopen(name, "wb");

    if (!stream)
    {
        abort();
    }

    size_t bufferSize = 0;

    if (buffer)
    {
        bufferSize = strlen(buffer);
    }

    if (!buffer || !bufferSize)
    {
        if (fclose(stream) != 0)
        {
            abort();
        }

        stream = 0;

        printf("  Wrote empty file '%s'\n", name);

        return;
    }
    else
    {
        if (fwrite(buffer, sizeof(char), bufferSize, stream) != bufferSize)
        {
            fclose(stream);
            stream = 0;
            abort();
        }
    }

    if (fclose(stream) != 0)
    {
        abort();
    }

    stream = 0;

    printf("  Wrote file '%s'\n", name);
}


GREATEST_MAIN_DEFS();

int main(int argc, char **argv)
{
    // This banner is created with figlet using font 'small'
    unsigned char octaspire_dern_amalgamated_version_banner[] = {
      0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x2f,
      0x20, 0x5f, 0x20, 0x5c, 0x20, 0x5f, 0x5f, 0x7c, 0x20, 0x7c, 0x5f, 0x20,
      0x5f, 0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x5f, 0x5f, 0x20, 0x5f, 0x5f,
      0x28, 0x5f, 0x29, 0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20,
      0x7c, 0x20, 0x20, 0x20, 0x5c, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x5f, 0x20,
      0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x20, 0x20, 0x0a, 0x7c, 0x20, 0x28, 0x5f,
      0x29, 0x20, 0x2f, 0x20, 0x5f, 0x7c, 0x20, 0x20, 0x5f, 0x2f, 0x20, 0x5f,
      0x60, 0x20, 0x28, 0x5f, 0x2d, 0x3c, 0x20, 0x27, 0x5f, 0x20, 0x5c, 0x20,
      0x7c, 0x20, 0x27, 0x5f, 0x2f, 0x20, 0x2d, 0x5f, 0x29, 0x20, 0x7c, 0x20,
      0x7c, 0x29, 0x20, 0x2f, 0x20, 0x2d, 0x5f, 0x29, 0x20, 0x27, 0x5f, 0x7c,
      0x20, 0x27, 0x20, 0x5c, 0x20, 0x0a, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x2f,
      0x5c, 0x5f, 0x5f, 0x7c, 0x5c, 0x5f, 0x5f, 0x5c, 0x5f, 0x5f, 0x2c, 0x5f,
      0x2f, 0x5f, 0x5f, 0x2f, 0x20, 0x2e, 0x5f, 0x5f, 0x2f, 0x5f, 0x7c, 0x5f,
      0x7c, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x7c, 0x20, 0x7c, 0x5f, 0x5f, 0x5f,
      0x2f, 0x5c, 0x5f, 0x5f, 0x5f, 0x7c, 0x5f, 0x7c, 0x20, 0x7c, 0x5f, 0x7c,
      0x7c, 0x5f, 0x7c, 0x0a, 0x20, 0x20, 0x41, 0x6d, 0x61, 0x6c, 0x67, 0x61,
      0x6d, 0x61, 0x74, 0x65, 0x64, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
      0x6e, 0x7c, 0x5f, 0x7c, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x2d, 0x61, 0x6c,
      0x6f, 0x6e, 0x65, 0x20, 0x75, 0x6e, 0x69, 0x74, 0x20, 0x74, 0x65, 0x73,
      0x74, 0x20, 0x72, 0x75, 0x6e, 0x6e, 0x65, 0x72, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x0a, '\0'
    };





    printf(
        "%s  %s\n\n",
        octaspire_dern_amalgamated_version_banner,
        OCTASPIRE_DERN_CONFIG_VERSION_STR);

    printf(
        "  This is stand-alone unit test runner for the amalgamated version of\n"
        "  Octaspire Dern. Some of the unit tests test reading of files from\n"
        "  the filesystem. The full source distribution has these files in\n"
        "  the 'test/resource' directory. But because this amalgamated\n"
        "  distribution can have only one file, to be able to run all\n"
        "  the tests succesfully something must be done. What do you\n"
        "  want to do? Select 'a', 'b', 'c' or any other key:\n"
        "\n"
        "  a) Let this program to write those files to disk to the current working\n"
        "     directory. All existing files with the same name will be OVERWRITTEN.\n"
        "     The files to be written are of form 'octaspire_XYZ_test.abc', where XYZ\n"
        "     is the name of the test and abc is some suffix.\n"
        "\n"
        "  b) Let those tests to fail on missing files, or succeed if the files are\n"
        "     already present in the current working directory.\n"
        "\n"
        "  c) Abort and quit this program.\n"
        "\n"
        "  > ");

    int c = 0;

    if (argc >= 2)
    {
        if (strcmp(argv[1], "--write-test-files") == 0)
        {
            --argc;
            ++argv;
            c = (int)'a';
        }
        else
        {
            printf("Unknown option '%s'\n", argv[1]);
            return EXIT_FAILURE;
        }
        printf("Option '%c' given with command line argument.\n", (char)c);
    }
    else
    {
        c = getchar();
    }

    switch (c)
    {
        case 'a':
        {
            printf("Writing test files to current working directory...\n");



            char const * const octaspire_dern_vm_run_user_factorial_function_test_dern =
                "(define fact as\n"
                "  (fn (n) (if (== n {D+0}) {D+1} (* n (fact (- n {D+1})))))\n"
                "  [fact]\n"
                "  '(n [value to calculate n!])\n"
                "  howto-ok)\n"
                "\n"
                "(define i as {D+0} [i])\n"
                "(while (<= i {D+100}) (fact {D+10}) (++ i))\n";

            octaspire_dern_amalgamated_write_test_file(
                "octaspire_dern_vm_run_user_factorial_function_test.dern",
                octaspire_dern_vm_run_user_factorial_function_test_dern);





            char const * const octaspire_read_and_eval_path_test_dern =
                "(define y as {D+100} [y])\n"
                "y\n"
                "(define x as {D+200} [x])\n"
                "x\n";

            octaspire_dern_amalgamated_write_test_file(
                "octaspire_read_and_eval_path_test.dern",
                octaspire_read_and_eval_path_test_dern);





            char const * const octaspire_io_file_open_test_txt =
                "ABCABC\n";

            octaspire_dern_amalgamated_write_test_file(
                "octaspire_io_file_open_test.txt",
                octaspire_io_file_open_test_txt);

            printf("Done.\n");
        }
        break;

        case 'b':
        {
            printf("Tests reading files will fail, if the required files are not available.\n");
        }
        break;

        case 'c':
        default:
        {
            printf("Going to quit now, as requested\n");
            return EXIT_FAILURE;
        }
        break;
    }










    GREATEST_MAIN_BEGIN();
    RUN_SUITE(octaspire_dern_lexer_suite);
    RUN_SUITE(octaspire_dern_vm_suite);
    GREATEST_MAIN_END();
}


#endif // OCTASPIRE_DERN_AMALGAMATED_UNIT_TEST_IMPLEMENTATION
#endif // OCTASPIRE_DERN_AMALGAMATED_H

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          dev/etc/amalgamation_impl_unit_test_tail.c
//////////////////////////////////////////////////////////////////////////////////////////////////
