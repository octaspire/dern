; WIP conversion into stand alone 100% Dern version is
; not complete yet!
(require 'dern_sdl2)
(require 'dern_easing)
(require 'dern_animation)

(define sdl-init-vec as '(sdl2-Init 'VIDEO) [SDL2 is initialized by evaluating this vector])
(eval sdl-init-vec)

(define window   as (sdl2-CreateWindow [octaspire-lightboard] 'CENTERED 'CENTERED 640 480) [window])
(define renderer as (sdl2-CreateRenderer window -1 'SOFTWARE) [renderer])

(define texture as (sdl2-CreateTexture
        renderer
        'BASE64
        [iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAADTED8xAAAgAElEQVR42u19eZCkV3FnZr7vq7uqz7lHI41aGh1IQkjIAoTNYRaDkTGEsddhY5DxeoF17IYPTh8cFizGJrDDG2vA9vpgMcZewIZFtiNsA2JtxKXDukeoNdLc093T3dXVdX3f9zL3j/feV9XTc8+UJaT8RRCMZrp/lZUv82W+zHfgO9/5zmaziYhwviEitVptZmam3e3CCPhBJDZmZmYmsRZGA2SemZlhY0BkBOxou92ZmRkql0fEz93u7Oxs3GiMiB+63dnZ2aheH5X+e73Z2dl4clJGID8i9przUbPZ/NjHPjaiL/DmN7+5myRvecUrekly3slLhcL/vO22DOA6omwEwkcA32bGQiH9u7+DQuH8f0CS0MteFtdqt//iL0bV6nmnz9rtF/3e75lq9ZF3vctUKued33Y6V/z2b2O1uvSe92C5fP7nt2536oMfpLGxA294A41gfBlgw//+42gUc/+wkyFAL0n6WTY6/gzAju47iEChgHF8/olDnIyq1XgEBurIQcRUKmY0/O4zsFymEfCzU74IAdCIhGchUCiewVAHUKgDKBTqAAqFOoBCoQ6gUKgDKBTqAAqFOoBCoQ6gUKgDKBTqAAqFOoBCoQ6gUKgDKBTqAAqFOoBCoQ6gUKgDKBTqAAqFOoBCoQ6gUKgDKBTqAAqFOoBCoQ6gUKgDKBRPNqJR3LubQ0QEoDSKm2UBSoWC449GpBr3f4iQJCPRUZIAACJm7fYo6LN2GxEB0XY6o+D3tIjS7fIojMddKo7IoxlfBgBC1OvRTwK9Hv3k/E+H69H/HaKMTdMROVghihAx6/dHxB/HMSKmo5lBAYCIADFZXR1VfI8iQOw3myPiL5VKgNhdWhqR/qvVKhK1Dh0alf3UCiN/H6Ddbr/jHe8YEf+HPvShXq/34z/+4yPi/8xnPpOm6XOf+9wR8X/zm98UkampqRHxLy8vp2l64403joj/7rvv7vV6P/mTPzki/s9//vOrq6vvfve7R8T/wd/5AI38fYAR8480dn2v86uKTsmuVSDFMxrqAIpnNE62CL7rrrtOn+i6664708+++eabT/+Hv/SlLym/8p93fo0ACk2BFApNgc4uvTmjNOkswt8ZhTnlV/4z5dcIoNAUSKHQFOiMMp8z+plzWfj/4fvfP1L+j77lLSPlf/+rXz1S/rfdcMNI+d+8bdtI+X/qHPpcp8P/3Ntu0wigUKgDKBTqAArFaa0Bzrq4eZpLgrMufp1mv/Bs+D/+8dHyf/GLI+X/yM03j5T/EyPm//SI+F/1quFfWc+vEUChKZBCoQ6gUKgDKBTqAAqFOoBCoQ6gUKgDKBTqAAqFOoBCoQ6gUKgDKBRPDxx/M9y5HHM5HZzFHRjKr/yj4NcIoHhmp0Ajfx9gxPwj1c73Or+q6JTs/x7vA6ysrIyIv1wuz8zMtN1LECPgj+P4kksu6fV6o5p+iGZmZrIsG1WCG0Wzs7PMI3piAkql0qOPPpqO7Pr7arU6Ozvb7XZHdz26pkCKZ/YiWN8HOAn0fYCTQ98HOAX0fYAnl19VdEp2TYEUz2ioAyie2WuAk/zb+84k+rzvzMtVej+98j/p/BoBFJoCKRSaAp1devO+87FI1/vvlf/J4tcIoNAUSKHQFOiMMp/zgnO5+/90cC53/58OzuXu/9PBudz9fzo4l7v/Twc/NeIe2Snv/tcIoFCoAygU6gAKxRmsAc6iuOl+5TSXDWdR/Lr5XO6P//jHR8v/xS+OlP8jp6Guc+H/xIj5Pz0i/rV3/58dv0YAhaZACoU6gEKhDqBQqAMoFOoACoU6gEKhDqBQqAMoFOoACoU6gEKhDqBQPD1wgs1wIz4Ko/fTK/9ThF8jgOKZnQLp+wBPY35V0SnZ9X2Ak/Hr+wAnh74PoFB8jy+C9X2Ak0DfBzg59H2AU0DfB3hy+VVFp2TXFEjxjIY6gOKZvQY4yb/p+wDK/7Tn1wig0BRIodAU6OzSG30fQPm/p/k1Aig0BVIoNAX698fp3O9+LnfAn8799Odyh/3p3K9/Lnfwn877AOfyhsDpvG9wLm8gnM77DOfyhsPpvC9xyp/RCKDQFEihUAdQKHQN4HFMcfN0ap1n8z7A6dzvvvZnRnc//adHfL/+J0b8PsBHRvy+gfuZ0b3P4H7mLPlPG/o+gEKhDqBQqAMoFOoACnUAhUIdQKFQB1Ao1AEUCnUAhUIdQKFQB1Ao1AEUiqcr9H0A5X9G82sEUDyzUyB9H+BpzK8qOiW7vg9wMn59H+DkeBq8DxABADNnWdbv9ycn04sv3rhxQ7Xfh34vZbEiCM4FEUEEEAAQQBAAAAXA/ZnIFEuFYlHm5juPPXZkcTEuFotR5BcYaEyv3+92uxEtbN5cHW9EZ82/vGIPH17NeLpcLpeKRRdhMIq63W673e6szo41qFzis+bv9kxzxVZqM9VqtVwuOzVRsdhutVqt1uGDd8dxz2DvrPmtlNO0uHnrc+r1erVehyQBEVMurzSbzWbzkYe+mqVLNm2eNb+Jx6N4fNcVLx4bG2uMjTn+qFZrt1orKyuH998Zma7B7jnIX8lsafP26xuNRrVelyQBkUKj0e10VldXV5cfqdekXMjOXv9J3FqF2viuWq1WrlQkTYW5umlTt9PpdDqY7t8wWWhU8az5V9owv9iXeHulUqlUKknraLS0tHTrrbfeedc3suS+fl+Wm3zJZS/ffuGVlbEGEwiDMcAMkQFhsAKIwAJsAREIgQXiGEigtdTau+e+bveffuD7NxaLGBWuvv665/3ar/1au9d73Y03fvu+O0tX2iTdtrxst44/e9PUhaVyUQwN8zMDr+V3XyqOAZk77eTg3J5u595rrhorxNI7VL3h6uv/6utf71u7s92+d8/uLVfF6XhtaSmbxIunpjcVCpHjj3J+AWYAAmGwFsjxA0QRoOVe386tHOzYx3dsL8fRocX70507L5stl9mYhc9+dvf8gR0v3tKoRUuLssFu3RyPxwWQmHiY/8TyQ8ZJhkvLi4vR4vhklq7ecc+XDl22YdvEq19N5fKX3vrWx7vLV/zY1SJxcympL1anbIk4kzgSgYiOIz9bQPL8UQSQZRnELWyvTHUmJrPZ+//yoc/dd1F5/OaPfQxKpbt+5Vf2pu1rf/4H6pXC4lFb2suVLlYTC4V4zfgKWAYkYB4aX4A4AkhTa6RTytILs4mppL94+z9++Gs74uoNv/u7XCod+vVf3yv9573jR8c3FxcX+p27mtFyWuy2sVjgdfo/rn4kSaRYW20QPmvj9s1FI49844Nf2IHFHR/6ENTrj95yy0IBXvvnv8pm6uhcd+9f3pntmUuWFrFclHX6BwRZx8+9vhmbogunpn/4hitmpsgu/s0b3zadwI4//8Moy7I77/wG4UPLy+mFF7/4h1774m4CWQatNpNBZkFEIhRmImJhy2KMSRMxBgEEhNOIiJBK9a2XPv/yZ7/g3m999YnHvrpx40N33glZlvV7vW/fd+fYzt7cnN3QuOra63f1JU4tdLtiSCwLeX4hwpw/SSRy/CBRgkTEpjg+fflNW2Ye3//d+ZX7Nu7sffu+O/v9fq/bvXfP7q031ObmuuPxRd+3Y0tKpSzD1YxJiFnIIiFwKkQowDYRikyaQmRAAFA4EkICiaExNrN5YtuB5uHl7uzWG2r3fns37rxstdXaPX9g16sunpvrVtPpK4u1LK5aCz0WQmSETMAYTNnzZ1aMMakVYxAEAFkAqYAQSy2qTsvUwkp7JT6061UX777tsavb7Waz+Xhn+bpbbpyb6xaa1Qu7Za40rAXLQoaEJUM0BJ5f2DIYQzYBY0AAQFgiojIYlmo6NrG00kqoO9a87o033vVn32w2m+1Wa2/afv4vv3JurouHYPpIT6rjtoxZUQyhFRAEwrXyR8bxWwAQZoNURWSJU6k8vNzbUpQt9PxffuUdH/37K1ZXu+32Xum/9AM/PTfXzWY7pUf3Y306K5VtsUGEzJIhEmEuf8ZijMkSiYyboZkNUg2FGTsSfe2J1q4Lopn4pR/46S//+l9Mt9u9Tmchhtd/4bfm5rpHv7J7+bZ/jjZutxxjYxMRsAAjGkLLTEQY7McmQgYBBIXBYFQmttz97tLe9/5p50d+cOolM6//wm996tXv2tjumCuvvPKqZ8nScrbr8h+eufamTkdEABCZhRkAyfkAu8kf0TJYK2QoyySKkFkAkAwKgFjp9mV6+84iVffvf7hYWLj7nkP1RmPnZXa5mW0df86W7bt6SeQClmWwLIhkBRDROn7yf09EmZUoQrYCgGgQAJmln1FjfLog5bnl/bXpbM/jnVqttnFnZ3nFTkeXbpi8oG9jcITs5hu0LO4/vfwC1gISOn7LAgBEKAjCkNioWm7EXDzamZu4IFpYKlSr1ca25nKLG90tY8XJREpOfmZgFiAKnwIAKIjsvlcuv9MPIQAKSyqFkilGabycNTftaiR2ulKpRBvmmy0uztcqXMqwCpLz+4FARGuD/CzWAhnMMogiCPwAiMKQQjG2aBKzSt3tz95UaVw6Nze38WrTXBV8DAqrkkU1EPT8Aojo5Oe1+iGnH+PlR0JAZCsZlambUhe7ZbvjxgvZbJmfn7/ipZubq5Le24K5VY7HQBCJLIOwIBKfwfiCNRVZbmMHkjEz86LLmt36wuLiS95040obD3/u7pXvPAS1DQCAho6xTztkn2wF19gnkXFfWaQ81nlsHzcTs3PjNa+7ad9RNC95yZUXX7ytVrtk5jkvT/tCCOLGUoDFZVTgFlGWBRCc6RNhljERIhJbRkT3Goy1YK1Mbdu+cnjO8sqhwwdqVdi6dTLmjRu3XJNl5PhdsuaN0kV2wMzZoqE08CMhreNnxvr4eGd5BQv9I0cORVFvcrJK3bGJsRlrI0QUQZcLeqMUpwWwVgQRDaapuAEmREJkZiRCBEC0FpmxWq32Wm1T4bkjh61tVqsRL5eqZiNL7KIqIAogs6BT1EA/iIRefhv0w4yEiAiEmQURKhUKSbcfN2h+7ki3M2dMlh7BuFtlKRKCk18Ag/4x8AMgksEsFTK5/pGt4/fyC1ABMEttcbKwsHBkYf7xWi3u7k1gXhhLFPQjQT9O/wLgbIgIs+PITwCA5PiNSVMWrGyszM0faTUPTk/XWt9tJXtaYsqEIACCCIBOIfn42jBXHkc/Q+MrGEGnLRTVtjbm5g4n3aPbtk0f+fpjh//pHirU0ennpPaZHs8+ERGRrAU0ce/gobg+Nrlr6+Ejh8zrX/8yxMqNL3pDJrFlQES/pkD3Gew+DImsQJhNxVpAg2nGhZisFSJEQEIQARFgxq3bdz503x3VKk5OVq0t7NrxQotFtoCEDH5cQfwE5mOO4ye0IpkFNJhZjmNiFiQkQHLpqYiAmW5MPXH40UpFavU46ZsdjWdZKlkLSM5AXS6IzAyAAoiILGhZgJBFLAMaSjOOC8gWnP0Yl56KCJjxYu3gysFS2ZaL2O3AhmwrU9mFDpGw1IIgPwB6+WHAT5haLhTIWiFERDQI4uTHqA7xfLZcLGbG2NVWVl8oS1SxDMHB3B9wSP9oGVkEEK2ItRj0j54fINc/YFTu83IhieMUMel2IHqkx1GVrSChCAj6LzAsv/VrALQiGYfxHZKfEESERZAKhZVueyIuFrJCzEnfZN88JIWqH18ZVGyGx9cOj2/QTxyTk2p4fJEKtLCcbhsrFW25QjaN9/3BbVBqnNI+mQVOZZ8sQHGp99CjledfXSkL7bhgvFQcT+OKc6eMhQEti1uvEJIIuExWBK2VzIqJqJ9lAmgFrQAZshmLCAK4hYG1DKVKqTi+44KxjRvKMZRTU/L8VhiQRcSHrIH1i2BmIcvEGEpsxoiZuAyarBURAYHIIKJYK1IoxVDetLE8PmYoixMqBvmBAZhBGAiBCF0hmQEYILOSWaCIkswKgBWwAmjIWgYBEIgMIIBlkULRZPHEmKmUM+hi4MfMCoPzEyAAcvIDsgALDvFngkE/RNYKsONHQLFWOC5CF6uVLKI2t7I+FoblD/lbrn9gAQnyB/3DQP+WRQAFjAEAsSwcFbiVRbRaLWfZUr8PsTObYf0g4kB+AAE3vmCc/ICZ5zfWigiAgDGIINaKjeJsqV8pJeNjlMy3exAJ4LB+XEnmmPG1FjILxlCShfEFICIO/H58GSzFyXx7vAEbJ4vtvfNdS4B4jH3SOvvMTtM+WTKg9t75jZMFAihu2nwRW0A/nAICSBjmTVeBFXFhDcBaQYRCTGmWkYE0ZZfgumTAGDAGQdimsHnzRQAlgMJUdZqZCHNzcS+f+YQBECSETQTJrCBCHFGWZoYgTdkQ+l8RIAOGEMRaS1PVaYAiSGEsqokYBCACHxfJT3J+4gIA8WUfa4UG/JilbEI3XACIgJz81jSiGkBRpFDJIhHjqiLg2jJujnMWRE4/QAgAYjNew594+QFBAMiAMQTAzKaSRSJFkUK8mgFEbgp3RT0kH8RcKcPJdlz9Z6kQQR6Rcv2LRIXVzPGbo22gGBGIQIJ+fIWanH78fDTgj0yaZoYwTTnnBwAiL79AbI62RYogBTi4iBQT+hAEQVSXUCG58XV/KTZjpKHxTZz9gLMICvIDxnBwUaQIUGg/MEtxydknnIl9GgOZt59j7RNMqfPALECRmKUrVYPgTJDQuZeLXAIo7jsQhi8vkqZcLBgUiQ2BCLMYQ5atc7IowsggCvSkylaYpYs1gyAibgzcXwogiwAIGZcBen4ESVMuFQ0IrOG3VkAIIYowihAF+lgL/HVXMXJTvqviuVkTEIgAURCFCIgIRNJEikUCgChCYWELJgQBRIiNlz/BuuPvkeMXF0fZirDj9wtoRCCUYBySJFwsGjefiQi7uo21TgORQRdnEsr5G8ZPCH496pJayeXP9e/kT6VYIBSIHX+Q3026Tv8A0KeG5zcNLz8AEVoWti7ggXj9AHr5EYSdfhAgNgi8hp9y+QUSE/ijsVw/RMhW3KKCRQSAyC2hB/pJEy4VDQ7G1wWxML6GoghQIInGHH8Sjef2iW4ty66+dgr7jAzJie0zjcbZCgEASGYIMJgXgAi7ZYz3ZiIAEeM+BkEsE0IhNjbLDCGIGJP3IsQQGgJEYJv6mZXTyAD5r4cAwiz53EYIhgDA8yMAWyaAYkw2s44/okH3zhC6MbOBHzg1JshvnPiStw69/CCGwBAQCltLCMWYOLWRoVx+V0Im/2Ngs2RYfgQwBJFxpUH2k/QQPxkgBAKvHyd/ZEiEvX68/OD0k/OvkT+Cgf6H5Rc2BETH6N8aQoBh/UP4msDZkP4JXISMDICAiIsbgoEfnf5db8FaQig4/Q/pB0Fy/mPlpyH9O/248HUMPwJCLr/jRxCOzPD4ejF4SP+O3wT75DOxTzmefebjSwBos54hIABEMAixQZfFhdwDIkKn+ogwMmQIbSqlAhFIROjmQkN+WxEhGIORAWv7Lh5a2ze5LhBigwgM4DoJzrDQILjZMTYUDfjZTWYs4kYCBIicGEP8Wc8gEIof48hXmtxgIEBk0BAiQEQQGxMZsimUCkQoESGgn6TdxG4IIkJzDD95fkN+DFxCnPM7048MxpGXv1ggA2IIECDwu4gBEWFEw/rx/ARg/BzBLp8J+gciJICIIPL6gVIBg/6FZYjf6Z/A2t56+YkgjgCERcAYlIH8jh/jY8cXgn7QZaouEEXr9OPDOEIcuQbjgN/4IOD1YwhtEsaXfBnHjy8Mxjc7Rv/BPp1+4MT2Ga21T1xnn5EZjC8BAHPq3Q5c/o2RQRAhApdfOdNBEUMQG4yJgDkiKEYGgY1BsUyhbwUABpEQmFNXj3QePBxkjONHnzcfy29Icn4RY5DZZ4oCAgIucWXr+VlSQ0Do3Sk2LvdgJF8NcobrJqHIQEQIzAahGBkANoaEfaYLIiI+aq+RHx2/uMQgMiDC5IOYoFu9gUTkMoSgn5gQxBgUthSWIuD4acDPjp+C/JGTMNc/eP14B4bI6R+9/iNDYpkMrNH/EL8E/SAAefkRhIncZmAJq/+B/oElQijGJsgf9O+Wwmv14+zHYB4E0BgA4TXja8L4kuN3+vH8HPTjlqBufMWu4fchK9inHM8+I4LYYBTss3QC+6Qh+6QwB3sFiQihRBEhCLP42RTEECF6kzUEkSHOpBiTC0BkUERctVhEjHEejz5IgQtqgZ8kzvkNCjOCEJGbAp0rx4Y4k0JMIXd3/J4hMt7jc35D4Er5LkTEESGKWIkiFBEUMIRueAyCIYgNsYVCjC53J4PO7p09hCg8JL9x4dvPC04/whIZBGYEMYje09wsRcSZFCIiECIkIhEhv9wUZ0A0xG8MkF/PASFEESEKW4giAGE3iSIwDuvfQjFGGugfvP4ZwnyMw/oJ+gcvPwpbiSIElsAv5AIIQmTQ6Qd9kr1G/yHZWM/v7XL9+BpcM77OfgoRodfPuvF1Zcvh8Q3L3dw+JdgnBvvEtfZZiIlOZZ+uwQG5hzmrMoSG3LwFocciFFzcEBKKmw4iQ25p5ZtbfpYAMoDAeRZrzMCDfUz02yvAuB4RuWKtuEBGIQN2/IZQAr+rMxCFzU4AhEAmX+yGYgWRMBv0fkL5FItgCBHFZ7TGOPcA8P0zV7IwBBj4c/1gKDUYQheXnOMBovNSJ4AxrjULAmAiQhesBTB0P7z8IMNZ/lp+GNZ/+Blf7Hf5jNOEMQTD+hf/vzXy+wWia1VL4CdhpsEi2MvvMqg83EaGUIblP47+nX4MAQAPxtcMjy+in6F8iMgnr8jrh2Q9f24/tFY/wT6Z7SDyn8A+nX6c/DRknybYJ4V6lfva4n4APQsAizHk2isU5tgw2OBrIAAEGHoxLqcKa7hQNHRm4St6Q/zid7yASD6jCIZl0IAf0ZyEHxBxzZB7LfjNfCQiLJ4q2JC3RhdGXUU/15RvpR3Db3wTJsjv6qViDAkLS5gpgo2G6TyYL2L+nxxqjkE/jh8QXYrnTAoNAbjk2+sf81rkkP4BfUcC/EwUyl/r9eOKwwP9D+nH6x/QTyjhy+Re5/9Ax5MfEBHI+Cnb8Ufkuv5iIhKWofH1FRv/XUILb834ruen9frHgf5PZZ8IGPTv7SfXD/m1PQyqSBLyVEPGWs7LNT6q+jH2EdUFHZeohKMLrocPCK5Y6//eELilRXBxJCJrmWjQ/iREXw0MAS98+oDfbScc5ufg08Y1Alh8RZ/IsvViC6z9IkBh7yySOE9wkvntMc4WvPw+poX9fxJGkbx+3AYGrx//B78fA3PTDGc7ECVv4jt+9stTX2L3+gdar/9Qkqd8LMIUvkb/J5SfJAwAERgkHtYPhZQd83zPly7W9BD89qG1/AiGnK+KrNcPev1Q2LSMIeEbFAPX6F/ADdCw/Ovsk87WPn2TDhBQfKzwXmUQUHyNIHQumMUY73qhg56nO5B34GlgQwiCzK6vg+hULgCDSdT1GULRk93GveDvoWI9dGpkEAfd/n8RZPbrF7/p2/lYXk3jvN0GzL7MCn5eCWeM8iIa+hW5S7TE73GAkPr5/QV5H9FtwczbVcwSWmmCQ4eY3DfFkO24IO4KWUF+zOV3U1LOw4N2kjj53ah7/ecT/HH0n+9BGNI/5PL733N9BudOzELkSqPOKGBYP7lpujxTfPsA7Br9nGB8KR9f90vBqPxmkrAkpUHYFz8Aa+xnvX3KadgnDukH1tqnDPGTWxKH3riP0T4mkmtls4iQN4OcWkIW6yY8CWVNce5rre+EA4V+uwx8NPSbAV3XUsQPVNilEvjBrcwQBAO/aydZ9n1eoMEeJAorGRHftQnye2U58d3s5VJGP8PlI+1q8G7nWc4fvjyFWlCeMwT5fSMThgjzjChUf1xZEIbk9/rBY+UH1ykc6B+AfB7k88nhVYTroAf/l3zn3Hr9IOVTAAf5MRRevHPmfdyhaODzEeNLrgIIPDy+hMzHjq/np1w/kq9P1iSHrhIPg30Kjn/YfpBQ8r0tPoc8oX3iWvsMy4aBfboeS84fciTJA433KxBGRKKgh9B1XmMxIbVweyjQt0X9XCthrwCgGz23/MK8nEaOH8VvBcw7/7n7ehJAlzb4TNSF3CF+8FkgCBj3E26axfBxEHKSsL8gTP8oIhRaJBgqG/kp1MA/kH9QrfPGQW4OzyUHzMUHtwuA/JYbCS0zOFZ+DPIDUF6K8j/vl6On0D+t1T/kuyeG5XebebwL541b9EY50D/CYAHm+8cD/eSuvoYfjje+uX5CTpLz54MysC1hzscXjh3fNfo/kX3mjjqsH1lnn26HAwzZJ7qVgbCA+JqUHwEOvapQzUU/XYk3HUIAoXy7Slg85UmG269LSH7j4YDfTaJD/IM9Qn68Pb/bMeTU4b9AviPHfZwrGvupL+x38HFyWH5whYIwlqEbCnmS6otX+dm6wO8I3Uzm6g95EFgvvwvB6NOGobWH58fBCA/0gyiDWX9I/4NeWND/evnFt6RDouzlx7Xyu9AgQT9hks57SeLXMD6FGNYPrdGP37uFuHZ83crSp+bH0Y8cox8EEQ7jCzQol6MPFuv4XaZAXv/HsU9Ya598UvvEYJ9hBILGnRDG/Sr4r8TC+fIi339E7jOQJKw5QgPcJWpuxT2Y2kFClkWYjwEIEBEz06BtjmumZ78+c50L9qsx923B8/tUxG/uDaslzBM5FBbvWji0fCRg9pNo2DfK+ULWHQMJ8udZigACGjRkcLA4o3xnBOblBn820vvwQD/5RjRZw+9KBUH/sE7/MqR/GNJ/Xlxy+5BloH8BgiH5/aTv1yRkaK38kteIMRRrKOgnTyad/DQo5QX+8JVDlENyNUvh9eOLQzHZ1f5DfDt2fGktf26feIb2CcezTwn8hKGiK0Ju7WW8o/hMIpwVwXxfRx51hP1UB6GS4OYwPx0Skt+4Qy7nZxhsWUPyC6OwhPepA+Vba9CdkwR2i5uc3/sXEJHn91mL36nvMsV8VnAeRUPkTsyDCkYAABQYSURBVH6/9iVfNHT8ftNomP5zfi+/yyIgr9L6zV6IPrsOLbmB/M4NXIELPT8ey+9VfVz9h0JeMCBDYb505aP18q/Xv19vBvkx7yHm8g8KKW64/PjK0Pj6eReCAa/VzxB/XkWVkMbkCy+/9BoeX4TgtxTGN8wgQ/xwKvsM3apcP0H/5PWPuf7X6ocMGSJyaSC7bVKDYBRSWSJ/ysf1n1EAGN1nhHTf9/NYvJMLEJFBY8jkuRmz58/rvk4S4/jB87viBJyEn3xY8Pxr5PdFceMnoeFcGcPKSXC44jlIhGhQCRDAXH6/TQKFfT0kzysgtO4lX7t7Y3L5GOXrY3fiQ7wzwzC/i6KAkMufZ6sga5oJEOQHYBzKcfPmgCuA+mn7GPkRWbychE7nIQi48QL0ORICCKP7XuxWMmHz/fH04+XPxxc9P+ZdxbDhwFfDcv2g10/I/chXhEPN3vOH8ZUT26ess89h+/HZ4PHsk0wUI9DwdvA8BTTkKtbiFueDnQK+jSREyMyusI1hl79L1NzpNxPFJooJzbH8fk+EW2MJuh3aof1LJo/CLmyhhOMVbpOtMziiyPEjmkH5z7Jf4ogYJB+F82Jl2MriJDUEwowI+e5Un+YQnEx+8bOv8adtnPw+2wkLQQQQg44/T07yao+T3wzLfyy/37/F+WQfdiu5UynemNjLPyg3+SAMgEE/Xn7w2/FhwB+21/uOpPdn4wOo53enmcPS1fOv0T+tk98dpl8zvr6dHBayOCR/Pr6+Ikyu8W+iE9rPadun13+wTxmyTzKRiWKKo7iA3ZDV+cK5X1u6+DMoLQshsOV8b0K+xRcQMuvnPPY1TihIJ47jOIpj6cgQvzvgh4iGMBQhfOlvwG/87O21A2CzcHo98MfcDvztvBUgToOh92RCmHFWQuQPTJAvbfpT5+6oGvjjBP7nc/6IVyUcBQbvgT7Q+7kwVO+J0LVm8r2NgO7YA2TWLyLZ1wUhsqtefl4F9AskyOVH9Ns3ZNDcIARr3dYdCvpHlwIN5PdFcohty8tvW6EVMJAfIcgfPoCt380PCH7vZKhGAIK1EqYkX0WJshXPn7VgzfgKkq8wrhtfDONLx46v9atY8X1jiFLPb7KVcDpiYJ80ZJ8D/SPYYJ8Duz2efSKCSZpxHBNzf/Ho/jgOPQhAa/1nCQshhaaD6+qha/3k+5bQewIGE3emxlEEi0cPMPeZ+62kGUWcl4YyK/kkRKH7P+D3Ox0C/+AQepjbEJnZGG4lK8x95qSHPWNsXhmy7vS16z6GQ0oIaDO/U8U1MsGXJtE3lWUgv2Umsj3sMyciSVZGgzaXf3iSDhUPIESnet+IRW/6oSaDvlkUVpNENiuTSCKSwESZMMur5E7/ob2FeX80y9itM1zahmEqyT1/WP+EGUyUHb/ZPG4gzfvQQX5fZ8v5nes6TwunVSU/gxumi8APqdk8IZIwJ4WLNpKkxx9fOmZ8fRvOh4Dh8R0q7TMzSlq4aBNzwpyMX3sZ2N6J7NOlcbTOPuGk9ilZb/zay5kT2rNnzkTSX235AAEoiNaGNRAOfNQfqkdiyYX2aatzKmZ3EoUAMFldMTHv2TN38GCzUI3TTjsYAQpg5q5acYEVcuOgjAHdEsz1fsJZWHdCjdnPIgCYtlcLtejAweWFo93SWCXtdnAoJ7cW8sQAgNwBJUCyNrSUfED0BXE36bubNpzu0k67NF6eX+g0V2x1upH1Onn9UsBftSKeH8PQkOuP+hOx+Vk933n1R6VcAzjrdKob6svNrNsz9c2TWa+brxrFXYICMKR/v2awdg3/kP5995TD56bdbn3LZLdnllfs2PaNWb+HPodGBnSn70PihMJOIWT9qfZ80vEtJwnXLuT6yfq9sQs2NFu8cLQ7ceHWLOnlxxVz/fhYOnCeY8aXhsZ3SP+IAmj7vYmLthxd7B060tp4xSWcpXnxScIlKE4/ECYXWGufedXkOPYpwFmy8cqZg0dW6OHd+6em6nfe8dlSCYSFRTjcUBKuGADr79zC1LpqPvjmasgv8psqrAUAKZTo7m9+bmqy/vDD+/buX5qaqj/yxB2FghUf3vwAhzIBWPYazzJ2581dIi+ho+J6hQJgLQhIFMvs/m9MTdafeOLo/EJ3aqr+xOL9cZSxT7/cDSj5TrNwRhshs+KMhhkE3Wj5BqX7LHdNUGR4f/OBqcn6kbnOagempuqHsr2xSdxZPAbMLAx35JndGT3MMvb3YoQtFRIkd1/HWpdkZ3Oyd2qyvrIqmVSmpupL5aUI+25THQNk7PdQDfQPAAipFc75Q99/kP55/QNBulJbmpqsZ1xebcPUVL29yRrouk2B4ibpfPMJog1ZTZpJ0D/kW6XCtk8ECYkK9Htb7NRkvd3B+cX+1FTdXlol7ohw4F+z1S/wD49vfkMn+h0kfnxFAIi7fFl1arK+sJjsO9ScmqqP/8h1kKzwCewz3AmHmc31L+J3/B7HPiVZnfrR66cm63sPNc2OHZdftqtRKpnmYnPDtpksC/tq/UlKFwowv3fR97VlWPX+c9wHxwX67j1fZp5bbS3d/rW9ldrGTdNpday6PL80Pr7ZWpRQgTM0xO9bi64ohvmI+knXmZoAgxgjB/bdU5ywqytHH3oknZjYXowX6lNjS0eONqpTmVBulCbc6zRQN/h7pkTyZWHY3uZ9QIj4yMLu2tZiq7lwdHl805ZLequPjm+eWjo0Xy00rJBbj7lDWO6+MIa8CuTn4MCPbu7MP4VBDGZHV/dNXDK+sjRPxct2XHjl3P7vTGzfdPTgXInKLMbPvizGYH5RShAXj6f//M/CIgRp0y5svGbryuLc1ote3O2b3soj0xdtO7r/cCGLGCKBIX4X6sPOZvTr3dAshcHmn1x+lKQTr2573iXNo0eKjWuWW7bABzdccuHCvkOmKwxRKEK4k8RD4xsy8pBTeLuSfBOGW/LbXjpmL3rJNc2Fw61s2/xSMl5Y3H7ts4489oQ90hQqDOmH3D0oPGSfuf3IevtkYQFJOsUrN1/zhh9eOnLgsfkiVatVMpdZbq8sP3j/t79YLfuaeubPNfs1BIv4mzM43xUU5onQVUbCapnu+9b/XVl+wNo20q5qtdpoNNr7y5bbXFrc88S3iiZ11jx0v4i4vI3zG9cGkSvckOPWPwQlyvY8/i0uLVrbXt1Xqtfr4xMT8//WsdyOppMDC/cXpeuitqsGucnGFeM5OBgD8NDWc8j5EQrQ3z//QDSdWNueu6czPj4xPTX9+Jf3Wm5Xdhbne4/Htu2imJvVrL+GAlwQEEQrfhIVgfxotYAgCiDEWedI5/HKzoK17cf/ee/U1NTGTZse+Ou7Lbcnrp5apnnTb7omasaD+1dchZQBBP3nDvQ/ZP8AYJLWEi5MXD1pbfv+v75r46ZNU9PTd33iy5bbm15wUbvRwe6iMAtLFqLNQC0CguAvoBlkngAI7FMboc5yu9bd9IILrW3f9YkvT09Pj09MfP3Dn7PcvuDlV6VbCFrzzEF+kQF/CJIsw+ObT4bi9/i2FtLN5oKXX2Vt+18//LmJicmxsbHPv/FWy+1rf+G1tZsuTuf2snXyA4vY49knhwjMMmjXuDQom9tXfcHMtb/wGmvbn3/jrY3xsSiKomuvvfHuuyVN7o/jA1/50ocv2HnThi2XV8enGaFYRLZAAJlFcC0Mobx9na+KkLHdnD9ycPfePf86Pl7vdlfiwlXPec7zPv/52wrF4nVXXnfn/XcWtzTHxqMHH/+76dqlE/Vt5UqDCUpD/OJPN9P6rcuQSa+7srhyYL793YnJRnO52T9Uv/6q62fv+HqpXN61Y9d9d+yevKowvnX68aPfqdlN9cKGUqHCTIUIxAIiZOzbwEIAYtGdXve7AUFSTpJ2s7/QMkcmto4tLy0v3p9cfdFlj1VK1XrtksktD3/xkQtetHXyko3zC3vjxXJJajEVM0uGgBkMgFhg12UL6Va+HRERIOWU+x1cTSa7U1Pjy0fn991+8NLpbW6C2F6sf+d/ff3yH7t68zWbFucXs8dXom7BMPUKkSEQC4SQ2SC/gA27rCXsYeZ+xsYmpdTMFDZPTy8tzD38uft2lMcajUa1VttGpX/5nS9d+59+4ILnXbQ4dzS5fwGbgqn049gYf0+wzQDItxo40Ob756SX2gLaMSy9YPKCDZNL80fu+eOvXRBVqrVauVLZmkX/9O5P3vj2H734pVceveroyh1P8FwPelm/UMj5swzAdxg8P+YXYRBwL+FSBBtL9ZftmtowuTh3+Ju/84XtUihXK8VyebxjP3nz217zZ7967RtfsfBD1+/5zNfauw+ny6u2VCQDYoEAUgthTzuka+2TEGy3H09Uy7u2XP6et0xvmj56+MDf3vLfJ/tQrJTxne9859LSUpqmSZJMTKSXzGzauXM6y6J+P7FuPQ+Dnbcg4eZpGNzbgYAmMsViIYqyPXsWHp09srQUFwqFOI4bjcbMzEyr3e71+t1ux9DC1i31bVvrZ81/4GDr4KGW5elyuVIqFYtxPDMz002STqfTbrfbq49NjEUbpgtnzT+/kCw1s2rt4mq1WqlUIsSZmZkUYLXVaq2sHDp4T6mQNOpw1vwrLeglhS1br603GrV6HZJkZmaG4zhcj347Z81SsX/W/L1+kaKxXVe8yF2PTmk6OztL1erqykqr1Tq4785i1G/U5Rzkx35W3HrB9fV6vdZomCSZnZ3FSqXTbrfb7dbS7rE6TU9GZ82/sJg1W1yfuKxarVaq1ShNZ2dnzdhYp9PpdjqS7N88Xd6yqXzW/IeOdA8vdLGwveyuR19dxHe8/e1JpQqjeIcD0bRWZmZm0uqo+GF5eWZmhhuNEfHbo0dnZmZwYmIU75QgYnLkyMzMjJmYGNEDFnZpaXZ2trBp04jkl6Wl2dlZMzU1Iv3Tysrs7CyMj49qfFtHo6RSfdX735eWovPOH/eyL/7Gb9hG49Kf+Rkbn//HyEzKD//Jn8DEBL/whSN564wBvvwVMz394LZtZhTWCXDpnscLExN/g1gYAX8C8FoRM73h4R07RiT/lQcOwNFFftGLRqR/+pd/sY3G5bfcMiL7eeDP/ygCkbQUpeXKCL5Bx63zbUxcq51/+tXVfPcMjjXO/xM6zRUQBmYDYCbOPz8srbgCewGgMCJ+AJBRyu8vYR2d/gV4lPYjoq9EKp7RUAdQqAMoFOoACsUzECcr/kiWcb+PcYxxvP6hVhGRJBFrqVQKR0bOcJWj/Mr/ZPOf8B9stzv50h+85jN/tf0tb+F255hCsjuBfslv/ubVn/qL4vbtfOZPPSu/8j8V+I8fAcTaxnXXXfe3X0xWlqdf+cptt7zpjuc829RqmN/VBPDChx82tbpYu/V1P/GVC7dnzebp+7HyK/9ThJ9O9AHTr3hl2mpKltlOp3zhjuffdbdttcQ9eCLywoceplKZ+33JsrSzuvE1rxG/xfl0v4DyK/9Tgf/4DoBErX+7x9Tr4E6Op2n5oovcZ4DITQ89TJWKWOscLqrUDn/mM2jOoNuo/Mr/FOE/gQNE0ZHP/+2+j/1BVK/7a4bStLxz53O/8tXnfevbplp17CIST04+9Ev/LWu1zmgdo/zK/xThP2EVKB5vPPhf/isSbXvTz2WtlvuM+jXXgMgw+yNvf9ve3/8f0Zl3wpVf+Z8K/CcrgxYmGg+85ReAaNsbb8lWV93lXRBO8seTk9995zue+OjvRme7D0T5lf9J549O/Rn/+a3S72+95WclTfO/N+Xy7l/6pSd+//fjc9sFpfzK/+TynyLxEuaoWpp8+ctlbSWVk2TT616Hg8v2zxLKr/xPLv/JHEBEJE1veuDB4qbN/tr5oTpU/dnP/r47vpE1W2f9HZRf+Z90fjoJO/eTmx54MBofz1cVVCphHPt1d5LUrrzixm/ckTVbZye98iv/k85PJ2K3K62bHnwwmpwcrKnHJx5973sOffovTLU69BlX3vj1f03c2YszkV75lf+pwH+CrRBZtu1NP1vcssW224F9fPY33//4Rz4qAqZc3vQT/9H9EyfJ2A03bLz5lUu3347R6Z6rVH7lf4rwnzAFiqenwz1aEo+Pz37gA7PvvzUebxQmGve+4WePfPb/OD8DAM6ywuYtZ5rJKb/yPxX4T9AJNubQpz4lWWaq1eLk9GO33jr73vfH4VxpYaJx7+vfePCTnyxMTkf1era0dPBP/+T03Vf5lf+pw4+/+J73vvy3P7j+ULyISNLf8OrXtO79t+6jj5pq9ZgfyFZXK5deWr1018I//L2pHOdMfdzt/MPb3rVr164Lf+6W9Yeaz52fVle/+7E/2nXZruxF37/+UPa580tzRf7xn3ft2rX7ggvWHyo/d367tHLxY4/t2rnzNsTCCPiTpZVXiTyyZ89jF188Ivkv27fvkUcewf/wgyPSf3T7/3tk9yOXvvXnR2Q/D//Rx0/odogIheL8bV9CovXsABDVav0DB/r79lG5fBareOVX/qcCf3Tyzzh5YML8YduzgvIr/5POr2eCFc9oqAMo1AEUCnUAheIZiAgQ414G0Dnv1HEvE0RBNCnD6up55zcpu+cUgUGaK+dfN+yeDyAL4Z7N8woL/tn4ZDT8SVgJjlB+IkAapf4RaJT2g6jXo5+MX69HP7n8T4Pr0TUGKhQKhUKhUCgUCoVCoVAoFAqFQqFQKBQKhUKhUCgUCoVCoVAoFAqFQqFQKBQKhUKhUCgUCoVCoVAoFAqFQqFQKBQKhUKhUCgUCoVCoVAoFAqFQqFQKBQKhUKhUCgUCoVCoVAoFAqFQqFQKBQKhUKhUCgUCoVCoVAoFAqFQqFQKBQKhUKhUCgUCoVCoVAoFAqFQqFQKBQKhUKhUCgUCoVCoVAoFAqF4umA/w9OMuatcdiDygAAAABJRU5ErkJggg==]
        255
        0
        180) [texture])

(define level                as '()                         [level])
(define level-width          as 5                           [number of slots per side])
(define m                    as (- level-width 1)           [max coordinate] )
(define level-length         as (* level-width level-width) [number of slots])
(define level-current-number as nil                         [current level number])

(define origoX                     as 320                              [X-coordinate of center for drawing])
(define origoY                     as 240                              [Y-coordinate of center for drawing])
(define shakeStepsLeft             as 0                                [Times to shake the level])
(define shakeX                     as 0                                [Shake x-coordinate])

(define shake as (fn ()
    (= shakeStepsLeft 20))
  [shake the level] '() howto-no)

(define coordinates-to-index as (fn (x y)
    (+ x (* y level-width)))
  [kkk] '(x [x] y [y]) howto-ok)

(define index-to-x as (fn (index)
    (mod index level-width))
  [kkk] '(index [index]) howto-ok)

(define index-to-y as (fn (index)
    (/ index level-width))
  [kkk] '(index [index]) howto-ok)



(define texture-index-to-x as (fn (index)
        (return (mod (* index 32) 256))) [index-to-x] '(index [index]) howto-ok)

(define texture-index-to-y as (fn (index)
        (return (to-integer (/ (* index 32) 256)))) [index-to-x] '(index [index]) howto-ok)

(define texture-index-to-vec as (fn (index)
        (define result as (vector) [result])
        (+= result (index-to-x index))
        (+= result (index-to-y index))
        (+= result 32)
        (+= result 32)
        (+= result 0)
        (+= result 0)
        (+= result 32)
        (+= result 32)
        (+= result 0.2)
        (return result)
        )
        [Index to texture coordinates] '(index [index]) howto-ok)

(define create-new-anim as (fn (name x y slot index ...)
        (define f as (vector 'animation-add
                              name
                              '(ln@ slot 'sx 'hash)
                              '(ln@ slot 'sy 'hash)
                              '(ln@ slot 'sw 'hash)
                              '(ln@ slot 'sh 'hash)
                              '(ln@ slot 'tx 'hash)
                              '(ln@ slot 'ty 'hash)
                              '(ln@ slot 'tw 'hash)
                              '(ln@ slot 'th 'hash)
                              []
                              0
                              ) [to be evaluated])

        (for i in index
             (+= f (texture-index-to-vec i)))

        (eval f))
        [create new animation from frame indices] '(name [id] x [x] y [y] slot [slot] index [index] ... [varargs]) howto-no)


(define new-anim as (fn (name type x y)
    (animation-remove name)
    (define slot as (level-get-slot x y) [slot at x y])

    (select
        (== type [lock-full-opened]) (create-new-anim name x y slot  16  15 14 13 12 11 10  9  8)
        (== type [lock-half-closed]) (create-new-anim name x y slot   8   9 10 11 12 13 14 15 16)
        (== type [lock-full-closed]) (create-new-anim name x y slot  16  17 18 19 20 21 22 23 24)
        (== type [lock-half-opened]) (create-new-anim name x y slot  24  23 22 21 20 19 18 17 16)
        (== type [slot-covered-on])  (create-new-anim name x y slot  32  33 34 35 36 37 38 39)
        (== type [slot-covered-off]) (create-new-anim name x y slot  39  38 37 36 35 34 33 32)
        (== type [slot-missing])     (create-new-anim name x y slot  40  41 42 43 44 45 46 47)
        (== type [slot-off])         (create-new-anim name x y slot  7    6  5  4  3  2  1  0)
        (== type [slot-on])          (create-new-anim name x y slot  0    1  2  3  4  5  6  7)
                                                    ))
    [new animation] '(name [name] type [type] x [x] y [y]) howto-no)

(define make-slot as (fn (index type)
    (define x    as (index-to-x index)              [x])
    (define y    as (to-integer (index-to-y index)) [y])
    (define name as (string-format [{}{}] x y)      [name])

    (new-anim name type x y)

    (hash-map
         'id   name
         'x    x
         'y    y
         'type type
         'sx   0
         'sy   0
         'sw   0
         'sh   0
         'tx   0
         'ty   0
         'tw   0
         'th   0))
  [make slot of the given type] '(index [index] type [type]) howto-no)

(define slot-toggle-at as (fn (x y)
    (slot-toggle (level-get-slot x y)))
  [-] '(x [x] y [y]) howto-no)

(define slot-toggle as (fn (slot)
    (define id   as (find slot 'id)   [id])
    (define type as (find slot 'type) [type])
    (define x    as (find slot 'x)    [type])
    (define y    as (find slot 'y)    [type])

    (if (== type [slot-off])
        (do
            (= slot 'type [slot-on])
            (animation-entity-remove id)
            (new-anim id [slot-on] x y)
            (return nil)))

    (if (== type [slot-on])
        (do
            (= slot 'type [slot-off])
            (animation-entity-remove id)
            (new-anim id [slot-off] x y)
            (return nil)))

    (if (== type [slot-covered-on])
        (do
            (= slot 'type [slot-covered-off])
            (animation-entity-remove id)
            (new-anim id [slot-covered-off] x y)
            (return nil)))

    (if (== type [slot-covered-off])
        (do
            (= slot 'type [slot-covered-on])
            (animation-entity-remove id)
            (new-anim id [slot-covered-on] x y)
            (return nil)))

    (if (== type [lock-full-opened])
        (do
            (= slot 'type [lock-full-closed])
            (animation-entity-remove id)
            (new-anim id [lock-full-closed] x y)
            (return nil)))

    (if (== type [lock-half-closed])
        (do
            (= slot 'type [lock-full-closed])
            (animation-entity-remove id)
            (new-anim id [lock-full-closed] x y)
            (return nil)))

    (if (== type [lock-half-opened])
        (do
            (= slot 'type [lock-full-opened])
            (animation-entity-remove id)
            (new-anim id [lock-full-opened] x y)
            (return nil)))

    (if (== type [lock-full-closed])
        (do
            (= slot 'type [lock-half-opened])
            (animation-entity-remove id)
            (new-anim id [lock-half-opened] x y)
            (return nil))))
  [-] '(slot [slot]) howto-no)

(define slot-toggle-neighbors as (fn (slot)
    (define x as (find slot 'x) [type])
    (define y as (find slot 'y) [type])

    ; Corners
    (if (and (== x 0) (== y 0)) (do (slot-toggle-at (+ x 1) y) (slot-toggle-at x (+ y 1)) (return nil)))
    (if (and (== x m) (== y 0)) (do (slot-toggle-at (- x 1) y) (slot-toggle-at x (+ y 1)) (return nil)))
    (if (and (== x 0) (== y m)) (do (slot-toggle-at (+ x 1) y) (slot-toggle-at x (- y 1)) (return nil)))
    (if (and (== x m) (== y m)) (do (slot-toggle-at (- x 1) y) (slot-toggle-at x (- y 1)) (return nil)))

    ; Left side
    (if (== x 0) (do (slot-toggle-at (+ x 1) y) (slot-toggle-at x (- y 1)) (slot-toggle-at x (+ y 1)) (return nil)))

    ; Right side
    (if (== x m) (do (slot-toggle-at (- x 1) y) (slot-toggle-at x (- y 1)) (slot-toggle-at x (+ y 1)) (return nil)))

    ; Top side
    (if (== y 0) (do (slot-toggle-at x (+ y 1)) (slot-toggle-at (- x 1) y) (slot-toggle-at (+ x 1) y) (return nil)))

    ; Bottom side
    (if (== y m) (do (slot-toggle-at x (- y 1)) (slot-toggle-at (- x 1) y) (slot-toggle-at (+ x 1) y) (return nil)))

    ; Somewhere "middle"; not corners and not borders
    (slot-toggle-at x (- y 1))
    (slot-toggle-at x (+ y 1))
    (slot-toggle-at (+ x 1) y)
    (slot-toggle-at (- x 1) y))
  [-] '(slot [slot]) howto-no)

(define slot-is-passed as (fn (slot)
    (define type as (find slot 'type) [type])

    (if (== type [slot-off])         (return true ))
    (if (== type [slot-covered-off]) (return true ))
    (if (== type [lock-full-opened]) (return true ))
    (if (== type [slot-missing])     (return true ))

    (return false))
  [is this slot in a state allowing level pass] '(slot [slot]) howto-no)

(define slot-on-mouse as (fn (slot x y ox oy)
    (define id  as (find slot 'id) [id])

    (define mx1 as (+ ox (animation-entity-get-x id)) [mx1])
    (define mx2 as (+ mx1 32) [mx2])

    (define my1 as (+ oy (animation-entity-get-y id)) [my1])
    (define my2 as (+ my1 32) [my2])

    ; TODO XXX make if to return errors it encounters
    (if (< x mx1) (return nil))
    (if (> x mx2) (return nil))

    (if (< y my1) (return nil))
    (if (> y my2) (return nil))

    (define type as (find slot 'type) [type])

    (if (== type [slot-off])
        (do
            (slot-toggle slot)
            (slot-toggle-neighbors slot)
            (return nil)))

    (if (== type [slot-on])
        (do
            (slot-toggle slot)
            (slot-toggle-neighbors slot)
            (return nil)))

    (if (== type [slot-covered-on])
        (do
            (return nil)))

    (if (== type [slot-covered-off])
        (do
            (return nil)))

    (if (== type [lock-full-opened])
        (do
            (slot-toggle slot)
            (slot-toggle-neighbors slot)
            (return nil)))

    (if (== type [lock-half-closed])
        (do
            (slot-toggle slot)
            (slot-toggle-neighbors slot)
            (return nil)))

    (if (== type [lock-half-opened])
        (do
            (slot-toggle slot)
            (slot-toggle-neighbors slot)
            (return nil)))

    (if (== type [lock-full-closed])
        (do
            (slot-toggle slot)
            (slot-toggle-neighbors slot)
            (return nil))))
  [slot on mouse] '(slot [slot] x [x] y [y] ox [ox] oy [oy]) howto-no)

(define level-reset-to as (fn (input)
    (animation-entity-remove-all)
    (= level '())
    (> (len input) level-length (abort [level input is too long!]))
    (if (< (len input) level-length) (for i from (len input) to (- level-length 1) (+= input [slot-off])))
    (for i from 0 to (- level-length 1) (+= level (make-slot i (ln@ input i)))))
  [clear level to the given level] '(input [level as vector of strings]) howto-no)

(define level-set-slot as (fn (x y type)
    (= (ln@ level (coordinates-to-index x y)) 'type type))
  [level-set-slot] '(x [x] y [y] type [type]) howto-no)

(define level-get-slot as (fn (x y)
    (ln@ level (coordinates-to-index x y)))
  [level-get-slot] '(x [x] y [y]) howto-no)

(define level-1 as (fn ()
    (level-reset-to '(
        [slot-on]  [slot-on]  [slot-off] [slot-off] [slot-off]
        [slot-on]))
    (= level-current-number 1))
  [level-1] '() howto-no)

(define level-2 as (fn ()
    (level-reset-to '(
        [slot-off]  [slot-off]  [slot-off] [slot-off] [slot-off]
        [slot-off]  [slot-off]  [slot-off] [slot-off] [slot-off]
        [slot-off]  [slot-off]  [lock-full-closed]))
    (= level-current-number 2))
  [level-2] '() howto-no)

(define level-3 as (fn ()
    (level-reset-to '(
        [slot-missing] [slot-off] [slot-off] [slot-off] [slot-missing]
        [slot-off] [slot-off] [slot-off] [slot-off] [slot-off]
        [slot-off] [slot-off] [slot-covered-on] [slot-off] [slot-off]
        [slot-off] [slot-off] [slot-off] [slot-off] [slot-off]
        [slot-missing] [slot-off] [slot-off] [slot-off] [slot-missing]
    ))
    (= level-current-number 3))
  [level-3] '() howto-no)

(define level-4 as (fn ()
    (level-reset-to '(
        [slot-off] [slot-off] [slot-off] [slot-off] [slot-off]
        [slot-off] [slot-off] [slot-off] [slot-off] [slot-off]
        [slot-off] [slot-off] [slot-on]
    ))
    (= level-current-number 4))
  [level-4] '() howto-no)

(define level-5 as (fn ()
    (level-reset-to '([slot-on]))
    (= level-current-number 5))
  [level-5] '() howto-no)

(define level-restart as (fn ()
    ; implement 'select' and use it here. these if's
    ; without else will not work without the temp variable
    (define lnum as level-current-number [level number before change])

    (if (== 1 lnum) (level-1))
    (if (== 2 lnum) (level-2))
    (if (== 3 lnum) (level-3))
    (if (== 4 lnum) (level-4))
    (if (== 5 lnum) (level-5))

    (shake))
  [restart level] '() howto-no)

(define level-next as (fn ()
    ; implement 'select' and use it here. these if's
    ; without else will not work without the temp variable
    (define lnum as level-current-number [level number before change])

    (if (== 1 lnum) (level-2))
    (if (== 2 lnum) (level-3))
    (if (== 3 lnum) (level-4))
    (if (== 4 lnum) (level-5))
    (if (== 5 lnum) (level-1))

    )
  [next level] '() howto-no)

(define current-state as [game] [current-state])

(define printlevel as false [printlevel])

(define check-possible-level-pass as (fn ()
    (for i in level (if (== false (slot-is-passed i)) (return nil)))
    ; Level is passed
    (= current-state [tweenOut])
    (tween-level-out))
  [-] '() howto-no)

(define on-mouse-button-down as (fn (x y ox oy)
    (for i in level (slot-on-mouse i x y ox oy))
    (check-possible-level-pass) nil)
  [----] '(x [x] y [y] ox [ox] oy [oy]) howto-no)

(define state-update-game as (fn (dt input input-x input-y origo-x origo-y)
    (if (== input [restart])           (do (= input []) (level-restart)))
    (if (== input [action 1])          (do (= input []) (= printlevel (not printlevel))))
    (if (== input [down]) (do (= input []) (on-mouse-button-down input-x input-y origo-x origo-y)))

    true)
  [state-update]
  '(dt [delta time]
    input   [string 'mouse-button-down', 'restart' or 'action 1' ]
    input-x [x coord of mouse]
    input-y [y coord of mouse]
    origo-x [origo x]
    origo-y [origo y])
  howto-no)

(define state-update-tween-out as (fn (dt input input-x input-y origo-x origo-y) true)
  [state-update]
  '(dt [delta time]
    input   [string 'mouse-button-down', 'restart' or 'action 1' ]
    input-x [x coord of mouse]
    input-y [y coord of mouse]
    origo-x [origo-x]
    origo-y [origo-y])
  howto-no)

(define state-update as (fn (dt input input-x input-y origo-x origo-y)

    (define tmpState as current-state [tmpState])

    (if (== [game]     tmpState) (state-update-game      dt input input-x input-y origo-x origo-y))
    (if (== [tweenOut] tmpState) (state-update-tween-out dt input input-x input-y origo-x origo-y))

    (if printlevel (level-print))

    true)
  [state-update]
  '(dt [delta time]
    input   [string 'mouse-button-down', 'restart' or 'action 1' ]
    input-x [x coord of mouse]
    input-y [y coord of mouse]
    origo-x [origo-x]
    origo-y [origo-y])
  howto-no)

(define state-on-tween-out-done as (fn ()
    ;(message-show 0)
    (level-next))
  [---] '() howto-no)

(define state-on-tween-in-done as (fn ()
    (= current-state [game]))
  [---] '() howto-no)

; Game starts here
(level-1)



(define state-render as (fn (dt)
    (sdl2-RenderClear renderer)
    (select
        (== [ingame-tween-in]  current-state) (ingame-state-tween-in-render  dt)
        (== [ingame]           current-state) (ingame-state-render           dt)
        (== [ingame-tween-out] current-state) (ingame-state-tween-out-render dt)
        (== [ingame-shake]     current-state) (ingame-state-shake-render     dt))
    (sdl2-RenderPresent renderer))
  [state-render]
  '(dt [delta time]) howto-no)




(define running             as true                [running])
(define targetFPS           as 20                  [target FPS])
(define targetFrameDuration as (/ 1.0 targetFPS)   [time for a frame to last])

(define dt as targetFrameDuration [delta time])

(while running
       (sdl2-TimerReset)

       (define event as (sdl2-PollEvent) [event from sdl2])
       (define type  as nil              [type of event])
       (if (and (!= event nil) (> (len event) 0)) (= type (ln@ event 0)))
       (define input as [] [input event]) ; TODO

       (select (== type 'QUIT)          (= running false)
               (== type 'JOYBUTTONDOWN) (println [Joystick button {} pressed] (ln@ event 1))
               (== type 'JOYAXIS)       (println [Joystick axis   {}]         (ln@ event 1))
               (== type 'KEYDOWN)       (do
                                          (if (== (ln@ event 1) [UP])    (= input [up]))
                                          (if (== (ln@ event 1) [DOWN])  (= input [down]))
                                          (if (== (ln@ event 1) [LEFT])  (= input [left]))
                                          (if (== (ln@ event 1) [RIGHT]) (= input [right]))
                                          (if (== (ln@ event 1) [j])     (= input [down]))
                                          (if (== (ln@ event 1) [k])     (= input [up]))
                                          (if (== (ln@ event 1) [h])     (= input [left]))
                                          (if (== (ln@ event 1) [l])     (= input [right]))
                                          ))
       (easing-update    dt)
       (state-update     dt input)
       (animation-update dt)
       (state-render     dt)

       (if (> targetFrameDuration dt)
         (do
           (define delayInSeconds as (- targetFrameDuration dt) [time to sleep])
           (if (> delayInSeconds 0)
             (sdl2-Delay delayInSeconds))))

       (sdl2-TimerUpdate)
       (= dt (sdl2-TimerGetSeconds)))

(sdl2-Quit)








;;; Here are some helper functions for debugging purposes.
;;; Can be removed later

(define level-print-row as (fn (y)
    (for x from 0 to (- level-width 1) (level-print-slot x y))
    (println []))
  [lll] '(y [y]) howto-no)

(define level-print as (fn ()
    (println [-------------------------------------------------])
    (for y from 0 to (- level-width 1) (level-print-row y))
    (println [-------------------------------------------------]))
  [lll] '() howto-no)

(define level-print-slot as (fn (x y)
    (define name as (find (level-get-slot x y) 'type) [name])

    (define str as
        (string-format [{} ({},{})] name (find (level-get-slot x y) 'x) (find (level-get-slot x y) 'y)) [str])

    (print str)

    (define spaces as (- 18 (len str)) [ll])
    (for i from 0 to spaces (print [ ])))
  [kk] '(x [x] y [y]) howto-no)

