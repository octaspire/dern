(require 'dern_ncurses)
(require 'dern_socket)

(define win as (ncurses-initscr) [win])
(ncurses-set-keypad win true)
(ncurses-set-cbreak true)
(ncurses-set-nl true)
(ncurses-halfdelay {D+1})
(ncurses-set-echo false)

(define running           as true                             [should this program be running])
(define current-channel   as nil                              [currently joined channel])
(define current-username  as []                               [username])
(define current-realname  as []                               [realname])
(define hint              as []                               [hint])
(define rebuild-statusbar as true                             [should statusbar be (re)build])
(define statusbar         as []                               [shows username, realname and hint])
(define socket            as nil                              [socket])
(define num-rows-and-cols as (ncurses-getmaxyx win)           [number of rows and cols on screen] )
(define maxlines          as (- (cp@ num-rows-and-cols {D+0}) {D+3})  [maxlines] )
(define lines             as (queue-with-max-length maxlines) [messages] )
(define title             as []                               [title])
(define debug             as false                            [is debug mode on])
(define user-input-buffer as []                               [stores line of user input])
(define redraw-required   as true                             [is (re)draw required or not])

(define PAIR-BORDER          as {D+1} [PAIR-BORDER])
(define PAIR-PROMPT          as {D+2} [PAIR-PROMPT])
(define PAIR-INPUT           as {D+3} [PAIR-INPUT])
(define PAIR-OTHER           as {D+4} [PAIR-OTHER])
(define PAIR-DEBUG           as {D+5} [PAIR-DEBUG])
(define PAIR-USER            as {D+6} [PAIR-USER])
(define PAIR-MESSAGE         as {D+7} [PAIR-MESSAGE])
(define PAIR-PRIVATE-MESSAGE as {D+8} [PAIR-PRIVATE-MESSAGE])

(if (ncurses-has-colors)
    (do
      (ncurses-start-color)
      (ncurses-init-pair PAIR-BORDER          'WHITE  'YELLOW)
      (ncurses-init-pair PAIR-PROMPT          'YELLOW 'BLACK)
      (ncurses-init-pair PAIR-INPUT           'WHITE  'BLACK)
      (ncurses-init-pair PAIR-OTHER           'RED    'BLACK)
      (ncurses-init-pair PAIR-DEBUG           'BLUE   'BLACK)
      (ncurses-init-pair PAIR-USER            'WHITE  'BLACK)
      (ncurses-init-pair PAIR-MESSAGE         'GREEN  'BLACK)
      (ncurses-init-pair PAIR-PRIVATE-MESSAGE 'YELLOW 'BLACK)
      ))

(define set-current-channel as (fn (channel)
    (= current-channel channel)
    (if (== current-channel nil) (set-title [-]) (set-title current-channel)))
  [set current channel] '(channel [channel]) howto-no)

(define leave-current-channel as (fn ()
    (define message as (string-format [PART {}|newline|] current-channel) [message])
    (socket-send socket message)
    (set-current-channel nil))
  [leave the current channel] '() howto-no)

(define substr as (fn (str startIndex)
    (define result as [] [result])

    (if (>= startIndex (len str)) (return result))

    (for i from startIndex to (- (len str) {D+1})
         (+= result (cp@ str i)))
    result)
  [substr] '(str [str] startIndex [startIndex]) howto-no)

(define handle-nick as (fn (line)
    (= current-username (substr line {D+6}))
    (send-user-data))
  [handle /nick] '(line [line of text starting with /nick]) howto-no)

(define handle-join as (fn (line)
    (if (== current-username [])
      (do (set-hint [Please set a nick first by using /nick or /user]) (return)))

    (define channel as (substr line {D+6}) [channel])

    (define message as (string-format [JOIN {}|newline|] channel) [message])
    (socket-send socket message)

    (set-current-channel channel))
  [handle /join] '(line [line of text starting with /join]) howto-no)

(define handle-msg as (fn (line)
    (define restOfLine as (substr line {D+5}) [line without /msg])

    (define tokens as (split restOfLine | |) [line split by space])

    (if (< (len tokens) {D+2}) (do (set-hint [/msg expect target name and message]) (return)))

    (define target as (ln@ tokens {D+0}) [target] )
    (define msgtxt as [] [msgtxt])

    (for i from {D+1} to (- (len tokens) {D+1})
         (+= msgtxt (ln@ tokens i))
         (if (< i (- (len tokens) {D+1})) (+= msgtxt | |)))

    (define message as (string-format [PRIVMSG {} :{}|newline|] target msgtxt) [message])
    (socket-send socket message)
    (push-text-to-lines 'PRIVATE-MESSAGE (string-format [<---------------You---------------> {}] msgtxt)))
  [handle /msg] '(line [line of text starting with /msg]) howto-no)

(define set-hint as (fn (h)
    (= hint h)
    (= rebuild-statusbar true))
  [Set the current hint] '(h [the new hint]) howto-no)

(define build-statusbar as (fn ()
    (= redraw-required true)
    (= rebuild-statusbar false)
    (= statusbar (string-format [--/{}/{}/{}/--] current-username current-realname hint))
    (for i from (len statusbar) to (- (cp@ num-rows-and-cols {D+1}) {D+1}) (+= statusbar |-|)))
  [Build string for the status bar from the username, realname and hint] '() howto-no)

(define handle-connect as (fn (line)
    (if (== current-username [])
      (do (set-hint [Please set a nick first by using /nick or nick and a real name using /user]) (return)))

    (define restOfLine as (substr line {D+9})        [line without /connect])
    (define tokens     as (split restOfLine | |)     [line split by space] )
    (define address    as [localhost]                [address])
    (define portnum    as {D+6667}                   [portnum])

    (if (>= (len tokens) {D+1}) (= address (ln@ tokens {D+0})))
    (if (>= (len tokens) {D+2}) (= portnum (ln@ tokens {D+1})))

    (= portnum (to-integer portnum))

    ; Sockets cannot be copied with '='
    (define socket as (socket-new-ipv4-stream-socket address portnum) [socket] in (env-global))

    (if (string? socket)
      (do
        (set-hint socket)
        (= socket nil)
        (return)))

    (read-socket)
    (send-user-data)
    (read-socket)

    (set-hint (string-format [connected to {} at port {}] address portnum)))
  [handle /connect] '(line [line of text starting with /connect]) howto-no)

(define send-user-data as (fn ()
    (if (== socket nil) (return))

    (socket-send socket (string-format [NICK {}|newline|] current-username))
    (socket-send socket (string-format [USER {} 8 * :{}|newline|] current-username current-realname)))
  [send nick and possible real name to server] '() howto-no)

(define handle-user as (fn (line)
    (define restOfLine as (substr line {D+6}) [line without /user])

    (define tokens as (split restOfLine | |) [line split by space])

    (= current-username (cp@ tokens {D+0}))
    (= current-realname [])

    (= rebuild-statusbar true)

    (if (> (len tokens) {D+1})
        (for i from {D+1} to (- (len tokens) {D+1})
             (+= current-realname (cp@ tokens i))
             (if (< i (- (len tokens) {D+1})) (+= current-realname | |))))

    (send-user-data))
  [handle /user] '(line [line of text starting with /user]) howto-no)

(define handle-command as (fn (line)
    (if (starts-with? line [/quit])    (do (= running false)       (return)))
    (if (starts-with? line [/debug])   (do (= debug (not debug))   (return)))
    (if (starts-with? line [/connect]) (do (handle-connect line)   (return)))

    (if (starts-with? line [/user])    (do (handle-user    line)   (return)))
    (if (starts-with? line [/nick])    (do (handle-nick    line)   (return)))

    (if (== socket nil) (do (set-hint [You must connect first])    (return)))

    (if (starts-with? line [/join])    (do (handle-join    line)   (return)))
    (if (starts-with? line [/msg])     (do (handle-msg     line)   (return)))
    (if (starts-with? line [/part])    (do (leave-current-channel) (return)))

    (set-hint (string-format [Unknown command "{}"] line)))
  [handle command, for example /join] '(line [line of text starting with /]) howto-no)

(define handle-message as (fn (line)
    (if (== nil current-channel)
      (do
        (set-hint [You must enter a channel first])
        (return)))

    (define message as (string-format [PRIVMSG {} :{}|newline|] current-channel line) [message])
    (socket-send socket message)
    (push-text-to-lines 'USER (string-format [<---------------You---------------> {}] line)))
  [handle a line starting without /] '(line [line of text starting with /]) howto-no)

(define show-title as (fn (t)
    (ncurses-attron 'BOLD)
    (if (ncurses-has-colors) (ncurses-attron PAIR-BORDER))
    (ncurses-print win {D+0} {D+0} t)
    (if (ncurses-has-colors) (ncurses-attroff PAIR-BORDER))
    (ncurses-attroff 'BOLD))
  [show title bar] '(t [title message]) howto-no)

(define show-statusbar as (fn ()
    (ncurses-attron 'BOLD)
    (if (ncurses-has-colors) (ncurses-attron PAIR-BORDER))
    (ncurses-print win (- (cp@ num-rows-and-cols {D+0}) {D+2}) {D+0} statusbar)
    (if (ncurses-has-colors) (ncurses-attroff PAIR-BORDER))
    (ncurses-attroff 'BOLD))
  [draw statusbar into display] '() howto-no)

(define set-title as (fn (m)
    (= title (string-format [--{}] m))
    (for i from (len title) to (- (cp@ num-rows-and-cols {D+1}) {D+1}) (+= title |-|)))
  [show title message] '(m [title message]) howto-no)

(define show-input-line as (fn ()
    (ncurses-attron 'BOLD)
    (ncurses-attron PAIR-PROMPT)
    (ncurses-print win (- (cp@ num-rows-and-cols {D+0}) {D+1}) {D+0} (string-format [>{}] user-input-buffer))
    (ncurses-attroff PAIR-PROMPT)
    (ncurses-attroff 'BOLD)
    (ncurses-attroff PAIR-INPUT)
    (ncurses-move win (- (cp@ num-rows-and-cols {D+0}) {D+1}) (+ (len user-input-buffer) {D+1})))
    [show user input] '() howto-no)

(define read-and-handle-input as (fn ()
    (define char as (ncurses-getch) [octet of input from the user])

    (if (== 'ERR char) (return))

    (= redraw-required true)

    (if (== 'KEY_ENTER char)
          (do
            (handle-input-line)
            (= user-input-buffer [])
            (show-input-line)
            (return)))

    (if (and (or (== 'KEY_BACKSPACE char) (== 'KEY_DC char)) (> (len user-input-buffer) {D+0}))
          (do
            (-- user-input-buffer)
            (show-input-line)
            (return)))

    (if (character? char)
        (do
          (+= user-input-buffer char)
          (show-input-line)
          (return))))
    [read input and handle it if needed] '() howto-no)

(define handle-input-line as (fn ()
    (if (== {D+0} (len user-input-buffer)) (return))

    (define first-char as (cp@ user-input-buffer {D+0}) [first character of user input])

    (if (== |/| first-char)
      (handle-command user-input-buffer)
      (handle-message user-input-buffer)))
  [get user input and handle it] '() howto-no)

(define handle-ping as (fn (message)
    (= message {D+1} |O|)
    ;(+= lines message) ; TODO remove
    (socket-send socket message))
  [handle PING message from the IRC server] '(message [message]) howto-no)

(define push-text-to-lines as (fn (type text)
    (define line as [] [tmp line])

    (if (== {D+0} (len text)) (return))

    (for i from {D+0} to (- (len text) {D+1})
         (define c as (cp@ text i) [c])
         (if (== c |newline|)
            (do (+= lines (vector type line))
                (=  line []))
            (+= line c))
         (if (>= (len line) (cp@ num-rows-and-cols {D+1}))
           (do
             (+= lines (vector type line))
             (= line []))))

    (if (> (len line) {D+0})
        (do (+= lines (vector type line)))))
  [push text to lines] '(type [type] text [text]) howto-no)

(define extract-only-message-from-input as (fn (message)

    (define result as [] [result])
    (define numsyms as {D+0} [number of syms])

    (for i from {D+0} to (- (len message) {D+1})
        (define c as (cp@ message i) [c])
        (if (>= numsyms {D+2})
          (+= result c)
          (if (== c |:|) (++ numsyms))))

    (if (>= numsyms {D+2}) result message))
  [get only the actual message] '(message [message]) howto-no)

(define read-socket as (fn ()
    (if (== socket nil) (return))

    (define input-from-socket as (socket-receive socket false) [possible input from socket] )

    (if (== nil input-from-socket) (return))

    (= redraw-required true)

    (if debug (push-text-to-lines 'DEBUG input-from-socket))

    (define first-char as (cp@ input-from-socket {D+0}) [first character of user input])

    (if (== |P| first-char)
        (return (handle-ping input-from-socket)))

    (define tokens as (split input-from-socket | |) [line split by space])

    (define command as [] [command])

    (if (>= (len tokens) {D+2}) (= command (ln@ tokens {D+1})))

    (if (== command [PRIVMSG])
      (do
        (define receiver as [] [channel or user])
        (define sender   as [] [message is from])

        (if (>= (len tokens) {D+1}) (= sender (substr (ln@ tokens {D+0}) {D+1})))
        (if (>= (len tokens) {D+3}) (= receiver (ln@ tokens {D+2})))

        (if (> (len sender) {D+32})
          (do
            (for i from {D+0} to {D+3} (-- sender))
            (+= sender [...])))

        ; TODO XXX fix crash on (++ sender | |)
        (if (< (len sender) {D+32})
            (for i from (len sender) to {D+32} (+= sender |-|)))

        (define msgToShow as
          (string-format [<{}> {}] sender (extract-only-message-from-input input-from-socket)) [msgToShow])

        (push-text-to-lines (if (== receiver current-channel) 'MESSAGE 'PRIVATE-MESSAGE) msgToShow)

        (return)))

    (push-text-to-lines 'OTHER input-from-socket))
  [read input from socket, if available] '() howto-no)

(define print-lines as (fn ()
    (show-title title)
    (show-statusbar)

    (define row as {D+1} [current row])
    (for line in lines
         (define type as (cp@ line {D+0}) [type])

         (if (== type 'OTHER)           (ncurses-attron PAIR-OTHER))
         (if (== type 'DEBUG)           (ncurses-attron PAIR-DEBUG))
         (if (== type 'USER)            (ncurses-attron PAIR-USER))
         (if (== type 'MESSAGE)         (ncurses-attron PAIR-MESSAGE))

         (if (== type 'PRIVATE-MESSAGE) (do (ncurses-attron PAIR-PRIVATE-MESSAGE)
                                            (ncurses-attron 'BOLD)))

         (ncurses-print win row {D+1} (ln@ line {D+1}))

         (if (== type 'OTHER)           (ncurses-attroff PAIR-OTHER))
         (if (== type 'DEBUG)           (ncurses-attroff PAIR-DEBUG))
         (if (== type 'USER)            (ncurses-attroff PAIR-USER))
         (if (== type 'MESSAGE)         (ncurses-attroff PAIR-MESSAGE))

         (if (== type 'PRIVATE-MESSAGE) (do (ncurses-attroff PAIR-PRIVATE-MESSAGE)
                                            (ncurses-attroff 'BOLD)))

         (++ row))

         (ncurses-refresh)
    )
  [print messages] '() howto-no)

(set-title [-])

(while running
    (read-socket)
    (read-and-handle-input)
    (if rebuild-statusbar (build-statusbar))
    (if redraw-required
      (do
        (ncurses-clear win)
        (print-lines)
        (show-input-line)
        (= redraw-required false))))

(ncurses-endwin)

