(require 'dern_ncurses)
(require 'dern_socket)

(define win as (ncurses-initscr) [win])
(ncurses-set-keypad win true)
(ncurses-set-cbreak true)
(ncurses-set-nl true)
(ncurses-halfdelay 1)
(ncurses-set-echo false)

(define running           as true                             [should this program be running])
(define current-channel   as nil                              [currently joined channel])
(define current-username  as []                               [username])
(define current-realname  as []                               [realname])
(define socket            as nil                              [socket])
(define num-rows-and-cols as (ncurses-getmaxyx win)           [number of rows and cols on screen] )
(define maxlines          as (- (cp@ num-rows-and-cols 0) 3)  [maxlines] )
(define lines             as (queue-with-max-length maxlines) [messages] )
(define hint              as []                               [hint])
(define title             as []                               [title])
(define debug             as false                            [is debug mode on])
(define user-input-buffer as []                               [stores line of user input])

(define PAIR-BORDER          as 1 [PAIR-BORDER])
(define PAIR-PROMPT          as 2 [PAIR-PROMPT])
(define PAIR-INPUT           as 3 [PAIR-INPUT])
(define PAIR-OTHER           as 4 [PAIR-OTHER])
(define PAIR-DEBUG           as 5 [PAIR-DEBUG])
(define PAIR-USER            as 6 [PAIR-USER])
(define PAIR-MESSAGE         as 7 [PAIR-MESSAGE])
(define PAIR-PRIVATE-MESSAGE as 8 [PAIR-PRIVATE-MESSAGE])

(if (ncurses-has-colors)
    (do
      (ncurses-start-color)
      (ncurses-init-pair PAIR-BORDER          'WHITE  'YELLOW)
      (ncurses-init-pair PAIR-PROMPT          'YELLOW 'BLACK)
      (ncurses-init-pair PAIR-INPUT           'WHITE  'BLACK)
      (ncurses-init-pair PAIR-OTHER           'RED    'BLACK)
      (ncurses-init-pair PAIR-DEBUG           'BLUE   'BLACK)
      (ncurses-init-pair PAIR-USER            'WHITE  'BLACK)
      (ncurses-init-pair PAIR-MESSAGE         'GREEN  'BLACK)
      (ncurses-init-pair PAIR-PRIVATE-MESSAGE 'YELLOW 'BLACK)
      ))

(define set-current-channel as (fn (channel)
    (= current-channel channel)
    (if (== current-channel nil) (set-title [-]) (set-title current-channel)))
  [set current channel] '(channel [channel]) howto-no)

(define leave-current-channel as (fn ()
    (define message as (string-format [PART {}|newline|] current-channel) [message])
    (socket-send socket message)
    (set-current-channel nil))
  [leave the current channel] '() howto-no)

(define substr as (fn (str startIndex)
    (define result as [] [result])

    (if (>= startIndex (len str)) (return result))

    (for i from startIndex to (- (len str) 1)
         (+= result (cp@ str i)))
    result)
  [substr] '(str [str] startIndex [startIndex]) howto-no)

(define handle-nick as (fn (line)
    (= current-username (substr line 6))
    (send-user-data))
  [handle /nick] '(line [line of text starting with /nick]) howto-no)

(define handle-join as (fn (line)
    (if (== current-username [])
      (do (set-hint [Please set a nick first by using /nick or /user]) (return)))

    (define channel as (substr line 6) [channel])

    (define message as (string-format [JOIN {}|newline|] channel) [message])
    (socket-send socket message)

    (set-current-channel channel))
  [handle /join] '(line [line of text starting with /join]) howto-no)

(define handle-msg as (fn (line)
    (define restOfLine as (substr line 5) [line without /msg])

    (define tokens as (split restOfLine | |) [line split by space])

    (if (< (len tokens) 2) (do (set-hint [/msg expect target name and message]) (return)))

    (define target as (ln@ tokens 0) [target] )
    (define msgtxt as [] [msgtxt])

    (for i from 1 to (- (len tokens) 1)
         (+= msgtxt (ln@ tokens i))
         (if (< i (- (len tokens) 1)) (+= msgtxt | |)))

    (define message as (string-format [PRIVMSG {} :{}|newline|] target msgtxt) [message])
    (socket-send socket message)
    (push-text-to-lines 'PRIVATE-MESSAGE (string-format [<---------------You---------------> {}] msgtxt)))
  [handle /msg] '(line [line of text starting with /msg]) howto-no)

(define set-hint as (fn (h)
    (= hint [--])
    (+= hint h)
    (for i from (len hint) to (- (cp@ num-rows-and-cols 1) 1) (+= hint |-|)))
  [set-hint] '(h [new hint]) howto-no)

(define handle-connect as (fn (line)
    (if (== current-username [])
      (do (set-hint [Please set a nick first by using /nick or nick and a real name using /user]) (return)))

    (define restOfLine as (substr line 9)        [line without /connect])
    (define tokens     as (split restOfLine | |) [line split by space] )
    (define address    as [localhost]            [address])
    (define portnum    as 6667                   [portnum])

    (if (>= (len tokens) 1) (= address (ln@ tokens 0)))
    (if (>= (len tokens) 2) (= portnum (ln@ tokens 1)))

    (= portnum (to-integer portnum))

    ; Sockets cannot be copied with '='
    (define socket as (socket-new-ipv4-stream-socket address portnum) [socket] in (env-global))

    (if (string? socket)
      (do
        (set-hint socket)
        (= socket nil)
        (return)))

    (read-socket)
    (send-user-data)
    (read-socket)

    (set-hint (string-format [connected to {} at port {}] address portnum)))
  [handle /connect] '(line [line of text starting with /connect]) howto-no)

(define send-user-data as (fn ()
    (if (== socket nil) (return))

    (socket-send socket (string-format [NICK {}|newline|] current-username))
    (socket-send socket (string-format [USER {} 8 * :{}|newline|] current-username current-realname)))
  [send nick and possible real name to server] '() howto-no)

(define handle-user as (fn (line)
    (define restOfLine as (substr line 6) [line without /user])

    (define tokens as (split restOfLine | |) [line split by space])

    (= current-username (cp@ tokens 0))
    (= current-realname [])

    (if (> (len tokens) 1)
        (for i from 1 to (- (len tokens) 1)
             (+= current-realname (cp@ tokens i))
             (if (< i (- (len tokens) 1)) (+= current-realname | |))))

    (send-user-data))
  [handle /user] '(line [line of text starting with /user]) howto-no)

(define handle-command as (fn (line)
    (if (starts-with? line [/quit])    (do (= running false)       (return)))
    (if (starts-with? line [/debug])   (do (= debug (not debug))   (return)))
    (if (starts-with? line [/connect]) (do (handle-connect line)   (return)))

    (if (starts-with? line [/user])    (do (handle-user    line)   (return)))
    (if (starts-with? line [/nick])    (do (handle-nick    line)   (return)))

    (if (== socket nil) (do (set-hint [You must connect first])    (return)))

    (if (starts-with? line [/join])    (do (handle-join    line)   (return)))
    (if (starts-with? line [/msg])     (do (handle-msg     line)   (return)))
    (if (starts-with? line [/part])    (do (leave-current-channel) (return)))

    (set-hint (string-format [Unknown command "{}"] line)))
  [handle command, for example /join] '(line [line of text starting with /]) howto-no)

(define handle-message as (fn (line)
    (if (== nil current-channel)
      (do
        (set-hint [You must enter a channel first])
        (return)))

    (define message as (string-format [PRIVMSG {} :{}|newline|] current-channel line) [message])
    (socket-send socket message)
    (push-text-to-lines 'USER (string-format [<---------------You---------------> {}] line)))
  [handle a line starting without /] '(line [line of text starting with /]) howto-no)

(define show-title as (fn (t)
    (ncurses-attron 'BOLD)
    (if (ncurses-has-colors) (ncurses-attron PAIR-BORDER))
    (ncurses-print win 0 0 t)
    (if (ncurses-has-colors) (ncurses-attroff PAIR-BORDER))
    (ncurses-attroff 'BOLD))
  [show title bar] '(t [title message]) howto-no)

(define show-hint as (fn (h)
    (ncurses-attron 'BOLD)
    (if (ncurses-has-colors) (ncurses-attron PAIR-BORDER))
    (ncurses-print win (- (cp@ num-rows-and-cols 0) 2) 0 h)
    (if (ncurses-has-colors) (ncurses-attroff PAIR-BORDER))
    (ncurses-attroff 'BOLD))
  [show help message] '(h [hint message]) howto-no)

(define show-empty-hint as (fn ()
    (define message as (string-format [/{}/{}/] current-username current-realname) [message])
    (if debug (+= message [--debug]))
    (set-hint message))
  [show empty hint line] '() howto-no)

(define show-empty-title as (fn ()
    (= title [])
    (for i from 1 to (- (cp@  num-rows-and-cols 1) 1) (+= title |-|)))
  [show empty title line] '() howto-no)

(define set-title as (fn (m)
    (= title (string-format [--{}] m))
    (for i from (len title) to (- (cp@ num-rows-and-cols 1) 1) (+= title |-|)))
  [show title message] '(m [title message]) howto-no)

(define show-input-line as (fn ()
    (ncurses-attron 'BOLD)
    (ncurses-attron PAIR-PROMPT)
    (ncurses-print win (- (cp@ num-rows-and-cols 0) 1) 0 (string-format [>{}] user-input-buffer))
    (ncurses-attroff PAIR-PROMPT)
    (ncurses-attroff 'BOLD)
    (ncurses-attroff PAIR-INPUT)
    (ncurses-move win (- (cp@ num-rows-and-cols 0) 1) (+ (len user-input-buffer) 2)))
    [show user input] '() howto-no)

(define read-and-handle-input as (fn ()
    (define char as (ncurses-getch) [octet of input from the user])

    (if (== 'ERR char) (return))

    (if (== 'KEY_ENTER char)
          (do
            (handle-input-line)
            (= user-input-buffer [])
            (show-input-line)
            (return)))

    (if (and (== 'KEY_BACKSPACE char) (> (len user-input-buffer) 0))
          (do
            (-- user-input-buffer)
            (show-input-line)
            (return)))

    (if (character? char)
        (do
          (+= user-input-buffer char)
          (show-input-line)
          (return))))
    [read input and handle it if needed] '() howto-no)

(define handle-input-line as (fn ()
    (if (== 0 (len user-input-buffer)) (do (show-empty-hint) (return)))

    (define first-char as (cp@ user-input-buffer 0) [first character of user input])

    (if (== |/| first-char)
      (handle-command user-input-buffer)
      (handle-message user-input-buffer)))
  [get user input and handle it] '() howto-no)

(define handle-ping as (fn (message)
    (= message 1 |O|)
    ;(+= lines message) ; TODO remove
    (socket-send socket message))
  [handle PING message from the IRC server] '(message [message]) howto-no)

(define push-text-to-lines as (fn (type text)
    (define line as [] [tmp line])

    (if (== 0 (len text)) (return))

    (for i from 0 to (- (len text) 1)
         (define c as (cp@ text i) [c])
         (if (== c |newline|)
            (do (+= lines (vector type line))
                (=  line []))
            (+= line c))
         (if (>= (len line) (cp@ num-rows-and-cols 1))
           (do
             (+= lines (vector type line))
             (= line []))))

    (if (> (len line) 0)
        (do (+= lines (vector type line)))))
  [push text to lines] '(type [type] text [text]) howto-no)

(define extract-only-message-from-input as (fn (message)

    (define result as [] [result])
    (define numsyms as 0 [number of syms])

    (for i from 0 to (- (len message) 1)
        (define c as (cp@ message i) [c])
        (if (>= numsyms 2)
          (+= result c)
          (if (== c |:|) (++ numsyms))))

    (if (>= numsyms 2) result message))
  [get only the actual message] '(message [message]) howto-no)

(define read-socket as (fn ()
    (if (== socket nil) (return))

    (define input-from-socket as (socket-receive socket false) [possible input from socket] )

    (if (== nil input-from-socket) (return))

    (if debug (push-text-to-lines 'DEBUG input-from-socket))

    (define first-char as (cp@ input-from-socket 0) [first character of user input])

    (if (== |P| first-char)
        (return (handle-ping input-from-socket)))

    (define tokens as (split input-from-socket | |) [line split by space])

    (define command as [] [command])

    (if (>= (len tokens) 2) (= command (ln@ tokens 1)))

    (if (== command [PRIVMSG])
      (do
        (define receiver as [] [channel or user])
        (define sender   as [] [message is from])

        (if (>= (len tokens) 1) (= sender (substr (ln@ tokens 0) 1)))
        (if (>= (len tokens) 3) (= receiver (ln@ tokens 2)))

        (if (> (len sender) 32)
          (do
            (for i from 0 to 3 (-- sender))
            (+= sender [...])))

        ; TODO XXX fix crash on (++ sender | |)
        (if (< (len sender) 32)
            (for i from (len sender) to 32 (+= sender |-|)))

        (define msgToShow as
          (string-format [<{}> {}] sender (extract-only-message-from-input input-from-socket)) [msgToShow])

        (push-text-to-lines (if (== receiver current-channel) 'MESSAGE 'PRIVATE-MESSAGE) msgToShow)

        (return)))

    (push-text-to-lines 'OTHER input-from-socket))
  [read input from socket, if available] '() howto-no)

(define print-lines as (fn ()
    (show-title title)
    (show-hint  hint)

    (define row as 1 [current row])
    (for line in lines
         (define type as (cp@ line 0) [type])

         (if (== type 'OTHER)           (ncurses-attron PAIR-OTHER))
         (if (== type 'DEBUG)           (ncurses-attron PAIR-DEBUG))
         (if (== type 'USER)            (ncurses-attron PAIR-USER))
         (if (== type 'MESSAGE)         (ncurses-attron PAIR-MESSAGE))

         (if (== type 'PRIVATE-MESSAGE) (do (ncurses-attron PAIR-PRIVATE-MESSAGE)
                                            (ncurses-attron 'BOLD)))

         (ncurses-print win row 1 (ln@ line 1))

         (if (== type 'OTHER)           (ncurses-attroff PAIR-OTHER))
         (if (== type 'DEBUG)           (ncurses-attroff PAIR-DEBUG))
         (if (== type 'USER)            (ncurses-attroff PAIR-USER))
         (if (== type 'MESSAGE)         (ncurses-attroff PAIR-MESSAGE))

         (if (== type 'PRIVATE-MESSAGE) (do (ncurses-attroff PAIR-PRIVATE-MESSAGE)
                                            (ncurses-attroff 'BOLD)))

         (++ row))

         (ncurses-refresh)
    )
  [print messages] '() howto-no)

(show-empty-hint)
(show-empty-title)

(while running
    (ncurses-move win (- (cp@ num-rows-and-cols 0) 1) (+ (len user-input-buffer) 1))
    (read-socket)
    (read-and-handle-input)
    (ncurses-clear win)
    (show-input-line)
    (print-lines)
    (ncurses-move win (- (cp@ num-rows-and-cols 0) 1) (+ (len user-input-buffer) 1))
    )

(ncurses-endwin)

