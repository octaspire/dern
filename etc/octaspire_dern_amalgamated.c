/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*******************************************************************************

  This file is amalgamated version of the header files of Octaspire Dern.
  It is created automatically by a script.

                            DO NOT EDIT MANUALLY!

  Edit the separate header files and then let the script create this file.

******************************************************************************/
#ifndef OCTASPIRE_DERN_AMALGAMATED_H
#define OCTASPIRE_DERN_AMALGAMATED_H

#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#include <dlfcn.h>
#endif


#ifdef OCTASPIRE_PLAN9_IMPLEMENTATION

#include <u.h>
#include <libc.h>
#include <mp.h>
#include <stdio.h>
#include <ctype.h>

#else

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include <string.h>
#include <inttypes.h>
#include <ctype.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <stdarg.h>
#include <limits.h>
#include <wchar.h>
#include <locale.h>

#endif



#ifdef OCTASPIRE_DERN_AMALGAMATED_UNIT_TEST_IMPLEMENTATION
#define OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION 1
#endif

#ifdef OCTASPIRE_DERN_AMALGAMATED_REPL_IMPLEMENTATION
#define OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION 1
#endif

#ifdef OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION
#define OCTASPIRE_CORE_AMALGAMATED_IMPLEMENTATION 1
#endif


//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../external/octaspire_core/etc/octaspire_core_amalgamated.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*******************************************************************************

  This file is amalgamated version of the header files, implementation files
  and unit tests of Octaspire Core. It is created automatically by a script.

                            DO NOT EDIT MANUALLY!

  Edit the separate .h and .c files in the source distribution and then let
  the script create this file again with the modifications.

******************************************************************************/
#ifndef OCTASPIRE_CORE_AMALGAMATED_H
#define OCTASPIRE_CORE_AMALGAMATED_H


#ifdef OCTASPIRE_PLAN9_IMPLEMENTATION


typedef long               int32_t;
typedef unsigned long      uint32_t;
typedef char               bool;
typedef char               int8_t;
typedef unsigned char      uint8_t;
typedef long               ptrdiff_t;
typedef unsigned long      size_t;
typedef unsigned long long uintmax_t;

#define true 1
#define false 0

#define CHAR_BIT 8
#define INT32_MAX 2147483647
#define UINTMAX_MAX 0xFFFFFFFF
#define va_copy(x,y) (x) = (y)
#define PRId32 "ld"
#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0

void exit(int32_t const status)
{
    exits(status == 0 ? "" : "error");
}

#else



#endif



#define OCTASPIRE_CORE_CONFIG_TEST_RES_PATH ""


#ifdef OCTASPIRE_CORE_AMALGAMATED_UNIT_TEST_IMPLEMENTATION
#define OCTASPIRE_CORE_AMALGAMATED_IMPLEMENTATION 1
#endif
//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../external/jenkins_one_at_a_time.h
//////////////////////////////////////////////////////////////////////////////////////////////////
// Based on public domain code from:
// burtleburtle.net/bob/hash/doobs.html
#ifndef OCTASPIRE_CORE_JENKINS_ONE_AT_A_TIME_H
#define OCTASPIRE_CORE_JENKINS_ONE_AT_A_TIME_H


#ifdef __cplusplus
extern "C"
{
#endif

uint32_t jenkins_one_at_a_time_hash(void const * const data, size_t const lengthInOctets);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../external/jenkins_one_at_a_time.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../build/include/octaspire/core/octaspire_core_config.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_CORE_CONFIG_H
#define OCTASPIRE_CORE_CONFIG_H

#define OCTASPIRE_CORE_CONFIG_VERSION_MAJOR "0"
#define OCTASPIRE_CORE_CONFIG_VERSION_MINOR "55"
#define OCTASPIRE_CORE_CONFIG_VERSION_PATCH "0"

#define OCTASPIRE_CORE_CONFIG_VERSION_STR   "Octaspire Core version 0.55.0"



#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../build/include/octaspire/core/octaspire_core_config.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/core/octaspire_utf8.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_UTF8_H
#define OCTASPIRE_UTF8_H


#ifdef __cplusplus
extern "C" {
#endif

typedef enum octaspire_utf8_decode_status_t
{
    OCTASPIRE_UTF8_DECODE_STATUS_OK = 0,
    OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL,
    OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
    OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
    OCTASPIRE_UTF8_DECODE_STATUS_INPUT_NOT_ENOUGH_OCTETS_AVAILABLE
}
octaspire_utf8_decode_status_t;

typedef enum octaspire_utf8_encode_status_t
{
    OCTASPIRE_UTF8_ENCODE_STATUS_OK = 0,
    OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER
}
octaspire_utf8_encode_status_t;

typedef struct octaspire_utf8_character_t
{
    size_t        numoctets;
    unsigned char octets[4];
    char          padding[4];
}
octaspire_utf8_character_t;

octaspire_utf8_encode_status_t octaspire_utf8_encode_character(
    uint32_t const character,
    octaspire_utf8_character_t *result);

octaspire_utf8_decode_status_t octaspire_utf8_decode_character(
    char const * const text,
    size_t const textLengthInOctets,
    uint32_t *result,
    int *numoctets);

octaspire_utf8_decode_status_t octaspire_utf8_decode_character_from_buffer(
    char const * const buffer,
    size_t const bufferLengthInOctets,
    size_t const currentIndex,
    uint32_t *result,
    int *numoctets);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/core/octaspire_utf8.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/core/octaspire_memory.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_MEMORY_H
#define OCTASPIRE_MEMORY_H


#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*octaspire_memory_allocator_custom_malloc_function_t)(size_t size);
typedef void  (*octaspire_memory_allocator_custom_free_function_t)(void *ptr);
typedef void *(*octaspire_memory_allocator_custom_realloc_function_t)(void *ptr, size_t size);

typedef struct octaspire_memory_allocator_config_t
{
    octaspire_memory_allocator_custom_malloc_function_t  customMallocFunction;
    octaspire_memory_allocator_custom_free_function_t    customFreeFunction;
    octaspire_memory_allocator_custom_realloc_function_t customReallocFunction;
}
octaspire_memory_allocator_config_t;

octaspire_memory_allocator_config_t octaspire_memory_allocator_config_default(void);




typedef struct octaspire_memory_allocator_t octaspire_memory_allocator_t;

octaspire_memory_allocator_t *octaspire_memory_allocator_new(
    octaspire_memory_allocator_config_t const * config);

void octaspire_memory_allocator_release(octaspire_memory_allocator_t *self);

void *octaspire_memory_allocator_malloc(
    octaspire_memory_allocator_t *self,
    size_t const size);

void *octaspire_memory_allocator_realloc(
    octaspire_memory_allocator_t *self,
    void *ptr, size_t const size);

void octaspire_memory_allocator_free(
    octaspire_memory_allocator_t *self,
    void *ptr);

void octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
    octaspire_memory_allocator_t *self,
    size_t const count,
    uint32_t const bitQueue0);

void octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged_when_larger_than_32(
    octaspire_memory_allocator_t *self,
    size_t const count,
    uint32_t const bitQueue0,
    uint32_t const bitQueue1,
    uint32_t const bitQueue2,
    uint32_t const bitQueue3,
    uint32_t const bitQueue4,
    uint32_t const bitQueue5,
    uint32_t const bitQueue6,
    uint32_t const bitQueue7,
    uint32_t const bitQueue8,
    uint32_t const bitQueue9,
    uint32_t const bitQueue10,
    uint32_t const bitQueue11,
    uint32_t const bitQueue12,
    uint32_t const bitQueue13,
    uint32_t const bitQueue14,
    uint32_t const bitQueue15,
    uint32_t const bitQueue16,
    uint32_t const bitQueue17,
    uint32_t const bitQueue18,
    uint32_t const bitQueue19);

size_t octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
    octaspire_memory_allocator_t const * const self);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/core/octaspire_memory.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/core/octaspire_container_vector.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_CONTAINER_VECTOR_H
#define OCTASPIRE_CONTAINER_VECTOR_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct octaspire_container_vector_t octaspire_container_vector_t;

typedef void  (*octaspire_container_vector_element_callback_t)(void *element);

typedef int (*octaspire_container_vector_element_compare_function_t)(void const *a, void const *b);

octaspire_container_vector_t *octaspire_container_vector_new(
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_container_vector_element_callback_t elementReleaseCallback,
    octaspire_memory_allocator_t *allocator);

octaspire_container_vector_t *octaspire_container_vector_new_with_preallocated_elements(
    size_t const elementSize,
    bool const elementIsPointer,
    size_t const numElementsPreAllocated,
    octaspire_container_vector_element_callback_t elementReleaseCallback,
    octaspire_memory_allocator_t *allocator);

octaspire_container_vector_t *octaspire_container_vector_new_shallow_copy(
    octaspire_container_vector_t * other,
    octaspire_memory_allocator_t * allocator);

void octaspire_container_vector_release(octaspire_container_vector_t *self);

// Vector can never be compacted smaller than this limit, if set
void octaspire_container_vector_set_compacting_limit_for_preallocated_elements(
    octaspire_container_vector_t * const self,
    size_t const numPreAllocatedElementsAtLeastPresentAtAnyMoment);

size_t octaspire_container_vector_get_length(
    octaspire_container_vector_t const * const self);

size_t octaspire_container_vector_get_length_in_octets(
    octaspire_container_vector_t const * const self);

bool octaspire_container_vector_is_empty(
    octaspire_container_vector_t const * const self);

bool octaspire_container_vector_remove_element_at(
    octaspire_container_vector_t * const self,
    size_t const index);

void *octaspire_container_vector_get_element_at(
    octaspire_container_vector_t * const self,
    size_t const index);

void const *octaspire_container_vector_get_element_at_const(
    octaspire_container_vector_t const * const self,
    size_t const index);

size_t octaspire_container_vector_get_element_size_in_octets(
    octaspire_container_vector_t const * const self);

bool octaspire_container_vector_insert_element_before_the_element_at_index(
    octaspire_container_vector_t *self,
    void const *element,
    ptrdiff_t const index);

bool octaspire_container_vector_replace_element_at_index_or_push_back(
    octaspire_container_vector_t *self,
    void const *element,
    ptrdiff_t const index);

bool octaspire_container_vector_insert_element_at(
    octaspire_container_vector_t * const self,
    void const * const element,
    size_t const index);

bool octaspire_container_vector_replace_element_at(
    octaspire_container_vector_t *self,
    size_t const index,
    void const *element);

bool octaspire_container_vector_push_front_element(
    octaspire_container_vector_t *self,
    void const *element);

bool octaspire_container_vector_push_back_element(
    octaspire_container_vector_t * const self,
    void const * const element);

bool octaspire_container_vector_push_back_char(
    octaspire_container_vector_t *self,
    char const element);

void octaspire_container_vector_for_each(
    octaspire_container_vector_t *self,
    octaspire_container_vector_element_callback_t callback);

bool octaspire_container_vector_pop_back_element(
    octaspire_container_vector_t *self);

void *octaspire_container_vector_peek_back_element(
    octaspire_container_vector_t *self);

void const * octaspire_container_vector_peek_back_element_const(
    octaspire_container_vector_t const * const self);

bool octaspire_container_vector_pop_front_element(
    octaspire_container_vector_t *self);

void *octaspire_container_vector_peek_front_element(
    octaspire_container_vector_t *self);

void const * octaspire_container_vector_peek_front_element_const(
    octaspire_container_vector_t const * const self);

octaspire_container_vector_element_callback_t
octaspire_container_vector_get_element_release_callback_const(
    octaspire_container_vector_t const * const self);

bool octaspire_container_vector_clear(
    octaspire_container_vector_t * const self);

void octaspire_container_vector_sort(
    octaspire_container_vector_t * const self,
    octaspire_container_vector_element_compare_function_t elementCompareFunction);

bool octaspire_container_vector_is_valid_index(
    octaspire_container_vector_t const * const self,
    ptrdiff_t const index);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/core/octaspire_container_vector.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/core/octaspire_container_list.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_CONTAINER_LIST_H
#define OCTASPIRE_CONTAINER_LIST_H


#ifdef __cplusplus
extern "C"
{
#endif

typedef struct octaspire_container_list_node_t octaspire_container_list_node_t;

typedef void (*octaspire_container_list_element_callback_t)(void *element);

octaspire_container_list_node_t *octaspire_container_list_node_new(
    octaspire_container_list_node_t * const previous,
    octaspire_container_list_node_t * const next,
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_container_list_element_callback_t const elementReleaseCallback,
    void const * const element,
    octaspire_memory_allocator_t * const allocator);

void octaspire_container_list_node_release(octaspire_container_list_node_t *self);

void *octaspire_container_list_node_get_element(octaspire_container_list_node_t *self);

void const *octaspire_container_list_node_get_element_const(
    octaspire_container_list_node_t const * const self);

size_t octaspire_container_list_node_get_size_of_element_in_octets(
    octaspire_container_list_node_t const * const self);

void octaspire_container_list_node_set_next(
    octaspire_container_list_node_t * const self,
    octaspire_container_list_node_t * const next);

octaspire_container_list_node_t *octaspire_container_list_node_get_next(
    octaspire_container_list_node_t * const self);

octaspire_container_list_node_t const *octaspire_container_list_node_get_next_const(
    octaspire_container_list_node_t const * const self);

void octaspire_container_list_node_set_previous(
    octaspire_container_list_node_t * const self,
    octaspire_container_list_node_t * const previous);

octaspire_container_list_node_t *octaspire_container_list_node_get_previous(
    octaspire_container_list_node_t * const self);

octaspire_container_list_node_t const *octaspire_container_list_node_get_previous_const(
    octaspire_container_list_node_t const * const self);



typedef struct octaspire_container_list_t octaspire_container_list_t;

octaspire_container_list_t *octaspire_container_list_new(
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_container_list_element_callback_t const elementReleaseCallback,
    octaspire_memory_allocator_t *allocator);

void octaspire_container_list_release(octaspire_container_list_t *self);

octaspire_container_list_node_t *octaspire_container_list_get_front(
    octaspire_container_list_t *self);

octaspire_container_list_node_t const *octaspire_container_list_get_front_const(
    octaspire_container_list_t const * const self);

octaspire_container_list_node_t *octaspire_container_list_get_back(
    octaspire_container_list_t *self);

octaspire_container_list_node_t const *octaspire_container_list_get_back_const(
    octaspire_container_list_t const * const self);

bool octaspire_container_list_push_front(
    octaspire_container_list_t *self,
    void const * const element);

bool octaspire_container_list_push_back(
    octaspire_container_list_t *self,
    void const * const element);

bool octaspire_container_list_pop_front(
    octaspire_container_list_t * const self);

bool octaspire_container_list_pop_back(
    octaspire_container_list_t * const self);

bool octaspire_container_list_remove(
    octaspire_container_list_t * const self,
    octaspire_container_list_node_t * const node);

bool octaspire_container_list_clear(
    octaspire_container_list_t * const self);

size_t octaspire_container_list_get_length(
    octaspire_container_list_t const * const self);

bool octaspire_container_list_is_empty(
    octaspire_container_list_t const * const self);

octaspire_container_list_node_t *octaspire_container_list_get_at(
    octaspire_container_list_t * const self,
    size_t const index);

octaspire_container_list_node_t const *octaspire_container_list_get_at_const(
    octaspire_container_list_t const * const self,
    size_t const index);


#ifdef __cplusplus
}
#endif

#endif
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/core/octaspire_container_list.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/core/octaspire_container_queue.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_CONTAINER_QUEUE_H
#define OCTASPIRE_CONTAINER_QUEUE_H


#ifdef __cplusplus
extern "C"
{
#endif

typedef void (*octaspire_container_queue_element_callback_t)(void *element);

typedef struct octaspire_container_queue_t octaspire_container_queue_t;

octaspire_container_queue_t *octaspire_container_queue_new(
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_container_queue_element_callback_t const elementReleaseCallback,
    octaspire_memory_allocator_t *allocator);

octaspire_container_queue_t *octaspire_container_queue_new_with_max_length(
    size_t const maxLength,
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_container_queue_element_callback_t const elementReleaseCallback,
    octaspire_memory_allocator_t *allocator);

void octaspire_container_queue_release(octaspire_container_queue_t *self);

void *octaspire_container_queue_peek(
    octaspire_container_queue_t * const self);

void const *octaspire_container_queue_peek_const(
    octaspire_container_queue_t const * const self);

bool octaspire_container_queue_pop(
    octaspire_container_queue_t * const self);

bool octaspire_container_queue_push(
    octaspire_container_queue_t *self,
    void const * const element);

bool octaspire_container_queue_clear(
    octaspire_container_queue_t * const self);

size_t octaspire_container_queue_get_length(
    octaspire_container_queue_t const * const self);

bool octaspire_container_queue_is_empty(
    octaspire_container_queue_t const * const self);

void *octaspire_container_queue_get_at(
    octaspire_container_queue_t * const self,
    size_t const index);

void const *octaspire_container_queue_get_at_const(
    octaspire_container_queue_t const * const self,
    size_t const index);

size_t octaspire_container_queue_get_max_length(
    octaspire_container_queue_t const * const self);

bool octaspire_container_queue_has_max_length(
    octaspire_container_queue_t const * const self);

bool octaspire_container_queue_set_max_length(
    octaspire_container_queue_t * const self,
    size_t maxLength);

bool octaspire_container_queue_set_has_max_length(
    octaspire_container_queue_t * const self,
    bool hasMaxLength);

#ifdef __cplusplus
}
#endif

#endif
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/core/octaspire_container_queue.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/core/octaspire_container_utf8_string.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_CONTAINER_UTF8_STRING_H
#define OCTASPIRE_CONTAINER_UTF8_STRING_H


#ifdef __cplusplus
extern "C"
{
#endif

typedef enum
{
    OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK,
    OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_ENCODING_ERROR,
    OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_DECODING_ERROR
}
octaspire_container_utf8_string_error_status_t;

typedef struct octaspire_container_utf8_string_t octaspire_container_utf8_string_t;

octaspire_container_utf8_string_t *octaspire_container_utf8_string_new(
    char const * const str,
    octaspire_memory_allocator_t *allocator);

octaspire_container_utf8_string_t *octaspire_container_utf8_string_new_from_buffer(
    char const * const buffer,
    size_t const lengthInOctets,
    octaspire_memory_allocator_t *allocator);

octaspire_container_utf8_string_t *octaspire_container_utf8_string_new_format(
    octaspire_memory_allocator_t *allocator,
    char const * const fmt,
    ...);

octaspire_container_utf8_string_t *octaspire_container_utf8_string_new_vformat(
    octaspire_memory_allocator_t *allocator,
    char const * const fmt,
    va_list arguments);

octaspire_container_utf8_string_t *octaspire_container_utf8_string_new_copy(
    octaspire_container_utf8_string_t const * const other,
    octaspire_memory_allocator_t *allocator);

octaspire_container_utf8_string_t *octaspire_container_utf8_string_new_substring_from_given_index_and_length(
    octaspire_container_utf8_string_t const * const other,
    octaspire_memory_allocator_t *allocator,
    size_t const ucsCharStartIndex,
    size_t const lengthInUcsChars);

void octaspire_container_utf8_string_release(octaspire_container_utf8_string_t *self);

bool octaspire_container_utf8_string_is_empty(
    octaspire_container_utf8_string_t const * const self);

size_t octaspire_container_utf8_string_get_length_in_ucs_characters(
    octaspire_container_utf8_string_t const * const self);

size_t octaspire_container_utf8_string_get_length_in_octets(
    octaspire_container_utf8_string_t const * const self);

uint32_t octaspire_container_utf8_string_get_ucs_character_at_index(
    octaspire_container_utf8_string_t const * const self, size_t const index);

char const * octaspire_container_utf8_string_get_c_string(
    octaspire_container_utf8_string_t const * const self);

bool octaspire_container_utf8_string_is_error(
    octaspire_container_utf8_string_t const * const self);

octaspire_container_utf8_string_error_status_t octaspire_container_utf8_string_get_error_status(
    octaspire_container_utf8_string_t const * const self);

size_t octaspire_container_utf8_string_get_error_position_in_octets(
    octaspire_container_utf8_string_t const * const self);

void octaspire_container_utf8_string_reset_error_status(
    octaspire_container_utf8_string_t * const self);

bool octaspire_container_utf8_string_concatenate(
    octaspire_container_utf8_string_t * const self,
    octaspire_container_utf8_string_t const * const other);

bool octaspire_container_utf8_string_concatenate_c_string(
    octaspire_container_utf8_string_t * const self,
    char const * const str);

bool octaspire_container_utf8_string_concatenate_format(
    octaspire_container_utf8_string_t * const self,
    char const * const fmt,
    ...);

ptrdiff_t octaspire_container_utf8_string_find_first_substring(
    octaspire_container_utf8_string_t const * const self,
    size_t const startFromIndex,
    octaspire_container_utf8_string_t const * const substring);

bool octaspire_container_utf8_string_remove_character_at(
    octaspire_container_utf8_string_t * const self,
    size_t const index);

size_t octaspire_container_utf8_string_remove_characters_at(
    octaspire_container_utf8_string_t * const self,
    size_t const startFromIndex,
    size_t const numCharacters);

size_t octaspire_container_utf8_string_remove_all_substrings(
    octaspire_container_utf8_string_t * const self,
    octaspire_container_utf8_string_t const * const substring);

bool octaspire_container_utf8_string_clear(
    octaspire_container_utf8_string_t * const self);

bool octaspire_container_utf8_string_is_equal(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const other);

bool octaspire_container_utf8_string_is_equal_to_c_string(
    octaspire_container_utf8_string_t const * const self,
    char const * const str);

int octaspire_container_utf8_string_compare(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const other);

int octaspire_container_utf8_string_compare_to_c_string(
    octaspire_container_utf8_string_t const * const self,
    char const * const str);

bool octaspire_container_utf8_string_starts_with(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const other);

bool octaspire_container_utf8_string_ends_with(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const other);

uint32_t octaspire_container_utf8_string_get_hash(
    octaspire_container_utf8_string_t const * const self);

bool octaspire_container_utf8_string_push_back_ucs_character(
    octaspire_container_utf8_string_t *self,
    uint32_t const character);

bool octaspire_container_utf8_string_pop_back_ucs_character(
    octaspire_container_utf8_string_t *self);

bool octaspire_container_utf8_string_insert_string_to(
    octaspire_container_utf8_string_t * const self,
    octaspire_container_utf8_string_t const * const str,
    ptrdiff_t const indexToPutFirstCharacter);

bool octaspire_container_utf8_string_overwrite_with_string_at(
    octaspire_container_utf8_string_t * const self,
    octaspire_container_utf8_string_t const * const str,
    ptrdiff_t const indexToPutFirstCharacter);

octaspire_container_vector_t *octaspire_container_utf8_string_split(
    octaspire_container_utf8_string_t *self,
    char const * const delimiter);

// TODO make API yhten√§inen, nyt this differs from find_char below
bool octaspire_container_utf8_string_contains_char(
    octaspire_container_utf8_string_t const * const self,
    uint32_t const character);

bool octaspire_container_utf8_string_contains_only_these_chars(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const chars);

octaspire_container_vector_t *octaspire_container_utf8_string_find_char(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const character,
    size_t const characterIndex);

octaspire_container_vector_t *octaspire_container_utf8_string_find_string(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const str,
    size_t const strStartIndex,
    size_t const strLength);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/core/octaspire_container_utf8_string.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/core/octaspire_container_pair.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_CONTAINER_PAIR_H
#define OCTASPIRE_CONTAINER_PAIR_H


#ifdef __cplusplus
extern "C"
{
#endif

typedef struct octaspire_container_pair_t octaspire_container_pair_t;

typedef void (*octaspire_container_pair_element_callback_t)(void *element);

size_t octaspire_container_pair_t_get_sizeof(void);

octaspire_container_pair_t *octaspire_container_pair_new(
    size_t const firstElementSize,
    bool firstElementIsPointer,
    size_t const secondElementSize,
    bool secondElementIsPointer,
    octaspire_container_pair_element_callback_t firstElementReleaseCallback,
    octaspire_container_pair_element_callback_t secondElementReleaseCallback,
    octaspire_memory_allocator_t *allocator);

octaspire_container_pair_t *octaspire_container_pair_new_shallow_copy(
    octaspire_container_pair_t   *other,
    octaspire_memory_allocator_t *allocator);

void octaspire_container_pair_release(octaspire_container_pair_t *self);

void *octaspire_container_pair_get_first(octaspire_container_pair_t *self);

void const *octaspire_container_pair_get_first_const(octaspire_container_pair_t const * const self);

void *octaspire_container_pair_get_second(octaspire_container_pair_t *self);

void const *octaspire_container_pair_get_second_const(
    octaspire_container_pair_t const * const self);

size_t octaspire_container_pair_get_size_of_first_element_in_octets(
    octaspire_container_pair_t const * const self);

size_t octaspire_container_pair_get_size_of_second_element_in_octets(
    octaspire_container_pair_t const * const self);

void octaspire_container_pair_set(
    octaspire_container_pair_t *self,
    void const *first,
    void const *second);

void octaspire_container_pair_set_first(
    octaspire_container_pair_t *self,
    void const *first);

void octaspire_container_pair_set_second(
    octaspire_container_pair_t *self,
    void const *second);

bool octaspire_container_pair_set_first_to_void_pointer(
    octaspire_container_pair_t *self,
    void *element);

bool octaspire_container_pair_set_second_to_void_pointer(
    octaspire_container_pair_t *self,
    void *second);

void octaspire_container_pair_clear(
    octaspire_container_pair_t * const self);

#ifdef __cplusplus
}
#endif

#endif
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/core/octaspire_container_pair.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/core/octaspire_stdio.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_STDIO_H
#define OCTASPIRE_STDIO_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct octaspire_stdio_t octaspire_stdio_t;

octaspire_stdio_t *octaspire_stdio_new(octaspire_memory_allocator_t *allocator);

void octaspire_stdio_release(octaspire_stdio_t *self);

size_t octaspire_stdio_fread(
    octaspire_stdio_t *self,
    void *ptr,
    size_t const size,
    size_t const nmemb,
    FILE *stream);

void octaspire_stdio_set_number_and_type_of_future_reads_to_be_rigged(
    octaspire_stdio_t *self,
    size_t const count,
    uint32_t const bitQueue);

size_t octaspire_stdio_get_number_of_future_reads_to_be_rigged(
    octaspire_stdio_t const * const self);

octaspire_container_utf8_string_t *octaspire_stdio_read_line(octaspire_stdio_t *self, FILE *stream);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/core/octaspire_stdio.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/core/octaspire_input.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_INPUT_H
#define OCTASPIRE_INPUT_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct octaspire_input_t octaspire_input_t;

octaspire_input_t *octaspire_input_new_from_c_string(
    char const * const str,
    octaspire_memory_allocator_t *allocator);

octaspire_input_t *octaspire_input_new_from_buffer(
    char const * const buffer,
    size_t const lengthInOctets,
    octaspire_memory_allocator_t *allocator);

octaspire_input_t *octaspire_input_new_from_path(
    char const * const path,
    octaspire_memory_allocator_t *octaspireAllocator,
    octaspire_stdio_t *octaspireStdio);

void octaspire_input_release(octaspire_input_t *self);

size_t octaspire_input_get_length_in_ucs_characters(octaspire_input_t const * const self);

void   octaspire_input_clear(octaspire_input_t *self);

void   octaspire_input_rewind(octaspire_input_t *self);

uint32_t octaspire_input_peek_next_ucs_character(octaspire_input_t *self);
uint32_t octaspire_input_peek_next_next_ucs_character(octaspire_input_t *self);

bool octaspire_input_pop_next_ucs_character(octaspire_input_t *self);

bool octaspire_input_is_good(octaspire_input_t const * const self);

bool octaspire_input_push_back_from_string(
    octaspire_input_t * const self,
    octaspire_container_utf8_string_t const * const str);

bool octaspire_input_push_back_from_c_string(octaspire_input_t * const self, char const * const str);

size_t octaspire_input_get_line_number(octaspire_input_t const * const self);
size_t octaspire_input_get_column_number(octaspire_input_t const * const self);
size_t octaspire_input_get_ucs_character_index(octaspire_input_t const * const self);

void octaspire_input_print(octaspire_input_t const * const self);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/core/octaspire_input.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/core/octaspire_container_hash_map.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_CONTAINER_HASH_MAP_H
#define OCTASPIRE_CONTAINER_HASH_MAP_H


#ifdef __cplusplus
extern "C"
{
#endif

// Hash map element
typedef struct octaspire_container_hash_map_element_t octaspire_container_hash_map_element_t;

octaspire_container_hash_map_element_t *octaspire_container_hash_map_element_new(
    uint32_t const hash,
    size_t const keySizeInOctets,
    bool const keyIsPointer,
    void const * const key,
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    void const * const value,
    octaspire_memory_allocator_t * const allocator);

void octaspire_container_hash_map_element_release(octaspire_container_hash_map_element_t *self);

uint32_t octaspire_container_hash_map_element_get_hash(
    octaspire_container_hash_map_element_t const * const self);

void *octaspire_container_hash_map_element_get_key(
    octaspire_container_hash_map_element_t const * const self);

octaspire_container_vector_t *octaspire_container_hash_map_element_get_values(
    octaspire_container_hash_map_element_t * const self);

void *octaspire_container_hash_map_element_get_value(
    octaspire_container_hash_map_element_t const * const self);

// Hash map
typedef struct octaspire_container_hash_map_t octaspire_container_hash_map_t;

typedef bool (*octaspire_container_hash_map_key_compare_function_t)(
    void const * const key1,
    void const * const key2);

typedef uint32_t (*octaspire_container_hash_map_key_hash_function_t)(
    void const * const key);

typedef void (*octaspire_container_hash_map_element_callback_function_t)(
    void * element);

octaspire_container_hash_map_t *octaspire_container_hash_map_new(
    size_t const keySizeInOctets,
    bool const keyIsPointer,
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    octaspire_container_hash_map_key_compare_function_t keyCompareFunction,
    octaspire_container_hash_map_key_hash_function_t keyHashFunction,
    octaspire_container_hash_map_element_callback_function_t keyReleaseCallback,
    octaspire_container_hash_map_element_callback_function_t valueReleaseCallback,
    octaspire_memory_allocator_t *allocator);

octaspire_container_hash_map_t *octaspire_container_hash_map_new_with_octaspire_container_utf8_string_keys(
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    octaspire_container_hash_map_element_callback_function_t valueReleaseCallback,
    octaspire_memory_allocator_t *allocator);

void octaspire_container_hash_map_release(octaspire_container_hash_map_t *self);

bool octaspire_container_hash_map_remove(
    octaspire_container_hash_map_t *self,
    uint32_t const hash,
    void const * const key);

bool octaspire_container_hash_map_clear(
    octaspire_container_hash_map_t * const self);

bool octaspire_container_hash_map_add_hash_map(
    octaspire_container_hash_map_t * const self,
    octaspire_container_hash_map_t * const other);

bool octaspire_container_hash_map_put(
    octaspire_container_hash_map_t *self,
    uint32_t const hash,
    void const * const key,
    void const * const value);

octaspire_container_hash_map_element_t *octaspire_container_hash_map_get(
    octaspire_container_hash_map_t *self,
    uint32_t const hash,
    void const * const key);

octaspire_container_hash_map_element_t const * octaspire_container_hash_map_get_const(
    octaspire_container_hash_map_t const * const self,
    uint32_t const hash,
    void const * const key);

size_t octaspire_container_hash_map_get_number_of_elements(
    octaspire_container_hash_map_t const * const self);

octaspire_container_hash_map_element_t *octaspire_container_hash_map_get_at_index(
    octaspire_container_hash_map_t *self,
    size_t const index);

typedef struct octaspire_container_hash_map_element_iterator_t
{
    octaspire_container_hash_map_t *hashMap;
    octaspire_container_hash_map_element_t *element;
    size_t bucketIndex;
    size_t elementInsideBucketIndex;
}
octaspire_container_hash_map_element_iterator_t;

octaspire_container_hash_map_element_iterator_t octaspire_container_hash_map_element_iterator_init(
    octaspire_container_hash_map_t * const self);

bool octaspire_container_hash_map_element_iterator_next(
    octaspire_container_hash_map_element_iterator_t * const self);

#ifdef __cplusplus
}
#endif

#endif
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/core/octaspire_container_hash_map.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/core/octaspire_helpers.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_HELPERS_H
#define OCTASPIRE_HELPERS_H


#ifdef __cplusplus
extern "C" {
#endif

#define OCTASPIRE_HELPERS_UNUSED_PARAMETER(x) (void)(x)

bool  octaspire_helpers_test_bit(uint32_t const bitSet, size_t const index);

char *octaspire_helpers_path_to_buffer(
    char const * const path,
    size_t *octetsAllocated,
    octaspire_memory_allocator_t *allocator,
    octaspire_stdio_t *stdio);

uint32_t octaspire_helpers_calculate_hash_for_size_t_argument(size_t const value);
uint32_t octaspire_helpers_calculate_hash_for_bool_argument(bool const value);
uint32_t octaspire_helpers_calculate_hash_for_int32_t_argument(int32_t const value);
uint32_t octaspire_helpers_calculate_hash_for_double_argument(double const value);
uint32_t octaspire_helpers_calculate_hash_for_void_pointer_argument(void const * const value);

size_t octaspire_helpers_character_digit_to_number(uint32_t const c);

size_t octaspire_helpers_min_size_t(size_t const a, size_t const b);
size_t octaspire_helpers_max_size_t(size_t const a, size_t const b);

void octaspire_helpers_verify_true(bool const condition);
void octaspire_helpers_verify_null(void const * const ptr);
void octaspire_helpers_verify_not_null(void const * const ptr);

float octaspire_helpers_maxf(float const a, float const b);
float octaspire_helpers_ceilf(float const value);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/core/octaspire_helpers.h
//////////////////////////////////////////////////////////////////////////////////////////////////



#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif

#endif








#ifdef OCTASPIRE_CORE_AMALGAMATED_IMPLEMENTATION

//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../external/jenkins_one_at_a_time.c
//////////////////////////////////////////////////////////////////////////////////////////////////
// Based on public domain code from:
// burtleburtle.net/bob/hash/doobs.html


uint32_t jenkins_one_at_a_time_hash(void const * const data, size_t const lengthInOctets)
{
    uint32_t hash = 0;

    for (size_t i = 0; i < lengthInOctets; ++i)
    {
        hash += ((uint8_t const * const)data)[i];
        hash += (hash << 10);
        hash ^= (hash >>  6);
    }

    hash += (hash <<  3);
    hash ^= (hash >> 11);
    hash += (hash << 15);

    return hash;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../external/jenkins_one_at_a_time.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_memory.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/


struct octaspire_memory_allocator_t
{
    size_t                                               numberOfFutureAllocationsToBeRigged;
    size_t                                               bitIndex;
    uint32_t                                             bitQueue[20];
    octaspire_memory_allocator_custom_malloc_function_t  customMallocFunction;
    octaspire_memory_allocator_custom_free_function_t    customFreeFunction;
    octaspire_memory_allocator_custom_realloc_function_t customReallocFunction;
};

octaspire_memory_allocator_config_t octaspire_memory_allocator_config_default(void)
{
    octaspire_memory_allocator_config_t result =
    {
        .customMallocFunction  = 0,
        .customFreeFunction    = 0,
        .customReallocFunction = 0
    };

    return result;
}

octaspire_memory_allocator_t *octaspire_memory_allocator_new(
    octaspire_memory_allocator_config_t const * config)
{
    octaspire_memory_allocator_config_t defaultConfig = octaspire_memory_allocator_config_default();

    if (!config)
    {
        config = &defaultConfig;
    }

    size_t const size = sizeof(octaspire_memory_allocator_t);

    octaspire_memory_allocator_t *self = malloc(size);

    if (!self)
    {
        return self;
    }

    memset(self, 0, size);

    self->numberOfFutureAllocationsToBeRigged = 0;
    self->bitIndex = 0;

    if (self->bitQueue != memset(self->bitQueue, 0, sizeof(self->bitQueue)))
    {
        abort();
    }

    self->customMallocFunction  = config->customMallocFunction;
    self->customFreeFunction    = config->customFreeFunction;
    self->customReallocFunction = config->customReallocFunction;

    return self;
}

void octaspire_memory_allocator_release(octaspire_memory_allocator_t *self)
{
    if (!self)
    {
        return;
    }

    free(self);
}

bool octaspire_memory_allocator_private_test_bit(octaspire_memory_allocator_t const * const self);

bool octaspire_memory_allocator_private_test_bit(octaspire_memory_allocator_t const * const self)
{
    size_t const arrayIndex = (size_t)((float)self->bitIndex / 32.0f);
    size_t const bitIndex   = self->bitIndex % 8;
    assert(bitIndex < 32);
    assert(arrayIndex < (sizeof(self->bitQueue) / sizeof(self->bitQueue[0])));
    return octaspire_helpers_test_bit(self->bitQueue[arrayIndex], bitIndex);
}

void *octaspire_memory_allocator_malloc(
    octaspire_memory_allocator_t *self,
    size_t const size)
{
    if (self->numberOfFutureAllocationsToBeRigged)
    {
        --(self->numberOfFutureAllocationsToBeRigged);

        if (!octaspire_memory_allocator_private_test_bit(self))
        {
            ++(self->bitIndex);
            return 0;
        }

        ++(self->bitIndex);
    }

    assert(size);

    void * const result =
        self->customMallocFunction ? self->customMallocFunction(size) : malloc(size);

    if (!result)
    {
        return result;
    }

    if (!self->customMallocFunction)
    {
        if (result != memset(result, 0, size))
        {
            abort();
        }
    }

    return result;
}

void *octaspire_memory_allocator_realloc(
    octaspire_memory_allocator_t *self,
    void *ptr, size_t const size)
{
    if (self->numberOfFutureAllocationsToBeRigged)
    {
        --(self->numberOfFutureAllocationsToBeRigged);

        if (!octaspire_memory_allocator_private_test_bit(self))
        {
            ++(self->bitIndex);
            return 0;
        }

        ++(self->bitIndex);
    }

    return self->customReallocFunction ? self->customReallocFunction(ptr, size) : realloc(ptr, size);
}

void octaspire_memory_allocator_free(
    octaspire_memory_allocator_t *self,
    void *ptr)
{
    assert(self);

    self->customFreeFunction ? self->customFreeFunction(ptr) : free(ptr);
}

void octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
    octaspire_memory_allocator_t *self,
    size_t const count,
    uint32_t const bitQueue0)
{
    assert(count <= 32);
    self->numberOfFutureAllocationsToBeRigged = count;
    self->bitIndex  = 0;

    if (self->bitQueue != memset(self->bitQueue, 0, sizeof(self->bitQueue)))
    {
        abort();
    }

    self->bitQueue[0] = bitQueue0;
}

void octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged_when_larger_than_32(
    octaspire_memory_allocator_t *self,
    size_t const count,
    uint32_t const bitQueue0,
    uint32_t const bitQueue1,
    uint32_t const bitQueue2,
    uint32_t const bitQueue3,
    uint32_t const bitQueue4,
    uint32_t const bitQueue5,
    uint32_t const bitQueue6,
    uint32_t const bitQueue7,
    uint32_t const bitQueue8,
    uint32_t const bitQueue9,
    uint32_t const bitQueue10,
    uint32_t const bitQueue11,
    uint32_t const bitQueue12,
    uint32_t const bitQueue13,
    uint32_t const bitQueue14,
    uint32_t const bitQueue15,
    uint32_t const bitQueue16,
    uint32_t const bitQueue17,
    uint32_t const bitQueue18,
    uint32_t const bitQueue19)
{
    assert(count <= 640);
    self->numberOfFutureAllocationsToBeRigged = count;
    self->bitIndex = 0;

    if (self->bitQueue != memset(self->bitQueue, 0, sizeof(self->bitQueue)))
    {
        abort();
    }

    self->bitQueue[0]  = bitQueue0;
    self->bitQueue[1]  = bitQueue1;
    self->bitQueue[2]  = bitQueue2;
    self->bitQueue[3]  = bitQueue3;
    self->bitQueue[4]  = bitQueue4;
    self->bitQueue[5]  = bitQueue5;
    self->bitQueue[6]  = bitQueue6;
    self->bitQueue[7]  = bitQueue7;
    self->bitQueue[8]  = bitQueue8;
    self->bitQueue[9]  = bitQueue9;
    self->bitQueue[10] = bitQueue10;
    self->bitQueue[11] = bitQueue11;
    self->bitQueue[12] = bitQueue12;
    self->bitQueue[13] = bitQueue13;
    self->bitQueue[14] = bitQueue14;
    self->bitQueue[15] = bitQueue15;
    self->bitQueue[16] = bitQueue16;
    self->bitQueue[17] = bitQueue17;
    self->bitQueue[18] = bitQueue18;
    self->bitQueue[19] = bitQueue19;
}

size_t octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
    octaspire_memory_allocator_t const * const self)
{
    return self->numberOfFutureAllocationsToBeRigged;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_memory.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_helpers.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

bool octaspire_helpers_test_bit(uint32_t const bitSet, size_t const index)
{
    assert(index < 32);
    return bitSet & ((uint32_t)0x01 << index);
}

char *octaspire_helpers_path_to_buffer(
    char const * const path,
    size_t *octetsAllocated,
    octaspire_memory_allocator_t *allocator,
    octaspire_stdio_t *stdio)
{
    *octetsAllocated = 0;
    FILE *f = fopen(path, "rb");

    if (!f)
    {
        return 0;
    }

    fseek(f, 0, SEEK_END);

    long const length = ftell(f);

    if (length <= 0)
    {
        fclose(f);
        f = 0;
        return 0;
    }

    fseek(f, 0, SEEK_SET);

    char *result = octaspire_memory_allocator_malloc(allocator, sizeof(char) * (size_t)length);

    if (!result)
    {
        fclose(f);
        f = 0;
        return 0;
    }

    *octetsAllocated = (size_t)length;

    if (*octetsAllocated != octaspire_stdio_fread(stdio, result, sizeof(char), *octetsAllocated, f))
    {
        fclose(f);
        f = 0;
        octaspire_memory_allocator_free(allocator, result);
        result = 0;
        *octetsAllocated = 0;
        return 0;
    }

    fclose(f);
    f = 0;

    return result;
}

uint32_t octaspire_helpers_calculate_hash_for_size_t_argument(size_t const value)
{
    return jenkins_one_at_a_time_hash(&value, sizeof(value));
}

uint32_t octaspire_helpers_calculate_hash_for_bool_argument(bool const value)
{
    return jenkins_one_at_a_time_hash(&value, sizeof(value));
}

uint32_t octaspire_helpers_calculate_hash_for_int32_t_argument(int32_t const value)
{
    return jenkins_one_at_a_time_hash(&value, sizeof(value));
}

uint32_t octaspire_helpers_calculate_hash_for_double_argument(double const value)
{
    return jenkins_one_at_a_time_hash(&value, sizeof(value));
}

uint32_t octaspire_helpers_calculate_hash_for_void_pointer_argument(void const * const value)
{
    return jenkins_one_at_a_time_hash(&value, sizeof(value));
}

size_t octaspire_helpers_character_digit_to_number(uint32_t const c)
{
    return c - '0';
}

size_t octaspire_helpers_min_size_t(size_t const a, size_t const b)
{
    if (a < b)
    {
        return a;
    }

    return b;
}

size_t octaspire_helpers_max_size_t(size_t const a, size_t const b)
{
    if (a > b)
    {
        return a;
    }

    return b;
}

void octaspire_helpers_verify_true(bool const condition)
{
    if (!condition)
    {
        abort();
    }
}

void octaspire_helpers_verify_null(void const * const ptr)
{
    if (ptr)
    {
        abort();
    }
}

void octaspire_helpers_verify_not_null(void const * const ptr)
{
    if (!ptr)
    {
        abort();
    }
}

float octaspire_helpers_maxf(float const a, float const b)
{
    if (a > b)
    {
        return a;
    }

    return b;
}

float octaspire_helpers_ceilf(float const value)
{
    return (float)ceil((double)value);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_helpers.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_utf8.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

typedef enum octaspire_utf8_character_range_t
{
    OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST,
    OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND,
    OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD,
    OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH,
    OCTASPIRE_UTF8_CHARACTER_RANGE_ILLEGAL
}
octaspire_utf8_character_range_t;

static octaspire_utf8_character_range_t octaspire_utf8_private_rangeof(uint32_t const character);
//static octaspire_utf8_character_range_t   octaspire_utf8_private_rangeof          (octaspire_utf8_character_range_t const range);
static uint32_t                           octaspire_utf8_private_high_order_bits  (octaspire_utf8_character_range_t const range);
static void                               octaspire_utf8_private_set_bit          (uint32_t *bitset, size_t const index, bool const on);
static void                               octaspire_utf8_private_set_bit_of_char  (unsigned char *bitset, size_t const index, bool const on);
static bool                               octaspire_utf8_private_get_bit          (uint32_t const bitset, size_t const index);
static bool                               octaspire_utf8_private_get_bit_of_uint8 (char const bitset, size_t const index);

static int                                octaspire_utf8_private_octets_in_next   (char const * const text, size_t const textLengthInOctets);
static int                                octaspire_utf8_private_octets_in_next_from_buffer   (char const * const buffer, size_t const lengthInOctets, size_t const currentIndex);

octaspire_utf8_decode_status_t octaspire_utf8_private_decode_helper(
    char const * const buffer,
    size_t const numOctetsNeeded,
    size_t const numOctetsAvailable,
    uint32_t *result);

static uint32_t const octaspire_utf8_private_range1_end   = ((uint32_t)0x007F);

static uint32_t const octaspire_utf8_private_range2_start = ((uint32_t)0x0080);
static uint32_t const octaspire_utf8_private_range2_end   = ((uint32_t)0x07FF);

static uint32_t const octaspire_utf8_private_range3_start = ((uint32_t)0x0800);
static uint32_t const octaspire_utf8_private_range3_end   = ((uint32_t)0xFFFF);

static uint32_t const octaspire_utf8_private_range4_start = ((uint32_t)0x00010000);
static uint32_t const octaspire_utf8_private_range4_end   = ((uint32_t)0x0010FFFF);

static octaspire_utf8_character_range_t octaspire_utf8_private_rangeof(uint32_t const character)
{
    if (character <= octaspire_utf8_private_range1_end)
        return OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST;

    if (character >= octaspire_utf8_private_range2_start && character <= octaspire_utf8_private_range2_end)
        return OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND;

    if (character >= octaspire_utf8_private_range3_start && character <= octaspire_utf8_private_range3_end)
        return OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD;

    if (character >= octaspire_utf8_private_range4_start && character <= octaspire_utf8_private_range4_end)
        return OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH;

    return OCTASPIRE_UTF8_CHARACTER_RANGE_ILLEGAL;
}

static uint32_t octaspire_utf8_private_high_order_bits(octaspire_utf8_character_range_t const range)
{
    if (range == OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST)
        return 0;

    if (range == OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND)
        return 0xC080;

    if (range == OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD)
        return 0xE08080;

    if (range == OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH)
        return 0xF0808080;

    // Error, illegal range. Should there be another/better way of reporting it?
    return ((uint32_t)0xFFFFFFFF);
}

static void octaspire_utf8_private_set_bit(uint32_t *bitset, size_t const index, bool const on)
{
    assert(index < 32);

    // INVALID_READ_OF_1
    if (on)
    {
        (*bitset) |= (uint32_t)1 << index;
    }
    else
    {
        (*bitset) &= ~((uint32_t)1 << index);
    }
}

static void octaspire_utf8_private_set_bit_of_char(unsigned char *bitset, size_t const index, bool const on)
{
    assert(index < CHAR_BIT);

    if (on)
    {
        (*bitset) |= (unsigned char)(1 << index);
    }
    else
    {
        (*bitset) &= (unsigned char)(~(1 << index));
    }
}

static bool octaspire_utf8_private_get_bit(uint32_t const bitset, size_t const index)
{
    assert(index < 32);
    return (bitset >> index) & 1;
}

static bool octaspire_utf8_private_get_bit_of_uint8(char const bitset, size_t const index)
{
    assert(index < 8);
    return (((uint8_t)bitset) >> index) & 1;
}

octaspire_utf8_encode_status_t octaspire_utf8_encode_character(uint32_t const character, octaspire_utf8_character_t *result)
{
    memset(result->octets, 0, 4);
    result->numoctets = 0;

    // TODO XXX are the upper and lower bounds inclusive or not?
    // Check that and remove the equality operator part if necessary.
    if (character >= 0xD800 && character <= 0xDFFF)
    {
        return OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER;
    }

    octaspire_utf8_character_range_t const range = octaspire_utf8_private_rangeof(character);

    uint32_t bitset = octaspire_utf8_private_high_order_bits(range);

    switch (range)
    {
        case OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST:
        {
            for (size_t i = 0; i < 7; ++i)
            {
                octaspire_utf8_private_set_bit(&bitset, i, octaspire_utf8_private_get_bit(character, i));
            }

            result->numoctets = 1;
        }
        break;

        case OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND:
        {
            for (size_t i = 0; i < 6; ++i)
            {
                octaspire_utf8_private_set_bit(&bitset, i, octaspire_utf8_private_get_bit(character, i));
            }

            for (size_t i = 0; i < 5; ++i)
            {
                octaspire_utf8_private_set_bit(&bitset, 8+i, octaspire_utf8_private_get_bit(character, 6+i));
            }

            result->numoctets = 2;
        }
        break;

        case OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD:
        {
            for (size_t i = 0; i < 6; ++i)
            {
                octaspire_utf8_private_set_bit(&bitset, i, octaspire_utf8_private_get_bit(character, i));
            }

            for (size_t i = 0; i < 6; ++i)
            {
                octaspire_utf8_private_set_bit(&bitset, 8+i, octaspire_utf8_private_get_bit(character, 6+i));
            }

            for (size_t i = 0; i < 4; ++i)
            {
                octaspire_utf8_private_set_bit(&bitset, 16+i, octaspire_utf8_private_get_bit(character, 12+i));
            }

            result->numoctets = 3;
        }
        break;

        case OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH:
        {
            for (size_t i = 0; i < 6; ++i)
            {
                octaspire_utf8_private_set_bit(&bitset, i, octaspire_utf8_private_get_bit(character, i));
            }

            for (size_t i = 0; i < 6; ++i)
            {
                octaspire_utf8_private_set_bit(&bitset, 8+i, octaspire_utf8_private_get_bit(character, 6+i));
            }

            for (size_t i = 0; i < 6; ++i)
            {
                octaspire_utf8_private_set_bit(&bitset, 16+i, octaspire_utf8_private_get_bit(character, 12+i));
            }

            for (size_t i = 0; i < 3; ++i)
            {
                octaspire_utf8_private_set_bit(&bitset, 24+i, octaspire_utf8_private_get_bit(character, 18+i));
            }

            result->numoctets = 4;
        }
        break;

        case OCTASPIRE_UTF8_CHARACTER_RANGE_ILLEGAL:
        {
            return OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER;
        }
    }

    for (size_t i = 0; i < 8; ++i)
    {
        octaspire_utf8_private_set_bit_of_char(&(result->octets[3]), i, octaspire_utf8_private_get_bit(bitset, i));
    }

    for (size_t i = 0; i < 8; ++i)
    {
        octaspire_utf8_private_set_bit_of_char(&(result->octets[2]), i, octaspire_utf8_private_get_bit(bitset, 8+i));
    }

    for (size_t i = 0; i < 8; ++i)
    {
        octaspire_utf8_private_set_bit_of_char(&(result->octets[1]), i, octaspire_utf8_private_get_bit(bitset, 16+i));
    }

    for (size_t i = 0; i < 8; ++i)
    {
        octaspire_utf8_private_set_bit_of_char(&(result->octets[0]), i, octaspire_utf8_private_get_bit(bitset, 24+i));
    }

    return OCTASPIRE_UTF8_ENCODE_STATUS_OK;
}

static int octaspire_utf8_private_octets_in_next(char const * const text, size_t const textLengthInOctets)
{
    size_t lengthInOctets = 0;

    if (!text || textLengthInOctets == 0 || text[0] == '\0')
    {
        return 0;
    }

    for (size_t i = 0; i < octaspire_helpers_min_size_t(4, textLengthInOctets); ++i)
    {
        if (text[i] == '\0')
        {
            break;
        }
        else
        {
            ++lengthInOctets;
        }
    }

    return octaspire_utf8_private_octets_in_next_from_buffer(text, lengthInOctets, 0);
}

static int octaspire_utf8_private_octets_in_next_from_buffer(char const * const buffer, size_t const lengthInOctets, size_t const currentIndex)
{
    if (!buffer || currentIndex >= lengthInOctets)
        return 0;

    size_t const octetsAvailable = lengthInOctets - currentIndex;

    if (!octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 7))
    {
        return 1;
    }

    if ( octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 7) &&
         octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 6) &&
        !octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 5))
    {
        if (octetsAvailable < 2)
        {
            return -1;
        }

        if ( octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 1], 7) &&
            !octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 1], 6))
        {
            return 2;
        }

        return -1;
    }

    if ( octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 7) &&
         octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 6) &&
         octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 5) &&
        !octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 4))
    {
        if (octetsAvailable < 3)
        {
            return -1;
        }

        if ( octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 1], 7) &&
            !octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 1], 6) &&
             octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 2], 7) &&
            !octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 2], 6))
        {
            return 3;
        }

        return -1;
    }

    if ( octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 7) &&
         octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 6) &&
         octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 5) &&
         octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 4) &&
        !octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 0], 3))
    {
        if (octetsAvailable < 4)
        {
            return -1;
        }

        if ( octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 1], 7) &&
            !octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 1], 6) &&
             octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 2], 7) &&
            !octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 2], 6) &&
             octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 3], 7) &&
            !octaspire_utf8_private_get_bit_of_uint8(buffer[currentIndex + 3], 6))
        {
            return 4;
        }

        return -1;
    }

    return -1;
}

octaspire_utf8_decode_status_t octaspire_utf8_private_decode_helper(
    char const * const buffer,
    size_t const numOctetsNeeded,
    size_t const numOctetsAvailable,
    uint32_t *result)
{
    assert(numOctetsNeeded <= 4);

    if (numOctetsNeeded > numOctetsAvailable || !buffer)
    {
        return OCTASPIRE_UTF8_DECODE_STATUS_INPUT_NOT_ENOUGH_OCTETS_AVAILABLE;
    }

    switch (numOctetsNeeded)
    {
        case 1:
        {
            // 0xxxxxxx

            for (size_t i = 0; i < 7; ++i)
            {
                // INVALID_READ_OF_1
                octaspire_utf8_private_set_bit(result, i, octaspire_utf8_private_get_bit_of_uint8(buffer[0], i));
            }
        }
        break;

        case 2:
        {
            // 110xxxxx 10xxxxxx

            for (size_t i = 0; i < 5; ++i)
            {
                octaspire_utf8_private_set_bit(result, i+6, octaspire_utf8_private_get_bit_of_uint8(buffer[0], i));
            }

            for (size_t i = 0; i < 6; ++i)
            {
                octaspire_utf8_private_set_bit(result, i,  octaspire_utf8_private_get_bit_of_uint8(buffer[1], i));
            }

            if (*result <= 0x7F)
            {
                return OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER;
            }
        }
        break;

        case 3:
        {
            // 1110xxxx 10xxxxxx 10xxxxxx

            for (size_t i = 0; i < 4; ++i)
            {
                octaspire_utf8_private_set_bit(result, i+12, octaspire_utf8_private_get_bit_of_uint8(buffer[0], i));
            }

            for (size_t i = 0; i < 6; ++i)
            {
                octaspire_utf8_private_set_bit(result, i+6, octaspire_utf8_private_get_bit_of_uint8(buffer[1], i));
            }

            for (size_t i = 0; i < 6; ++i)
            {
                octaspire_utf8_private_set_bit(result, i,  octaspire_utf8_private_get_bit_of_uint8(buffer[2], i));
            }

            if (*result <= 2047)
            {
                return OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER;
            }
        }
        break;

        case 4:
        {
            // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

            for (size_t i = 0; i < 3; ++i)
            {
                octaspire_utf8_private_set_bit(result, i+18, octaspire_utf8_private_get_bit_of_uint8(buffer[0], i));
            }

            for (size_t i = 0; i < 6; ++i)
            {
                octaspire_utf8_private_set_bit(result, i+12, octaspire_utf8_private_get_bit_of_uint8(buffer[1], i));
            }

            for (size_t i = 0; i < 6; ++i)
            {
                octaspire_utf8_private_set_bit(result, i+6, octaspire_utf8_private_get_bit_of_uint8(buffer[2], i));
            }

            for (size_t i = 0; i < 6; ++i)
            {
                octaspire_utf8_private_set_bit(result, i,  octaspire_utf8_private_get_bit_of_uint8(buffer[3], i));
            }

            if (*result <= 65535)
            {
                return OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER;
            }
        }
        break;
    }

    return OCTASPIRE_UTF8_DECODE_STATUS_OK;
}

octaspire_utf8_decode_status_t octaspire_utf8_decode_character(char const * const text, size_t const textLengthInOctets, uint32_t *result, int *numoctets)
{
    if (!text || textLengthInOctets == 0 || text[0] == '\0')
    {
        *result = 0;
        *numoctets = 0;
        return OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL;
    }

    *result = 0;
    *numoctets = octaspire_utf8_private_octets_in_next(text, textLengthInOctets);

    if (*numoctets <= 0 || *numoctets > 4)
    {
        return OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS;
    }

    if ((size_t)(*numoctets) > textLengthInOctets)
    {
        return OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS;
    }

    size_t numOctetsAvailable = 0;

    for (size_t i = 0; i < octaspire_helpers_min_size_t(4, textLengthInOctets); ++i)
    {
        if (text[i] == '\0')
        {
            break;
        }
        else
        {
            ++numOctetsAvailable;
        }
    }

    return octaspire_utf8_private_decode_helper(text, (size_t)*numoctets, numOctetsAvailable, result);
}

octaspire_utf8_decode_status_t octaspire_utf8_decode_character_from_buffer(
    char const * const buffer,
    size_t const bufferLengthInOctets,
    size_t const currentIndex,
    uint32_t *result,
    int *numoctets)
{
    if (!buffer)
    {
        *result = 0;
        *numoctets = 0;
        return OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL;
    }

    *result = 0;
    *numoctets = octaspire_utf8_private_octets_in_next_from_buffer(buffer, bufferLengthInOctets, currentIndex);

    if (*numoctets <= 0 || *numoctets > 4)
    {
        return OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS;
    }

    size_t numOctetsAvailable = 0;

    if (bufferLengthInOctets > currentIndex)
    {
        numOctetsAvailable = bufferLengthInOctets - currentIndex;
    }

    return octaspire_utf8_private_decode_helper(buffer, (size_t)*numoctets, numOctetsAvailable, result);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_utf8.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_container_vector.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/


struct octaspire_container_vector_t
{
    void   *elements;
    size_t  elementSize;
    size_t  numElements;
    size_t  numAllocated;
    size_t  compactingLimitForAllocated;
    octaspire_container_vector_element_callback_t elementReleaseCallback;
    octaspire_memory_allocator_t *allocator;
    bool    elementIsPointer;
    char    padding[7];
};

static size_t const OCTASPIRE_CONTAINER_VECTOR_INITIAL_SIZE = 1;

static void *octaspire_container_vector_private_index_to_pointer(
    octaspire_container_vector_t * const self,
    size_t const index)
{
    assert(self->elements);
    assert(index < self->numAllocated);
    return ((char*)self->elements) + (self->elementSize * index);
}

static void const *octaspire_container_vector_private_index_to_pointer_const(
    octaspire_container_vector_t const * const self,
    size_t const index)
{
    return ((char const * const)self->elements) + (self->elementSize * index);
}

static bool octaspire_container_vector_private_grow(
    octaspire_container_vector_t *self,
    float const factor)
{
    size_t const newNumAllocated = (size_t)(self->numAllocated * octaspire_helpers_maxf(2, factor));

    void *newElements = octaspire_memory_allocator_realloc(
        self->allocator,
        self->elements,
        self->elementSize * newNumAllocated);

    if (!newElements)
    {
        return false;
    }

    self->elements     = newElements;
    self->numAllocated = newNumAllocated;

    // Initialize new elements to zero.
    for (size_t i = self->numElements; i < self->numAllocated; ++i)
    {
        void *s = ((char*)self->elements) + (i * self->elementSize);

        if (s != memset(s, 0, self->elementSize))
        {
            abort();
        }
    }

    return true;
}

static bool octaspire_container_vector_private_compact(
    octaspire_container_vector_t *self)
{
    if (self->numAllocated <= 1)
    {
        return true;
    }

    if (self->numAllocated <= (self->numElements * 3))
    {
        return true;
    }

    if (self->numAllocated <= self->compactingLimitForAllocated)
    {
        return true;
    }

    size_t newNumAllocated =
        self->numElements ? self->numElements : OCTASPIRE_CONTAINER_VECTOR_INITIAL_SIZE;

    if (newNumAllocated < self->compactingLimitForAllocated)
    {
        newNumAllocated = self->compactingLimitForAllocated;
    }

    void *newElements = octaspire_memory_allocator_realloc(
        self->allocator,
        self->elements,
        self->elementSize * newNumAllocated);

    if (!newElements)
    {
        return false;
    }

    self->elements     = newElements;
    self->numAllocated = newNumAllocated;

    return true;
}

octaspire_container_vector_t *octaspire_container_vector_new(
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_container_vector_element_callback_t elementReleaseCallback,
    octaspire_memory_allocator_t *allocator)
{
    return octaspire_container_vector_new_with_preallocated_elements(
        elementSize,
        elementIsPointer,
        OCTASPIRE_CONTAINER_VECTOR_INITIAL_SIZE,
        elementReleaseCallback,
        allocator);
}

octaspire_container_vector_t *octaspire_container_vector_new_with_preallocated_elements(
    size_t const elementSize,
    bool const elementIsPointer,
    size_t const numElementsPreAllocated,
    octaspire_container_vector_element_callback_t elementReleaseCallback,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_container_vector_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_vector_t));

    if (!self)
    {
        return self;
    }

    self->allocator        = allocator;
    self->elementSize      = elementSize ? elementSize : sizeof(char);
    self->elementIsPointer = elementIsPointer;
    self->numElements      = 0;

    self->numAllocated = numElementsPreAllocated ?
        numElementsPreAllocated : OCTASPIRE_CONTAINER_VECTOR_INITIAL_SIZE;

    self->compactingLimitForAllocated = self->numAllocated;

    self->elements     =
        octaspire_memory_allocator_malloc(self->allocator, self->elementSize * self->numAllocated);

    if (!self->elements)
    {
        octaspire_container_vector_release(self);
        self = 0;
        return 0;
    }

    self->elementReleaseCallback  = elementReleaseCallback;

    return self;
}

octaspire_container_vector_t *octaspire_container_vector_new_shallow_copy(
    octaspire_container_vector_t * other,
    octaspire_memory_allocator_t * allocator)
{
    octaspire_container_vector_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_vector_t));

    if (!self)
    {
        return self;
    }

    self->allocator    = allocator;

    self->elementSize  = octaspire_container_vector_get_element_size_in_octets(other);
    self->numElements  = octaspire_container_vector_get_length(other);
    self->numAllocated = self->numElements;
    self->compactingLimitForAllocated = other->compactingLimitForAllocated;

    // This is here to prevent assert on octaspire_memory_allocator_malloc
    // on 0 size of allocation. Should that check be removed, or this?
    if (self->numAllocated == 0)
    {
        self->numAllocated = 1;
    }

    self->elements     = octaspire_memory_allocator_malloc(
        self->allocator,
        self->elementSize * self->numAllocated);

    if (!self->elements)
    {
        octaspire_container_vector_release(self);
        self = 0;
        return 0;
    }

    self->elementReleaseCallback =
        octaspire_container_vector_get_element_release_callback_const(other);

    if (memcpy(
        self->elements,
        octaspire_container_vector_get_element_at_const(other, 0),
        (self->numElements * self->elementSize)) != self->elements)
    {
        abort();
    }

    return self;
}

void octaspire_container_vector_release(octaspire_container_vector_t *self)
{
    if (!self)
    {
        return;
    }

    if (self->elementReleaseCallback)
    {
        octaspire_container_vector_for_each(self, self->elementReleaseCallback);
    }

    assert(self->allocator);

    octaspire_memory_allocator_free(self->allocator, self->elements);
    octaspire_memory_allocator_free(self->allocator, self);
}

// Vector can never be compacted smaller than this limit, if set
void octaspire_container_vector_set_compacting_limit_for_preallocated_elements(
    octaspire_container_vector_t * const self,
    size_t const numPreAllocatedElementsAtLeastPresentAtAnyMoment)
{
    self->compactingLimitForAllocated = numPreAllocatedElementsAtLeastPresentAtAnyMoment;
}

size_t octaspire_container_vector_get_length(
    octaspire_container_vector_t const * const self)
{
    assert(self);
    return self->numElements;
}

size_t octaspire_container_vector_get_length_in_octets(
    octaspire_container_vector_t const * const self)
{
    return self->numElements * self->elementSize;
}

bool octaspire_container_vector_is_empty(
    octaspire_container_vector_t const * const self)
{
    return (self->numElements == 0);
}

bool octaspire_container_vector_remove_element_at(
    octaspire_container_vector_t * const self,
    size_t const index)
{
    if (octaspire_container_vector_is_empty(self))
    {
        return false;
    }

    if (index >= octaspire_container_vector_get_length(self))
    {
        return false;
    }

    if (self->elementReleaseCallback)
    {
        if (self->elementIsPointer)
        {
            self->elementReleaseCallback(*(void**)octaspire_container_vector_private_index_to_pointer(self, index));
        }
        else
        {
            self->elementReleaseCallback(octaspire_container_vector_private_index_to_pointer(self, index));
        }
    }

    if ((index + 1) != self->numElements)
    {
        size_t const numOctetsToMove = (self->numElements - index - 1) * self->elementSize;
        void *moveTarget = octaspire_container_vector_private_index_to_pointer(self, index);
        void *moveSource = octaspire_container_vector_private_index_to_pointer(self, index + 1);

        if (moveTarget != memmove(moveTarget, moveSource, numOctetsToMove))
        {
            abort();
        }
    }

    --(self->numElements);

    return true;
}

void *octaspire_container_vector_get_element_at(
    octaspire_container_vector_t * const self,
    size_t const index)
{
    if (index >= octaspire_container_vector_get_length(self))
    {
        return 0;
    }

    void *result = octaspire_container_vector_private_index_to_pointer(self, index);

    if (self->elementIsPointer)
    {
        return *(void**)result;
    }

    return result;
}

void const *octaspire_container_vector_get_element_at_const(
    octaspire_container_vector_t const * const self,
    size_t const index)
{
    if (index >= octaspire_container_vector_get_length(self))
    {
        return 0;
    }

    void const * const result = octaspire_container_vector_private_index_to_pointer_const(self, index);

    if (self->elementIsPointer)
    {
        return *(void const * const *)result;
    }

    return result;
}

size_t octaspire_container_vector_get_element_size_in_octets(
    octaspire_container_vector_t const * const self)
{
    return self->elementSize;
}

bool octaspire_container_vector_insert_element_before_the_element_at_index(
    octaspire_container_vector_t *self,
    void const *element,
    ptrdiff_t const index)
{
    if (octaspire_container_vector_is_empty(self))
    {
        return false;
    }

    size_t realIndexToUse = 0;

    if (index < 0)
    {
        ptrdiff_t const tmpIdx = (ptrdiff_t)octaspire_container_vector_get_length(self) + index;

        if (tmpIdx < 0)
        {
            abort();
        }

        realIndexToUse = (size_t)tmpIdx;
    }
    else
    {
        if ((size_t)index >= octaspire_container_vector_get_length(self))
        {
            return false;
        }

        realIndexToUse = (size_t)index;
    }

    assert(realIndexToUse < octaspire_container_vector_get_length(self));

    // Make room for the new element
    if (self->numElements >= self->numAllocated)
    {
        if (!octaspire_container_vector_private_grow(self, 2))
        {
            return false;
        }
    }

    size_t const numOctetsToMove = (self->numElements - realIndexToUse) * self->elementSize;
    void *moveTarget = octaspire_container_vector_private_index_to_pointer(self, realIndexToUse + 1);
    void *moveSource = octaspire_container_vector_private_index_to_pointer(self, realIndexToUse);

    if (moveTarget != memmove(moveTarget, moveSource, numOctetsToMove))
    {
        abort();
    }

    // Copy the new element into the vector
    void *copyTarget = octaspire_container_vector_private_index_to_pointer(self, realIndexToUse);

    if (copyTarget != memcpy(copyTarget, element, self->elementSize))
    {
        abort();
    }

    ++(self->numElements);

    return true;
}

bool octaspire_container_vector_replace_element_at_index_or_push_back(
    octaspire_container_vector_t *self,
    void const *element,
    ptrdiff_t const index)
{
    size_t realIndexToUse = 0;

    if (index < 0)
    {
        ptrdiff_t const tmpIdx = (ptrdiff_t)octaspire_container_vector_get_length(self) + index;

        if (tmpIdx < 0)
        {
            abort();
        }

        realIndexToUse = (size_t)tmpIdx;
    }
    else
    {
        realIndexToUse = (size_t)index;
    }

    if (realIndexToUse >= octaspire_container_vector_get_length(self))
    {
        return octaspire_container_vector_push_back_element(self, element);
    }

    return octaspire_container_vector_insert_element_at(self, element, realIndexToUse);
}

bool octaspire_container_vector_insert_element_at(
    octaspire_container_vector_t * const self,
    void const * const element,
    size_t const index)
{
    size_t const originalNumElements = self->numElements;

    while (index >= self->numAllocated)
    {
        if (!octaspire_container_vector_private_grow(
                self,
                octaspire_helpers_ceilf((float)index / (float)self->numAllocated)))
        {
            return false;
        }
    }

    for (size_t i = originalNumElements; i < index; ++i)
    {
        void *s = octaspire_container_vector_private_index_to_pointer(self, i);

        if (s != memset(s, 0, self->elementSize))
        {
            abort();
        }
        ++(self->numElements);
    }

    void *target = octaspire_container_vector_private_index_to_pointer(self, index);

    if (target != memcpy(target, element, self->elementSize))
    {
        abort();
    }

    if (index >= self->numElements)
    {
        ++(self->numElements);
    }

    return true;
}

bool octaspire_container_vector_replace_element_at(
    octaspire_container_vector_t *self,
    size_t const index,
    void const *element)
{
    if (index >= octaspire_container_vector_get_length(self))
    {
        return false;
    }

    if (self->elementReleaseCallback)
    {
        if (self->elementIsPointer)
        {
            self->elementReleaseCallback(*(void**)octaspire_container_vector_private_index_to_pointer(self, index));
        }
        else
        {
            self->elementReleaseCallback(octaspire_container_vector_private_index_to_pointer(self, index));
        }
    }

    return octaspire_container_vector_insert_element_at(self, element, index);
}

bool octaspire_container_vector_push_front_element(
    octaspire_container_vector_t *self,
    void const *element)
{
    if (octaspire_container_vector_is_empty(self))
    {
        return octaspire_container_vector_push_back_element(self, element);
    }

    return octaspire_container_vector_insert_element_before_the_element_at_index(
        self,
        element,
        0);
}

bool octaspire_container_vector_push_back_element(
    octaspire_container_vector_t * const self,
    void const * const element)
{
    return octaspire_container_vector_insert_element_at(
        self,
        element,
        octaspire_container_vector_get_length(self));
}

bool octaspire_container_vector_push_back_char(
    octaspire_container_vector_t *self,
    char const element)
{
    if (self->elementSize != sizeof(element))
    {
        return false;
    }

    return octaspire_container_vector_insert_element_at(
        self,
        &element,
        octaspire_container_vector_get_length(self));
}

void octaspire_container_vector_for_each(
    octaspire_container_vector_t *self,
    octaspire_container_vector_element_callback_t callback)
{
    assert(self);
    assert(callback);

    for (size_t i = 0; i < octaspire_container_vector_get_length(self); ++i)
    {
        callback(octaspire_container_vector_get_element_at(self, i));
    }
}

bool octaspire_container_vector_pop_back_element(
    octaspire_container_vector_t *self)
{
    if (octaspire_container_vector_is_empty(self))
    {
        return false;
    }

    --(self->numElements);

    return octaspire_container_vector_private_compact(self);
}

void *octaspire_container_vector_peek_back_element(
    octaspire_container_vector_t *self)
{
    if (octaspire_container_vector_is_empty(self))
    {
        return 0;
    }

    return octaspire_container_vector_get_element_at(
        self,
        octaspire_container_vector_get_length(self) - 1);
}

void const * octaspire_container_vector_peek_back_element_const(
    octaspire_container_vector_t const * const self)
{
    if (octaspire_container_vector_is_empty(self))
    {
        return 0;
    }

    return octaspire_container_vector_get_element_at_const(
        self,
        octaspire_container_vector_get_length(self) - 1);
}

bool octaspire_container_vector_pop_front_element(
    octaspire_container_vector_t *self)
{
    if (octaspire_container_vector_is_empty(self))
    {
        return false;
    }

    --(self->numElements);

    if (self->numElements > 0)
    {
        void *dest = octaspire_container_vector_private_index_to_pointer(self, 0);
        void *src  = octaspire_container_vector_private_index_to_pointer(self, 1);

        if (dest != memmove(dest, src, (self->elementSize * self->numElements)))
        {
            abort();
        }
    }

    return octaspire_container_vector_private_compact(self);
}

void *octaspire_container_vector_peek_front_element(
    octaspire_container_vector_t *self)
{
    if (octaspire_container_vector_is_empty(self))
    {
        return 0;
    }

    return octaspire_container_vector_get_element_at(self, 0);
}

void const * octaspire_container_vector_peek_front_element_const(
    octaspire_container_vector_t const * const self)
{
    if (octaspire_container_vector_is_empty(self))
    {
        return 0;
    }

    return octaspire_container_vector_get_element_at_const(self, 0);
}

octaspire_container_vector_element_callback_t octaspire_container_vector_get_element_release_callback_const(octaspire_container_vector_t const * const self)
{
    return self->elementReleaseCallback;
}

bool octaspire_container_vector_clear(
    octaspire_container_vector_t * const self)
{
    if (octaspire_container_vector_is_empty(self))
    {
        return true;
    }

    self->numElements = 0;

    return octaspire_container_vector_private_compact(self);
}

void octaspire_container_vector_sort(
    octaspire_container_vector_t * const self,
    octaspire_container_vector_element_compare_function_t elementCompareFunction)
{
    qsort(
        self->elements,
        octaspire_container_vector_get_length(self),
        octaspire_container_vector_get_element_size_in_octets(self),
        elementCompareFunction);
}

bool octaspire_container_vector_is_valid_index(
    octaspire_container_vector_t const * const self,
    ptrdiff_t const index)
{
    // TODO Should indexing with negative indices from back be supported?
    if (index < 0)
    {
        return false;
    }

    size_t const len = octaspire_container_vector_get_length(self);

    if (!len)
    {
        return false;
    }

    return ((size_t)index < len);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_container_vector.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_container_list.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_container_list_node_t
{
    void                                        *element;
    octaspire_container_list_node_t             *next;
    octaspire_container_list_node_t             *previous;
    octaspire_memory_allocator_t                *allocator;
    size_t                                       elementSize;
    octaspire_container_list_element_callback_t  elementReleaseCallback;
    bool                                         elementIsPointer;
    char                                         padding[7];
};

octaspire_container_list_node_t *octaspire_container_list_node_new(
    octaspire_container_list_node_t * const previous,
    octaspire_container_list_node_t * const next,
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_container_list_element_callback_t const elementReleaseCallback,
    void const * const element,
    octaspire_memory_allocator_t * const allocator)
{
    octaspire_container_list_node_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_list_node_t));

    if (!self)
    {
        return self;
    }

    self->allocator              = allocator;
    self->elementSize            = elementSize;
    self->elementIsPointer       = elementIsPointer;
    self->elementReleaseCallback = elementReleaseCallback;
    self->next                   = next;
    self->previous               = previous;

    self->element = octaspire_memory_allocator_malloc(self->allocator, elementSize);

    if (!self->element)
    {
        octaspire_container_list_node_release(self);
        self = 0;
        return self;
    }

    if (self->element != memcpy(self->element, element, self->elementSize))
    {
        octaspire_container_list_node_release(self);
        self = 0;
        return self;
    }

    return self;
}

void octaspire_container_list_node_release(octaspire_container_list_node_t *self)
{
    if (!self)
    {
        return;
    }

    if (self->elementReleaseCallback)
    {
        self->elementReleaseCallback(self->elementIsPointer ? *(void**)self->element : self->element);
    }

    octaspire_memory_allocator_free(self->allocator, self->element);
    self->element = 0;

    octaspire_memory_allocator_free(self->allocator, self);
}

void *octaspire_container_list_node_get_element(octaspire_container_list_node_t *self)
{
    octaspire_helpers_verify_not_null(self);

    if (!self->element)
    {
        return self->element;
    }

    return self->elementIsPointer ? *(void**)self->element : self->element;
}

void const *octaspire_container_list_node_get_element_const(
    octaspire_container_list_node_t const * const self)
{
    octaspire_helpers_verify_not_null(self);

    if (!self->element)
    {
        return self->element;
    }

    return self->elementIsPointer ? *(void**)self->element : self->element;
}

size_t octaspire_container_list_node_get_size_of_element_in_octets(
    octaspire_container_list_node_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->elementSize;
}

void octaspire_container_list_node_set_next(
    octaspire_container_list_node_t * const self,
    octaspire_container_list_node_t * const next)
{
    octaspire_helpers_verify_not_null(self);
    self->next = next;
}

octaspire_container_list_node_t *octaspire_container_list_node_get_next(
    octaspire_container_list_node_t * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->next;
}

octaspire_container_list_node_t const *octaspire_container_list_node_get_next_const(
    octaspire_container_list_node_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->next;
}

void octaspire_container_list_node_set_previous(
    octaspire_container_list_node_t * const self,
    octaspire_container_list_node_t * const previous)
{
    octaspire_helpers_verify_not_null(self);
    self->previous = previous;
}

octaspire_container_list_node_t *octaspire_container_list_node_get_previous(
    octaspire_container_list_node_t * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->previous;
}

octaspire_container_list_node_t const *octaspire_container_list_node_get_previous_const(
    octaspire_container_list_node_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->previous;
}




struct octaspire_container_list_t
{
    octaspire_memory_allocator_t                *allocator;
    octaspire_container_list_node_t             *front;
    octaspire_container_list_node_t             *back;
    size_t                                       elementSize;
    octaspire_container_list_element_callback_t  elementReleaseCallback;
    size_t                                       numElements;
    bool                                         elementIsPointer;
    char                                         padding[7];
};

octaspire_container_list_t *octaspire_container_list_new(
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_container_list_element_callback_t const elementReleaseCallback,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_container_list_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_list_t));

    if (!self)
    {
        return self;
    }

    self->allocator              = allocator;
    self->front                  = 0;
    self->back                   = 0;
    self->elementSize            = elementSize;
    self->elementReleaseCallback = elementReleaseCallback;
    self->numElements            = 0;
    self->elementIsPointer       = elementIsPointer;

    return self;
}

void octaspire_container_list_release(octaspire_container_list_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_helpers_verify_true(octaspire_container_list_clear(self));
    octaspire_memory_allocator_free(self->allocator, self);
}

octaspire_container_list_node_t *octaspire_container_list_get_front(
    octaspire_container_list_t *self)
{
    octaspire_helpers_verify_not_null(self);
    return self->front;
}

octaspire_container_list_node_t const *octaspire_container_list_get_front_const(
    octaspire_container_list_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->front;
}

octaspire_container_list_node_t *octaspire_container_list_get_back(
    octaspire_container_list_t *self)
{
    octaspire_helpers_verify_not_null(self);
    return self->back;
}

octaspire_container_list_node_t const *octaspire_container_list_get_back_const(
    octaspire_container_list_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->back;
}

bool octaspire_container_list_push_front(
    octaspire_container_list_t *self,
    void const * const element)
{
    octaspire_helpers_verify_not_null(self);

    octaspire_container_list_node_t *newFirst = octaspire_container_list_node_new(
        0,
        self->front,
        self->elementSize,
        self->elementIsPointer,
        self->elementReleaseCallback,
        element,
        self->allocator);

    if (!newFirst)
    {
        return false;
    }

    if (self->front)
    {
        octaspire_container_list_node_set_previous(self->front, newFirst);
    }

    self->front = newFirst;

    if (octaspire_container_list_get_length(self) == 0)
    {
        self->back = self->front;
    }

    ++(self->numElements);

    return true;
}

bool octaspire_container_list_push_back(
    octaspire_container_list_t *self,
    void const * const element)
{
    octaspire_helpers_verify_not_null(self);

    octaspire_container_list_node_t *newLast = octaspire_container_list_node_new(
        self->back,
        0,
        self->elementSize,
        self->elementIsPointer,
        self->elementReleaseCallback,
        element,
        self->allocator);

    if (!newLast)
    {
        return false;
    }

    if (self->back)
    {
        octaspire_container_list_node_set_next(self->back, newLast);
    }

    self->back = newLast;

    if (octaspire_container_list_get_length(self) == 0)
    {
        self->front = self->back;
    }

    // Sanity checks
    if (self->numElements > 0)
    {
        octaspire_helpers_verify_not_null(octaspire_container_list_node_get_previous(self->back));
    }
    else
    {
        octaspire_helpers_verify_null(octaspire_container_list_node_get_previous(self->back));
    }

    ++(self->numElements);

    return true;
}

bool octaspire_container_list_pop_front(
    octaspire_container_list_t * const self)
{
    octaspire_helpers_verify_not_null(self);

    if (self->front)
    {
        octaspire_container_list_node_t *oldFirst = self->front;

        self->front = octaspire_container_list_node_get_next(self->front);

        if (self->front)
        {
            octaspire_container_list_node_set_previous(self->front, 0);
        }

        octaspire_container_list_node_set_next(oldFirst, 0);

        octaspire_helpers_verify_null(octaspire_container_list_node_get_previous(oldFirst));
        octaspire_helpers_verify_true(self->numElements > 0);

        --(self->numElements);

        if (octaspire_container_list_get_length(self) == 0)
        {
            self->back = self->front;
        }

        octaspire_container_list_node_release(oldFirst);
        oldFirst = 0;

        return true;
    }

    return true;
}

bool octaspire_container_list_pop_back(
    octaspire_container_list_t * const self)
{
    octaspire_helpers_verify_not_null(self);

    if (self->back)
    {
        octaspire_container_list_node_t *oldLast = self->back;

        self->back = octaspire_container_list_node_get_previous(self->back);

        if (self->back)
        {
            octaspire_container_list_node_set_next(self->back, 0);
        }

        octaspire_container_list_node_set_previous(oldLast, 0);

        octaspire_helpers_verify_null(octaspire_container_list_node_get_next(oldLast));
        octaspire_helpers_verify_true(self->numElements > 0);

        --(self->numElements);

        if (octaspire_container_list_get_length(self) == 0)
        {
            self->front = self->back;
        }

        octaspire_container_list_node_release(oldLast);
        oldLast = 0;

        return true;
    }

    return true;
}

bool octaspire_container_list_remove(
    octaspire_container_list_t * const self,
    octaspire_container_list_node_t * const node)
{
    octaspire_helpers_verify_not_null(self);

    if (node == octaspire_container_list_get_front_const(self))
    {
        return octaspire_container_list_pop_front(self);
    }
    else if (node == octaspire_container_list_get_back_const(self))
    {
        return octaspire_container_list_pop_back(self);
    }
    else
    {
        octaspire_container_list_node_t * const prev =
            octaspire_container_list_node_get_previous(node);

        octaspire_container_list_node_t * const next =
            octaspire_container_list_node_get_next(node);

        if (prev)
        {
            octaspire_container_list_node_set_next(prev, next);
        }

        if (next)
        {
            octaspire_container_list_node_set_previous(next, prev);
        }

        octaspire_container_list_node_set_next(node, 0);
        octaspire_container_list_node_set_previous(node, 0);

        octaspire_helpers_verify_true(self->numElements > 0);

        --(self->numElements);

        if (octaspire_container_list_get_length(self) == 0)
        {
            self->front = self->back;
        }

        octaspire_container_list_node_release(node);
        return true;
    }
}

bool octaspire_container_list_clear(
    octaspire_container_list_t * const self)
{
    octaspire_helpers_verify_not_null(self);

    while (!octaspire_container_list_is_empty(self))
    {
        if (!octaspire_container_list_pop_front(self))
        {
            return false;
        }

    }

    return true;
}

size_t octaspire_container_list_get_length(
    octaspire_container_list_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->numElements;
}

bool octaspire_container_list_is_empty(
    octaspire_container_list_t const * const self)
{
    return (self->front == 0);
}

octaspire_container_list_node_t *octaspire_container_list_get_at(
    octaspire_container_list_t * const self,
    size_t const index)
{
    octaspire_helpers_verify_not_null(self);

    size_t counter = 0;
    octaspire_container_list_node_t * node = octaspire_container_list_get_front(self);

    while (true)
    {
        if (counter == index)
        {
            return node;
        }

        node = octaspire_container_list_node_get_next(node);

        if (!node)
        {
            break;
        }

        ++counter;
    }

    return 0;
}

octaspire_container_list_node_t const *octaspire_container_list_get_at_const(
    octaspire_container_list_t const * const self,
    size_t const index)
{
    octaspire_helpers_verify_not_null(self);

    size_t counter = 0;
    octaspire_container_list_node_t const * node = octaspire_container_list_get_front_const(self);

    while (true)
    {
        if (counter == index)
        {
            return node;
        }

        node = octaspire_container_list_node_get_next_const(node);

        if (!node)
        {
            break;
        }

        ++counter;
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_container_list.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_container_queue.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_container_queue_t
{
    octaspire_memory_allocator_t *allocator;
    octaspire_container_list_t   *list;
    size_t                        maxLength;
    bool                          hasMaxLength;
    char                          padding[7];
};

static bool octaspire_container_queue_private_ensure_max_length(
    octaspire_container_queue_t * const self)
{
    if (self->hasMaxLength)
    {
        while (octaspire_container_queue_get_length(self) > self->maxLength)
        {
            if (!octaspire_container_queue_pop(self))
            {
                return false;
            }
        }
    }

    return true;
}

octaspire_container_queue_t *octaspire_container_queue_new(
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_container_queue_element_callback_t const elementReleaseCallback,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_container_queue_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_queue_t));

    if (!self)
    {
        return self;
    }

    self->allocator    = allocator;
    self->hasMaxLength = false;
    self->maxLength    = 0;

    self->list = octaspire_container_list_new(
        elementSize,
        elementIsPointer,
        elementReleaseCallback,
        allocator);

    if (!self->list)
    {
        octaspire_container_queue_release(self);
        self = 0;
        return self;
    }

    return self;
}

octaspire_container_queue_t *octaspire_container_queue_new_with_max_length(
    size_t const maxLength,
    size_t const elementSize,
    bool const elementIsPointer,
    octaspire_container_queue_element_callback_t const elementReleaseCallback,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_container_queue_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_queue_t));

    if (!self)
    {
        return self;
    }

    self->allocator    = allocator;
    self->hasMaxLength = true;
    self->maxLength    = maxLength;

    self->list = octaspire_container_list_new(
        elementSize,
        elementIsPointer,
        elementReleaseCallback,
        allocator);

    if (!self->list)
    {
        octaspire_container_queue_release(self);
        self = 0;
        return self;
    }

    return self;
}

void octaspire_container_queue_release(octaspire_container_queue_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_container_list_release(self->list);
    self->list = 0;

    octaspire_helpers_verify_not_null(self->allocator);
    octaspire_memory_allocator_free(self->allocator, self);
}

void *octaspire_container_queue_peek(
    octaspire_container_queue_t * const self)
{
    octaspire_container_list_node_t * const node = octaspire_container_list_get_front(self->list);

    if (!node)
    {
        return 0;
    }

    return octaspire_container_list_node_get_element(node);
}

void const *octaspire_container_queue_peek_const(
    octaspire_container_queue_t const * const self)
{
    octaspire_container_list_node_t const * const node =
        octaspire_container_list_get_front(self->list);

    if (!node)
    {
        return 0;
    }

    return octaspire_container_list_node_get_element_const(node);
}

bool octaspire_container_queue_pop(
    octaspire_container_queue_t * const self)
{
    return octaspire_container_list_pop_front(self->list);
}

bool octaspire_container_queue_push(
    octaspire_container_queue_t *self,
    void const * const element)
{
    if (!octaspire_container_list_push_back(self->list, element))
    {
        return false;
    }

    return octaspire_container_queue_private_ensure_max_length(self);
}

bool octaspire_container_queue_clear(
    octaspire_container_queue_t * const self)
{
    return octaspire_container_list_clear(self->list);
}

size_t octaspire_container_queue_get_length(
    octaspire_container_queue_t const * const self)
{
    return octaspire_container_list_get_length(self->list);
}

bool octaspire_container_queue_is_empty(
    octaspire_container_queue_t const * const self)
{
    return octaspire_container_list_is_empty(self->list);
}

void *octaspire_container_queue_get_at(
    octaspire_container_queue_t * const self,
    size_t const index)
{
    octaspire_container_list_node_t * const node =
        octaspire_container_list_get_at(self->list, index);

    if (!node)
    {
        return 0;
    }

    return octaspire_container_list_node_get_element(node);
}

void const *octaspire_container_queue_get_at_const(
    octaspire_container_queue_t const * const self,
    size_t const index)
{
    octaspire_container_list_node_t const * const node =
        octaspire_container_list_get_at(self->list, index);

    if (!node)
    {
        return 0;
    }

    return octaspire_container_list_node_get_element_const(node);
}

size_t octaspire_container_queue_get_max_length(
    octaspire_container_queue_t const * const self)
{
    return self->maxLength;
}

bool octaspire_container_queue_has_max_length(
    octaspire_container_queue_t const * const self)
{
    return self->hasMaxLength;
}

bool octaspire_container_queue_set_max_length(
    octaspire_container_queue_t * const self,
    size_t maxLength)
{
    self->maxLength = maxLength;
    return octaspire_container_queue_private_ensure_max_length(self);
}

bool octaspire_container_queue_set_has_max_length(
    octaspire_container_queue_t * const self,
    bool hasMaxLength)
{
    self->hasMaxLength = hasMaxLength;
    return octaspire_container_queue_set_max_length(self, self->maxLength);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_container_queue.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_container_utf8_string.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_container_utf8_string_t
{
    octaspire_container_vector_t                   *octets;
    octaspire_container_vector_t                   *ucsCharacters;
    octaspire_memory_allocator_t                   *allocator;
    size_t                                          errorAtOctet;
    octaspire_container_utf8_string_error_status_t  errorStatus;
    bool                                            octetsAreUpToDate;
    char                                            padding[3];
};

static char const octaspire_container_utf8_string_private_null_octet = '\0';


// Prototypes for private functions /////////////////////////////////////////
static bool octaspire_container_utf8_string_private_check_substring_match_at(
    octaspire_container_utf8_string_t const * const self,
    size_t const startFromIndex,
    octaspire_container_utf8_string_t const * const substring);

static bool octaspire_container_utf8_string_private_is_string_at_index(
    octaspire_container_utf8_string_t const * const self,
    size_t const selfIndex,
    octaspire_container_utf8_string_t const * const str,
    size_t const strFirstIndex,
    size_t const strLastIndex);

static size_t octaspire_container_utf8_string_private_get_real_index_from_user_index(
    octaspire_container_utf8_string_t * const self,
    ptrdiff_t userIndex);

static bool octaspire_container_utf8_string_private_bring_octets_up_to_date(
    octaspire_container_utf8_string_t * const self);

//////////////////////////////////////////////////////////////////////////////


octaspire_container_utf8_string_t *octaspire_container_utf8_string_new(
    char const * const str,
    octaspire_memory_allocator_t *allocator)
{
    return octaspire_container_utf8_string_new_from_buffer(
        str,
        str ? strlen(str) : 0,
        allocator);
}

octaspire_container_utf8_string_t *octaspire_container_utf8_string_new_from_buffer(
    char const * const buffer,
    size_t const lengthInOctets,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_container_utf8_string_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_utf8_string_t));

    if (!self)
    {
        return 0;
    }

    self->allocator        = allocator;

    // We cannot know how many actual UCS characters there are in buffer, because
    // characters can be encoded between one and four octets. To speed up allocation,
    // without allocating too much space, we preallocate lengthInOctets / 4 characters.
    self->ucsCharacters    = octaspire_container_vector_new_with_preallocated_elements(
        sizeof(uint32_t),
        false,
        lengthInOctets / 4,
        0,
        self->allocator);

    if (!self->ucsCharacters)
    {
        octaspire_container_utf8_string_release(self);
        self = 0;
        return 0;
    }

    self->errorStatus       = OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK;
    self->octetsAreUpToDate = false;
    self->errorAtOctet      = 0;

    if (buffer && lengthInOctets)
    {
        size_t index = 0;
        uint32_t ucsChar = 0;
        int numOctets = 0;
        while (index < lengthInOctets)
        {
            // TODO XXX is (lengthInOctets - index) correct?
            octaspire_utf8_decode_status_t status =
                octaspire_utf8_decode_character(buffer + index, (lengthInOctets - index), &ucsChar, &numOctets);

            if (status != OCTASPIRE_UTF8_DECODE_STATUS_OK)
            {
                self->errorStatus  = OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_DECODING_ERROR;
                self->errorAtOctet = index;
                break;
            }

            if (numOctets > 0)
            {
                if (!octaspire_container_vector_push_back_element(self->ucsCharacters, &ucsChar))
                {
                    octaspire_container_utf8_string_release(self);
                    self = 0;
                    return 0;
                }

                index += (size_t)numOctets;
            }
        }
    }

    if (!octaspire_container_utf8_string_private_bring_octets_up_to_date(self))
    {
        octaspire_container_utf8_string_release(self);
        self = 0;
        return 0;
    }

    return self;
}

octaspire_container_utf8_string_t *octaspire_container_utf8_string_new_format(
    octaspire_memory_allocator_t *allocator,
    char const * const fmt,
    ...)
{
    va_list arguments;
    va_start(arguments, fmt);

    octaspire_container_utf8_string_t *result =
        octaspire_container_utf8_string_new_vformat(allocator, fmt, arguments);

    va_end(arguments);

    return result;
}

octaspire_container_utf8_string_t *octaspire_container_utf8_string_new_vformat(
    octaspire_memory_allocator_t *allocator,
    char const * const fmt,
    va_list arguments)
{
    va_list copyOfVarArgs;
    va_copy(copyOfVarArgs, arguments);

    octaspire_container_utf8_string_error_status_t errorStatus =
        OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK;

    size_t                                         errorAtOctet = 0;

    octaspire_container_utf8_string_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_utf8_string_t));

    if (!self)
    {
        return self;
    }

    self->allocator        = allocator;

    assert(self->allocator);

    self->octets            = 0;
    self->octetsAreUpToDate = false;
    self->ucsCharacters     = octaspire_container_vector_new(sizeof(uint32_t), false, 0, self->allocator);

    octaspire_container_utf8_string_reset_error_status(self);

    size_t buflen = 8;
    char *buffer = octaspire_memory_allocator_malloc(allocator, buflen);
    assert(buffer);

    octaspire_container_vector_t *vec2 = octaspire_container_vector_new(
        sizeof(char),
        false,
        0,
        allocator);

    assert(vec2);

    int negativeResultCounter = -1;

    bool firstRound = true;
    while (true)
    {
        if (negativeResultCounter > 1000)
        {
            errorStatus = OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_ENCODING_ERROR;
            // TODO XXX what octet index to put here? Negative index, or just unused on this error type?
            errorAtOctet = 0;
            break;
        }

        int n = 0;

        if (firstRound)
        {
            firstRound = false;
        }
        else
        {
            va_copy(copyOfVarArgs, arguments);
        }

#ifdef OCTASPIRE_CLANG_PRAGMAS_ENABLED
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wformat-nonliteral"
#endif
        n = vsnprintf(
            buffer,
            buflen,
            fmt,
            copyOfVarArgs);

#ifdef OCTASPIRE_CLANG_PRAGMAS_ENABLED
#pragma clang diagnostic pop
#endif

        va_end(copyOfVarArgs);

        if (n < 0)
        {
            // Encoding error in C99 or, on older glibc, the output was truncated.
            // Try again with more space. Because we don't know how much
            // space is required, lets double it (and make sure that the length is not zero). Because we don't know
            // is the reason for failure an encoding error or missing space,
            // we will start counting to prevent looping forever.
            ++negativeResultCounter;

            buflen *= 2;
            char *tmpPtr = octaspire_memory_allocator_realloc(allocator, buffer, buflen);
            //char *tmpPtr = realloc(buffer, buflen);

            if (tmpPtr)
            {
                buffer = tmpPtr;
                memset(buffer, 0, buflen);
            }
            else
            {
                //free(buffer);
                octaspire_memory_allocator_free(allocator, buffer);
                buffer = 0;
                return 0;
            }
        }
        else if ((size_t)n >= buflen)
        {
            // TODO calculate exact size

            buflen *= 2;
            char *tmpPtr = octaspire_memory_allocator_realloc(allocator, buffer, buflen);
            //char *tmpPtr = realloc(buffer, buflen);

            if (tmpPtr)
            {
                buffer = tmpPtr;
                memset(buffer, 0, buflen);
            }
            else
            {
                //free(buffer);
                octaspire_memory_allocator_free(allocator, buffer);
                buffer = 0;
                return 0;
            }
        }
        else if (n > 0)
        {
            assert((size_t)n < buflen);
            // Success
            for (size_t i = 0; i < (size_t)n; ++i)
            {
                char const c = buffer[i];

                octaspire_container_vector_push_back_element(vec2, &c);
            }

            if (!octaspire_container_vector_push_back_char(
                    vec2,
                    octaspire_container_utf8_string_private_null_octet))
            {
                abort();
            }

            break;
        }
        else
        {
            // Empty string
            break;
            //assert(false);
        }
    }

    //assert(!octaspire_container_vector_is_empty(vec2));

    if (!octaspire_container_vector_push_back_char(vec2, octaspire_container_utf8_string_private_null_octet))
    {
        abort();
    }

    octaspire_container_utf8_string_t *tmpStr = octaspire_container_utf8_string_new(
        octaspire_container_vector_get_element_at(vec2, 0),
        allocator);

    octaspire_container_utf8_string_release(self);
    self = tmpStr;

    assert(self);

    if (!octaspire_container_utf8_string_is_error(self))
    {
        if (errorStatus != OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK)
        {
            self->errorStatus  = errorStatus;
            self->errorAtOctet = errorAtOctet;
        }
    }

    octaspire_memory_allocator_free(allocator, buffer);
    //free(buffer);
    buffer = 0;

    octaspire_container_vector_release(vec2);
    vec2 = 0;

    if (!octaspire_container_utf8_string_private_bring_octets_up_to_date(self))
    {
        // TODO
        abort();
    }

    return self;
}

octaspire_container_utf8_string_t *octaspire_container_utf8_string_new_copy(
    octaspire_container_utf8_string_t const * const other,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_container_utf8_string_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_utf8_string_t));

    if (!self)
    {
        return self;
    }

    self->octets            = octaspire_container_vector_new_shallow_copy(other->octets, allocator);
    self->octetsAreUpToDate = other->octetsAreUpToDate;
    self->ucsCharacters     = octaspire_container_vector_new_shallow_copy(other->ucsCharacters, allocator);
    self->errorStatus       = other->errorStatus;
    self->errorAtOctet      = other->errorAtOctet;
    self->allocator         = allocator;

    if (!octaspire_container_utf8_string_private_bring_octets_up_to_date(self))
    {
        // TODO
        abort();
    }

    return self;
}

octaspire_container_utf8_string_t *octaspire_container_utf8_string_new_substring_from_given_index_and_length(
    octaspire_container_utf8_string_t const * const other,
    octaspire_memory_allocator_t *allocator,
    size_t const ucsCharStartIndex,
    size_t const lengthInUcsChars)
{
    assert(other);
    assert(allocator);

    size_t const endIndex = ucsCharStartIndex + lengthInUcsChars;

    if (endIndex >= octaspire_container_utf8_string_get_length_in_ucs_characters(other))
    {
        return 0;
    }

    octaspire_container_utf8_string_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_utf8_string_t));

    if (!self)
    {
        return self;
    }

    self->allocator         = allocator;
    self->octets            = 0;
    self->octetsAreUpToDate = false;

    self->ucsCharacters     = octaspire_container_vector_new_with_preallocated_elements(
        sizeof(uint32_t),
        false,
        lengthInUcsChars,
        0,
        self->allocator);

    if (!self->ucsCharacters)
    {
        octaspire_container_utf8_string_release(self);
        self = 0;
        return 0;
    }

    self->errorStatus   = OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK;
    self->errorAtOctet  = 0;

    for (size_t i = 0; i < lengthInUcsChars; ++i)
    {
        octaspire_container_utf8_string_push_back_ucs_character(
            self,
            octaspire_container_utf8_string_get_ucs_character_at_index(
                other,
                ucsCharStartIndex + i));
    }

    if (!octaspire_container_utf8_string_private_bring_octets_up_to_date(self))
    {
        octaspire_container_utf8_string_release(self);
        self = 0;
        return 0;
    }

    return self;
}

void octaspire_container_utf8_string_release(octaspire_container_utf8_string_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_container_vector_release(self->octets);
    octaspire_container_vector_release(self->ucsCharacters);

    octaspire_memory_allocator_free(self->allocator, self);
}

bool octaspire_container_utf8_string_is_empty(
    octaspire_container_utf8_string_t const * const self)
{
    return octaspire_container_utf8_string_get_length_in_ucs_characters(self) == 0;
}

size_t octaspire_container_utf8_string_get_length_in_ucs_characters(
    octaspire_container_utf8_string_t const * const self)
{
    assert(self);
    return octaspire_container_vector_get_length(self->ucsCharacters);
}

size_t octaspire_container_utf8_string_get_length_in_octets(
    octaspire_container_utf8_string_t const * const self)
{
    octaspire_helpers_verify_true(self->octetsAreUpToDate);
    assert(!octaspire_container_vector_is_empty(self->octets));
    assert(*(char const*)octaspire_container_vector_peek_back_element_const(self->octets) == '\0');
    // Subtract one because of '\0' at the end
    return octaspire_container_vector_get_length(self->octets) - 1;
}

uint32_t octaspire_container_utf8_string_get_ucs_character_at_index(
    octaspire_container_utf8_string_t const * const self, size_t const index)
{
    assert(index < octaspire_container_utf8_string_get_length_in_ucs_characters(self));
    return *(uint32_t*)octaspire_container_vector_get_element_at(self->ucsCharacters, index);
}

char const * octaspire_container_utf8_string_get_c_string(
    octaspire_container_utf8_string_t const * const self)
{
    octaspire_helpers_verify_true(self->octetsAreUpToDate);
    assert(!octaspire_container_vector_is_empty(self->octets));
    assert(*(char const*)octaspire_container_vector_peek_back_element_const(self->octets) == '\0');
    return octaspire_container_vector_peek_front_element_const(self->octets);
}

bool octaspire_container_utf8_string_is_error(
    octaspire_container_utf8_string_t const * const self)
{
    return self->errorStatus != OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK;
}

octaspire_container_utf8_string_error_status_t octaspire_container_utf8_string_get_error_status(
    octaspire_container_utf8_string_t const * const self)
{
    return self->errorStatus;
}

size_t octaspire_container_utf8_string_get_error_position_in_octets(
    octaspire_container_utf8_string_t const * const self)
{
    return self->errorAtOctet;
}

void octaspire_container_utf8_string_reset_error_status(
    octaspire_container_utf8_string_t * const self)
{
    self->errorStatus   = OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK;
    self->errorAtOctet  = 0;
}

bool octaspire_container_utf8_string_concatenate(
    octaspire_container_utf8_string_t * const self,
    octaspire_container_utf8_string_t const * const other)
{
    return octaspire_container_utf8_string_concatenate_c_string(
        self,
        octaspire_container_utf8_string_get_c_string(other));
}

bool octaspire_container_utf8_string_concatenate_c_string(
    octaspire_container_utf8_string_t * const self,
    char const * const str)
{
    octaspire_container_utf8_string_reset_error_status(self);

    if (!str || str[0] == '\0')
    {
        return true;
    }

    self->octetsAreUpToDate = false;

    size_t const strLen = strlen(str);

    bool result = true;

    size_t index = 0;
    uint32_t ucsChar = 0;
    int numOctets = 0;
    while (str[index] != '\0')
    {
        octaspire_utf8_decode_status_t status =
            octaspire_utf8_decode_character(str + index, (strLen - index), &ucsChar, &numOctets);

        assert(numOctets >= 0);

        if (status != OCTASPIRE_UTF8_DECODE_STATUS_OK)
        {
            self->errorStatus  = OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_DECODING_ERROR;
            self->errorAtOctet = index;
            break;
        }

        if (!octaspire_container_vector_push_back_element(self->ucsCharacters, &ucsChar))
        {
            result = false;
        }

        index += (size_t)numOctets;
    }

    if (!octaspire_container_utf8_string_private_bring_octets_up_to_date(self))
    {
        result = false;
    }

    return result;
}

bool octaspire_container_utf8_string_concatenate_format(
    octaspire_container_utf8_string_t * const self,
    char const * const fmt,
    ...)
{
    va_list arguments;
    va_start(arguments, fmt);

    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_vformat(self->allocator, fmt, arguments);

    va_end(arguments);

    if (!str)
    {
        return false;
    }

    self->octetsAreUpToDate = false;

    bool result = octaspire_container_utf8_string_concatenate_c_string(
        self,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    if (!octaspire_container_utf8_string_private_bring_octets_up_to_date(self))
    {
        result = false;
    }

    return result;
}

bool octaspire_container_utf8_string_private_check_substring_match_at(
    octaspire_container_utf8_string_t const * const self,
    size_t const startFromIndex,
    octaspire_container_utf8_string_t const * const substring)
{
    size_t const selfLength = octaspire_container_utf8_string_get_length_in_ucs_characters(self);

    size_t const substringLength =
        octaspire_container_utf8_string_get_length_in_ucs_characters(substring);

    for (size_t i = 0; i < substringLength; ++i)
    {
        if ((startFromIndex + i) >= selfLength)
        {
            return false;
        }

        if (octaspire_container_utf8_string_get_ucs_character_at_index(self, startFromIndex + i) !=
            octaspire_container_utf8_string_get_ucs_character_at_index(substring, i))
        {
            return false;
        }
    }

    return true;
}

ptrdiff_t octaspire_container_utf8_string_find_first_substring(
    octaspire_container_utf8_string_t const * const self,
    size_t const startFromIndex,
    octaspire_container_utf8_string_t const * const substring)
{
    size_t const selfLength = octaspire_container_utf8_string_get_length_in_ucs_characters(self);

    for (size_t i = startFromIndex; i < (startFromIndex + selfLength); ++i)
    {
        if (octaspire_container_utf8_string_private_check_substring_match_at(self, i, substring))
        {
            return (ptrdiff_t)i;
        }
    }

    return -1;
}

bool octaspire_container_utf8_string_remove_character_at(
    octaspire_container_utf8_string_t * const self,
    size_t const index)
{
    if (index >= octaspire_container_utf8_string_get_length_in_ucs_characters(self))
    {
        return false;
    }

    self->octetsAreUpToDate = false;

    if (!octaspire_container_vector_remove_element_at(self->ucsCharacters, index))
    {
        assert(false);
        return false;
    }

    return octaspire_container_utf8_string_private_bring_octets_up_to_date(self);
}

size_t octaspire_container_utf8_string_remove_characters_at(
    octaspire_container_utf8_string_t * const self,
    size_t const startFromIndex,
    size_t const numCharacters)
{
    assert(numCharacters);

    self->octetsAreUpToDate = false;

    size_t result = 0;

    for (ptrdiff_t i = (ptrdiff_t)numCharacters - 1; i >= 0; --i)
    {
        if (octaspire_container_utf8_string_remove_character_at(self, startFromIndex + (size_t)i))
        {
            ++result;
        }
    }

    if (!octaspire_container_utf8_string_private_bring_octets_up_to_date(self))
    {
        abort();
    }

    return result;
}

size_t octaspire_container_utf8_string_remove_all_substrings(
    octaspire_container_utf8_string_t * const self,
    octaspire_container_utf8_string_t const * const substring)
{
    self->octetsAreUpToDate = false;

    size_t result = 0;

    size_t const substringLength =
        octaspire_container_utf8_string_get_length_in_ucs_characters(substring);

    while (true)
    {
        if (octaspire_container_utf8_string_is_empty(self))
        {
            if (!octaspire_container_utf8_string_private_bring_octets_up_to_date(self))
            {
                // TODO
                abort();
            }

            return result;
        }

        ptrdiff_t const substringIndex =
            octaspire_container_utf8_string_find_first_substring(self, 0, substring);

        if (substringIndex < 0)
        {
            if (!octaspire_container_utf8_string_private_bring_octets_up_to_date(self))
            {
                // TODO
                abort();
            }

            return result;
        }

        if (octaspire_container_utf8_string_remove_characters_at(self, (size_t)substringIndex, substringLength))
        {
            ++result;
        }
    }
}

bool octaspire_container_utf8_string_clear(
    octaspire_container_utf8_string_t * const self)
{
    self->errorStatus       = OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK;
    self->errorAtOctet      = 0;
    self->octetsAreUpToDate = false;

    bool const result = octaspire_container_vector_clear(self->ucsCharacters);

    if (!octaspire_container_utf8_string_private_bring_octets_up_to_date(self))
    {
        return false;
    }

    return result;
}

bool octaspire_container_utf8_string_is_equal(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const other)
{
    assert(self);
    assert(other);

    size_t const myLen = octaspire_container_utf8_string_get_length_in_ucs_characters(self);

    if (myLen != octaspire_container_utf8_string_get_length_in_ucs_characters(other))
    {
        return false;
    }

    for (size_t i = 0; i < myLen; ++i)
    {
        uint32_t ucsChar1 =
            *(uint32_t const * const)octaspire_container_vector_get_element_at(self->ucsCharacters, i);

        uint32_t ucsChar2 =
            *(uint32_t const * const)octaspire_container_vector_get_element_at(other->ucsCharacters, i);

        if (ucsChar1 != ucsChar2)
        {
            return false;
        }

    }

    return true;
}

bool octaspire_container_utf8_string_is_equal_to_c_string(
    octaspire_container_utf8_string_t const * const self,
    char const * const str)
{
    assert(self);
    assert(str);

    octaspire_helpers_verify_true(self->octetsAreUpToDate);
    assert(!octaspire_container_vector_is_empty(self->octets));
    assert(*(char const*)octaspire_container_vector_peek_back_element_const(self->octets) == '\0');

    size_t const len = octaspire_container_utf8_string_get_length_in_octets(self);

    if (strlen(str) != len)
    {
        return false;
    }

    return memcmp(octaspire_container_vector_get_element_at(self->octets,  0), str, len) == 0;
}

int octaspire_container_utf8_string_compare(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const other)
{
    assert(self);
    assert(other);

    return octaspire_container_utf8_string_compare_to_c_string(
        self,
        octaspire_container_utf8_string_get_c_string(other));
}

int octaspire_container_utf8_string_compare_to_c_string(
    octaspire_container_utf8_string_t const * const self,
    char const * const str)
{
    assert(self);
    assert(str);

    octaspire_helpers_verify_true(self->octetsAreUpToDate);
    assert(!octaspire_container_vector_is_empty(self->octets));
    assert(*(char const*)octaspire_container_vector_peek_back_element_const(self->octets) == '\0');

    return strcmp(octaspire_container_utf8_string_get_c_string(self), str);
}

bool octaspire_container_utf8_string_starts_with(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const other)
{
    assert(self && other);

    size_t const myLen = octaspire_container_utf8_string_get_length_in_ucs_characters(self);
    size_t const otherLen = octaspire_container_utf8_string_get_length_in_ucs_characters(other);

    if (myLen < otherLen)
    {
        return false;
    }

    for (size_t i = 0; i < otherLen; ++i)
    {
        if (octaspire_container_utf8_string_get_ucs_character_at_index(self,  i) !=
            octaspire_container_utf8_string_get_ucs_character_at_index(other, i))
        {
            return false;
        }
    }

    return true;
}

bool octaspire_container_utf8_string_ends_with(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const other)
{
    assert(self && other);

    size_t const myLen = octaspire_container_utf8_string_get_length_in_ucs_characters(self);
    size_t const otherLen = octaspire_container_utf8_string_get_length_in_ucs_characters(other);

    if (myLen < otherLen)
    {
        return false;
    }

    size_t const myStartIndex = myLen - otherLen;

    for (size_t i = 0; i < otherLen; ++i)
    {
        if (octaspire_container_utf8_string_get_ucs_character_at_index(self, myStartIndex + i) !=
            octaspire_container_utf8_string_get_ucs_character_at_index(other, i))
        {
            return false;
        }
    }

    return true;
}

uint32_t octaspire_container_utf8_string_get_hash(
    octaspire_container_utf8_string_t const * const self)
{
    uint32_t hash = 0;

    octaspire_helpers_verify_true(self->octetsAreUpToDate);
    assert(!octaspire_container_vector_is_empty(self->octets));
    assert(*(char const*)octaspire_container_vector_peek_back_element_const(self->octets) == '\0');

    size_t const len = octaspire_container_vector_get_length(self->octets);

    if (!octaspire_container_vector_is_empty(self->octets))
    {
        hash = jenkins_one_at_a_time_hash(
            octaspire_container_vector_get_element_at(self->octets, 0), len);
    }

    return hash;
}

bool octaspire_container_utf8_string_push_back_ucs_character(
    octaspire_container_utf8_string_t *self,
    uint32_t const character)
{
    assert(self);

    if (!octaspire_container_vector_push_back_element(self->ucsCharacters, &character))
    {
        return false;
    }

    self->octetsAreUpToDate = false;

    return octaspire_container_utf8_string_private_bring_octets_up_to_date(self);
}

bool octaspire_container_utf8_string_pop_back_ucs_character(
    octaspire_container_utf8_string_t *self)
{
    assert(self);

    if (octaspire_container_utf8_string_is_empty(self))
    {
        return false;
    }

    self->octetsAreUpToDate = false;

    bool const result = octaspire_container_utf8_string_remove_character_at(
        self,
        octaspire_container_utf8_string_get_length_in_ucs_characters(self) - 1);

    if (!octaspire_container_utf8_string_private_bring_octets_up_to_date(self))
    {
        return false;
    }

    return result;
}

bool octaspire_container_utf8_string_insert_string_to(
    octaspire_container_utf8_string_t * const self,
    octaspire_container_utf8_string_t const * const str,
    ptrdiff_t const indexToPutFirstCharacter)
{
    size_t const index =
        octaspire_container_utf8_string_private_get_real_index_from_user_index(
            self,
            indexToPutFirstCharacter);

    if (index >= octaspire_container_utf8_string_get_length_in_ucs_characters(self))
    {
        return false;
    }

    self->octetsAreUpToDate = false;

    for (size_t i = 0; i < octaspire_container_utf8_string_get_length_in_ucs_characters(str); ++i)
    {
        uint32_t const c = octaspire_container_utf8_string_get_ucs_character_at_index(str, i);

        if (!octaspire_container_vector_insert_element_before_the_element_at_index(
            self->ucsCharacters,
            &c,
            (ptrdiff_t)(index + i)))
        {
            return false;
        }
    }

    return octaspire_container_utf8_string_private_bring_octets_up_to_date(self);
}

bool octaspire_container_utf8_string_overwrite_with_string_at(
    octaspire_container_utf8_string_t * const self,
    octaspire_container_utf8_string_t const * const str,
    ptrdiff_t const indexToPutFirstCharacter)
{
    self->octetsAreUpToDate = false;

    size_t const index =
        octaspire_container_utf8_string_private_get_real_index_from_user_index(
            self,
            indexToPutFirstCharacter);

    for (size_t i = 0; i < octaspire_container_utf8_string_get_length_in_ucs_characters(str); ++i)
    {
        uint32_t const c = octaspire_container_utf8_string_get_ucs_character_at_index(str, i);

        if (!octaspire_container_vector_replace_element_at_index_or_push_back(
            self->ucsCharacters,
            &c,
            (ptrdiff_t)(index + i)))
        {
            octaspire_container_utf8_string_private_bring_octets_up_to_date(self);
            return false;
        }
    }

    return octaspire_container_utf8_string_private_bring_octets_up_to_date(self);
}

octaspire_container_vector_t *octaspire_container_utf8_string_split(
    octaspire_container_utf8_string_t *self,
    char const * const delimiter)
{
    octaspire_container_utf8_string_t *delimString = octaspire_container_utf8_string_new(
        delimiter,
        self->allocator);

    if (!delimString)
    {
        return 0;
    }

    octaspire_container_vector_t *result = octaspire_container_vector_new(
        sizeof(octaspire_container_utf8_string_t*),
        true,
        (octaspire_container_vector_element_callback_t)octaspire_container_utf8_string_release,
        self->allocator);

    if (!result)
    {
        octaspire_container_utf8_string_release(delimString);
        delimString = 0;
        return 0;
    }

    octaspire_container_utf8_string_t *collectorString = octaspire_container_utf8_string_new(
        "",
        self->allocator);

    if (!collectorString)
    {
        octaspire_container_utf8_string_release(delimString);
        delimString = 0;

        octaspire_container_vector_release(result);
        result = 0;
        return 0;
    }

    for (size_t i = 0; i < octaspire_container_utf8_string_get_length_in_ucs_characters(self); ++i)
    {
        octaspire_container_utf8_string_push_back_ucs_character(
            collectorString,
            octaspire_container_utf8_string_get_ucs_character_at_index(self, i));

        if (octaspire_container_utf8_string_is_equal(collectorString, delimString))
        {
            octaspire_container_utf8_string_clear(collectorString);
        }
        else if (octaspire_container_utf8_string_ends_with(collectorString, delimString))
        {
            size_t const numUcsCharsToGet =
                octaspire_container_utf8_string_get_length_in_ucs_characters(collectorString) -
                octaspire_container_utf8_string_get_length_in_ucs_characters(delimString);

            octaspire_container_utf8_string_t *token =
                octaspire_container_utf8_string_new_substring_from_given_index_and_length(
                    collectorString,
                    collectorString->allocator,
                    0,
                    numUcsCharsToGet);

            assert(token);

            octaspire_container_vector_push_back_element(result, &token);

            octaspire_container_utf8_string_clear(collectorString);
        }
    }

    if (!octaspire_container_utf8_string_is_empty(collectorString))
    {
        if (octaspire_container_utf8_string_is_equal(collectorString, delimString))
        {
            octaspire_container_utf8_string_clear(collectorString);
        }
        else if (octaspire_container_utf8_string_ends_with(collectorString, delimString))
        {
            size_t const numUcsCharsToGet =
                octaspire_container_utf8_string_get_length_in_ucs_characters(collectorString) -
                octaspire_container_utf8_string_get_length_in_ucs_characters(delimString);

            octaspire_container_utf8_string_t *token =
                octaspire_container_utf8_string_new_substring_from_given_index_and_length(
                    collectorString,
                    collectorString->allocator,
                    0,
                    numUcsCharsToGet);

            assert(token);

            octaspire_container_vector_push_back_element(result, &token);

            octaspire_container_utf8_string_clear(collectorString);
        }
        else
        {
            octaspire_container_utf8_string_t *token =
                octaspire_container_utf8_string_new_copy(
                    collectorString,
                    collectorString->allocator);

            assert(token);

            octaspire_container_vector_push_back_element(result, &token);

            octaspire_container_utf8_string_clear(collectorString);
        }

        octaspire_container_utf8_string_clear(collectorString);
    }

    octaspire_container_utf8_string_release(collectorString);
    collectorString = 0;

    octaspire_container_utf8_string_release(delimString);
    delimString = 0;

    return result;
}

bool octaspire_container_utf8_string_contains_char(
    octaspire_container_utf8_string_t const * const self,
    uint32_t const character)
{
    for (size_t i = 0; i < octaspire_container_utf8_string_get_length_in_ucs_characters(self); ++i)
    {
        if (octaspire_container_utf8_string_get_ucs_character_at_index(self, i) == character)
        {
            return true;
        }
    }

    return false;
}

bool octaspire_container_utf8_string_contains_only_these_chars(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const chars)
{
    for (size_t i = 0; i < octaspire_container_utf8_string_get_length_in_ucs_characters(self); ++i)
    {
        uint32_t const selfChar = octaspire_container_utf8_string_get_ucs_character_at_index(self,  i);

        bool found = false;

        for (size_t j = 0; j < octaspire_container_utf8_string_get_length_in_ucs_characters(chars); ++j)
        {
            if (octaspire_container_utf8_string_get_ucs_character_at_index(chars, j) == selfChar)
            {
                found = true;
                break;
            }
        }

        if (!found)
        {
            return false;
        }
    }

    return true;
}

octaspire_container_vector_t *octaspire_container_utf8_string_find_char(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const character,
    size_t const characterIndex)
{
    if (octaspire_container_utf8_string_get_length_in_ucs_characters(character) <= characterIndex)
    {
        return 0;
    }

    octaspire_container_vector_t *result = octaspire_container_vector_new(
        sizeof(size_t),
        false,
        0,
        self->allocator);

    for (size_t i = 0; i < octaspire_container_utf8_string_get_length_in_ucs_characters(self); ++i)
    {
        if (octaspire_container_utf8_string_get_ucs_character_at_index(self, i) ==
            octaspire_container_utf8_string_get_ucs_character_at_index(character, characterIndex))
        {
            octaspire_container_vector_push_back_element(result, &i);
        }
    }

    return result;
}

static size_t octaspire_container_utf8_string_private_get_real_index_from_user_index(
    octaspire_container_utf8_string_t * const self,
    ptrdiff_t userIndex)
{
    size_t realIndex = 0;

    if (userIndex < 0)
    {
        realIndex = (size_t)
            ((ptrdiff_t)octaspire_container_utf8_string_get_length_in_ucs_characters(self) +
            userIndex);
    }
    else
    {
        realIndex = (size_t)userIndex;
    }

    return realIndex;
}

static bool octaspire_container_utf8_string_private_bring_octets_up_to_date(
    octaspire_container_utf8_string_t * const self)
{
    if (!self->octets)
    {
        self->octets = octaspire_container_vector_new_with_preallocated_elements(
            sizeof(char),
            false,
            octaspire_container_vector_get_length(self->ucsCharacters),
            0,
            self->allocator);
    }

    if (!self->octets)
    {
        return false;
    }

    if (!octaspire_container_vector_clear(self->octets))
    {
        return false;
    }

    for (size_t i = 0; i < octaspire_container_vector_get_length(self->ucsCharacters); ++i)
    {
        octaspire_utf8_character_t encoded;

        uint32_t const ucsChar = *(uint32_t const * const)
            octaspire_container_vector_get_element_at_const(self->ucsCharacters, i);

        octaspire_utf8_encode_status_t const status = octaspire_utf8_encode_character(
            ucsChar,
            &encoded);

        if (status != OCTASPIRE_UTF8_ENCODE_STATUS_OK)
        {
            return false;
        }

        for (size_t j = 0; j < encoded.numoctets; ++j)
        {
            if (!octaspire_container_vector_push_back_element(
                    self->octets,
                    encoded.octets + 4 - encoded.numoctets + j))
            {
                return false;
            }
        }
    }

    // Append null byte to allow use with libc
    if (!octaspire_container_vector_push_back_element(
        self->octets,
        &octaspire_container_utf8_string_private_null_octet))
    {
        return false;
    }

    self->octetsAreUpToDate = true;
    return true;
}

bool octaspire_container_utf8_string_private_is_string_at_index(
    octaspire_container_utf8_string_t const * const self,
    size_t const selfIndex,
    octaspire_container_utf8_string_t const * const str,
    size_t const strFirstIndex,
    size_t const strLastIndex)
{
    size_t selfIndex2 = selfIndex;
    for (size_t i = strFirstIndex; i <= strLastIndex; ++i)
    {
        if (selfIndex2 >= octaspire_container_utf8_string_get_length_in_ucs_characters(self))
        {
            return false;
        }

        if (octaspire_container_utf8_string_get_ucs_character_at_index(self, selfIndex2) !=
            octaspire_container_utf8_string_get_ucs_character_at_index(str, i))
        {
            return false;
        }

        ++selfIndex2;
    }

    return true;
}

octaspire_container_vector_t *octaspire_container_utf8_string_find_string(
    octaspire_container_utf8_string_t const * const self,
    octaspire_container_utf8_string_t const * const str,
    size_t const strStartIndex,
    size_t const strLength)
{
    if (!strLength)
    {
        return 0;
    }

    if (strStartIndex >= octaspire_container_utf8_string_get_length_in_ucs_characters(str))
    {
        return 0;
    }

    size_t const strEndIndex = strStartIndex + (strLength - 1);

    if (strEndIndex >= octaspire_container_utf8_string_get_length_in_ucs_characters(str))
    {
        return 0;
    }

    octaspire_container_vector_t *result = octaspire_container_vector_new(
        sizeof(size_t),
        false,
        0,
        self->allocator);

    for (size_t i = 0; i < octaspire_container_utf8_string_get_length_in_ucs_characters(self); ++i)
    {
        if (octaspire_container_utf8_string_private_is_string_at_index(
            self,
            i,
            str,
            strStartIndex,
            strEndIndex))
        {
            octaspire_container_vector_push_back_element(result, &i);
        }
    }

    return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_container_utf8_string.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_container_pair.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_container_pair_t
{
    void   *first;
    void   *second;
    size_t firstSize;
    size_t secondSize;
    octaspire_container_pair_element_callback_t firstReleaseCallback;
    octaspire_container_pair_element_callback_t secondReleaseCallback;
    octaspire_memory_allocator_t *allocator;
    bool   firstIsPointer;
    bool   secondIsPointer;
    char   padding[6];
};

size_t octaspire_container_pair_t_get_sizeof(void)
{
    return sizeof(octaspire_container_pair_t);
}

octaspire_container_pair_t *octaspire_container_pair_new(
    size_t const firstElementSize,
    bool const firstElementIsPointer,
    size_t const secondElementSize,
    bool const secondElementIsPointer,
    octaspire_container_pair_element_callback_t firstElementReleaseCallback,
    octaspire_container_pair_element_callback_t secondElementReleaseCallback,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_container_pair_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_pair_t));

    if (!self)
    {
        return self;
    }

    self->allocator             = allocator;
    self->first                 = 0;
    self->second                = 0;
    self->firstSize             = firstElementSize;
    self->firstIsPointer        = firstElementIsPointer;
    self->secondSize            = secondElementSize;
    self->secondIsPointer       = secondElementIsPointer;
    self->firstReleaseCallback  = firstElementReleaseCallback;
    self->secondReleaseCallback = secondElementReleaseCallback;

    self->first = octaspire_memory_allocator_malloc(self->allocator, self->firstSize);

    if (!self->first)
    {
        octaspire_container_pair_release(self);
        self = 0;
        return 0;
    }

    self->second = octaspire_memory_allocator_malloc(self->allocator, self->secondSize);

    if (!self->second)
    {
        octaspire_container_pair_release(self);
        self = 0;
        return 0;
    }

    return self;
}

octaspire_container_pair_t *octaspire_container_pair_new_shallow_copy(
    octaspire_container_pair_t   *other,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_container_pair_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_pair_t));

    if (!self)
    {
        return self;
    }

    self->allocator = allocator;
    self->first                 = 0;
    self->second                = 0;
    self->firstSize             = other->firstSize;
    self->firstIsPointer        = other->firstIsPointer;
    self->secondSize            = other->secondSize;
    self->secondIsPointer       = other->secondIsPointer;
    self->firstReleaseCallback  = other->firstReleaseCallback;
    self->secondReleaseCallback = other->secondReleaseCallback;

    self->first  = octaspire_memory_allocator_malloc(self->allocator, self->firstSize);

    if (!self->first)
    {
        octaspire_container_pair_release(self);
        self = 0;
        return 0;
    }

    self->second = octaspire_memory_allocator_malloc(self->allocator, self->secondSize);

    if (!self->second)
    {
        octaspire_container_pair_release(self);
        self = 0;
        return 0;
    }

    if (self->first != memcpy(self->first,  other->first,  self->firstSize))
    {
        octaspire_container_pair_release(self);
        self = 0;
        return 0;
    }

    if (self->second != memcpy(self->second, other->second, self->secondSize))
    {
        octaspire_container_pair_release(self);
        self = 0;
        return 0;
    }

    return self;
}

void octaspire_container_pair_release(octaspire_container_pair_t *self)
{
    if (!self)
    {
        return;
    }

    if (self->firstReleaseCallback)
    {
        if (self->firstIsPointer)
        {
            if (self->first)
            {
                (self->firstReleaseCallback)(*(void**)self->first);
            }
        }
        else
        {
            (self->firstReleaseCallback)(self->first);
        }
    }

    if (self->first)
    {
        octaspire_memory_allocator_free(self->allocator, self->first);
        self->first = 0;
    }

    if (self->secondReleaseCallback)
    {
        if (self->secondIsPointer)
        {
            if (self->second)
            {
                (self->secondReleaseCallback)(*(void**)self->second);
            }
        }
        else
        {
            (self->secondReleaseCallback)(self->second);
        }
    }

    if (self->second)
    {
        octaspire_memory_allocator_free(self->allocator, self->second);
        self->second = 0;
    }

    octaspire_memory_allocator_free(self->allocator, self);
}

void *octaspire_container_pair_get_first(octaspire_container_pair_t *self)
{
    return self->firstIsPointer ? (*(void**)self->first) : self->first;
}

void const *octaspire_container_pair_get_first_const(octaspire_container_pair_t const * const self)
{
    return self->firstIsPointer ? (*(void const **)self->first) : self->first;
}

void *octaspire_container_pair_get_second(octaspire_container_pair_t *self)
{
    return self->secondIsPointer ? (*(void**)self->second) : self->second;
}

void const *octaspire_container_pair_get_second_const(octaspire_container_pair_t const * const self)
{
    return self->secondIsPointer ? (*(void const **)self->second) : self->second;
}

size_t octaspire_container_pair_get_size_of_first_element_in_octets(
    octaspire_container_pair_t const * const self)
{
    return self->firstSize;
}

size_t octaspire_container_pair_get_size_of_second_element_in_octets(
    octaspire_container_pair_t const * const self)
{
    return self->secondSize;
}

void octaspire_container_pair_set(
    octaspire_container_pair_t *self,
    void const *first,
    void const *second)
{
    octaspire_container_pair_set_first( self, first);
    octaspire_container_pair_set_second(self, second);
}

void octaspire_container_pair_set_first(
    octaspire_container_pair_t *self,
    void const *first)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(first);
    if (self->first != memcpy(self->first,  first,  self->firstSize))
    {
        abort();
    }
}

void octaspire_container_pair_set_second(
    octaspire_container_pair_t *self,
    void const *second)
{
    if (self->second != memcpy(self->second, second, self->secondSize))
    {
        abort();
    }
}

bool octaspire_container_pair_set_first_to_void_pointer(
    octaspire_container_pair_t *self,
    void *element)
{
    if (self->firstSize != sizeof(element))
    {
        return false;
    }

    octaspire_container_pair_set_first(self, &element);

    return true;
}

bool octaspire_container_pair_set_second_to_void_pointer(
    octaspire_container_pair_t *self,
    void *element)
{
    if (self->secondSize != sizeof(element))
    {
        return false;
    }

    octaspire_container_pair_set_second(self, &element);

    return true;
}

void octaspire_container_pair_clear(
    octaspire_container_pair_t * const self)
{
    if (self->first != memset(self->first,  0, self->firstSize))
    {
        abort();
    }

    if (self->second != memset(self->second, 0, self->secondSize))
    {
        abort();
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_container_pair.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_container_hash_map.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/



struct octaspire_container_hash_map_element_t
{
    size_t                        keySizeInOctets;
    void                         *key;
    size_t                        valueSizeInOctets;
    octaspire_container_vector_t *values;
    octaspire_memory_allocator_t *allocator;
    uint32_t                      hash;
    bool                          keyIsPointer;
    bool                          valueIsPointer;
    char                          padding[2];
};

octaspire_container_hash_map_element_t *octaspire_container_hash_map_element_new(
    uint32_t const hash,
    size_t const keySizeInOctets,
    bool const keyIsPointer,
    void const * const key,
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    void const * const value,
    octaspire_memory_allocator_t * const allocator)
{
    octaspire_container_hash_map_element_t *self = octaspire_memory_allocator_malloc(
        allocator,
        sizeof(octaspire_container_hash_map_element_t));

    if (!self)
    {
        return self;
    }

    self->allocator = allocator;
    self->hash = hash;
    self->keySizeInOctets = keySizeInOctets;
    self->keyIsPointer    = keyIsPointer;
    self->key = octaspire_memory_allocator_malloc(self->allocator, self->keySizeInOctets);

    if (!self->key)
    {
        octaspire_container_hash_map_element_release(self);
        self = 0;
        return 0;
    }

    if (self->key != memcpy(self->key, key, self->keySizeInOctets))
    {
        abort();
    }

    self->valueSizeInOctets = valueSizeInOctets;
    self->valueIsPointer    = valueIsPointer;
    //self->value = octaspire_memory_allocator_malloc(self->allocator, self->valueSizeInOctets);

    self->values = octaspire_container_vector_new(
        valueSizeInOctets,
        valueIsPointer,
        0,
        allocator);

    if (!self->values)
    {
        octaspire_container_hash_map_element_release(self);
        self = 0;
        return 0;
    }

    if (!octaspire_container_vector_push_back_element(self->values, value))
    {
        abort();
    }

    return self;
}

void octaspire_container_hash_map_element_release(octaspire_container_hash_map_element_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_memory_allocator_free(self->allocator, self->key);
    self->key = 0;

    //octaspire_memory_allocator_free(self->allocator, self->value);
    //self->value= 0;

    octaspire_container_vector_release(self->values);
    self->values = 0;

    octaspire_memory_allocator_free(self->allocator, self);
}

uint32_t octaspire_container_hash_map_element_get_hash(
    octaspire_container_hash_map_element_t const * const self)
{
    assert(self);
    return self->hash;
}

void *octaspire_container_hash_map_element_get_key(
    octaspire_container_hash_map_element_t const * const self)
{
    assert(self);
    return self->keyIsPointer ? (*(void**)self->key) : self->key;
}

octaspire_container_vector_t *octaspire_container_hash_map_element_get_values(
    octaspire_container_hash_map_element_t * const self)
{
    return self->values;
}

void *octaspire_container_hash_map_element_get_value(
    octaspire_container_hash_map_element_t const * const self)
{
    assert(self);
    assert(octaspire_container_vector_get_length(self->values) < 2);
    return octaspire_container_vector_get_element_at(self->values, 0);
    //return self->valueIsPointer ? (*(void**)self->value) : self->value;
}



struct octaspire_container_hash_map_t
{
    size_t                                                   keySizeInOctets;
    size_t                                                   valueSizeInOctets;
    octaspire_memory_allocator_t                            *allocator;
    octaspire_container_vector_t                            *buckets;
    octaspire_container_hash_map_key_compare_function_t      keyCompareFunction;
    octaspire_container_hash_map_key_hash_function_t         keyHashFunction;
    octaspire_container_hash_map_element_callback_function_t keyReleaseCallback;
    octaspire_container_hash_map_element_callback_function_t valueReleaseCallback;
    size_t                                                   numBucketsInUse;
    size_t                                                   numElements;
    bool                                                     keyIsPointer;
    bool                                                     valueIsPointer;
    char                                                     padding[6];
};

static size_t const OCTASPIRE_CONTAINER_HASH_MAP_SMALLEST_SIZE   = 128;
static float  const OCTASPIRE_CONTAINER_HASH_MAP_MAX_LOAD_FACTOR = 0.75f;

// Prototypes for static functions
static octaspire_container_vector_t *octaspire_container_hash_map_private_build_new_buckets(
    octaspire_container_hash_map_t *self,
    size_t const numBuckets,
    octaspire_memory_allocator_t *allocator);

static float octaspire_container_hash_map_private_get_load_factor(
    octaspire_container_hash_map_t const * const self);

static bool octaspire_container_hash_map_private_rehash(
    octaspire_container_hash_map_t * const self);

static void octaspire_container_hash_map_private_release_given_buckets(
    octaspire_container_hash_map_t *self,
    octaspire_container_vector_t **bucketsPtr);


static bool octaspire_container_hash_map_private_rehash(
    octaspire_container_hash_map_t * const self)
{
    assert(self);

    size_t const oldBucketCount = octaspire_container_vector_get_length(self->buckets);
    size_t const newBucketCount = oldBucketCount * 2;

    assert(oldBucketCount && newBucketCount);

    octaspire_container_vector_t *newBuckets =
        octaspire_container_hash_map_private_build_new_buckets(self, newBucketCount, self->allocator);

    self->numBucketsInUse = 0;
    self->numElements     = 0;

    if (!newBuckets)
    {
        return false;
    }

    for (size_t i = 0; i < oldBucketCount; ++i)
    {
        octaspire_container_vector_t *oldBucket =
            (octaspire_container_vector_t*)octaspire_container_vector_get_element_at(
                self->buckets,
                i);

        for (size_t j = 0; j < octaspire_container_vector_get_length(oldBucket); ++j)
        {
            octaspire_container_hash_map_element_t *element =
                (octaspire_container_hash_map_element_t*)octaspire_container_vector_get_element_at(
                    oldBucket,
                    j);

            uint32_t hash = octaspire_container_hash_map_element_get_hash(element);

            size_t const bucketIndex = hash % newBucketCount;

            octaspire_container_vector_t *bucket =
                (octaspire_container_vector_t*)octaspire_container_vector_get_element_at(
                    newBuckets,
                    bucketIndex);

            assert(bucket);

            if (octaspire_container_vector_is_empty(bucket))
            {
                ++(self->numBucketsInUse);
            }

            if (!octaspire_container_vector_push_back_element(bucket, &element))
            {
                return false;
            }

            ++(self->numElements);
        }

        octaspire_container_vector_release(oldBucket);
        oldBucket = 0;
    }

    octaspire_container_vector_release(self->buckets);
    self->buckets = 0;

    self->buckets = newBuckets;

    assert(octaspire_container_hash_map_private_get_load_factor(self) <
        OCTASPIRE_CONTAINER_HASH_MAP_MAX_LOAD_FACTOR);

    return true;
}

static float octaspire_container_hash_map_private_get_load_factor(
    octaspire_container_hash_map_t const * const self)
{
    return (float)self->numBucketsInUse / octaspire_container_vector_get_length(self->buckets);
}

static void octaspire_container_hash_map_private_release_given_buckets(
    octaspire_container_hash_map_t *self,
    octaspire_container_vector_t **bucketsPtr)
{
    assert(self && bucketsPtr && *bucketsPtr);

    octaspire_container_vector_t *buckets = *bucketsPtr;

    size_t const numBuckets = octaspire_container_vector_get_length(buckets);

    for (size_t i = 0; i < numBuckets; ++i)
    {
        octaspire_container_vector_t *bucket =
            (octaspire_container_vector_t*)octaspire_container_vector_get_element_at(
                buckets,
                i);

        assert(bucket);

        for (size_t j = 0; j < octaspire_container_vector_get_length(bucket); ++j)
        {
            octaspire_container_hash_map_element_t *element = (octaspire_container_hash_map_element_t*)
                octaspire_container_vector_get_element_at(bucket, j);

            if (self->valueReleaseCallback)
            {
                for (size_t k = 0; k < octaspire_container_vector_get_length(element->values); ++k)
                {
                    //self->valueReleaseCallback(*(void**)element->value);
                    self->valueReleaseCallback(
                        octaspire_container_vector_get_element_at(element->values, k));
                }
            }

            if (self->keyReleaseCallback)
            {
                if (element->keyIsPointer)
                {
                    self->keyReleaseCallback(*(void**)element->key);
                }
                else
                {
                    self->keyReleaseCallback(element->key);
                }
            }

            octaspire_container_hash_map_element_release(element);
        }

        //octaspire_container_vector_clear(bucket);
        octaspire_container_vector_release(bucket);
        bucket = 0;

    }

    octaspire_container_vector_release(buckets);
    *bucketsPtr = 0;
}

static octaspire_container_vector_t *octaspire_container_hash_map_private_build_new_buckets(
    octaspire_container_hash_map_t *self,
    size_t const numBuckets,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_container_vector_t *buckets = octaspire_container_vector_new_with_preallocated_elements(
        sizeof(octaspire_container_vector_t*),
        true,
        numBuckets,
        0, //(octaspire_container_vector_element_callback_t)octaspire_container_vector_release,
        allocator);

    if (!buckets)
    {
        return 0;
    }

    for (size_t i = 0; i < numBuckets; ++i)
    {
        octaspire_container_vector_t *bucket = octaspire_container_vector_new(
            sizeof(octaspire_container_hash_map_element_t *),
            true,
            0, // (octaspire_container_vector_element_callback_t)octaspire_container_hash_map_element_release,
            allocator);

        if (!bucket)
        {
            octaspire_container_hash_map_private_release_given_buckets(self, &buckets);
            assert(!buckets);
            return 0;
        }

        if (!octaspire_container_vector_push_back_element(buckets, &bucket))
        {
            // This should never happen, because numBuckets buckets are
            // preallocated on the vector. So assert could be
            // used here, but maybe this is still safer?
            octaspire_container_hash_map_private_release_given_buckets(self, &buckets);
            assert(!buckets);
            return 0;
        }
    }

    assert(octaspire_container_vector_get_length(buckets) == numBuckets);

    return buckets;
}

octaspire_container_hash_map_t *octaspire_container_hash_map_new(
    size_t const keySizeInOctets,
    bool const keyIsPointer,
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    octaspire_container_hash_map_key_compare_function_t keyCompareFunction,
    octaspire_container_hash_map_key_hash_function_t keyHashFunction,
    octaspire_container_hash_map_element_callback_function_t keyReleaseCallback,
    octaspire_container_hash_map_element_callback_function_t valueReleaseCallback,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_container_hash_map_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_container_hash_map_t));

    if (!self)
    {
        return self;
    }

    self->keySizeInOctets      = keySizeInOctets;
    self->keyIsPointer         = keyIsPointer;
    self->valueSizeInOctets    = valueSizeInOctets;
    self->valueIsPointer       = valueIsPointer;
    self->allocator            = allocator;
    self->keyCompareFunction   = keyCompareFunction;
    self->keyHashFunction      = keyHashFunction;
    self->keyReleaseCallback   = keyReleaseCallback;
    self->valueReleaseCallback = valueReleaseCallback;
    self->numBucketsInUse      = 0;
    self->numElements          = 0;

    self->buckets = octaspire_container_hash_map_private_build_new_buckets(
        self,
        OCTASPIRE_CONTAINER_HASH_MAP_SMALLEST_SIZE,
        self->allocator);

    if (!self->buckets)
    {
        octaspire_container_hash_map_release(self);
        self = 0;
        return 0;
    }

    return self;
}

octaspire_container_hash_map_t *octaspire_container_hash_map_new_with_octaspire_container_utf8_string_keys(
    size_t const valueSizeInOctets,
    bool const valueIsPointer,
    octaspire_container_hash_map_element_callback_function_t valueReleaseCallback,
    octaspire_memory_allocator_t *allocator)
{
    return octaspire_container_hash_map_new(
        sizeof(octaspire_container_utf8_string_t*),
        true,
        valueSizeInOctets,
        valueIsPointer,
        (octaspire_container_hash_map_key_compare_function_t)octaspire_container_utf8_string_is_equal,
        (octaspire_container_hash_map_key_hash_function_t)octaspire_container_utf8_string_get_hash,
        (octaspire_container_hash_map_element_callback_function_t)octaspire_container_utf8_string_release,
        valueReleaseCallback,
        allocator);
}

void octaspire_container_hash_map_release(octaspire_container_hash_map_t *self)
{
    if (!self)
    {
        return;
    }

    if (self->buckets)
    {
        octaspire_container_hash_map_private_release_given_buckets(self, &(self->buckets));
        assert(!(self->buckets));
    }

    self->buckets = 0;

    octaspire_memory_allocator_free(self->allocator, self);
}

bool octaspire_container_hash_map_remove(
    octaspire_container_hash_map_t *self,
    uint32_t const hash,
    void const * const key)
{
    size_t const bucketIndex = hash % octaspire_container_vector_get_length(self->buckets);

    octaspire_container_vector_t *bucket =
        (octaspire_container_vector_t*)octaspire_container_vector_get_element_at(
            self->buckets,
            bucketIndex);

    if (!bucket)
    {
        return false;
    }

    size_t const numElementsInBucket = octaspire_container_vector_get_length(bucket);

    for (size_t i = 0; i < numElementsInBucket; ++i)
    {
        octaspire_container_hash_map_element_t *element =
            (octaspire_container_hash_map_element_t*)octaspire_container_vector_get_element_at(
                bucket,
                i);

        assert(element);

        void const * key2 = octaspire_container_hash_map_element_get_key(element);

        if (self->keyCompareFunction(element->keyIsPointer ? *(void const * const *)key : key, key2))
        {
            if (self->valueReleaseCallback)
            {
                for (size_t j = 0; j < octaspire_container_vector_get_length(element->values); ++j)
                {
                    //self->valueReleaseCallback(*(void**)element->value);
                    self->valueReleaseCallback(
                        octaspire_container_vector_get_element_at(element->values, j));
                }
            }

            if (self->keyReleaseCallback)
            {
                if (element->keyIsPointer)
                {
                    self->keyReleaseCallback(*(void**)element->key);
                }
                else
                {
                    self->keyReleaseCallback(element->key);
                }
            }

            octaspire_container_hash_map_element_release(element);
            if (octaspire_container_vector_remove_element_at(bucket, i))
            {
                --(self->numElements);
                return true;
            }
            else
            {
                return false;
            }
        }
    }

    return false;
}

bool octaspire_container_hash_map_clear(
    octaspire_container_hash_map_t * const self)
{
    // TODO XXX how to this in best way?

    octaspire_container_vector_t *buckets = octaspire_container_hash_map_private_build_new_buckets(
        self,
        OCTASPIRE_CONTAINER_HASH_MAP_SMALLEST_SIZE,
        self->allocator);

    if (!buckets)
    {
        return false;
    }

    if (self->buckets)
    {
        octaspire_container_hash_map_private_release_given_buckets(self, &(self->buckets));
        assert(!(self->buckets));
    }

    self->buckets = buckets;

    self->numBucketsInUse = 0;
    self->numElements     = 0;

    return true;
}

bool octaspire_container_hash_map_add_hash_map(
    octaspire_container_hash_map_t * const self,
    octaspire_container_hash_map_t * const other)
{
    bool result = true;

    for (size_t i = 0; i < octaspire_container_hash_map_get_number_of_elements(other); ++i)
    {
        octaspire_container_hash_map_element_t *otherElement =
            octaspire_container_hash_map_get_at_index(other, i);

        for (size_t j = 0; j < octaspire_container_vector_get_length(otherElement->values); ++j)
        {
            void * const key   = otherElement->key;
            void * const value = octaspire_container_vector_get_element_at(otherElement->values, j);

            if (!octaspire_container_hash_map_put(
                self,
                otherElement->hash,
                key,
                &value))
            {
                result = false;
            }
        }
    }

    return result;
}

bool octaspire_container_hash_map_put(
    octaspire_container_hash_map_t *self,
    uint32_t const hash,
    void const * const key,
    void const * const value)
{
    assert(self);
    assert(octaspire_container_vector_get_length(self->buckets));

    octaspire_container_hash_map_element_t *element =
        octaspire_container_hash_map_get(self, hash, key);

    if (element)
    {
        return octaspire_container_vector_push_back_element(element->values, value);
    }
    else
    {
        //octaspire_container_hash_map_remove(self, hash, key);

        size_t const bucketIndex = hash % octaspire_container_vector_get_length(self->buckets);

        octaspire_container_vector_t *bucket =
            (octaspire_container_vector_t*)octaspire_container_vector_get_element_at(
                self->buckets,
                bucketIndex);

        assert(bucket);

        if (octaspire_container_vector_is_empty(bucket))
        {
            ++(self->numBucketsInUse);
        }

        element = octaspire_container_hash_map_element_new(
            hash,
            self->keySizeInOctets,
            self->keyIsPointer,
            key,
            self->valueSizeInOctets,
            self->valueIsPointer,
            value,
            self->allocator);

        if (!octaspire_container_vector_push_back_element(bucket, &element))
        {
            return false;
        }

        ++(self->numElements);

        if (octaspire_container_hash_map_private_get_load_factor(self) >=
                OCTASPIRE_CONTAINER_HASH_MAP_MAX_LOAD_FACTOR)
        {
            if (!octaspire_container_hash_map_private_rehash(self))
            {
                return false;
            }
        }

        return true;
    }
}

octaspire_container_hash_map_element_t const * octaspire_container_hash_map_get_const(
    octaspire_container_hash_map_t const * const self,
    uint32_t const hash,
    void const * const key)
{
    size_t const bucketIndex = hash % octaspire_container_vector_get_length(self->buckets);

    octaspire_container_vector_t *bucket =
        (octaspire_container_vector_t*)octaspire_container_vector_get_element_at(
            self->buckets,
            bucketIndex);

    assert(bucket);

    size_t const numElementsInBucket = octaspire_container_vector_get_length(bucket);

    if (numElementsInBucket == 1)
    {
        octaspire_container_hash_map_element_t *element = (octaspire_container_hash_map_element_t*)
            octaspire_container_vector_peek_front_element(bucket);

        assert(element);

        void const * const key2 = octaspire_container_hash_map_element_get_key(element);

        if (self->keyCompareFunction(element->keyIsPointer ? *(void const * const *)key : key, key2))
        {
            return element;
        }

        return 0;
    }

    for (size_t i = 0; i < numElementsInBucket; ++i)
    {
        octaspire_container_hash_map_element_t *element =
            (octaspire_container_hash_map_element_t*)octaspire_container_vector_get_element_at(
                bucket,
                i);

        assert(element);

        void const * const key2 = octaspire_container_hash_map_element_get_key(element);

        if (self->keyCompareFunction(element->keyIsPointer ? *(void const * const *)key : key, key2))
        {
            return element;
        }
    }

    return 0;
}

octaspire_container_hash_map_element_t *octaspire_container_hash_map_get(
    octaspire_container_hash_map_t *self, uint32_t const hash, void const * const key)
{
    size_t const bucketIndex = hash % octaspire_container_vector_get_length(self->buckets);

    octaspire_container_vector_t *bucket =
        (octaspire_container_vector_t*)octaspire_container_vector_get_element_at(
            self->buckets,
            bucketIndex);

    assert(bucket);

    size_t const numElementsInBucket = octaspire_container_vector_get_length(bucket);

    if (numElementsInBucket == 1)
    {
        octaspire_container_hash_map_element_t *element = (octaspire_container_hash_map_element_t*)
            octaspire_container_vector_peek_front_element(bucket);

        assert(element);

        void const * key2 = octaspire_container_hash_map_element_get_key(element);

        if (self->keyCompareFunction(element->keyIsPointer ? *(void const * const *)key : key, key2))
        {
            return element;
        }

        return 0;
    }

    for (size_t i = 0; i < numElementsInBucket; ++i)
    {
        octaspire_container_hash_map_element_t *element =
            (octaspire_container_hash_map_element_t*)octaspire_container_vector_get_element_at(
                bucket,
                i);

        assert(element);

        void const * key2 = octaspire_container_hash_map_element_get_key(element);

        if (self->keyCompareFunction(element->keyIsPointer ? *(void const * const *)key : key, key2))
        {
            return element;
        }
    }

    return 0;
}

size_t octaspire_container_hash_map_get_number_of_elements(octaspire_container_hash_map_t const * const self)
{
    assert(self);
    return self->numElements;
}

octaspire_container_hash_map_element_t *octaspire_container_hash_map_get_at_index(
    octaspire_container_hash_map_t * const self,
    size_t const index)
{
    size_t counter = 0;
    for (size_t i = 0; i < octaspire_container_vector_get_length(self->buckets); ++i)
    {
        octaspire_container_vector_t * const bucket = (octaspire_container_vector_t*)
            octaspire_container_vector_get_element_at(
                self->buckets,
                i);

        size_t const bucketSize = octaspire_container_vector_get_length(bucket);

        if (bucketSize)
        {
            if (index <= (counter + bucketSize - 1))
            {
                return (octaspire_container_hash_map_element_t*)
                    octaspire_container_vector_get_element_at(bucket, index - counter);
            }

            counter += bucketSize;
        }
     }

    return 0;
}

octaspire_container_hash_map_element_iterator_t
octaspire_container_hash_map_element_iterator_init(
    octaspire_container_hash_map_t * const self)
{
    octaspire_container_hash_map_element_iterator_t iterator;

    iterator.hashMap = self;
    iterator.bucketIndex = 0;
    iterator.elementInsideBucketIndex = 0;
    iterator.element = 0;

    while (!(iterator.element))
    {
        if (iterator.bucketIndex < octaspire_container_vector_get_length(self->buckets))
        {
            octaspire_container_vector_t * const bucket = (octaspire_container_vector_t*)
                octaspire_container_vector_get_element_at(
                    self->buckets,
                    iterator.bucketIndex);

            size_t const bucketSize = octaspire_container_vector_get_length(bucket);

            for (; iterator.elementInsideBucketIndex < bucketSize; ++(iterator.elementInsideBucketIndex))
            {
                iterator.element = (octaspire_container_hash_map_element_t*)
                    octaspire_container_vector_get_element_at(
                        bucket,
                        iterator.elementInsideBucketIndex);

                if (iterator.element)
                {
                    break;
                }
            }
        }
        else
        {
            break;
        }

        if (iterator.element)
        {
            return iterator;
        }

        ++(iterator.bucketIndex);
        iterator.elementInsideBucketIndex = 0;
    }

    return iterator;
}

bool octaspire_container_hash_map_element_iterator_next(
    octaspire_container_hash_map_element_iterator_t * const self)
{
    self->element = 0;
    ++(self->elementInsideBucketIndex);

    while (!(self->element))
    {
        if (self->bucketIndex < octaspire_container_vector_get_length(self->hashMap->buckets))
        {
            octaspire_container_vector_t * const bucket = (octaspire_container_vector_t*)
                octaspire_container_vector_get_element_at(
                    self->hashMap->buckets,
                    self->bucketIndex);

            size_t const bucketSize = octaspire_container_vector_get_length(bucket);

            for (; self->elementInsideBucketIndex < bucketSize; ++(self->elementInsideBucketIndex))
            {
                self->element = (octaspire_container_hash_map_element_t*)
                    octaspire_container_vector_get_element_at(
                        bucket,
                        self->elementInsideBucketIndex);

                if (self->element)
                {
                    break;
                }
            }
        }
        else
        {
            break;
        }

        if (self->element)
        {
            return self->element != 0;
        }

        ++(self->bucketIndex);
        self->elementInsideBucketIndex = 0;
    }

    return self->element != 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_container_hash_map.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_input.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_input_t
{
    octaspire_container_utf8_string_t *text;
    size_t                             index;
    size_t                             line;
    size_t                             column;
    octaspire_memory_allocator_t      *allocator;
};

bool octaspire_input_private_is_ucs_character_index_valid(
    octaspire_input_t const * const self,
    size_t index);

octaspire_input_t *octaspire_input_new_from_c_string(
    char const * const str,
    octaspire_memory_allocator_t *allocator)
{
    return octaspire_input_new_from_buffer(str, str ? strlen(str) : 0, allocator);
}

octaspire_input_t *octaspire_input_new_from_buffer(
    char const * const buffer,
    size_t const lengthInOctets,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_input_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_input_t));

    if (!self)
    {
        return self;
    }

    self->allocator = allocator;

    self->index  = 0;
    self->line   = 1;
    self->column = 1;

    self->text   = octaspire_container_utf8_string_new_from_buffer(buffer, lengthInOctets, self->allocator);

    if (!self->text)
    {
        octaspire_input_release(self);
        self = 0;
        return 0;
    }

    return self;
}

octaspire_input_t *octaspire_input_new_from_path(
    char const * const path,
    octaspire_memory_allocator_t *octaspireAllocator,
    octaspire_stdio_t *octaspireStdio)
{
    size_t octetsAllocated = 0;
    char *buffer = octaspire_helpers_path_to_buffer(path, &octetsAllocated, octaspireAllocator, octaspireStdio);

    if (!buffer)
    {
        return 0;
    }

    octaspire_input_t *self = octaspire_input_new_from_buffer(buffer, octetsAllocated, octaspireAllocator);

    octaspire_memory_allocator_free(octaspireAllocator, buffer);
    buffer = 0;

    return self;
}

void octaspire_input_release(octaspire_input_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_container_utf8_string_release(self->text);
    octaspire_memory_allocator_free(self->allocator, self);
}

size_t octaspire_input_get_length_in_ucs_characters(octaspire_input_t const * const self)
{
    return octaspire_container_utf8_string_get_length_in_ucs_characters(self->text);
}

void   octaspire_input_clear(octaspire_input_t *self)
{
    octaspire_container_utf8_string_clear(self->text);
    self->index  = 0;
    self->line   = 1;
    self->column = 1;
}

void   octaspire_input_rewind(octaspire_input_t *self)
{
    self->index  = 0;
    self->line   = 1;
    self->column = 1;
}

uint32_t octaspire_input_peek_next_ucs_character(octaspire_input_t *self)
{
    if (self->index >= octaspire_container_utf8_string_get_length_in_ucs_characters(self->text))
    {
        return 0;
    }

    return octaspire_container_utf8_string_get_ucs_character_at_index(self->text, self->index);
}

uint32_t octaspire_input_peek_next_next_ucs_character(octaspire_input_t *self)
{
    if ((self->index + 1) >= octaspire_container_utf8_string_get_length_in_ucs_characters(self->text))
    {
        return 0;
    }

    return octaspire_container_utf8_string_get_ucs_character_at_index(self->text, self->index + 1);
}

bool octaspire_input_pop_next_ucs_character(octaspire_input_t *self)
{
    if (!octaspire_input_private_is_ucs_character_index_valid(self, self->index))
    {
        return false;
    }

    uint32_t const result =
        octaspire_container_utf8_string_get_ucs_character_at_index(self->text, self->index);

    ++(self->index);

    if (octaspire_input_private_is_ucs_character_index_valid(self, self->index))
    {
        if (result == '\n')
        {
            self->column = 1;
            ++(self->line);
        }
        else
        {
            ++(self->column);
        }
    }

    return true;
}

bool octaspire_input_is_good(octaspire_input_t const * const self)
{
    return self->index < octaspire_container_utf8_string_get_length_in_ucs_characters(self->text);
}

bool octaspire_input_private_is_ucs_character_index_valid(
    octaspire_input_t const * const self,
    size_t index)
{
    return index < octaspire_container_utf8_string_get_length_in_ucs_characters(self->text);
}

bool octaspire_input_push_back_from_string(
    octaspire_input_t * const self,
    octaspire_container_utf8_string_t const * const str)
{
    return octaspire_input_push_back_from_c_string(
        self,
        octaspire_container_utf8_string_get_c_string(str));
}

bool octaspire_input_push_back_from_c_string(octaspire_input_t * const self, char const * const str)
{
    assert(self);
    return octaspire_container_utf8_string_concatenate_c_string(self->text, str);
}

size_t octaspire_input_get_line_number(octaspire_input_t const * const self)
{
    return self->line;
}

size_t octaspire_input_get_column_number(octaspire_input_t const * const self)
{
    return self->column;
}

size_t octaspire_input_get_ucs_character_index(octaspire_input_t const * const self)
{
    return self->index;
}

void octaspire_input_print(octaspire_input_t const * const self)
{
    printf("\n-------------------------- octaspire input --------------------------\n");
    printf("%s", octaspire_container_utf8_string_get_c_string(self->text));
    printf("---------------------------------------------------------------------\n");
}


//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_input.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_stdio.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_stdio_t
{
    octaspire_memory_allocator_t *allocator;
    size_t   numberOfFutureReadsToBeRigged;
    size_t   bitIndex;
    uint32_t bitQueue;
    char     padding[4];
};

octaspire_stdio_t *octaspire_stdio_new(octaspire_memory_allocator_t *allocator)
{
    size_t const size = sizeof(octaspire_stdio_t);

    octaspire_stdio_t *self = octaspire_memory_allocator_malloc(allocator, size);

    if (!self)
    {
        return self;
    }

    memset(self, 0, size);

    self->allocator = allocator;

    return self;
}

void octaspire_stdio_release(octaspire_stdio_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_memory_allocator_free(self->allocator, self);
}

size_t octaspire_stdio_fread(
    octaspire_stdio_t *self,
    void *ptr,
    size_t const size,
    size_t const nmemb,
    FILE *stream)
{
    if (self->numberOfFutureReadsToBeRigged)
    {
        --(self->numberOfFutureReadsToBeRigged);

        if (!octaspire_helpers_test_bit(self->bitQueue, self->bitIndex))
        {
            ++(self->bitIndex);
            return 0;
        }

        ++(self->bitIndex);
    }

    return fread(ptr, size, nmemb, stream);
}

void octaspire_stdio_set_number_and_type_of_future_reads_to_be_rigged(
    octaspire_stdio_t *self,
    size_t const count,
    uint32_t const bitQueue)
{
    self->numberOfFutureReadsToBeRigged = count;
    self->bitIndex = 0;
    self->bitQueue = bitQueue;
}

size_t octaspire_stdio_get_number_of_future_reads_to_be_rigged(
    octaspire_stdio_t const * const self)
{
    return self->numberOfFutureReadsToBeRigged;
}

octaspire_container_utf8_string_t *octaspire_stdio_read_line(octaspire_stdio_t *self, FILE *stream)
{
    octaspire_container_vector_t *vec = octaspire_container_vector_new(
        sizeof(char),
        false,
        0,
        self->allocator);

    while (true)
    {
        int c = fgetc(stream);
        char const ch = (char)c;

        if (c == EOF)
        {
            octaspire_container_vector_release(vec);
            return 0;
        }
        else if (c == '\n')
        {
            octaspire_container_vector_push_back_element(vec, &ch);
            break;
        }

        octaspire_container_vector_push_back_element(vec, &ch);
    }

    octaspire_container_utf8_string_t* result = octaspire_container_utf8_string_new_from_buffer(
        octaspire_container_vector_get_element_at_const(vec, 0),
        octaspire_container_vector_get_length_in_octets(vec),
        self->allocator);

    octaspire_container_vector_release(vec);
    vec = 0;
    return result;
}


//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_stdio.c
//////////////////////////////////////////////////////////////////////////////////////////////////



#endif // OCTASPIRE_CORE_AMALGAMATED_IMPLEMENTATION








#ifdef OCTASPIRE_CORE_AMALGAMATED_UNIT_TEST_IMPLEMENTATION

//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../external/greatest.h
//////////////////////////////////////////////////////////////////////////////////////////////////
// This file is modified by www.octaspire.com. The original copyright is:

/*
 * Copyright (c) 2011-2016 Scott Vokes <vokes.s@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

// Modifications are released under similar license:

/*
 * Copyright (c) 2017 www.octaspire.com
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef GREATEST_H
#define GREATEST_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef GREATEST_ENABLE_ANSI_COLORS
#define GREATEST_ANSI_COLOR_RED    "\x1B[31m"
#define GREATEST_ANSI_COLOR_GREEN  "\x1B[32m"
#define GREATEST_ANSI_COLOR_YELLOW "\x1B[33m"
#define GREATEST_ANSI_COLOR_DGRAY  "\x1B[1;30m"
#define GREATEST_ANSI_COLOR_RESET  "\x1B[0m"
#else
#define GREATEST_ANSI_COLOR_RED    ""
#define GREATEST_ANSI_COLOR_GREEN  ""
#define GREATEST_ANSI_COLOR_YELLOW ""
#define GREATEST_ANSI_COLOR_DGRAY  ""
#define GREATEST_ANSI_COLOR_RESET  ""
#endif

/* 1.2.2 */
#define GREATEST_VERSION_MAJOR 1
#define GREATEST_VERSION_MINOR 2
#define GREATEST_VERSION_PATCH 2

/* A unit testing system for C, contained in 1 file.
 * It doesn't use dynamic allocation or depend on anything
 * beyond ANSI C89.
 *
 * An up-to-date version can be found at:
 *     https://github.com/silentbicycle/greatest/
 */


/***********
 * Options *
 ***********/

/* Default column width for non-verbose output. */
#ifndef GREATEST_DEFAULT_WIDTH
#define GREATEST_DEFAULT_WIDTH 72
#endif

/* FILE *, for test logging. */
#ifndef GREATEST_STDOUT
#define GREATEST_STDOUT stdout
#endif

/* Remove GREATEST_ prefix from most commonly used symbols? */
#ifndef GREATEST_USE_ABBREVS
#define GREATEST_USE_ABBREVS 1
#endif

/* Set to 0 to disable all use of setjmp/longjmp. */
#ifndef GREATEST_USE_LONGJMP
#define GREATEST_USE_LONGJMP 1
#endif

#ifdef GREATEST_USE_LONGJMP
#endif

/* Set to 0 to disable all use of time.h / clock(). */
#ifndef GREATEST_USE_TIME
#define GREATEST_USE_TIME 1
#endif

#ifdef GREATEST_USE_TIME
#endif

/* Floating point type, for ASSERT_IN_RANGE. */
#ifndef GREATEST_FLOAT
#define GREATEST_FLOAT double
#define GREATEST_FLOAT_FMT "%g"
#endif

/*********
 * Types *
 *********/

/* Info for the current running suite. */
typedef struct greatest_suite_info {
    unsigned int tests_run;
    unsigned int passed;
    unsigned int failed;
    unsigned int skipped;

#ifdef GREATEST_USE_TIME
    /* timers, pre/post running suite and individual tests */
    clock_t pre_suite;
    clock_t post_suite;
    clock_t pre_test;
    clock_t post_test;
#endif
} greatest_suite_info;

/* Type for a suite function. */
typedef void (greatest_suite_cb)(void);

/* Types for setup/teardown callbacks. If non-NULL, these will be run
 * and passed the pointer to their additional data. */
typedef void (greatest_setup_cb)(void *udata);
typedef void (greatest_teardown_cb)(void *udata);

/* Type for an equality comparison between two pointers of the same type.
 * Should return non-0 if equal, otherwise 0.
 * UDATA is a closure value, passed through from ASSERT_EQUAL_T[m]. */
typedef int greatest_equal_cb(const void *exp, const void *got, void *udata);

/* Type for a callback that prints a value pointed to by T.
 * Return value has the same meaning as printf's.
 * UDATA is a closure value, passed through from ASSERT_EQUAL_T[m]. */
typedef int greatest_printf_cb(const void *t, void *udata);

/* Callbacks for an arbitrary type; needed for type-specific
 * comparisons via GREATEST_ASSERT_EQUAL_T[m].*/
typedef struct greatest_type_info {
    greatest_equal_cb *equal;
    greatest_printf_cb *print;
} greatest_type_info;

typedef struct greatest_memory_cmp_env {
    const unsigned char *exp;
    const unsigned char *got;
    size_t size;
} greatest_memory_cmp_env;

/* Callbacks for string and raw memory types. */
extern greatest_type_info greatest_type_info_string;
extern greatest_type_info greatest_type_info_memory;

typedef enum {
    GREATEST_FLAG_FIRST_FAIL = 0x01,
    GREATEST_FLAG_LIST_ONLY = 0x02
} greatest_flag_t;

/* Struct containing all test runner state. */
typedef struct greatest_run_info {
    unsigned char flags;
    unsigned char verbosity;
    unsigned char pad_0[2];

    unsigned int tests_run;     /* total test count */

    /* currently running test suite */
    greatest_suite_info suite;

    /* overall pass/fail/skip counts */
    unsigned int passed;
    unsigned int failed;
    unsigned int skipped;
    unsigned int assertions;

    /* info to print about the most recent failure */
    unsigned int fail_line;
    unsigned int pad_1;
    const char *fail_file;
    const char *msg;

    /* current setup/teardown hooks and userdata */
    greatest_setup_cb *setup;
    void *setup_udata;
    greatest_teardown_cb *teardown;
    void *teardown_udata;

    /* formatting info for ".....s...F"-style output */
    unsigned int col;
    unsigned int width;

    /* only run a specific suite or test */
    const char *suite_filter;
    const char *test_filter;

#ifdef GREATEST_USE_TIME
    /* overall timers */
    clock_t begin;
    clock_t end;
#endif

#ifdef GREATEST_USE_LONGJMP
    int pad_jmp_buf;
    char octaspire_padding[4];
    jmp_buf jump_dest;
#endif
} greatest_run_info;

struct greatest_report_t {
    /* overall pass/fail/skip counts */
    unsigned int passed;
    unsigned int failed;
    unsigned int skipped;
    unsigned int assertions;
};

/* Global var for the current testing context.
 * Initialized by GREATEST_MAIN_DEFS(). */
extern greatest_run_info greatest_info;

/* Type for ASSERT_ENUM_EQ's ENUM_STR argument. */
typedef const char *greatest_enum_str_fun(int value);

/**********************
 * Exported functions *
 **********************/

/* These are used internally by greatest. */
void greatest_do_pass(const char *name);
void greatest_do_fail(const char *name);
void greatest_do_skip(const char *name);
int greatest_pre_test(const char *name);
void greatest_post_test(const char *name, int res);
void greatest_usage(const char *name);
int greatest_do_assert_equal_t(const void *exp, const void *got,
    greatest_type_info *type_info, void *udata);

/* These are part of the public greatest API. */
void GREATEST_SET_SETUP_CB(greatest_setup_cb *cb, void *udata);
void GREATEST_SET_TEARDOWN_CB(greatest_teardown_cb *cb, void *udata);
int greatest_all_passed(void);
void greatest_set_test_filter(const char *name);
void greatest_set_suite_filter(const char *name);
void greatest_get_report(struct greatest_report_t *report);
unsigned int greatest_get_verbosity(void);
void greatest_set_verbosity(unsigned int verbosity);
void greatest_set_flag(greatest_flag_t flag);


/********************
* Language Support *
********************/

/**********
 * Macros *
 **********/

/* Define a suite. */
#define GREATEST_SUITE(NAME) void NAME(void); void NAME(void)

/* Declare a suite, provided by another compilation unit. */
#define GREATEST_SUITE_EXTERN(NAME) void NAME(void)

/* Start defining a test function.
 * The arguments are not included, to allow parametric testing. */
#define GREATEST_TEST static enum greatest_test_res

/* PASS/FAIL/SKIP result from a test. Used internally. */
typedef enum greatest_test_res {
    GREATEST_TEST_RES_PASS = 0,
    GREATEST_TEST_RES_FAIL = -1,
    GREATEST_TEST_RES_SKIP = 1
} greatest_test_res;

/* Run a suite. */
#define GREATEST_RUN_SUITE(S_NAME) greatest_run_suite(S_NAME, #S_NAME)

/* Run a test in the current suite. */
#define GREATEST_RUN_TEST(TEST)                                         \
    do {                                                                \
        if (greatest_pre_test(#TEST) == 1) {                            \
            enum greatest_test_res res = GREATEST_SAVE_CONTEXT();       \
            if (res == GREATEST_TEST_RES_PASS) {                        \
                res = TEST();                                           \
            }                                                           \
            greatest_post_test(#TEST, res);                             \
        } else if (GREATEST_LIST_ONLY()) {                              \
            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
        }                                                               \
    } while (0)

/* Ignore a test, don't warn about it being unused. */
#define GREATEST_IGNORE_TEST(TEST) (void)TEST

/* Run a test in the current suite with one void * argument,
 * which can be a pointer to a struct with multiple arguments. */
#define GREATEST_RUN_TEST1(TEST, ENV)                                   \
    do {                                                                \
        if (greatest_pre_test(#TEST) == 1) {                            \
            int res = TEST(ENV);                                        \
            greatest_post_test(#TEST, res);                             \
        } else if (GREATEST_LIST_ONLY()) {                              \
            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
        }                                                               \
    } while (0)

#ifdef GREATEST_VA_ARGS
#define GREATEST_RUN_TESTp(TEST, ...)                                   \
    do {                                                                \
        if (greatest_pre_test(#TEST) == 1) {                            \
            int res = TEST(__VA_ARGS__);                                \
            greatest_post_test(#TEST, res);                             \
        } else if (GREATEST_LIST_ONLY()) {                              \
            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
        }                                                               \
    } while (0)
#endif


/* Check if the test runner is in verbose mode. */
#define GREATEST_IS_VERBOSE() ((greatest_info.verbosity) > 0)
#define GREATEST_LIST_ONLY()                                            \
    (greatest_info.flags & GREATEST_FLAG_LIST_ONLY)
#define GREATEST_FIRST_FAIL()                                           \
    (greatest_info.flags & GREATEST_FLAG_FIRST_FAIL)
#define GREATEST_FAILURE_ABORT()                                        \
    (greatest_info.suite.failed > 0 && GREATEST_FIRST_FAIL())

/* Message-less forms of tests defined below. */
#define GREATEST_PASS() GREATEST_PASSm(NULL)
#define GREATEST_FAIL() GREATEST_FAILm(NULL)
#define GREATEST_SKIP() GREATEST_SKIPm(NULL)
#define GREATEST_ASSERT(COND)                                           \
    GREATEST_ASSERTm(#COND, COND)
#define GREATEST_ASSERT_OR_LONGJMP(COND)                                \
    GREATEST_ASSERT_OR_LONGJMPm(#COND, COND)
#define GREATEST_ASSERT_FALSE(COND)                                     \
    GREATEST_ASSERT_FALSEm(#COND, COND)
#define GREATEST_ASSERT_EQ(EXP, GOT)                                    \
    GREATEST_ASSERT_EQm(#EXP " != " #GOT, EXP, GOT)
#define GREATEST_ASSERT_EQ_FMT(EXP, GOT, FMT)                           \
    GREATEST_ASSERT_EQ_FMTm(#EXP " != " #GOT, EXP, GOT, FMT)
#define GREATEST_ASSERT_IN_RANGE(EXP, GOT, TOL)                         \
    GREATEST_ASSERT_IN_RANGEm(#EXP " != " #GOT " +/- " #TOL, EXP, GOT, TOL)
#define GREATEST_ASSERT_EQUAL_T(EXP, GOT, TYPE_INFO, UDATA)             \
    GREATEST_ASSERT_EQUAL_Tm(#EXP " != " #GOT, EXP, GOT, TYPE_INFO, UDATA)
#define GREATEST_ASSERT_STR_EQ(EXP, GOT)                                \
    GREATEST_ASSERT_STR_EQm(#EXP " != " #GOT, EXP, GOT)
#define GREATEST_ASSERT_STRN_EQ(EXP, GOT, SIZE)                         \
    GREATEST_ASSERT_STRN_EQm(#EXP " != " #GOT, EXP, GOT, SIZE)
#define GREATEST_ASSERT_MEM_EQ(EXP, GOT, SIZE)                          \
    GREATEST_ASSERT_MEM_EQm(#EXP " != " #GOT, EXP, GOT, SIZE)
#define GREATEST_ASSERT_ENUM_EQ(EXP, GOT, ENUM_STR)                     \
    GREATEST_ASSERT_ENUM_EQm(#EXP " != " #GOT, EXP, GOT, ENUM_STR)

/* The following forms take an additional message argument first,
 * to be displayed by the test runner. */

/* Fail if a condition is not true, with message. */
#define GREATEST_ASSERTm(MSG, COND)                                     \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if (!(COND)) { GREATEST_FAILm(MSG); }                           \
    } while (0)

/* Fail if a condition is not true, longjmping out of test. */
#define GREATEST_ASSERT_OR_LONGJMPm(MSG, COND)                          \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if (!(COND)) { GREATEST_FAIL_WITH_LONGJMPm(MSG); }              \
    } while (0)

/* Fail if a condition is not false, with message. */
#define GREATEST_ASSERT_FALSEm(MSG, COND)                               \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if ((COND)) { GREATEST_FAILm(MSG); }                            \
    } while (0)

/* Fail if EXP != GOT (equality comparison by ==). */
#define GREATEST_ASSERT_EQm(MSG, EXP, GOT)                              \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if ((EXP) != (GOT)) { GREATEST_FAILm(MSG); }                    \
    } while (0)

/* Fail if EXP != GOT (equality comparison by ==).
 * Warning: FMT, EXP, and GOT will be evaluated more
 * than once on failure. */
#define GREATEST_ASSERT_EQ_FMTm(MSG, EXP, GOT, FMT)                     \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if ((EXP) != (GOT)) {                                           \
            fprintf(GREATEST_STDOUT, "\nExpected: ");                   \
            fprintf(GREATEST_STDOUT, FMT, EXP);                         \
            fprintf(GREATEST_STDOUT, "\n     Got: ");                   \
            fprintf(GREATEST_STDOUT, FMT, GOT);                         \
            fprintf(GREATEST_STDOUT, "\n");                             \
            GREATEST_FAILm(MSG);                                        \
        }                                                               \
    } while (0)

/* Fail if EXP is not equal to GOT, printing enum IDs. */
#define GREATEST_ASSERT_ENUM_EQm(MSG, EXP, GOT, ENUM_STR)               \
    do {                                                                \
        int greatest_EXP = (int)(EXP);                                  \
        int greatest_GOT = (int)(GOT);                                  \
        greatest_enum_str_fun *greatest_ENUM_STR = ENUM_STR;            \
        if (greatest_EXP != greatest_GOT) {                             \
            fprintf(GREATEST_STDOUT, "\nExpected: %s",                  \
                greatest_ENUM_STR(greatest_EXP));                       \
            fprintf(GREATEST_STDOUT, "\n     Got: %s\n",                \
                greatest_ENUM_STR(greatest_GOT));                       \
            GREATEST_FAILm(MSG);                                        \
        }                                                               \
    } while (0)                                                         \

/* Fail if GOT not in range of EXP +|- TOL. */
#define GREATEST_ASSERT_IN_RANGEm(MSG, EXP, GOT, TOL)                   \
    do {                                                                \
        GREATEST_FLOAT greatest_EXP = (EXP);                            \
        GREATEST_FLOAT greatest_GOT = (GOT);                            \
        GREATEST_FLOAT greatest_TOL = (TOL);                            \
        greatest_info.assertions++;                                     \
        if ((greatest_EXP > greatest_GOT &&                             \
                greatest_EXP - greatest_GOT > greatest_TOL) ||          \
            (greatest_EXP < greatest_GOT &&                             \
                greatest_GOT - greatest_EXP > greatest_TOL)) {          \
            fprintf(GREATEST_STDOUT,                                    \
                "\nExpected: " GREATEST_FLOAT_FMT                       \
                " +/- " GREATEST_FLOAT_FMT                              \
                "\n     Got: " GREATEST_FLOAT_FMT                       \
                "\n",                                                   \
                greatest_EXP, greatest_TOL, greatest_GOT);              \
            GREATEST_FAILm(MSG);                                        \
        }                                                               \
    } while (0)

/* Fail if EXP is not equal to GOT, according to strcmp. */
#define GREATEST_ASSERT_STR_EQm(MSG, EXP, GOT)                          \
    do {                                                                \
        GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT,                         \
            &greatest_type_info_string, NULL);                          \
    } while (0)                                                         \

/* Fail if EXP is not equal to GOT, according to strcmp. */
#define GREATEST_ASSERT_STRN_EQm(MSG, EXP, GOT, SIZE)                   \
    do {                                                                \
        size_t size = SIZE;                                             \
        GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT,                         \
            &greatest_type_info_string, &size);                         \
    } while (0)                                                         \

/* Fail if EXP is not equal to GOT, according to memcmp. */
#define GREATEST_ASSERT_MEM_EQm(MSG, EXP, GOT, SIZE)                    \
    do {                                                                \
        greatest_memory_cmp_env env;                                    \
        env.exp = (const unsigned char *)EXP;                           \
        env.got = (const unsigned char *)GOT;                           \
        env.size = SIZE;                                                \
        GREATEST_ASSERT_EQUAL_Tm(MSG, env.exp, env.got,                 \
            &greatest_type_info_memory, &env);                          \
    } while (0)                                                         \

/* Fail if EXP is not equal to GOT, according to a comparison
 * callback in TYPE_INFO. If they are not equal, optionally use a
 * print callback in TYPE_INFO to print them. */
#define GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT, TYPE_INFO, UDATA)       \
    do {                                                                \
        greatest_type_info *type_info = (TYPE_INFO);                    \
        greatest_info.assertions++;                                     \
        if (!greatest_do_assert_equal_t(EXP, GOT,                       \
                type_info, UDATA)) {                                    \
            if (type_info == NULL || type_info->equal == NULL) {        \
                GREATEST_FAILm("type_info->equal callback missing!");   \
            } else {                                                    \
                GREATEST_FAILm(MSG);                                    \
            }                                                           \
        }                                                               \
    } while (0)                                                         \

/* Pass. */
#define GREATEST_PASSm(MSG)                                             \
    do {                                                                \
        greatest_info.msg = MSG;                                        \
        return GREATEST_TEST_RES_PASS;                                  \
    } while (0)

/* Fail. */
#define GREATEST_FAILm(MSG)                                             \
    do {                                                                \
        greatest_info.fail_file = __FILE__;                             \
        greatest_info.fail_line = __LINE__;                             \
        greatest_info.msg = MSG;                                        \
        return GREATEST_TEST_RES_FAIL;                                  \
    } while (0)

/* Optional GREATEST_FAILm variant that longjmps. */
#ifdef GREATEST_USE_LONGJMP
#define GREATEST_FAIL_WITH_LONGJMP() GREATEST_FAIL_WITH_LONGJMPm(NULL)
#define GREATEST_FAIL_WITH_LONGJMPm(MSG)                                \
    do {                                                                \
        greatest_info.fail_file = __FILE__;                             \
        greatest_info.fail_line = __LINE__;                             \
        greatest_info.msg = MSG;                                        \
        longjmp(greatest_info.jump_dest, GREATEST_TEST_RES_FAIL);       \
    } while (0)
#endif

/* Skip the current test. */
#define GREATEST_SKIPm(MSG)                                             \
    do {                                                                \
        greatest_info.msg = MSG;                                        \
        return GREATEST_TEST_RES_SKIP;                                  \
    } while (0)

/* Check the result of a subfunction using ASSERT, etc. */
#define GREATEST_CHECK_CALL(RES)                                        \
    do {                                                                \
        enum greatest_test_res greatest_RES = RES;                      \
        if (greatest_RES != GREATEST_TEST_RES_PASS) {                   \
            return greatest_RES;                                        \
        }                                                               \
    } while (0)                                                         \

#ifdef GREATEST_USE_TIME
#define GREATEST_SET_TIME(NAME)                                         \
    NAME = clock();                                                     \
    if (NAME == (clock_t) -1) {                                         \
        fprintf(GREATEST_STDOUT,                                        \
            "clock error: %s\n", #NAME);                                \
        exit(EXIT_FAILURE);                                             \
    }

#define GREATEST_CLOCK_DIFF(C1, C2)                                     \
    fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_DGRAY " (%lu ticks, %.3f sec)" GREATEST_ANSI_COLOR_RESET, \
        (long unsigned int) (C2) - (long unsigned int)(C1),             \
        (double)((C2) - (C1)) / (1.0 * (double)CLOCKS_PER_SEC))
#else
#define GREATEST_SET_TIME(UNUSED)
#define GREATEST_CLOCK_DIFF(UNUSED1, UNUSED2)
#endif

#ifdef GREATEST_USE_LONGJMP
#define GREATEST_SAVE_CONTEXT()                                         \
        /* setjmp returns 0 (GREATEST_TEST_RES_PASS) on first call */   \
        /* so the test runs, then RES_FAIL from FAIL_WITH_LONGJMP. */   \
        ((enum greatest_test_res)(setjmp(greatest_info.jump_dest)))
#else
#define GREATEST_SAVE_CONTEXT()                                         \
    /*a no-op, since setjmp/longjmp aren't being used */                \
    GREATEST_TEST_RES_PASS
#endif

/* Include several function definitions in the main test file. */
#define GREATEST_MAIN_DEFS()                                            \
                                                                        \
/* Is FILTER a subset of NAME? */                                       \
static int greatest_name_match(const char *name,                        \
    const char *filter) {                                               \
    size_t offset = 0;                                                  \
    size_t filter_len = strlen(filter);                                 \
    while (name[offset] != '\0') {                                      \
        if (name[offset] == filter[0]) {                                \
            if (0 == strncmp(&name[offset], filter, filter_len)) {      \
                return 1;                                               \
            }                                                           \
        }                                                               \
        offset++;                                                       \
    }                                                                   \
                                                                        \
    return 0;                                                           \
}                                                                       \
                                                                        \
int greatest_pre_test(const char *name) {                               \
    if (!GREATEST_LIST_ONLY()                                           \
        && (!GREATEST_FIRST_FAIL() || greatest_info.suite.failed == 0)  \
        && (greatest_info.test_filter == NULL ||                        \
            greatest_name_match(name, greatest_info.test_filter))) {    \
        GREATEST_SET_TIME(greatest_info.suite.pre_test);                \
        if (greatest_info.setup) {                                      \
            greatest_info.setup(greatest_info.setup_udata);             \
        }                                                               \
        return 1;               /* test should be run */                \
    } else {                                                            \
        return 0;               /* skipped */                           \
    }                                                                   \
}                                                                       \
                                                                        \
void greatest_post_test(const char *name, int res) {                    \
    GREATEST_SET_TIME(greatest_info.suite.post_test);                   \
    if (greatest_info.teardown) {                                       \
        void *udata = greatest_info.teardown_udata;                     \
        greatest_info.teardown(udata);                                  \
    }                                                                   \
                                                                        \
    if (res <= GREATEST_TEST_RES_FAIL) {                                \
        greatest_do_fail(name);                                         \
    } else if (res >= GREATEST_TEST_RES_SKIP) {                         \
        greatest_do_skip(name);                                         \
    } else if (res == GREATEST_TEST_RES_PASS) {                         \
        greatest_do_pass(name);                                         \
    }                                                                   \
    greatest_info.suite.tests_run++;                                    \
    greatest_info.col++;                                                \
    if (GREATEST_IS_VERBOSE()) {                                        \
        GREATEST_CLOCK_DIFF(greatest_info.suite.pre_test,               \
            greatest_info.suite.post_test);                             \
        fprintf(GREATEST_STDOUT, "\n");                                 \
    } else if (greatest_info.col % greatest_info.width == 0) {          \
        fprintf(GREATEST_STDOUT, "\n");                                 \
        greatest_info.col = 0;                                          \
    }                                                                   \
    fflush(GREATEST_STDOUT);                                            \
}                                                                       \
                                                                        \
static void report_suite(void) {                                        \
    if (greatest_info.suite.tests_run > 0) {                            \
        fprintf(GREATEST_STDOUT,                                        \
            "\n%u test%s - %u passed, %u failed, %u skipped",           \
            greatest_info.suite.tests_run,                              \
            greatest_info.suite.tests_run == 1 ? "" : "s",              \
            greatest_info.suite.passed,                                 \
            greatest_info.suite.failed,                                 \
            greatest_info.suite.skipped);                               \
        GREATEST_CLOCK_DIFF(greatest_info.suite.pre_suite,              \
            greatest_info.suite.post_suite);                            \
        fprintf(GREATEST_STDOUT, "\n");                                 \
    }                                                                   \
}                                                                       \
                                                                        \
static void update_counts_and_reset_suite(void) {                       \
    greatest_info.setup = NULL;                                         \
    greatest_info.setup_udata = NULL;                                   \
    greatest_info.teardown = NULL;                                      \
    greatest_info.teardown_udata = NULL;                                \
    greatest_info.passed += greatest_info.suite.passed;                 \
    greatest_info.failed += greatest_info.suite.failed;                 \
    greatest_info.skipped += greatest_info.suite.skipped;               \
    greatest_info.tests_run += greatest_info.suite.tests_run;           \
    memset(&greatest_info.suite, 0, sizeof(greatest_info.suite));       \
    greatest_info.col = 0;                                              \
}                                                                       \
                                                                        \
static void greatest_run_suite(greatest_suite_cb *suite_cb,             \
                               const char *suite_name) {                \
    if (greatest_info.suite_filter &&                                   \
        !greatest_name_match(suite_name, greatest_info.suite_filter)) { \
        return;                                                         \
    }                                                                   \
    update_counts_and_reset_suite();                                    \
    if (GREATEST_FIRST_FAIL() && greatest_info.failed > 0) { return; }  \
    fprintf(GREATEST_STDOUT, "\n" GREATEST_ANSI_COLOR_YELLOW "* Suite %s:" GREATEST_ANSI_COLOR_RESET "\n", suite_name);  \
    GREATEST_SET_TIME(greatest_info.suite.pre_suite);                   \
    suite_cb();                                                         \
    GREATEST_SET_TIME(greatest_info.suite.post_suite);                  \
    report_suite();                                                     \
}                                                                       \
                                                                        \
void greatest_do_pass(const char *name) {                               \
    if (GREATEST_IS_VERBOSE()) {                                        \
        fprintf(GREATEST_STDOUT, "PASS %s: %s",                         \
            name, greatest_info.msg ? greatest_info.msg : "");          \
    } else {                                                            \
        fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_GREEN "." GREATEST_ANSI_COLOR_RESET);  \
    }                                                                   \
    greatest_info.suite.passed++;                                       \
}                                                                       \
                                                                        \
void greatest_do_fail(const char *name) {                               \
    if (GREATEST_IS_VERBOSE()) {                                        \
        fprintf(GREATEST_STDOUT,                                        \
            "FAIL %s: %s (%s:%u)",                                      \
            name, greatest_info.msg ? greatest_info.msg : "",           \
            greatest_info.fail_file, greatest_info.fail_line);          \
    } else {                                                            \
        fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_RED "F" GREATEST_ANSI_COLOR_RESET);    \
        greatest_info.col++;                                            \
        /* add linebreak if in line of '.'s */                          \
        if (greatest_info.col != 0) {                                   \
            fprintf(GREATEST_STDOUT, "\n");                             \
            greatest_info.col = 0;                                      \
        }                                                               \
        fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_RED "FAIL" GREATEST_ANSI_COLOR_RESET " %s: %s (%s:%u)\n",  \
            name,                                                       \
            greatest_info.msg ? greatest_info.msg : "",                 \
            greatest_info.fail_file, greatest_info.fail_line);          \
    }                                                                   \
    greatest_info.suite.failed++;                                       \
}                                                                       \
                                                                        \
void greatest_do_skip(const char *name) {                               \
    if (GREATEST_IS_VERBOSE()) {                                        \
        fprintf(GREATEST_STDOUT, "SKIP %s: %s",                         \
            name,                                                       \
            greatest_info.msg ?                                         \
            greatest_info.msg : "" );                                   \
    } else {                                                            \
        fprintf(GREATEST_STDOUT, "s");                                  \
    }                                                                   \
    greatest_info.suite.skipped++;                                      \
}                                                                       \
                                                                        \
int greatest_do_assert_equal_t(const void *exp, const void *got,        \
        greatest_type_info *type_info, void *udata) {                   \
    int eq = 0;                                                         \
    if (type_info == NULL || type_info->equal == NULL) {                \
        return 0;                                                       \
    }                                                                   \
    eq = type_info->equal(exp, got, udata);                             \
    if (!eq) {                                                          \
        if (type_info->print != NULL) {                                 \
            fprintf(GREATEST_STDOUT, "\nExpected: ");                   \
            (void)type_info->print(exp, udata);                         \
            fprintf(GREATEST_STDOUT, "\n     Got: ");                   \
            (void)type_info->print(got, udata);                         \
            fprintf(GREATEST_STDOUT, "\n");                             \
        } else {                                                        \
            fprintf(GREATEST_STDOUT,                                    \
                "GREATEST_ASSERT_EQUAL_T failure at %s:%u\n",           \
                greatest_info.fail_file,                                \
                greatest_info.fail_line);                               \
        }                                                               \
    }                                                                   \
    return eq;                                                          \
}                                                                       \
                                                                        \
void greatest_usage(const char *name) {                                 \
    fprintf(GREATEST_STDOUT,                                            \
        "Usage: %s [-hlfv] [-s SUITE] [-t TEST]\n"                      \
        "  -h, --help  print this Help\n"                               \
        "  -l          List suites and their tests, then exit\n"        \
        "  -f          Stop runner after first failure\n"               \
        "  -v          Verbose output\n"                                \
        "  -s SUITE    only run suites containing string SUITE\n"       \
        "  -t TEST     only run tests containing string TEST\n",        \
        name);                                                          \
}                                                                       \
                                                                        \
static void greatest_parse_args(int argc, char **argv) {                \
    int i = 0;                                                          \
    for (i = 1; i < argc; i++) {                                        \
        if (0 == strncmp("-t", argv[i], 2)) {                           \
            if (argc <= i + 1) {                                        \
                greatest_usage(argv[0]);                                \
                exit(EXIT_FAILURE);                                     \
            }                                                           \
            greatest_info.test_filter = argv[i+1];                      \
            i++;                                                        \
        } else if (0 == strncmp("-s", argv[i], 2)) {                    \
            if (argc <= i + 1) {                                        \
                greatest_usage(argv[0]);                                \
                exit(EXIT_FAILURE);                                     \
            }                                                           \
            greatest_info.suite_filter = argv[i+1];                     \
            i++;                                                        \
        } else if (0 == strncmp("-f", argv[i], 2)) {                    \
            greatest_info.flags |= GREATEST_FLAG_FIRST_FAIL;            \
        } else if (0 == strncmp("-v", argv[i], 2)) {                    \
            greatest_info.verbosity++;                                  \
        } else if (0 == strncmp("-l", argv[i], 2)) {                    \
            greatest_info.flags |= GREATEST_FLAG_LIST_ONLY;             \
        } else if (0 == strncmp("-h", argv[i], 2) ||                    \
                   0 == strncmp("--help", argv[i], 6)) {                \
            greatest_usage(argv[0]);                                    \
            exit(EXIT_SUCCESS);                                         \
        } else if (0 == strncmp("--", argv[i], 2)) {                    \
            break;                                                      \
        } else {                                                        \
            fprintf(GREATEST_STDOUT,                                    \
                "Unknown argument '%s'\n", argv[i]);                    \
            greatest_usage(argv[0]);                                    \
            exit(EXIT_FAILURE);                                         \
        }                                                               \
    }                                                                   \
}                                                                       \
                                                                        \
int greatest_all_passed(void) { return (greatest_info.failed == 0); }   \
                                                                        \
void greatest_set_test_filter(const char *name) {                       \
    greatest_info.test_filter = name;                                   \
}                                                                       \
                                                                        \
void greatest_set_suite_filter(const char *name) {                      \
    greatest_info.suite_filter = name;                                  \
}                                                                       \
                                                                        \
void greatest_get_report(struct greatest_report_t *report) {            \
    if (report) {                                                       \
        report->passed = greatest_info.passed;                          \
        report->failed = greatest_info.failed;                          \
        report->skipped = greatest_info.skipped;                        \
        report->assertions = greatest_info.assertions;                  \
    }                                                                   \
}                                                                       \
                                                                        \
unsigned int greatest_get_verbosity(void) {                             \
    return greatest_info.verbosity;                                     \
}                                                                       \
                                                                        \
void greatest_set_verbosity(unsigned int verbosity) {                   \
    greatest_info.verbosity = (unsigned char)verbosity;                 \
}                                                                       \
                                                                        \
void greatest_set_flag(greatest_flag_t flag) {                          \
    greatest_info.flags |= flag;                                        \
}                                                                       \
                                                                        \
void GREATEST_SET_SETUP_CB(greatest_setup_cb *cb, void *udata) {        \
    greatest_info.setup = cb;                                           \
    greatest_info.setup_udata = udata;                                  \
}                                                                       \
                                                                        \
void GREATEST_SET_TEARDOWN_CB(greatest_teardown_cb *cb,                 \
                                    void *udata) {                      \
    greatest_info.teardown = cb;                                        \
    greatest_info.teardown_udata = udata;                               \
}                                                                       \
                                                                        \
static int greatest_string_equal_cb(const void *exp, const void *got,   \
    void *udata) {                                                      \
    size_t *size = (size_t *)udata;                                     \
    return (size != NULL                                                \
        ? (0 == strncmp((const char *)exp, (const char *)got, *size))   \
        : (0 == strcmp((const char *)exp, (const char *)got)));         \
}                                                                       \
                                                                        \
static int greatest_string_printf_cb(const void *t, void *udata) {      \
    (void)udata; /* note: does not check \0 termination. */             \
    return fprintf(GREATEST_STDOUT, "%s", (const char *)t);             \
}                                                                       \
                                                                        \
greatest_type_info greatest_type_info_string = {                        \
    greatest_string_equal_cb,                                           \
    greatest_string_printf_cb,                                          \
};                                                                      \
                                                                        \
static int greatest_memory_equal_cb(const void *exp, const void *got,   \
    void *udata) {                                                      \
    greatest_memory_cmp_env *env = (greatest_memory_cmp_env *)udata;    \
    return (0 == memcmp(exp, got, env->size));                          \
}                                                                       \
                                                                        \
static int greatest_memory_printf_cb(const void *t, void *udata) {      \
    greatest_memory_cmp_env *env = (greatest_memory_cmp_env *)udata;    \
    const unsigned char *buf = (const unsigned char *)t;                \
    unsigned char diff_mark = ' ';                                      \
    FILE *out = GREATEST_STDOUT;                                        \
    size_t i, line_i, line_len = 0;                                     \
    int len = 0;   /* format hexdump with differences highlighted */    \
    for (i = 0; i < env->size; i+= line_len) {                          \
        diff_mark = ' ';                                                \
        line_len = env->size - i;                                       \
        if (line_len > 16) { line_len = 16; }                           \
        for (line_i = i; line_i < i + line_len; line_i++) {             \
            if (env->exp[line_i] != env->got[line_i]) diff_mark = 'X';  \
        }                                                               \
        len += fprintf(out, "\n%04x %c ", (unsigned int)i, diff_mark);  \
        for (line_i = i; line_i < i + line_len; line_i++) {             \
            int m = env->exp[line_i] == env->got[line_i]; /* match? */  \
            len += fprintf(out, "%02x%c", buf[line_i], m ? ' ' : '<');  \
        }                                                               \
        for (line_i = 0; line_i < 16 - line_len; line_i++) {            \
            len += fprintf(out, "   ");                                 \
        }                                                               \
        fprintf(out, " ");                                              \
        for (line_i = i; line_i < i + line_len; line_i++) {             \
            unsigned char c = buf[line_i];                              \
            len += fprintf(out, "%c", isprint(c) ? c : '.');            \
        }                                                               \
    }                                                                   \
    len += fprintf(out, "\n");                                          \
    return len;                                                         \
}                                                                       \
                                                                        \
greatest_type_info greatest_type_info_memory = {                        \
    greatest_memory_equal_cb,                                           \
    greatest_memory_printf_cb,                                          \
};                                                                      \
                                                                        \
greatest_run_info greatest_info

/* Init internals. */
#define GREATEST_INIT()                                                 \
    do {                                                                \
        /* Suppress unused function warning if features aren't used */  \
        (void)greatest_run_suite;                                       \
        (void)greatest_parse_args;                                      \
                                                                        \
        memset(&greatest_info, 0, sizeof(greatest_info));               \
        greatest_info.width = GREATEST_DEFAULT_WIDTH;                   \
        GREATEST_SET_TIME(greatest_info.begin);                         \
    } while (0)                                                         \

/* Handle command-line arguments, etc. */
#define GREATEST_MAIN_BEGIN()                                           \
    do {                                                                \
        GREATEST_INIT();                                                \
        greatest_parse_args(argc, argv);                                \
    } while (0)

/* Report passes, failures, skipped tests, the number of
 * assertions, and the overall run time. */
#define GREATEST_PRINT_REPORT()                                         \
    do {                                                                \
        if (!GREATEST_LIST_ONLY()) {                                    \
            update_counts_and_reset_suite();                            \
            GREATEST_SET_TIME(greatest_info.end);                       \
            fprintf(GREATEST_STDOUT,                                    \
                "\nTotal: %u test%s",                                   \
                greatest_info.tests_run,                                \
                greatest_info.tests_run == 1 ? "" : "s");               \
            GREATEST_CLOCK_DIFF(greatest_info.begin,                    \
                greatest_info.end);                                     \
            fprintf(GREATEST_STDOUT, ", %u assertion%s\n",              \
                greatest_info.assertions,                               \
                greatest_info.assertions == 1 ? "" : "s");              \
            fprintf(GREATEST_STDOUT,                                    \
                GREATEST_ANSI_COLOR_GREEN "Pass: %u, fail: %u, skip: %u.\n" GREATEST_ANSI_COLOR_RESET,  \
                greatest_info.passed,                                   \
                greatest_info.failed, greatest_info.skipped);           \
        }                                                               \
    } while (0)

/* Report results, exit with exit status based on results. */
#define GREATEST_MAIN_END()                                             \
    do {                                                                \
        GREATEST_PRINT_REPORT();                                        \
        return (greatest_all_passed() ? EXIT_SUCCESS : EXIT_FAILURE);   \
    } while (0)

/* Make abbreviations without the GREATEST_ prefix for the
 * most commonly used symbols. */
#ifdef GREATEST_USE_ABBREVS
#define TEST           GREATEST_TEST
#define SUITE          GREATEST_SUITE
#define SUITE_EXTERN   GREATEST_SUITE_EXTERN
#define RUN_TEST       GREATEST_RUN_TEST
#define RUN_TEST1      GREATEST_RUN_TEST1
#define RUN_SUITE      GREATEST_RUN_SUITE
#define IGNORE_TEST    GREATEST_IGNORE_TEST
#define ASSERT         GREATEST_ASSERT
#define ASSERTm        GREATEST_ASSERTm
#define ASSERT_FALSE   GREATEST_ASSERT_FALSE
#define ASSERT_EQ      GREATEST_ASSERT_EQ
#define ASSERT_EQ_FMT  GREATEST_ASSERT_EQ_FMT
#define ASSERT_IN_RANGE GREATEST_ASSERT_IN_RANGE
#define ASSERT_EQUAL_T GREATEST_ASSERT_EQUAL_T
#define ASSERT_STR_EQ  GREATEST_ASSERT_STR_EQ
#define ASSERT_STRN_EQ GREATEST_ASSERT_STRN_EQ
#define ASSERT_MEM_EQ  GREATEST_ASSERT_MEM_EQ
#define ASSERT_ENUM_EQ GREATEST_ASSERT_ENUM_EQ
#define ASSERT_FALSEm  GREATEST_ASSERT_FALSEm
#define ASSERT_EQm     GREATEST_ASSERT_EQm
#define ASSERT_EQ_FMTm GREATEST_ASSERT_EQ_FMTm
#define ASSERT_IN_RANGEm GREATEST_ASSERT_IN_RANGEm
#define ASSERT_EQUAL_Tm GREATEST_ASSERT_EQUAL_Tm
#define ASSERT_STR_EQm GREATEST_ASSERT_STR_EQm
#define ASSERT_STRN_EQm GREATEST_ASSERT_STRN_EQm
#define ASSERT_MEM_EQm GREATEST_ASSERT_MEM_EQm
#define ASSERT_ENUM_EQm GREATEST_ASSERT_ENUM_EQm
#define PASS           GREATEST_PASS
#define FAIL           GREATEST_FAIL
#define SKIP           GREATEST_SKIP
#define PASSm          GREATEST_PASSm
#define FAILm          GREATEST_FAILm
#define SKIPm          GREATEST_SKIPm
#define SET_SETUP      GREATEST_SET_SETUP_CB
#define SET_TEARDOWN   GREATEST_SET_TEARDOWN_CB
#define CHECK_CALL     GREATEST_CHECK_CALL

#ifdef GREATEST_VA_ARGS
#define RUN_TESTp      GREATEST_RUN_TESTp
#endif

#ifdef GREATEST_USE_LONGJMP
#define ASSERT_OR_LONGJMP  GREATEST_ASSERT_OR_LONGJMP
#define ASSERT_OR_LONGJMPm GREATEST_ASSERT_OR_LONGJMPm
#define FAIL_WITH_LONGJMP  GREATEST_FAIL_WITH_LONGJMP
#define FAIL_WITH_LONGJMPm GREATEST_FAIL_WITH_LONGJMPm
#endif

#endif /* USE_ABBREVS */

#ifdef __cplusplus
}
#endif

#endif
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../external/greatest.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_helpers.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_memory_allocator_t *octaspireHelpersTestAllocator = 0;
static octaspire_stdio_t            *octaspireHelpersTestStdio = 0;

TEST octaspire_helpers_test_bit_when_only_highest_order_bit_is_set_test(void)
{
    uint32_t const bitSet = 0x80000000;

    for (size_t i = 0; i < 31; ++i)
    {
        ASSERT_FALSE(octaspire_helpers_test_bit(bitSet, i));
    }

    ASSERT(octaspire_helpers_test_bit(bitSet, 31));

    PASS();
}

TEST octaspire_helpers_test_bit_when_only_lowest_order_bit_is_set_test(void)
{
    uint32_t const bitSet = 0x00000001;

    ASSERT(octaspire_helpers_test_bit(bitSet, 0));

    for (size_t i = 1; i < 32; ++i)
    {
        ASSERT_FALSE(octaspire_helpers_test_bit(bitSet, i));
    }

    PASS();
}

TEST octaspire_helpers_test_bit_when_all_bits_are_set_test(void)
{
    uint32_t const bitSet = 0xFFFFFFFF;

    for (size_t i = 0; i < 32; ++i)
    {
        ASSERT(octaspire_helpers_test_bit(bitSet, i));
    }

    PASS();
}

TEST octaspire_helpers_test_bit_when_no_bits_are_set_test(void)
{
    uint32_t const bitSet = 0x00000000;

    for (size_t i = 0; i < 32; ++i)
    {
        ASSERT_FALSE(octaspire_helpers_test_bit(bitSet, i));
    }

    PASS();
}

TEST octaspire_helpers_test_bit_when_every_bit_at_even_index_is_set_test(void)
{
    uint32_t const bitSet = 0x55555555;

    for (size_t i = 0; i < 32; ++i)
    {
        if (i % 2 == 0)
        {
            ASSERT(octaspire_helpers_test_bit(bitSet, i));
        }
        else
        {
            ASSERT_FALSE(octaspire_helpers_test_bit(bitSet, i));
        }
    }

    PASS();
}

TEST octaspire_helpers_test_bit_when_every_bit_at_odd_index_is_set_test(void)
{
    uint32_t const bitSet = 0xAAAAAAAA;

    for (size_t i = 0; i < 32; ++i)
    {
        if (i % 2 != 0)
        {
            ASSERT(octaspire_helpers_test_bit(bitSet, i));
        }
        else
        {
            ASSERT_FALSE(octaspire_helpers_test_bit(bitSet, i));
        }
    }

    PASS();
}

TEST octaspire_helpers_path_to_buffer_test(void)
{
    size_t octetsAllocated = 0;

    char * buffer = octaspire_helpers_path_to_buffer(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_helpers_path_to_buffer_test",
        &octetsAllocated,
        octaspireHelpersTestAllocator,
        octaspireHelpersTestStdio);

    ASSERT(buffer);
    ASSERT_EQ(2 + 3 + 4, octetsAllocated);

    // Copyright sign 0xa9               2 octet
    // Equal sign     0x2260             3 octets
    // Linear b syllable b008 a 0x10000  4 octets
    char const * const expected = "\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    ASSERT_EQ(octetsAllocated, strlen(expected));

    ASSERT_MEM_EQ(expected, buffer, octetsAllocated);

    octaspire_memory_allocator_free(octaspireHelpersTestAllocator, buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_helpers_path_to_buffer_failure_on_nonexisting_file_test(void)
{
    size_t octetsAllocated = 0;

    char * buffer = octaspire_helpers_path_to_buffer(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_helpers_path_to_buffer_failure_on_nonexisting_file_test",
        &octetsAllocated,
        octaspireHelpersTestAllocator,
        octaspireHelpersTestStdio);

    ASSERT_FALSE(buffer);
    ASSERT_EQ(0, octetsAllocated);

    octaspire_memory_allocator_free(octaspireHelpersTestAllocator, buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_helpers_path_to_buffer_failure_on_empty_file_test(void)
{
    size_t octetsAllocated = 0;

    char * buffer = octaspire_helpers_path_to_buffer(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_helpers_path_to_buffer_failure_on_empty_file_test",
        &octetsAllocated,
        octaspireHelpersTestAllocator,
        octaspireHelpersTestStdio);

    ASSERT_FALSE(buffer);
    ASSERT_EQ(0, octetsAllocated);

    octaspire_memory_allocator_free(octaspireHelpersTestAllocator, buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_helpers_path_to_buffer_allocation_failure_test(void)
{
    size_t octetsAllocated = 0;

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireHelpersTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireHelpersTestAllocator));

    char * buffer = octaspire_helpers_path_to_buffer(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_helpers_path_to_buffer_test",
        &octetsAllocated,
        octaspireHelpersTestAllocator,
        octaspireHelpersTestStdio);

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireHelpersTestAllocator));

    ASSERT_FALSE(buffer);
    ASSERT_EQ(0, octetsAllocated);

    octaspire_memory_allocator_free(octaspireHelpersTestAllocator, buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_helpers_path_to_buffer_read_failure_test(void)
{
    size_t octetsAllocated = 0;

    octaspire_stdio_set_number_and_type_of_future_reads_to_be_rigged(octaspireHelpersTestStdio, 1, 0);
    ASSERT_EQ(1, octaspire_stdio_get_number_of_future_reads_to_be_rigged(octaspireHelpersTestStdio));

    char * buffer = octaspire_helpers_path_to_buffer(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_helpers_path_to_buffer_test",
        &octetsAllocated,
        octaspireHelpersTestAllocator,
        octaspireHelpersTestStdio);

    ASSERT_EQ(0, octaspire_stdio_get_number_of_future_reads_to_be_rigged(octaspireHelpersTestStdio));

    ASSERT_FALSE(buffer);
    ASSERT_EQ(0, octetsAllocated);

    octaspire_memory_allocator_free(octaspireHelpersTestAllocator, buffer);
    buffer = 0;

    PASS();
}

GREATEST_SUITE(octaspire_helpers_suite)
{
    octaspireHelpersTestAllocator = octaspire_memory_allocator_new(0);
    octaspireHelpersTestStdio     = octaspire_stdio_new(octaspireHelpersTestAllocator);

    assert(octaspireHelpersTestAllocator);
    assert(octaspireHelpersTestStdio);

    RUN_TEST(octaspire_helpers_test_bit_when_only_highest_order_bit_is_set_test);
    RUN_TEST(octaspire_helpers_test_bit_when_only_lowest_order_bit_is_set_test);
    RUN_TEST(octaspire_helpers_test_bit_when_all_bits_are_set_test);
    RUN_TEST(octaspire_helpers_test_bit_when_no_bits_are_set_test);
    RUN_TEST(octaspire_helpers_test_bit_when_every_bit_at_even_index_is_set_test);
    RUN_TEST(octaspire_helpers_test_bit_when_every_bit_at_odd_index_is_set_test);
    RUN_TEST(octaspire_helpers_path_to_buffer_test);
    RUN_TEST(octaspire_helpers_path_to_buffer_failure_on_nonexisting_file_test);
    RUN_TEST(octaspire_helpers_path_to_buffer_failure_on_empty_file_test);
    RUN_TEST(octaspire_helpers_path_to_buffer_allocation_failure_test);
    RUN_TEST(octaspire_helpers_path_to_buffer_read_failure_test);

    octaspire_stdio_release(octaspireHelpersTestStdio);
    octaspireHelpersTestStdio = 0;

    octaspire_memory_allocator_release(octaspireHelpersTestAllocator);
    octaspireHelpersTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_helpers.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_utf8.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_memory_allocator_t *octaspireUtf8TestAllocator = 0;

TEST octaspire_utf8_private_rangeof_test(void)
{
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST, octaspire_utf8_private_rangeof(0));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST, octaspire_utf8_private_rangeof(1));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST, octaspire_utf8_private_rangeof(126));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST, octaspire_utf8_private_rangeof(127));

    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND, octaspire_utf8_private_rangeof(128));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND, octaspire_utf8_private_rangeof(129));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND, octaspire_utf8_private_rangeof(1000));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND, octaspire_utf8_private_rangeof(2047));

    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD, octaspire_utf8_private_rangeof(2048));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD, octaspire_utf8_private_rangeof(2049));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD, octaspire_utf8_private_rangeof(32000));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD, octaspire_utf8_private_rangeof(65535));

    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH, octaspire_utf8_private_rangeof(65536));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH, octaspire_utf8_private_rangeof(65537));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH, octaspire_utf8_private_rangeof(100000));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH, octaspire_utf8_private_rangeof(1114111));

    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_ILLEGAL, octaspire_utf8_private_rangeof(1114112));
    ASSERT_EQ(OCTASPIRE_UTF8_CHARACTER_RANGE_ILLEGAL, octaspire_utf8_private_rangeof(1114113));

    PASS();
}

TEST octaspire_utf8_private_high_order_bits_test(void)
{
    ASSERT_EQ(((uint32_t)0x0),        octaspire_utf8_private_high_order_bits(OCTASPIRE_UTF8_CHARACTER_RANGE_FIRST));
    ASSERT_EQ(((uint32_t)0xC080),     octaspire_utf8_private_high_order_bits(OCTASPIRE_UTF8_CHARACTER_RANGE_SECOND));
    ASSERT_EQ(((uint32_t)0xE08080),   octaspire_utf8_private_high_order_bits(OCTASPIRE_UTF8_CHARACTER_RANGE_THIRD));
    ASSERT_EQ(((uint32_t)0xF0808080), octaspire_utf8_private_high_order_bits(OCTASPIRE_UTF8_CHARACTER_RANGE_FOURTH));
    ASSERT_EQ(((uint32_t)0xFFFFFFFF), octaspire_utf8_private_high_order_bits(OCTASPIRE_UTF8_CHARACTER_RANGE_ILLEGAL));

    PASS();
}

TEST octaspire_utf8_private_set_bit_test(void)
{
    uint32_t bitset = 0;

    for (size_t i = 0; i < 32; ++i)
    {
        octaspire_utf8_private_set_bit(&bitset, i, true);
        ASSERT_EQ(pow(2, i), bitset);
        octaspire_utf8_private_set_bit(&bitset, i, false);
        ASSERT_EQ(0, bitset);
    }

    PASS();
}

TEST octaspire_utf8_private_get_bit_test(void)
{
    uint32_t bitset = 0;

    for (size_t i = 0; i < 32; ++i)
    {
        octaspire_utf8_private_set_bit(&bitset, i, true);
        ASSERT_EQ(pow(2, i), bitset);

        for (size_t j = 0; j < 32; ++j)
        {
            ASSERT_EQ((j == i) ? true : false, octaspire_utf8_private_get_bit(bitset, j));
        }

        octaspire_utf8_private_set_bit(&bitset, i, false);
        ASSERT_EQ(0, bitset);
    }

    PASS();
}

TEST octaspire_utf8_encode_character_NUL_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character('\0', &encoded));

    ASSERT_EQ(1, encoded.numoctets);

    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(0, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_SOH_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(1, &encoded));

    ASSERT_EQ(1, encoded.numoctets);

    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(1, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_space_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(' ', &encoded));

    ASSERT_EQ(1, encoded.numoctets);

    ASSERT_EQ(0,  encoded.octets[0]);
    ASSERT_EQ(0,  encoded.octets[1]);
    ASSERT_EQ(0,  encoded.octets[2]);
    ASSERT_EQ(32, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_A_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character('A', &encoded));

    ASSERT_EQ(1, encoded.numoctets);

    ASSERT_EQ(0,  encoded.octets[0]);
    ASSERT_EQ(0,  encoded.octets[1]);
    ASSERT_EQ(0,  encoded.octets[2]);
    ASSERT_EQ(65, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_control_U_PLUS_0080_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0x80, &encoded));

    ASSERT_EQ(2, encoded.numoctets);

    ASSERT_EQ(0,    encoded.octets[0]);
    ASSERT_EQ(0,    encoded.octets[1]);
    ASSERT_EQ(0xc2, encoded.octets[2]);
    ASSERT_EQ(0x80, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_latin_small_letter_a_with_diaeresis_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0xE4, &encoded));

    ASSERT_EQ(2, encoded.numoctets);

    ASSERT_EQ(0,    encoded.octets[0]);
    ASSERT_EQ(0,    encoded.octets[1]);
    ASSERT_EQ(0xc3, encoded.octets[2]);
    ASSERT_EQ(0xa4, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_latin_small_letter_y_with_diaeresis_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0xFF, &encoded));

    ASSERT_EQ(2, encoded.numoctets);

    ASSERT_EQ(0,    encoded.octets[0]);
    ASSERT_EQ(0,    encoded.octets[1]);
    ASSERT_EQ(0xc3, encoded.octets[2]);
    ASSERT_EQ(0xbf, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_copyright_sign_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0xA9, &encoded));

    ASSERT_EQ(2, encoded.numoctets);

    ASSERT_EQ(0,    encoded.octets[0]);
    ASSERT_EQ(0,    encoded.octets[1]);
    ASSERT_EQ(0xc2, encoded.octets[2]);
    ASSERT_EQ(0xa9, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_not_equal_symbol_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0x2260, &encoded));

    ASSERT_EQ(3, encoded.numoctets);

    ASSERT_EQ(0x0,  encoded.octets[0]);
    ASSERT_EQ(0xe2, encoded.octets[1]);
    ASSERT_EQ(0x89, encoded.octets[2]);
    ASSERT_EQ(0xa0, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_linear_b_syllable_b008_a_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0x10000, &encoded));

    ASSERT_EQ(4, encoded.numoctets);

    ASSERT_EQ(0xf0, encoded.octets[0]);
    ASSERT_EQ(0x90, encoded.octets[1]);
    ASSERT_EQ(0x80, encoded.octets[2]);
    ASSERT_EQ(0x80, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_of_illegal_range_test(void)
{
    octaspire_utf8_character_t encoded;

    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER, octaspire_utf8_encode_character(0xFFFFFFFF, &encoded));

    ASSERT_EQ(0, encoded.numoctets);

    ASSERT_EQ(0x0, encoded.octets[0]);
    ASSERT_EQ(0x0, encoded.octets[1]);
    ASSERT_EQ(0x0, encoded.octets[2]);
    ASSERT_EQ(0x0, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_encode_character_illegal_range_from_U_PLUS_D800_to_U_PLUS_DFFF_test(void)
{
    octaspire_utf8_character_t encoded;

    // Lower limit minus one
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0xD7ff, &encoded));
    ASSERT_EQ(3,    encoded.numoctets);
    ASSERT_EQ(0,    encoded.octets[0]);
    ASSERT_EQ(0xed, encoded.octets[1]);
    ASSERT_EQ(0x9f, encoded.octets[2]);
    ASSERT_EQ(0xbf, encoded.octets[3]);

    // Lower limit
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER, octaspire_utf8_encode_character(0xD800, &encoded));
    ASSERT_EQ(0, encoded.numoctets);
    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(0, encoded.octets[3]);

    // Lower limit plus one
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER, octaspire_utf8_encode_character(0xD801, &encoded));
    ASSERT_EQ(0, encoded.numoctets);
    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(0, encoded.octets[3]);

    // In the middle between lower and upper limit
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER, octaspire_utf8_encode_character(0xdbff, &encoded));
    ASSERT_EQ(0, encoded.numoctets);
    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(0, encoded.octets[3]);

    // Upper limit minus one
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER, octaspire_utf8_encode_character(0xDFFE, &encoded));
    ASSERT_EQ(0, encoded.numoctets);
    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(0, encoded.octets[3]);

    // Upper limit
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_ILLEGAL_CHARACTER_NUMBER, octaspire_utf8_encode_character(0xDFFF, &encoded));
    ASSERT_EQ(0, encoded.numoctets);
    ASSERT_EQ(0, encoded.octets[0]);
    ASSERT_EQ(0, encoded.octets[1]);
    ASSERT_EQ(0, encoded.octets[2]);
    ASSERT_EQ(0, encoded.octets[3]);

    // Upper limit plus one
    ASSERT_EQ(OCTASPIRE_UTF8_ENCODE_STATUS_OK, octaspire_utf8_encode_character(0xE000, &encoded));
    ASSERT_EQ(3,    encoded.numoctets);
    ASSERT_EQ(0,    encoded.octets[0]);
    ASSERT_EQ(0xee, encoded.octets[1]);
    ASSERT_EQ(0x80, encoded.octets[2]);
    ASSERT_EQ(0x80, encoded.octets[3]);

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_is_empty_string_test(void)
{
    char const *text = "";
    ASSERT_EQ(0,  strlen(text));
    ASSERT_EQ(0, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_is_null_test(void)
{
    char const *text = 0;
    ASSERT_EQ(0, octaspire_utf8_private_octets_in_next(text, 0));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_one_octet_0x80_test(void)
{
    char const *text = "\x80";
    ASSERT_EQ(1,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_two_octets_0xC0FF_test(void)
{
    char const *text = "\xC0\xFF";
    ASSERT_EQ(2,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_three_octets_0xE080FF_test(void)
{
    char const *text = "\xE0\x80\xFF";
    ASSERT_EQ(3,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_four_octets_0xF08080FF_test(void)
{
    char const *text = "\xF0\x80\x80\xFF";
    ASSERT_EQ(4,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_one_octet_0x01_test(void)
{
    char const *text = "\x01";
    ASSERT_EQ(1,  strlen(text));
    ASSERT_EQ(1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_two_octets_0xC080_test(void)
{
    char const *text = "\xC0\x80";
    ASSERT_EQ(2,  strlen(text));
    ASSERT_EQ(2, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_two_octets_with_error_0xC000_test(void)
{
    char const *text = "\xC0\x00";
    ASSERT_EQ(1,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_two_octets_with_error_0xC070_test(void)
{
    char const *text = "\xC0\x70";
    ASSERT_EQ(2,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_0xE08080_test(void)
{
    char const *text = "\xE0\x80\x80";
    ASSERT_EQ(3,  strlen(text));
    ASSERT_EQ(3, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_with_error_0xE00080_test(void)
{
    char const *text = "\xE0\x00\x80";
    ASSERT_EQ(1,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_with_error_0xE08000_test(void)
{
    char const *text = "\xE0\x80\x00";
    ASSERT_EQ(2,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_with_error_0xE08070_test(void)
{
    char const *text = "\xE0\x80\x70";
    ASSERT_EQ(3,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_0xF0808080_test(void)
{
    char const *text = "\xF0\x80\x80\x80";
    ASSERT_EQ(4,  strlen(text));
    ASSERT_EQ(4, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0008080_test(void)
{
    char const *text = "\xF0\x00\x80\x80";
    ASSERT_EQ(1,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0800080_test(void)
{
    char const *text = "\xF0\x80\x00\x80";
    ASSERT_EQ(2,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0808000_test(void)
{
    char const *text = "\xF0\x80\x80\x00";
    ASSERT_EQ(3,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0808070_test(void)
{
    char const *text = "\xF0\x80\x80\x70";
    ASSERT_EQ(4,  strlen(text));
    ASSERT_EQ(-1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_one_of_five_octets_0x01F0808080_test(void)
{
    char const *text = "\x01\xF0\x80\x80\x80";
    ASSERT_EQ(5,  strlen(text));
    ASSERT_EQ(1, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_two_of_six_octets_0xC080F0808080_test(void)
{
    char const *text = "\xC0\x80\xF0\x80\x80\x80";
    ASSERT_EQ(6,  strlen(text));
    ASSERT_EQ(2, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_three_of_seven_octets_0xE08080F0808080_test(void)
{
    char const *text = "\xE0\x80\x80\xF0\x80\x80\x80";
    ASSERT_EQ(7,  strlen(text));
    ASSERT_EQ(3, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_octets_in_next_that_has_length_of_four_of_eight_octets_0xF0808080F0808080_test(void)
{
    char const *text = "\xF0\x80\x80\x80\xF0\x80\x80\x80";
    ASSERT_EQ(8,  strlen(text));
    ASSERT_EQ(4, octaspire_utf8_private_octets_in_next(text, strlen(text)));

    PASS();
}

TEST octaspire_utf8_private_decode_helper_error_with_more_octets_being_needed_than_available_test(void)
{
    char const *buffer = 0;
    uint32_t    result = 0;

    octaspire_utf8_decode_status_t const expected =
        OCTASPIRE_UTF8_DECODE_STATUS_INPUT_NOT_ENOUGH_OCTETS_AVAILABLE;

    for (size_t numOctetsNeeded = 1; numOctetsNeeded < 5; ++numOctetsNeeded)
    {
        ASSERT_EQ(
            expected,
            octaspire_utf8_private_decode_helper(buffer, numOctetsNeeded, 0, &result));
    }

    for (size_t numOctetsNeeded = 2; numOctetsNeeded < 5; ++numOctetsNeeded)
    {
        ASSERT_EQ(
            expected,
            octaspire_utf8_private_decode_helper(buffer, numOctetsNeeded, 1, &result));
    }

    for (size_t numOctetsNeeded = 3; numOctetsNeeded < 5; ++numOctetsNeeded)
    {
        ASSERT_EQ(
            expected,
            octaspire_utf8_private_decode_helper(buffer, numOctetsNeeded, 2, &result));
    }

    ASSERT_EQ(expected, octaspire_utf8_private_decode_helper(buffer, 4, 3, &result));

    PASS();
}

TEST octaspire_utf8_decode_character_null_string_test(void)
{
    char const *text = 0;
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL, octaspire_utf8_decode_character(text, 0, &result, &numoctets));
    ASSERT_EQ(0, result);
    ASSERT_EQ(0, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_from_buffer_null_string_test(void)
{
    size_t const currentIndex = 0;
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL,
        octaspire_utf8_decode_character_from_buffer(
            0,
            0,
            currentIndex,
            &result,
            &numoctets));

    ASSERT_EQ(0, result);
    ASSERT_EQ(0, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_empty_string_test(void)
{
    char const *text = "";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0, result);
    ASSERT_EQ(0, numoctets);

    PASS();
}

// TODO XXX Should this case be exactly the same as the above case with c-string?
// Now return value is different when decoded from c-string and buffer.
TEST octaspire_utf8_decode_character_from_buffer_empty_string_test(void)
{
    octaspire_container_vector_t *buffer =
        octaspire_container_vector_new(sizeof(char), false, 0, octaspireUtf8TestAllocator);

    size_t const currentIndex = 0;
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL,
        octaspire_utf8_decode_character_from_buffer(
            octaspire_container_vector_get_element_at(buffer, 0),
            octaspire_container_vector_get_length_in_octets(buffer),
            currentIndex,
            &result,
            &numoctets));

    ASSERT_EQ(0, result);
    ASSERT_EQ(0, numoctets);

    octaspire_container_vector_release(buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_utf8_decode_character_a_test(void)
{
    char const *text = "a";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OK,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(97, result);
    ASSERT_EQ(1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_from_buffer_a_test(void)
{
    octaspire_container_vector_t *buffer =
        octaspire_container_vector_new(sizeof(char), false, 0, octaspireUtf8TestAllocator);

    octaspire_container_vector_push_back_char(buffer, 'a');
    size_t const currentIndex = 0;
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OK,
        octaspire_utf8_decode_character_from_buffer(
            octaspire_container_vector_get_element_at(buffer, 0),
            octaspire_container_vector_get_length_in_octets(buffer),
            currentIndex,
            &result,
            &numoctets));

    ASSERT_EQ(97, result);
    ASSERT_EQ(1, numoctets);

    octaspire_container_vector_release(buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_utf8_decode_character_the_copyright_sign_test(void)
{
    char const *text = "¬©";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OK,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0xa9, result);
    ASSERT_EQ(2,    numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_not_equal_sign_test(void)
{
    char const *text = "‚â†";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OK,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0x2260, result);
    ASSERT_EQ(3,      numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_linear_b_syllable_b008_a_test(void)
{
    char const *text = "êÄÄ";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OK,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0x10000, result);
    ASSERT_EQ(4,       numoctets);

    PASS();
}

TEST octaspire_utf8_decode_a_short_string_test(void)
{
    char const *text = "A‚â¢Œë.ÌïúÍµ≠Ïñ¥Êó•Êú¨Ë™û£é¥";
    uint32_t result = 0;
    int numoctets = 0;

    uint32_t expectedResults[11]   =
    {
        0x0041,
        0x2262,
        0x0391,
        0x002E,
        0xD55C,
        0xAD6D,
        0xC5B4,
        0x65E5,
        0x672C,
        0x8A9E,
        0x233B4
    };

    int      expectedNumOctets[11] =
    {
        1,
        3,
        2,
        1,
        3,
        3,
        3,
        3,
        3,
        3,
        4
    };

    for (size_t i = 0; i < 11; ++i)
    {
        ASSERT_EQ(
            OCTASPIRE_UTF8_DECODE_STATUS_OK,
            octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

        ASSERT_EQ(expectedResults[i],   result);
        ASSERT_EQ(expectedNumOctets[i], numoctets);

        text += numoctets;
    }

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_INPUT_IS_NULL,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,     result);
    ASSERT_EQ(0,     numoctets);

    PASS();
}

// Is this good test? Is there potential out of bounds read possibility
// in the decoding part (from the encoded.octets) if the counting
// has error.
TEST octaspire_utf8_encode_and_then_decode_a_short_string_test(void)
{
    uint32_t result = 0;
    int numoctets = 0;

    uint32_t expectedResults[11]   =
    {
        0x0041,
        0x2262,
        0x0391,
        0x002E,
        0xD55C,
        0xAD6D,
        0xC5B4,
        0x65E5,
        0x672C,
        0x8A9E,
        0x233B4
    };

    size_t expectedNumOctets[11] =
    {
        1,
        3,
        2,
        1,
        3,
        3,
        3,
        3,
        3,
        3,
        4
    };

    octaspire_utf8_character_t encoded;


    for (size_t i = 0; i < 11; ++i)
    {
        ASSERT_EQ(
            OCTASPIRE_UTF8_ENCODE_STATUS_OK,
            octaspire_utf8_encode_character(expectedResults[i], &encoded));

        ASSERT_EQ(
            OCTASPIRE_UTF8_DECODE_STATUS_OK,
            octaspire_utf8_decode_character(
                (char const * const)(encoded.octets + (4 - expectedNumOctets[i])),
                expectedNumOctets[i],
                &result,
                &numoctets));

        ASSERT_EQ(expectedResults[i],   result);
        ASSERT_EQ(((int)expectedNumOctets[i]), numoctets);
    }

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_overlong_representations_of_the_null_character_test(void)
{
    // C0 80
    char const *text = "\xC0\x80";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0, result);
    ASSERT_EQ(2, numoctets);

    // E0 80 80
    text = "\xE0\x80\x80";
    result = 0;
    numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0, result);
    ASSERT_EQ(3, numoctets);

    // F0 80 80 80
    text = "\xF0\x80\x80\x80";
    result = 0;
    numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0, result);
    ASSERT_EQ(4, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_0x80_test(void)
{
    char const *text = "\x80";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_from_buffer_illegal_octet_0x80_test(void)
{
    octaspire_container_vector_t *buffer =
        octaspire_container_vector_new(sizeof(char), false, 0, octaspireUtf8TestAllocator);

    octaspire_container_vector_push_back_char(buffer, '\x80');
    size_t const currentIndex = 0;
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character_from_buffer(
            octaspire_container_vector_get_element_at(buffer, 0),
            octaspire_container_vector_get_length_in_octets(buffer),
            currentIndex,
            &result,
            &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    octaspire_container_vector_release(buffer);
    buffer = 0;

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_0x01_test(void)
{
    char const *text = "\xC0\x01";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_test(void)
{
    char const *text = "\xC0";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0x80_0x01_test(void)
{
    char const *text = "\xE0\x80\x01";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0x80_test(void)
{
    char const *text = "\xE0\x80";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_test(void)
{
    char const *text = "\xE0";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_0x80_0x01_test(void)
{
    char const *text = "\xF0\x80\x80\x01";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_0x80_test(void)
{
    char const *text = "\xF0\x80\x80";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_test(void)
{
    char const *text = "\xF0\x80";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_test(void)
{
    char const *text = "\xF0";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0xC0_0xC0_0xC0_test(void)
{
    char const *text = "\xF0\xC0\xC0\xC0";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0xC0_0xC0_test(void)
{
    char const *text = "\xE0\xC0\xC0";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_0xC0_test(void)
{
    char const *text = "\xC0\xC0";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_0xFF_test(void)
{
    char const *text = "\xFF";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_0xFE_test(void)
{
    char const *text = "\xFE";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xFE_0xFE_0xFF_0xFF_test(void)
{
    char const *text = "\xFE\xFE\xFF\xFF";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_ILLEGAL_NUMBER_OF_OCTETS,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0,  result);
    ASSERT_EQ(-1, numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_0xAF_test(void)
{
    char const *text = "\xC0\xAF";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0x2F, result);
    ASSERT_EQ(2,    numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0x80_0xAF_test(void)
{
    char const *text = "\xE0\x80\xAF";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0x2F, result);
    ASSERT_EQ(3,    numoctets);

    PASS();
}

TEST octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_0x80_0xAF_test(void)
{
    char const *text = "\xF0\x80\x80\xAF";
    uint32_t result = 0;
    int numoctets = 0;

    ASSERT_EQ(
        OCTASPIRE_UTF8_DECODE_STATUS_OVERLONG_REPRESENTATION_OF_CHARACTER,
        octaspire_utf8_decode_character(text, strlen(text), &result, &numoctets));

    ASSERT_EQ(0x2F, result);
    ASSERT_EQ(4,    numoctets);

    PASS();
}

GREATEST_SUITE(octaspire_utf8_suite)
{
    octaspireUtf8TestAllocator = octaspire_memory_allocator_new(0);
    assert(octaspireUtf8TestAllocator);

    RUN_TEST(octaspire_utf8_private_rangeof_test);
    RUN_TEST(octaspire_utf8_private_high_order_bits_test);
    RUN_TEST(octaspire_utf8_private_set_bit_test);
    RUN_TEST(octaspire_utf8_private_get_bit_test);
    RUN_TEST(octaspire_utf8_encode_character_NUL_test);
    RUN_TEST(octaspire_utf8_encode_character_SOH_test);
    RUN_TEST(octaspire_utf8_encode_character_space_test);
    RUN_TEST(octaspire_utf8_encode_character_A_test);
    RUN_TEST(octaspire_utf8_encode_character_control_U_PLUS_0080_test);
    RUN_TEST(octaspire_utf8_encode_character_latin_small_letter_a_with_diaeresis_test);
    RUN_TEST(octaspire_utf8_encode_character_latin_small_letter_y_with_diaeresis_test);
    RUN_TEST(octaspire_utf8_encode_character_copyright_sign_test);
    RUN_TEST(octaspire_utf8_encode_character_not_equal_symbol_test);
    RUN_TEST(octaspire_utf8_encode_character_linear_b_syllable_b008_a_test);
    RUN_TEST(octaspire_utf8_encode_character_of_illegal_range_test);
    RUN_TEST(octaspire_utf8_encode_character_illegal_range_from_U_PLUS_D800_to_U_PLUS_DFFF_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_is_empty_string_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_is_null_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_one_octet_0x80_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_two_octets_0xC0FF_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_three_octets_0xE080FF_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_is_invalid_of_length_four_octets_0xF08080FF_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_one_octet_0x01_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_two_octets_0xC080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_two_octets_with_error_0xC000_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_two_octets_with_error_0xC070_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_0xE08080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_with_error_0xE00080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_with_error_0xE08000_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_three_octets_with_error_0xE08070_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_0xF0808080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0008080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0800080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0808000_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_four_octets_with_error_0xF0808070_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_one_of_five_octets_0x01F0808080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_two_of_six_octets_0xC080F0808080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_three_of_seven_octets_0xE08080F0808080_test);
    RUN_TEST(octaspire_utf8_private_octets_in_next_that_has_length_of_four_of_eight_octets_0xF0808080F0808080_test);
    RUN_TEST(octaspire_utf8_private_decode_helper_error_with_more_octets_being_needed_than_available_test);
    RUN_TEST(octaspire_utf8_decode_character_null_string_test);
    RUN_TEST(octaspire_utf8_decode_character_from_buffer_null_string_test);
    RUN_TEST(octaspire_utf8_decode_character_empty_string_test);
    RUN_TEST(octaspire_utf8_decode_character_from_buffer_empty_string_test);
    RUN_TEST(octaspire_utf8_decode_character_a_test);
    RUN_TEST(octaspire_utf8_decode_character_from_buffer_a_test);
    RUN_TEST(octaspire_utf8_decode_character_the_copyright_sign_test);
    RUN_TEST(octaspire_utf8_decode_character_not_equal_sign_test);
    RUN_TEST(octaspire_utf8_decode_character_linear_b_syllable_b008_a_test);
    RUN_TEST(octaspire_utf8_decode_a_short_string_test);
    RUN_TEST(octaspire_utf8_encode_and_then_decode_a_short_string_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_overlong_representations_of_the_null_character_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_0x80_test);
    RUN_TEST(octaspire_utf8_decode_character_from_buffer_illegal_octet_0x80_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_0x01_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0x80_0x01_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0x80_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_0x80_0x01_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_0x80_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0xC0_0xC0_0xC0_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0xC0_0xC0_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_0xC0_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_0xFF_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_0xFE_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xFE_0xFE_0xFF_0xFF_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xC0_0xAF_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xE0_0x80_0xAF_test);
    RUN_TEST(octaspire_utf8_decode_character_illegal_octet_sequence_0xF0_0x80_0x80_0xAF_test);

    octaspire_memory_allocator_release(octaspireUtf8TestAllocator);
    octaspireUtf8TestAllocator = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_utf8.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_memory.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

TEST octaspire_memory_allocator_new_test(void)
{
    octaspire_memory_allocator_t *allocator = octaspire_memory_allocator_new(0);

    ASSERT(allocator);

    ASSERT_EQ(0, allocator->numberOfFutureAllocationsToBeRigged);
    ASSERT_EQ(0, allocator->bitIndex);

    size_t const bitQueueLen = sizeof(allocator->bitQueue) / sizeof(allocator->bitQueue[0]);
    ASSERT_EQ(20, bitQueueLen);

    for (size_t i = 0; i < bitQueueLen; ++i)
    {
        ASSERT_EQ(0, allocator->bitQueue[i]);
    }


    octaspire_memory_allocator_release(allocator);
    allocator = 0;

    PASS();
}

// How to test this efficiently, etc.?
/*
TEST octaspire_memory_allocator_new_failure_test(void)
{
    octaspire_memory_allocator_t *allocator = octaspire_memory_allocator_new();

    ASSERT_FALSE(allocator);

    octaspire_memory_allocator_release(allocator);
    allocator = 0;

    PASS();
}
*/

TEST octaspire_memory_allocator_malloc_test(void)
{
    octaspire_memory_allocator_t *allocator = octaspire_memory_allocator_new(0);

    size_t *ptrs[100];

    size_t const elemsize = sizeof(ptrs[0]);
    size_t const nelems   = sizeof(ptrs) / elemsize;

    for (size_t i = 0; i < nelems; ++i)
    {
        ptrs[i] = octaspire_memory_allocator_malloc(allocator, elemsize);
        ASSERT(ptrs[i]);
        ASSERT_EQ(0, *(ptrs[i]));
        *(ptrs[i]) = i;
    }

    for (size_t i = 0; i < nelems; ++i)
    {
        ASSERT_EQ(i, *(ptrs[i]));
    }

    for (size_t i = 0; i < nelems; ++i)
    {
        octaspire_memory_allocator_free(allocator, ptrs[i]);
        ptrs[i] = 0;
    }

    octaspire_memory_allocator_release(allocator);
    allocator = 0;

    PASS();
}

TEST octaspire_memory_allocator_free_test(void)
{
    octaspire_memory_allocator_t *allocator = octaspire_memory_allocator_new(0);

    octaspire_memory_allocator_free(allocator, 0);
    octaspire_memory_allocator_free(allocator, octaspire_memory_allocator_malloc(allocator, 10));

    octaspire_memory_allocator_release(allocator);
    allocator = 0;

    PASS();
}

TEST octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged_when_larger_than_32_test(void)
{
    octaspire_memory_allocator_t *allocator = octaspire_memory_allocator_new(0);

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    size_t const count = 640;

    uint32_t const bitPattern = 0x55; // 0101 0101

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged_when_larger_than_32(
        allocator,
        count,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern,
        bitPattern);

   ASSERT_EQ(count, allocator->numberOfFutureAllocationsToBeRigged);
   ASSERT_EQ(0,     allocator->bitIndex);

   for (size_t i = 0; i < (sizeof(allocator->bitQueue) / sizeof(allocator->bitQueue[0])); ++i)
   {
       ASSERT_EQ(bitPattern, allocator->bitQueue[i]);
   }

   ASSERT_EQ(count, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

   for (size_t i = 0; i < count; ++i)
   {
       if (i % 2 == 0)
       {
           ASSERT(octaspire_memory_allocator_private_test_bit(allocator));
       }
       else
       {
           ASSERT_FALSE(octaspire_memory_allocator_private_test_bit(allocator));
       }

       ++(allocator->bitIndex);
   }

   ASSERT_EQ(count, allocator->bitIndex);

   octaspire_memory_allocator_release(allocator);
   allocator = 0;

   PASS();
}

TEST octaspire_memory_allocator_setting_and_getting_future_allocations_to_fail_and_using_with_malloc_test(void)
{
    octaspire_memory_allocator_t *allocator = octaspire_memory_allocator_new(0);

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    size_t count = 32;

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(allocator, count, 0);

    ASSERT_EQ(count, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    for (size_t i = count; i > 0; --i)
    {
        ASSERT_FALSE(octaspire_memory_allocator_malloc(allocator, 1));
        ASSERT_EQ(i - 1, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(allocator));
    }

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    void *ptr = octaspire_memory_allocator_malloc(allocator, 1);
    ASSERT(ptr);
    octaspire_memory_allocator_free(allocator, ptr);
    ptr = 0;

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    octaspire_memory_allocator_release(allocator);
    allocator = 0;

    PASS();
}

TEST octaspire_memory_allocator_setting_and_getting_future_allocations_to_fail_and_using_with_realloc_test(void)
{
    octaspire_memory_allocator_t *allocator = octaspire_memory_allocator_new(0);

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    void *buffer = octaspire_memory_allocator_malloc(allocator, 1);

    ASSERT(buffer);

    size_t count = 32;

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(allocator, count, 0);

    ASSERT_EQ(count, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    for (size_t i = count; i > 0; --i)
    {
        ASSERT_FALSE(octaspire_memory_allocator_realloc(allocator, buffer, 2));
        ASSERT_EQ(i - 1, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(allocator));
    }

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    void *ptr = octaspire_memory_allocator_realloc(allocator, buffer, 2);
    ASSERT(ptr);
    octaspire_memory_allocator_free(allocator, ptr);
    ptr = 0;

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(allocator));

    octaspire_memory_allocator_release(allocator);
    allocator = 0;

    PASS();
}

GREATEST_SUITE(octaspire_memory_suite)
{
    RUN_TEST(octaspire_memory_allocator_new_test);
    //RUN_TEST(octaspire_memory_allocator_new_failure_test);
    RUN_TEST(octaspire_memory_allocator_malloc_test);
    RUN_TEST(octaspire_memory_allocator_free_test);
    RUN_TEST(octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged_when_larger_than_32_test);
    RUN_TEST(octaspire_memory_allocator_setting_and_getting_future_allocations_to_fail_and_using_with_malloc_test);
    RUN_TEST(octaspire_memory_allocator_setting_and_getting_future_allocations_to_fail_and_using_with_realloc_test);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_memory.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_stdio.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_memory_allocator_t *octaspireStdioTestAllocator = 0;

TEST octaspire_stdio_new_test(void)
{
    octaspire_stdio_t *stdio = octaspire_stdio_new(octaspireStdioTestAllocator);

    ASSERT(stdio);

    ASSERT_EQ(0, stdio->numberOfFutureReadsToBeRigged);
    ASSERT_EQ(0, stdio->bitIndex);
    ASSERT_EQ(0, stdio->bitQueue);
    ASSERT_EQ(octaspireStdioTestAllocator, stdio->allocator);

    octaspire_stdio_release(stdio);
    stdio = 0;

    PASS();
}

TEST octaspire_stdio_new_allocation_failure_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireStdioTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireStdioTestAllocator));

    octaspire_stdio_t *stdio = octaspire_stdio_new(octaspireStdioTestAllocator);

    ASSERT_FALSE(stdio);

    ASSERT_EQ(
        0,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireStdioTestAllocator));

    octaspire_stdio_release(stdio);
    stdio = 0;

    PASS();
}

TEST octaspire_stdio_fread_test(void)
{
    octaspire_stdio_t *stdio = octaspire_stdio_new(octaspireStdioTestAllocator);

    ASSERT(stdio);

    FILE *f = fopen(OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_stdio_fread_test", "rb");

    ASSERT(f);

    char octet = 0;
    char const * const expected = "0123456789qwertyuiop";

    for (size_t i = 0; i < strlen(expected); ++i)
    {
        ASSERT_EQ(1, octaspire_stdio_fread(stdio, &octet, sizeof(octet), 1, f));
        ASSERT_EQ(expected[i], octet);
    }

    fclose(f);
    f = 0;

    octaspire_stdio_release(stdio);
    stdio = 0;

    PASS();
}

TEST octaspire_stdio_fread_rigging_and_failure_test(void)
{
    octaspire_stdio_t *stdio = octaspire_stdio_new(octaspireStdioTestAllocator);

    ASSERT(stdio);

    FILE *f = fopen(OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_stdio_fread_test", "rb");

    ASSERT(f);

    char octet = 0;
    char const * const expected = "0123456789qwertyuiop";

    // 0101 0101 0101 0101 0101
    //    5    5    5    5    5
    octaspire_stdio_set_number_and_type_of_future_reads_to_be_rigged(stdio, 20, 0x55555);

    ASSERT_EQ(20, octaspire_stdio_get_number_of_future_reads_to_be_rigged(stdio));

    size_t index = 0;
    for (size_t i = 0; i < strlen(expected); ++i)
    {
        if (i % 2)
        {
            ASSERT_EQ(0, octaspire_stdio_fread(stdio, &octet, sizeof(octet), 1, f));
        }
        else
        {
            ASSERT_EQ(1, octaspire_stdio_fread(stdio, &octet, sizeof(octet), 1, f));
            ASSERT_EQ(expected[index], octet);
            ++index;
        }
    }

    ASSERT_EQ(0, octaspire_stdio_get_number_of_future_reads_to_be_rigged(stdio));

    fclose(f);
    f = 0;

    octaspire_stdio_release(stdio);
    stdio = 0;

    PASS();
}

GREATEST_SUITE(octaspire_stdio_suite)
{
    octaspireStdioTestAllocator = octaspire_memory_allocator_new(0);

    assert(octaspireStdioTestAllocator);

    RUN_TEST(octaspire_stdio_new_test);
    RUN_TEST(octaspire_stdio_new_allocation_failure_test);
    RUN_TEST(octaspire_stdio_fread_test);
    RUN_TEST(octaspire_stdio_fread_rigging_and_failure_test);

    octaspire_memory_allocator_release(octaspireStdioTestAllocator);
    octaspireStdioTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_stdio.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_input.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_memory_allocator_t *octaspireInputTestAllocator = 0;
static octaspire_stdio_t            *octaspireInputTestStdio = 0;

TEST octaspire_input_new_from_c_string_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    ASSERT(input->text);

    size_t const numUcsChars =
        octaspire_container_utf8_string_get_length_in_ucs_characters(input->text);

    ASSERT_EQ(6, numUcsChars);

    ASSERT_EQ(0x61,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 0));
    ASSERT_EQ(0x62,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 1));
    ASSERT_EQ(0x63,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 2));
    ASSERT_EQ(0xa9,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 3));
    ASSERT_EQ(0x2260,  octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 4));
    ASSERT_EQ(0x10000, octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 5));

    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(6, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_c_string_called_with_null_string_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(0, octaspireInputTestAllocator);

    ASSERT(input);

    ASSERT(input->text);

    ASSERT_EQ(0,         octaspire_container_utf8_string_get_length_in_ucs_characters(input->text));
    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(0, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_c_string_with_allocation_failure_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireInputTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT_EQ(
        0,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    ASSERT_FALSE(input);

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_buffer_test(void)
{
    char const buffer[] =
    {
        'a',
        'b',
        'c',
        '\xC2',
        '\xA9',
        '\xE2',
        '\x89',
        '\xA0',
        '\xF0',
        '\x90',
        '\x80',
        '\x80'
    };

    octaspire_input_t *input = octaspire_input_new_from_buffer(
        buffer, sizeof(buffer) / sizeof(buffer[0]),
        octaspireInputTestAllocator);

    ASSERT(input);

    ASSERT(input->text);

    size_t const numUcsChars =
        octaspire_container_utf8_string_get_length_in_ucs_characters(input->text);

    ASSERT_EQ(6, numUcsChars);

    ASSERT_EQ(0x61,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 0));
    ASSERT_EQ(0x62,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 1));
    ASSERT_EQ(0x63,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 2));
    ASSERT_EQ(0xa9,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 3));
    ASSERT_EQ(0x2260,  octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 4));
    ASSERT_EQ(0x10000, octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 5));

    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(6, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_buffer_with_allocation_failure_0x00_test(void)
{
    char const buffer[] =
    {
        'a',
        'b',
        'c',
        '\xC2',
        '\xA9',
        '\xE2',
        '\x89',
        '\xA0',
        '\xF0',
        '\x90',
        '\x80',
        '\x80'
    };

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireInputTestAllocator,
        1,
        0x00);

    ASSERT_EQ(
        1,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    octaspire_input_t *input = octaspire_input_new_from_buffer(
        buffer, sizeof(buffer) / sizeof(buffer[0]),
        octaspireInputTestAllocator);

    ASSERT_EQ(
        0,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    ASSERT_FALSE(input);

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_buffer_with_allocation_failure_0x01_test(void)
{
    char const buffer[] =
    {
        'a',
        'b',
        'c',
        '\xC2',
        '\xA9',
        '\xE2',
        '\x89',
        '\xA0',
        '\xF0',
        '\x90',
        '\x80',
        '\x80'
    };

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireInputTestAllocator,
        2,
        0x01);

    ASSERT_EQ(
        2,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    octaspire_input_t *input = octaspire_input_new_from_buffer(
        buffer, sizeof(buffer) / sizeof(buffer[0]),
        octaspireInputTestAllocator);

    ASSERT_EQ(
        0,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    ASSERT_FALSE(input);

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_path_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_path(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_input_new_from_path_test",
        octaspireInputTestAllocator,
        octaspireInputTestStdio);

    ASSERT(input);

    ASSERT(input->text);

    size_t const numUcsChars =
        octaspire_container_utf8_string_get_length_in_ucs_characters(input->text);

    ASSERT_EQ(6, numUcsChars);

    ASSERT_EQ(0x61,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 0));
    ASSERT_EQ(0x62,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 1));
    ASSERT_EQ(0x63,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 2));
    ASSERT_EQ(0xa9,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 3));
    ASSERT_EQ(0x2260,  octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 4));
    ASSERT_EQ(0x10000, octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 5));

    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(6, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_path_failure_on_nonexisting_file_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_path(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_input_new_from_path_failure_on_nonexisting_file_test",
        octaspireInputTestAllocator,
        octaspireInputTestStdio);

    ASSERT_FALSE(input);

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_new_from_path_allocation_failure_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireInputTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    octaspire_input_t *input = octaspire_input_new_from_path(
        OCTASPIRE_CORE_CONFIG_TEST_RES_PATH "octaspire_input_new_from_path_test",
        octaspireInputTestAllocator,
        octaspireInputTestStdio);

    ASSERT_EQ(
        0,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireInputTestAllocator));

    ASSERT_FALSE(input);

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_get_length_in_ucs_characters_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    ASSERT_EQ(6, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_clear_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    ASSERT(input->text);

    size_t const numUcsChars =
        octaspire_container_utf8_string_get_length_in_ucs_characters(input->text);

    ASSERT_EQ(6, numUcsChars);

    ASSERT_EQ(0x61,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 0));
    ASSERT_EQ(0x62,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 1));
    ASSERT_EQ(0x63,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 2));
    ASSERT_EQ(0xa9,    octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 3));
    ASSERT_EQ(0x2260,  octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 4));
    ASSERT_EQ(0x10000, octaspire_container_utf8_string_get_ucs_character_at_index(input->text, 5));

    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(6, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_clear(input);

    ASSERT(input->text);

    ASSERT_EQ(0, octaspire_container_utf8_string_get_length_in_ucs_characters(input->text));

    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(0, octaspire_input_get_length_in_ucs_characters(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_rewind_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);

    ASSERT_EQ(6, octaspire_input_get_length_in_ucs_characters(input));

    while (octaspire_input_is_good(input))
    {
        ASSERT(octaspire_input_pop_next_ucs_character(input));
    }

    ASSERT_FALSE(octaspire_input_is_good(input));

    octaspire_input_rewind(input);
    ASSERT_EQ(0,         input->index);
    ASSERT_EQ(1,         input->line);
    ASSERT_EQ(1,         input->column);
    ASSERT_EQ(octaspireInputTestAllocator, input->allocator);
    ASSERT(octaspire_input_is_good(input));

    uint32_t expected[] = {0x61, 0x62, 0x63, 0xa9, 0x2260, 0x10000};

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT(octaspire_input_is_good(input));
        ASSERT_EQ(expected[i], octaspire_input_peek_next_ucs_character(input));
        ASSERT(octaspire_input_pop_next_ucs_character(input));
    }

    ASSERT_FALSE(octaspire_input_is_good(input));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_peek_next_ucs_character_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    uint32_t expected[] = {0x61, 0x62, 0x63, 0xa9, 0x2260, 0x10000};

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT(octaspire_input_is_good(input));
        ASSERT_EQ(expected[i], octaspire_input_peek_next_ucs_character(input));
        ASSERT(octaspire_input_pop_next_ucs_character(input));
    }

    ASSERT_FALSE(octaspire_input_is_good(input));

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT_FALSE(octaspire_input_is_good(input));
        ASSERT_EQ(0, octaspire_input_peek_next_ucs_character(input));
    }

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_pop_next_ucs_character_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    uint32_t expected[] = {0x61, 0x62, 0x63, 0xa9, 0x2260, 0x10000};

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT(octaspire_input_is_good(input));
        ASSERT_EQ(expected[i], octaspire_input_peek_next_ucs_character(input));
        ASSERT(octaspire_input_pop_next_ucs_character(input));
    }

    ASSERT_FALSE(octaspire_input_is_good(input));

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT_FALSE(octaspire_input_is_good(input));
        ASSERT_EQ(0, octaspire_input_peek_next_ucs_character(input));
        ASSERT_FALSE(octaspire_input_pop_next_ucs_character(input));
    }

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_pop_next_ucs_character_current_line_and_column_are_calculated_correctly_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80\ndef\nghi";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    size_t expected_line[]   = {1, 1, 1, 1, 1, 1, 1,      2, 2, 2, 2,    3, 3, 3};
    size_t expected_column[] = {1, 2, 3, 4, 5, 6, 7,      1, 2, 3, 4,    1, 2, 3};

    ASSERT_EQ(
        sizeof(expected_line) / sizeof(expected_line[0]),
        octaspire_input_get_length_in_ucs_characters(input));

    ASSERT_EQ(
        sizeof(expected_column) / sizeof(expected_column[0]),
        octaspire_input_get_length_in_ucs_characters(input));

    for (size_t i = 0; i < octaspire_input_get_length_in_ucs_characters(input); ++i)
    {
        ASSERT(octaspire_input_is_good(input));

        ASSERT_EQ(expected_line[i],   input->line);
        ASSERT_EQ(expected_column[i], input->column);

        ASSERT(octaspire_input_pop_next_ucs_character(input));
    }

    ASSERT_FALSE(octaspire_input_is_good(input));

    size_t const lastIndex = octaspire_input_get_length_in_ucs_characters(input) - 1;

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT_EQ(expected_column[lastIndex], input->column);
        ASSERT_FALSE(octaspire_input_is_good(input));
        ASSERT_EQ(expected_line[lastIndex],   input->line);
        ASSERT_EQ(expected_column[lastIndex], input->column);
        ASSERT_FALSE(octaspire_input_pop_next_ucs_character(input));
    }

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_is_good_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT(octaspire_input_is_good(input));
        ASSERT(octaspire_input_pop_next_ucs_character(input));
    }

    ASSERT_FALSE(octaspire_input_is_good(input));

    for (size_t i = 0; i < 6; ++i)
    {
        ASSERT_FALSE(octaspire_input_is_good(input));
        ASSERT_FALSE(octaspire_input_pop_next_ucs_character(input));
    }

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_input_private_is_ucs_character_index_valid_test(void)
{
    char const * const cstr = "abc\xC2\xA9\xE2\x89\xA0\xF0\x90\x80\x80";

    octaspire_input_t *input = octaspire_input_new_from_c_string(cstr, octaspireInputTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < 1024; ++i)
    {
        bool const valid = octaspire_input_private_is_ucs_character_index_valid(input, i);
        if (i < octaspire_input_get_length_in_ucs_characters(input))
        {
            ASSERT(valid);
        }
        else
        {
            ASSERT_FALSE(valid);
        }
    }

    octaspire_input_release(input);
    input = 0;

    PASS();
}

GREATEST_SUITE(octaspire_input_suite)
{
    octaspireInputTestAllocator = octaspire_memory_allocator_new(0);
    octaspireInputTestStdio     = octaspire_stdio_new(octaspireInputTestAllocator);

    assert(octaspireInputTestAllocator);
    assert(octaspireInputTestStdio);

    RUN_TEST(octaspire_input_new_from_c_string_test);
    RUN_TEST(octaspire_input_new_from_c_string_called_with_null_string_test);
    RUN_TEST(octaspire_input_new_from_c_string_with_allocation_failure_test);
    RUN_TEST(octaspire_input_new_from_buffer_test);
    RUN_TEST(octaspire_input_new_from_buffer_with_allocation_failure_0x00_test);
    RUN_TEST(octaspire_input_new_from_buffer_with_allocation_failure_0x01_test);
    RUN_TEST(octaspire_input_new_from_path_test);
    RUN_TEST(octaspire_input_new_from_path_failure_on_nonexisting_file_test);
    RUN_TEST(octaspire_input_new_from_path_allocation_failure_test);
    RUN_TEST(octaspire_input_get_length_in_ucs_characters_test);
    RUN_TEST(octaspire_input_clear_test);
    RUN_TEST(octaspire_input_rewind_test);
    RUN_TEST(octaspire_input_peek_next_ucs_character_test);
    RUN_TEST(octaspire_input_pop_next_ucs_character_test);
    RUN_TEST(octaspire_input_pop_next_ucs_character_current_line_and_column_are_calculated_correctly_test);
    RUN_TEST(octaspire_input_is_good_test);
    RUN_TEST(octaspire_input_private_is_ucs_character_index_valid_test);

    octaspire_stdio_release(octaspireInputTestStdio);
    octaspireInputTestStdio = 0;

    octaspire_memory_allocator_release(octaspireInputTestAllocator);
    octaspireInputTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_input.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_container_vector.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_memory_allocator_t *octaspireContainerVectorTestAllocator = 0;

TEST octaspire_container_vector_private_index_to_pointer_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
    }

    for (size_t i = 0; i < len; ++i)
    {
        size_t const * expected = (size_t const *)(vec->elements) + i;

        ASSERT_EQ(
            expected,
            (size_t const *)octaspire_container_vector_private_index_to_pointer(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_private_index_to_pointer_const_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
    }

    for (size_t i = 0; i < len; ++i)
    {
        size_t const * expected = (size_t const *)(vec->elements) + i;

        ASSERT_EQ(
            expected,
            (size_t const *)octaspire_container_vector_private_index_to_pointer_const(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_private_grow_with_factor_2_success_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(double), false, 0, octaspireContainerVectorTestAllocator);

    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    char *expectedInitializedMemory =
        octaspire_memory_allocator_malloc(octaspireContainerVectorTestAllocator, originalElementSize);

    float const factor = 2;

    ASSERT(octaspire_container_vector_private_grow(vec, factor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,           vec->elementSize);
    ASSERT_EQ(originalNumElements,           vec->numElements);

    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * factor),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    ASSERT(octaspire_container_vector_private_grow(vec, factor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,                      vec->elementSize);
    ASSERT_EQ(originalNumElements,                      vec->numElements);
    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * (factor * factor)),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    octaspire_container_vector_release(vec);
    vec = 0;
    octaspire_memory_allocator_free(octaspireContainerVectorTestAllocator, expectedInitializedMemory);

    PASS();
}

TEST octaspire_container_vector_private_grow_with_factor_100_success_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(char), false, 0, octaspireContainerVectorTestAllocator);

    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    char *expectedInitializedMemory =
        octaspire_memory_allocator_malloc(octaspireContainerVectorTestAllocator, originalElementSize);

    float const factor = 100;

    ASSERT(octaspire_container_vector_private_grow(vec, factor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,           vec->elementSize);
    ASSERT_EQ(originalNumElements,           vec->numElements);

    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * factor),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    ASSERT(octaspire_container_vector_private_grow(vec, factor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,                      vec->elementSize);
    ASSERT_EQ(originalNumElements,                      vec->numElements);

    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * (factor * factor)),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    octaspire_container_vector_release(vec);
    vec = 0;
    octaspire_memory_allocator_free(octaspireContainerVectorTestAllocator, expectedInitializedMemory);

    PASS();
}

TEST octaspire_container_vector_private_grow_with_factor_2_even_when_zero_is_given_as_factor_success_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(double), false, 0, octaspireContainerVectorTestAllocator);

    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    char *expectedInitializedMemory =
        octaspire_memory_allocator_malloc(octaspireContainerVectorTestAllocator, originalElementSize);

    float const badFactor = 0;
    float const factor = 2;

    ASSERT(octaspire_container_vector_private_grow(vec, badFactor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,           vec->elementSize);
    ASSERT_EQ(originalNumElements,           vec->numElements);

    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * factor),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    ASSERT(octaspire_container_vector_private_grow(vec, badFactor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,                      vec->elementSize);
    ASSERT_EQ(originalNumElements,                      vec->numElements);
    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * (factor * factor)),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    octaspire_container_vector_release(vec);
    vec = 0;
    octaspire_memory_allocator_free(octaspireContainerVectorTestAllocator, expectedInitializedMemory);

    PASS();
}

TEST octaspire_container_vector_private_grow_with_factor_2_even_when_one_is_given_as_factor_success_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(double), false, 0, octaspireContainerVectorTestAllocator);

    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    char *expectedInitializedMemory =
        octaspire_memory_allocator_malloc(octaspireContainerVectorTestAllocator, originalElementSize);

    float const badFactor = 1;
    float const factor = 2;

    ASSERT(octaspire_container_vector_private_grow(vec, badFactor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,           vec->elementSize);
    ASSERT_EQ(originalNumElements,           vec->numElements);

    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * factor),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    ASSERT(octaspire_container_vector_private_grow(vec, badFactor));
    ASSERT(vec->elements);
    ASSERT_EQ(originalElementSize,                      vec->elementSize);
    ASSERT_EQ(originalNumElements,                      vec->numElements);
    ASSERT_EQ(
        (size_t)((float)originalNumAllocated * (factor * factor)),
        vec->numAllocated);

    for (size_t i = 0; i < vec->numAllocated; ++i)
    {
        ASSERT_MEM_EQ(
            expectedInitializedMemory,
            vec->elements + (i * originalElementSize),
            originalElementSize);
    }

    octaspire_container_vector_release(vec);
    vec = 0;
    octaspire_memory_allocator_free(octaspireContainerVectorTestAllocator, expectedInitializedMemory);

    PASS();
}

TEST octaspire_container_vector_private_grow_failure_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    void const * const originalElements     = vec->elements;
    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerVectorTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(octaspire_container_vector_private_grow(vec, 2));

    ASSERT_EQ(
        0,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerVectorTestAllocator));

    ASSERT_EQ(originalElements,     vec->elements);
    ASSERT_EQ(originalElementSize,  vec->elementSize);
    ASSERT_EQ(originalNumElements,  vec->numElements);
    ASSERT_EQ(originalNumAllocated, vec->numAllocated);

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_private_compact_success_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(octaspire_container_vector_private_grow(vec, 1000));

    for (size_t i = 0; i < 250; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
    }

    //void              *originalElements     = vec->elements;
    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;

    ASSERT(octaspire_container_vector_private_compact(vec));

    //ASSERT_EQ(originalElements,              vec->elements);
    ASSERT_EQ(originalElementSize,           vec->elementSize);
    ASSERT_EQ(originalNumElements,           vec->numElements);
    // Compacting should have made self->numAllocated == self->numElements
    ASSERT_EQ(originalNumElements,           vec->numAllocated);

    // TODO Continue here

    for (size_t i = 0; i < vec->numElements; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_private_compact_failure_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(octaspire_container_vector_private_grow(vec, 1000));

    for (size_t i = 0; i < 250; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
    }

    void              *originalElements     = vec->elements;
    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator, 1, 0);

    ASSERT_FALSE(octaspire_container_vector_private_compact(vec));

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    ASSERT_EQ(originalElements,     vec->elements);
    ASSERT_EQ(originalElementSize,  vec->elementSize);
    ASSERT_EQ(originalNumElements,  vec->numElements);
    ASSERT_EQ(originalNumAllocated, vec->numAllocated);

    for (size_t i = 0; i < vec->numElements; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_new_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(vec);

    ASSERT(vec->elements);
    ASSERT_EQ(sizeof(size_t),                          vec->elementSize);
    ASSERT_EQ(0,                                       vec->numElements);
    ASSERT_EQ(OCTASPIRE_CONTAINER_VECTOR_INITIAL_SIZE, vec->numAllocated);
    ASSERT_EQ(0,                                       vec->elementReleaseCallback);
    ASSERT_EQ(octaspireContainerVectorTestAllocator,                               vec->allocator);

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_new_failure_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator, 1, 0);

    ASSERT_EQ(1, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_FALSE(vec);

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_new_with_preallocated_elements_test(void)
{
    size_t const numPreAllocated = 100;

    octaspire_container_vector_t *vec = octaspire_container_vector_new_with_preallocated_elements(
        sizeof(size_t),
        false,
        numPreAllocated,
        0,
        octaspireContainerVectorTestAllocator);

    ASSERT(vec);

    ASSERT(vec->elements);
    ASSERT_EQ(sizeof(size_t),       vec->elementSize);
    ASSERT_EQ(0,                    vec->numElements);
    ASSERT_EQ(numPreAllocated,      vec->numAllocated);
    ASSERT_EQ(0,                    vec->elementReleaseCallback);
    ASSERT_EQ(octaspireContainerVectorTestAllocator,            vec->allocator);

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_new_with_preallocated_elements_allocation_failure_on_first_allocation_test(void)
{
    size_t const numPreAllocated = 100;

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    octaspire_container_vector_t *vec = octaspire_container_vector_new_with_preallocated_elements(
        sizeof(size_t),
        false,
        numPreAllocated,
        0,
        octaspireContainerVectorTestAllocator);

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(vec);

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_new_with_preallocated_elements_allocation_failure_on_second_allocation_test(void)
{
    size_t const numPreAllocated = 100;

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    octaspire_container_vector_t *vec = octaspire_container_vector_new_with_preallocated_elements(
        sizeof(size_t),
        false,
        numPreAllocated,
        0,
        octaspireContainerVectorTestAllocator);

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(vec);

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}



// TODO XXX test octaspire_container_vector_new_with_preallocated_elements
// It has newer allocation failure test that must also be tested




TEST octaspire_container_vector_new_shallow_copy_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(vec);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_back_element(vec, &i));
    }

    ASSERT_EQ(
        len,
        octaspire_container_vector_get_length(vec));

    octaspire_container_vector_t *cpy=
        octaspire_container_vector_new_shallow_copy(vec, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(
        octaspire_container_vector_get_length(vec),
        octaspire_container_vector_get_length(cpy));

    for (size_t i = 0; i < octaspire_container_vector_get_length(cpy); ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(cpy, i));
    }

    ASSERT_EQ(vec->elementSize, cpy->elementSize);
    ASSERT_EQ(vec->numElements, cpy->numElements);

    // Copy is compact
    ASSERT_EQ(cpy->numElements, cpy->numAllocated);
    ASSERT_MEM_EQ(vec->elements, cpy->elements, cpy->numElements);
    ASSERT_EQ(vec->elementReleaseCallback, cpy->elementReleaseCallback);
    ASSERT_EQ(vec->allocator, cpy->allocator);

    octaspire_container_vector_release(vec);
    vec = 0;

    octaspire_container_vector_release(cpy);
    cpy = 0;

    PASS();
}

TEST octaspire_container_vector_new_shallow_copy_allocation_failure_on_first_allocation_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(vec);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_back_element(vec, &i));
    }

    ASSERT_EQ(
        len,
        octaspire_container_vector_get_length(vec));

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(octaspire_container_vector_new_shallow_copy(vec, octaspireContainerVectorTestAllocator));

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_new_shallow_copy_allocation_failure_on_second_allocation_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(vec);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_back_element(vec, &i));
    }

    ASSERT_EQ(
        len,
        octaspire_container_vector_get_length(vec));

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(octaspire_container_vector_new_shallow_copy(vec, octaspireContainerVectorTestAllocator));

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerVectorTestAllocator));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_release_null_test(void)
{
    octaspire_container_vector_release(0);
    PASS();
}

void octaspire_container_vector_test_element_callback1(void *element);
void octaspire_container_vector_test_element_callback3_shrink_vector(void *element);
void octaspire_container_vector_test_element_callback2_grow_vector(void *element);

static size_t octaspireContainerVectorTestElementCallback1TimesCalled = 0;

void octaspire_container_vector_test_element_callback1(void *element)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(element);
    ++octaspireContainerVectorTestElementCallback1TimesCalled;
}

void octaspire_container_vector_test_element_callback2_grow_vector(void *element)
{
    octaspire_container_vector_t *vec = element;

    ++octaspireContainerVectorTestElementCallback1TimesCalled;

    if (octaspireContainerVectorTestElementCallback1TimesCalled < 100)
    {
        octaspire_container_vector_push_back_element(vec, &vec);
    }
}

void octaspire_container_vector_test_element_callback3_shrink_vector(void *element)
{
    octaspire_container_vector_t *vec = element;

    ++octaspireContainerVectorTestElementCallback1TimesCalled;

    if (!octaspire_container_vector_is_empty(vec))
    {
        octaspire_container_vector_pop_back_element(vec);
    }
}

TEST octaspire_container_vector_release_element_callback_called_for_all_elements_test(void)
{
    octaspireContainerVectorTestElementCallback1TimesCalled = 0;

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, octaspire_container_vector_test_element_callback1, octaspireContainerVectorTestAllocator);

    ASSERT(vec);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_back_element(vec, &i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    ASSERT_EQ(len, octaspireContainerVectorTestElementCallback1TimesCalled);

    PASS();
}

TEST octaspire_container_vector_get_length_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, octaspire_container_vector_get_length(vec));
        octaspire_container_vector_push_back_element(vec, &i);
        ASSERT_EQ(i + 1, octaspire_container_vector_get_length(vec));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_is_empty_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT(octaspire_container_vector_is_empty(vec));
    }

    for (size_t i = 0; i < 100; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
        ASSERT_FALSE(octaspire_container_vector_is_empty(vec));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_remove_element_at_index_0_of_100_elements_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    ASSERT(octaspire_container_vector_remove_element_at(vec, 0));

    for (size_t i = 0; i < len - 1; ++i)
    {
            ASSERT_EQ(i + 1, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_remove_element_at_index_50_of_100_elements_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    ASSERT(octaspire_container_vector_remove_element_at(vec, 50));

    for (size_t i = 0; i < len - 1; ++i)
    {
        if (i < 50)
        {
            ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
        }
        else
        {
            ASSERT_EQ(i + 1, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
        }
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_remove_element_at_index_99_of_100_elements_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    ASSERT(octaspire_container_vector_remove_element_at(vec, 99));

    for (size_t i = 0; i < len - 1; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_remove_element_at_failure_removing_index_100_of_100_elements_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    ASSERT_FALSE(octaspire_container_vector_remove_element_at(vec, 100));

    ASSERT_EQ(len, octaspire_container_vector_get_length(vec));

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_remove_element_at_failure_removing_indices_100_to_200_of_100_elements_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    for (size_t i = 100; i < 201; ++i)
    {
        ASSERT_FALSE(octaspire_container_vector_remove_element_at(vec, i));
    }

    ASSERT_EQ(len, octaspire_container_vector_get_length(vec));

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_remove_element_at_remove_all_100_elements_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_remove_element_at(vec, 0));

        ASSERT_EQ(len - (i + 1), octaspire_container_vector_get_length(vec));

        for (size_t j = 0; j < octaspire_container_vector_get_length(vec); ++j)
        {
            ASSERT_EQ(j + i + 1, *(size_t*)octaspire_container_vector_get_element_at(vec, j));
        }
    }

    ASSERT_EQ(0, octaspire_container_vector_get_length(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_get_element_at_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_FALSE((size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_FALSE((size_t*)octaspire_container_vector_get_element_at(vec, i));
        octaspire_container_vector_push_back_element(vec, &i);
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    ASSERT_FALSE((size_t*)octaspire_container_vector_get_element_at(vec, len + 1));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_get_element_at_const_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_FALSE((size_t const *)octaspire_container_vector_get_element_at_const(vec, i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_FALSE((size_t const *)octaspire_container_vector_get_element_at_const(vec, i));
        octaspire_container_vector_push_back_element(vec, &i);
        ASSERT_EQ(i, *(size_t const *)octaspire_container_vector_get_element_at_const(vec, i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t const *)octaspire_container_vector_get_element_at_const(vec, i));
    }

    ASSERT_FALSE((size_t const *)octaspire_container_vector_get_element_at_const(vec, len + 1));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_get_element_size_in_octets_when_element_is_of_type_uint8_t_test(void)
{
    size_t const expectedSize = sizeof(uint8_t);

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(expectedSize, false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_container_vector_get_element_size_in_octets(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_get_element_size_in_octets_when_element_is_of_type_int_test(void)
{
    size_t const expectedSize = sizeof(int);

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(expectedSize, false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_container_vector_get_element_size_in_octets(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_get_element_size_in_octets_when_element_is_of_type_size_t_test(void)
{
    size_t const expectedSize = sizeof(size_t);

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(expectedSize, false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_container_vector_get_element_size_in_octets(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_get_element_size_in_octets_when_element_is_of_type_double_test(void)
{
    size_t const expectedSize = sizeof(double);

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(expectedSize, false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_container_vector_get_element_size_in_octets(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_get_element_size_in_octets_when_element_is_of_type_void_ptr_test(void)
{
    size_t const expectedSize = sizeof(void*);

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(expectedSize, true, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_container_vector_get_element_size_in_octets(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_get_element_size_in_octets_when_element_size_is_10000_test(void)
{
    size_t const expectedSize = 10000;

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(expectedSize, false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_container_vector_get_element_size_in_octets(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_get_element_size_in_octets_when_element_size_is_illegal_zero_test(void)
{
    size_t const expectedSize = sizeof(char);

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(0, false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(expectedSize, octaspire_container_vector_get_element_size_in_octets(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_insert_element_before_the_element_at_index_minus_one_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t value = 2;

    octaspire_container_vector_push_front_element(vec, &value);

    value = 1;

    ASSERT(octaspire_container_vector_insert_element_before_the_element_at_index(vec, &value, -1));

    ASSERT_EQ(2,  octaspire_container_vector_get_length(vec));
    ASSERT_EQ(1, *(size_t*)octaspire_container_vector_get_element_at(vec, 0));
    ASSERT_EQ(2, *(size_t*)octaspire_container_vector_get_element_at(vec, 1));

    value = 9;

    ASSERT(octaspire_container_vector_insert_element_before_the_element_at_index(vec, &value, -1));

    ASSERT_EQ(3,  octaspire_container_vector_get_length(vec));
    ASSERT_EQ(1, *(size_t*)octaspire_container_vector_get_element_at(vec, 0));
    ASSERT_EQ(9, *(size_t*)octaspire_container_vector_get_element_at(vec, 1));
    ASSERT_EQ(2, *(size_t*)octaspire_container_vector_get_element_at(vec, 2));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_insert_element_before_the_element_at_index_zero_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    octaspire_container_vector_push_front_element(vec, &len);

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_insert_element_before_the_element_at_index(vec, &i, 0));
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, 0));
    }

    ASSERT_EQ(len + 1, octaspire_container_vector_get_length(vec));
    ASSERT_EQ(len, *(size_t*)octaspire_container_vector_peek_back_element(vec));

    for (size_t i = 0; i < octaspire_container_vector_get_length(vec) - 1; ++i)
    {
        ASSERT_EQ(len - (i + 1), *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_insert_element_before_the_element_at_index_called_on_empty_vector_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(
            octaspire_container_vector_insert_element_before_the_element_at_index(vec, &i, 0));
    }

    ASSERT(octaspire_container_vector_is_empty(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_insert_element_before_the_element_at_index_the_end_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    octaspire_container_vector_push_front_element(vec, &len);

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(
            octaspire_container_vector_insert_element_before_the_element_at_index(
                vec,
                &i,
                (ptrdiff_t)octaspire_container_vector_get_length(vec) - 1));

        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    ASSERT_EQ(len + 1, octaspire_container_vector_get_length(vec));
    ASSERT_EQ(len, *(size_t*)octaspire_container_vector_peek_back_element(vec));

    for (size_t i = 0; i < octaspire_container_vector_get_length(vec); ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_insert_element_before_the_element_at_index_past_the_end_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const value = 100;

    octaspire_container_vector_push_front_element(vec, &value);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(
            octaspire_container_vector_insert_element_before_the_element_at_index(
                vec,
                &i,
                10));

        ASSERT_EQ(1, octaspire_container_vector_get_length(vec));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_insert_element_before_the_element_at_index_allocation_failure_test(void)
{
    size_t const value = 123;

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT(octaspire_container_vector_push_front_element(vec, &value));

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerVectorTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(
        octaspire_container_vector_insert_element_before_the_element_at_index(
            vec,
            &value,
            0));

    ASSERT_EQ(
        0,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerVectorTestAllocator));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_insert_element_before_the_element_at_index_the_middle_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_back_element(vec, &i));
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_peek_back_element(vec));
    }

    ASSERT_EQ(len, octaspire_container_vector_get_length(vec));

    ASSERT(octaspire_container_vector_insert_element_before_the_element_at_index(vec, &len, 50));

    ASSERT_EQ(len + 1, octaspire_container_vector_get_length(vec));

    for (size_t i = 0; i < octaspire_container_vector_get_length(vec); ++i)
    {
        if (i < 50)
        {
            ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
        }
        else if (i == 50)
        {
            ASSERT_EQ(100, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
        }
        else
        {
            ASSERT_EQ(i - 1, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
        }
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_insert_element_at_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    size_t a = 900;
    size_t b = 901;
    size_t c = 902;

    ASSERT(octaspire_container_vector_insert_element_at(vec, &a, 0));
    ASSERT_EQ(a, *(size_t*)octaspire_container_vector_get_element_at(vec, 0));
    for (size_t i = 1; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    ASSERT(octaspire_container_vector_insert_element_at(vec, &b, 50));
    ASSERT_EQ(b, *(size_t*)octaspire_container_vector_get_element_at(vec, 50));
    ASSERT_EQ(a, *(size_t*)octaspire_container_vector_get_element_at(vec, 0));
    for (size_t i = 1; i < len; ++i)
    {
        if (i != 50)
        {
            ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
        }
    }

    ASSERT(octaspire_container_vector_insert_element_at(vec, &c, 102));
    ASSERT_EQ(a, *(size_t*)octaspire_container_vector_get_element_at(vec, 0));
    ASSERT_EQ(b, *(size_t*)octaspire_container_vector_get_element_at(vec, 50));
    for (size_t i = 1; i < len; ++i)
    {
        if (i != 50)
        {
            ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
        }
    }
    ASSERT_EQ(c, *(size_t*)octaspire_container_vector_get_element_at(vec, 102));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_replace_element_at_index_or_push_back_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t expected = 123;

    ASSERT(octaspire_container_vector_replace_element_at_index_or_push_back(vec, &expected, 0));
    ASSERT_EQ(1, octaspire_container_vector_get_length(vec));
    ASSERT_EQ(expected, *(size_t*)octaspire_container_vector_get_element_at(vec, 0));

    expected = 987;

    ASSERT(octaspire_container_vector_replace_element_at_index_or_push_back(vec, &expected, 0));
    ASSERT_EQ(1, octaspire_container_vector_get_length(vec));
    ASSERT_EQ(expected, *(size_t*)octaspire_container_vector_get_element_at(vec, 0));

    expected = 297;

    ASSERT(octaspire_container_vector_replace_element_at_index_or_push_back(vec, &expected, 1));
    ASSERT_EQ(2,        octaspire_container_vector_get_length(vec));
    ASSERT_EQ(987,      *(size_t*)octaspire_container_vector_get_element_at(vec, 0));
    ASSERT_EQ(expected, *(size_t*)octaspire_container_vector_get_element_at(vec, 1));

    expected = 777;

    ASSERT(octaspire_container_vector_replace_element_at_index_or_push_back(vec, &expected, 1));
    ASSERT_EQ(2,        octaspire_container_vector_get_length(vec));
    ASSERT_EQ(987,      *(size_t*)octaspire_container_vector_get_element_at(vec, 0));
    ASSERT_EQ(expected, *(size_t*)octaspire_container_vector_get_element_at(vec, 1));

    expected = 222;

    ASSERT(octaspire_container_vector_replace_element_at_index_or_push_back(vec, &expected, 0));
    ASSERT_EQ(2,        octaspire_container_vector_get_length(vec));
    ASSERT_EQ(expected, *(size_t*)octaspire_container_vector_get_element_at(vec, 0));
    ASSERT_EQ(777,      *(size_t*)octaspire_container_vector_get_element_at(vec, 1));

    expected = 1111;

    ASSERT(octaspire_container_vector_replace_element_at_index_or_push_back(vec, &expected, 2));
    ASSERT_EQ(3,        octaspire_container_vector_get_length(vec));
    ASSERT_EQ(222,      *(size_t*)octaspire_container_vector_get_element_at(vec, 0));
    ASSERT_EQ(777,      *(size_t*)octaspire_container_vector_get_element_at(vec, 1));
    ASSERT_EQ(expected, *(size_t*)octaspire_container_vector_get_element_at(vec, 2));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_insert_element_at_index_100_of_empty_vector_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t a = 900;
    size_t const index = 100;
    ASSERT(octaspire_container_vector_insert_element_at(vec, &a, index));

    ASSERT_EQ(index + 1, octaspire_container_vector_get_length(vec));

    for (size_t i = 0; i < (index - 1); ++i)
    {
        ASSERT_EQ(0, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    ASSERT_EQ(a, *(size_t*)octaspire_container_vector_get_element_at(vec, index));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_insert_element_at_failure_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const element = 0;

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerVectorTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerVectorTestAllocator));

    ASSERT_FALSE(octaspire_container_vector_insert_element_at(vec, &element, 4));

    ASSERT_EQ(
        0,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerVectorTestAllocator));

    ASSERT_EQ(0, octaspire_container_vector_get_length(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_push_front_element_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_front_element(vec, &i));
        ASSERT_EQ(i + 1, octaspire_container_vector_get_length(vec));
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, 0));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(len - (i + 1), *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_push_back_element_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_back_element(vec, &i));
        ASSERT_EQ(i + 1, octaspire_container_vector_get_length(vec));
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_get_element_at(vec, i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_push_back_char_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(char), false, 0, octaspireContainerVectorTestAllocator);

    char const len = 127;

    for (char i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_back_char(vec, i));
        ASSERT_EQ((size_t)i + 1, octaspire_container_vector_get_length(vec));
        ASSERT_EQ((char)i, *(char*)octaspire_container_vector_get_element_at(vec, (size_t)i));
    }

    for (char i = 0; i < len; ++i)
    {
        ASSERT_EQ((char)i, *(char*)octaspire_container_vector_get_element_at(vec, (size_t)i));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_push_back_char_to_vector_containing_floats_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(float), false, 0, octaspireContainerVectorTestAllocator);

    char const len = 127;

    for (char i = 0; i < len; ++i)
    {
        ASSERT_FALSE(octaspire_container_vector_push_back_char(vec, i));
        ASSERT_EQ(0, octaspire_container_vector_get_length(vec));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_for_each_called_on_empty_vector_test(void)
{
    octaspireContainerVectorTestElementCallback1TimesCalled = 0;

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    octaspire_container_vector_for_each(vec, octaspire_container_vector_test_element_callback1);

    ASSERT_EQ(0, octaspireContainerVectorTestElementCallback1TimesCalled);

    octaspireContainerVectorTestElementCallback1TimesCalled = 0;
    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_for_each_called_on_vector_with_one_element_test(void)
{
    octaspireContainerVectorTestElementCallback1TimesCalled = 0;

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const element = 999;

    octaspire_container_vector_push_back_element(vec, &element);

    octaspire_container_vector_for_each(vec, octaspire_container_vector_test_element_callback1);

    ASSERT_EQ(1, octaspireContainerVectorTestElementCallback1TimesCalled);

    octaspireContainerVectorTestElementCallback1TimesCalled = 0;
    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_for_each_called_on_vector_with_hundred_elements_test(void)
{
    octaspireContainerVectorTestElementCallback1TimesCalled = 0;

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &i);
    }

    octaspire_container_vector_for_each(vec, octaspire_container_vector_test_element_callback1);

    ASSERT_EQ(100, octaspireContainerVectorTestElementCallback1TimesCalled);

    octaspireContainerVectorTestElementCallback1TimesCalled = 0;
    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_for_each_called_on_vector_that_grows_during_iteration_test(void)
{
    octaspireContainerVectorTestElementCallback1TimesCalled = 0;

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(octaspire_container_vector_t*), true, 0, octaspireContainerVectorTestAllocator);

    octaspire_container_vector_push_back_element(vec, &vec);

    octaspire_container_vector_for_each(vec, octaspire_container_vector_test_element_callback2_grow_vector);

    ASSERT_EQ(100, octaspireContainerVectorTestElementCallback1TimesCalled);

    octaspireContainerVectorTestElementCallback1TimesCalled = 0;
    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_for_each_called_on_vector_that_shrinks_during_iteration_test(void)
{
    octaspireContainerVectorTestElementCallback1TimesCalled = 0;

    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(octaspire_container_vector_t*), true, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        octaspire_container_vector_push_back_element(vec, &vec);
    }

    octaspire_container_vector_for_each(
        vec,
        octaspire_container_vector_test_element_callback3_shrink_vector);

    ASSERT_EQ(50, octaspireContainerVectorTestElementCallback1TimesCalled);

    octaspireContainerVectorTestElementCallback1TimesCalled = 0;
    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_pop_back_element_called_on_empty_vector_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_container_vector_pop_back_element(vec));
    }

    ASSERT_EQ(0, octaspire_container_vector_get_length(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_pop_back_element_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_back_element(vec, &i));
    }

    ASSERT_EQ(len, octaspire_container_vector_get_length(vec));

    for (size_t i = len; i != 0; --i)
    {
        ASSERT_EQ(i-1, *(size_t*)octaspire_container_vector_peek_back_element(vec));
        ASSERT(octaspire_container_vector_pop_back_element(vec));
        ASSERT_EQ(i-1, octaspire_container_vector_get_length(vec));

        if (i > 1)
        {
            ASSERT_FALSE(octaspire_container_vector_is_empty(vec));
            ASSERT_EQ(i - 2, *(size_t*)octaspire_container_vector_peek_back_element(vec));
        }
    }

    ASSERT_EQ(0, octaspire_container_vector_get_length(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}



















TEST octaspire_container_vector_peek_back_element_called_on_empty_vector_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_container_vector_peek_back_element(vec));
    }

    ASSERT_EQ(0, octaspire_container_vector_get_length(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_peek_back_element_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_back_element(vec, &i));
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_peek_back_element(vec));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_peek_back_element_const_called_on_empty_vector_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_container_vector_peek_back_element_const(vec));
    }

    ASSERT_EQ(0, octaspire_container_vector_get_length(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_peek_back_element_const_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_back_element(vec, &i));
        ASSERT_EQ(i, *(size_t const *)octaspire_container_vector_peek_back_element_const(vec));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_pop_front_element_called_on_empty_vector_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    void const * const originalElements     = vec->elements;
    size_t const       originalElementSize  = vec->elementSize;
    size_t const       originalNumElements  = vec->numElements;
    size_t const       originalNumAllocated = vec->numAllocated;

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT_FALSE(octaspire_container_vector_pop_front_element(vec));
    }

    ASSERT_EQ(originalElements,     vec->elements);
    ASSERT_EQ(originalElementSize,  vec->elementSize);
    ASSERT_EQ(originalNumElements,  vec->numElements);
    ASSERT_EQ(originalNumAllocated, vec->numAllocated);

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_pop_front_element_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_back_element(vec, &i));
        ASSERT_EQ(i, *(size_t const *)octaspire_container_vector_peek_back_element_const(vec));
    }

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_pop_front_element(vec));
        ASSERT_EQ(len - 1 - i, octaspire_container_vector_get_length(vec));

        if (!octaspire_container_vector_is_empty(vec))
        {
            ASSERT_EQ(i + 1, *(size_t const *)octaspire_container_vector_peek_front_element_const(vec));
        }
        else
        {
            ASSERT_EQ(len - 1, i);
        }
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_peek_front_element_called_on_empty_vector_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_container_vector_peek_front_element(vec));
    }

    ASSERT_EQ(0, octaspire_container_vector_get_length(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_peek_front_element_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_front_element(vec, &i));
        ASSERT_EQ(i, *(size_t*)octaspire_container_vector_peek_front_element(vec));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_peek_front_element_const_called_on_empty_vector_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_container_vector_peek_front_element_const(vec));
    }

    ASSERT_EQ(0, octaspire_container_vector_get_length(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_peek_front_element_const_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_front_element(vec, &i));
        ASSERT_EQ(i, *(size_t const *)octaspire_container_vector_peek_front_element_const(vec));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_get_element_release_callback_const_when_it_is_null_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(0, octaspire_container_vector_get_element_release_callback_const(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_get_element_release_callback_const_test(void)
{
    octaspire_container_vector_element_callback_t const expected =
        (octaspire_container_vector_element_callback_t)octaspire_container_vector_release;

    octaspire_container_vector_t *vec = octaspire_container_vector_new(
        sizeof(octaspire_container_vector_t*),
        true,
        expected,
        octaspireContainerVectorTestAllocator);

    ASSERT_EQ(
        expected,
        octaspire_container_vector_get_element_release_callback_const(vec));

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_clear_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    size_t const len = 100;

    for (size_t i = 0; i < len; ++i)
    {
        ASSERT(octaspire_container_vector_push_front_element(vec, &i));
        ASSERT_EQ(i, *(size_t const *)octaspire_container_vector_peek_front_element_const(vec));
    }

    ASSERT_EQ(len, octaspire_container_vector_get_length(vec));

    ASSERT(octaspire_container_vector_clear(vec));

    ASSERT_EQ(0, octaspire_container_vector_get_length(vec));

    ASSERT_EQ(0, vec->numElements);
    ASSERT_EQ(1, vec->numAllocated);

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_vector_clear_called_on_empty_vector_test(void)
{
    octaspire_container_vector_t *vec =
        octaspire_container_vector_new(sizeof(size_t), false, 0, octaspireContainerVectorTestAllocator);

    ASSERT_EQ(0, octaspire_container_vector_get_length(vec));

    ASSERT(octaspire_container_vector_clear(vec));

    ASSERT_EQ(0, octaspire_container_vector_get_length(vec));

    ASSERT_EQ(0, vec->numElements);
    ASSERT_EQ(1, vec->numAllocated);

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

GREATEST_SUITE(octaspire_container_vector_suite)
{
    octaspireContainerVectorTestAllocator = octaspire_memory_allocator_new(0);
    assert(octaspireContainerVectorTestAllocator);

    RUN_TEST(octaspire_container_vector_private_index_to_pointer_test);
    RUN_TEST(octaspire_container_vector_private_index_to_pointer_const_test);
    RUN_TEST(octaspire_container_vector_private_grow_with_factor_2_success_test);
    RUN_TEST(octaspire_container_vector_private_grow_with_factor_100_success_test);
    RUN_TEST(octaspire_container_vector_private_grow_with_factor_2_even_when_zero_is_given_as_factor_success_test);
    RUN_TEST(octaspire_container_vector_private_grow_with_factor_2_even_when_one_is_given_as_factor_success_test);
    RUN_TEST(octaspire_container_vector_private_grow_failure_test);
    RUN_TEST(octaspire_container_vector_private_compact_success_test);
    RUN_TEST(octaspire_container_vector_private_compact_failure_test);
    RUN_TEST(octaspire_container_vector_new_test);
    RUN_TEST(octaspire_container_vector_new_failure_test);
    RUN_TEST(octaspire_container_vector_new_with_preallocated_elements_test);
    RUN_TEST(octaspire_container_vector_new_with_preallocated_elements_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_container_vector_new_with_preallocated_elements_allocation_failure_on_second_allocation_test);
    RUN_TEST(octaspire_container_vector_new_shallow_copy_test);
    RUN_TEST(octaspire_container_vector_new_shallow_copy_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_container_vector_new_shallow_copy_allocation_failure_on_second_allocation_test);
    RUN_TEST(octaspire_container_vector_release_null_test);
    RUN_TEST(octaspire_container_vector_release_element_callback_called_for_all_elements_test);
    RUN_TEST(octaspire_container_vector_get_length_test);
    RUN_TEST(octaspire_container_vector_is_empty_test);
    RUN_TEST(octaspire_container_vector_remove_element_at_index_0_of_100_elements_test);
    RUN_TEST(octaspire_container_vector_remove_element_at_index_50_of_100_elements_test);
    RUN_TEST(octaspire_container_vector_remove_element_at_index_99_of_100_elements_test);
    RUN_TEST(octaspire_container_vector_remove_element_at_failure_removing_index_100_of_100_elements_test);
    RUN_TEST(octaspire_container_vector_remove_element_at_failure_removing_indices_100_to_200_of_100_elements_test);
    RUN_TEST(octaspire_container_vector_remove_element_at_remove_all_100_elements_test);
    RUN_TEST(octaspire_container_vector_get_element_at_test);
    RUN_TEST(octaspire_container_vector_get_element_at_const_test);
    RUN_TEST(octaspire_container_vector_get_element_size_in_octets_when_element_is_of_type_uint8_t_test);
    RUN_TEST(octaspire_container_vector_get_element_size_in_octets_when_element_is_of_type_int_test);
    RUN_TEST(octaspire_container_vector_get_element_size_in_octets_when_element_is_of_type_size_t_test);
    RUN_TEST(octaspire_container_vector_get_element_size_in_octets_when_element_is_of_type_double_test);
    RUN_TEST(octaspire_container_vector_get_element_size_in_octets_when_element_is_of_type_void_ptr_test);
    RUN_TEST(octaspire_container_vector_get_element_size_in_octets_when_element_size_is_10000_test);
    RUN_TEST(octaspire_container_vector_get_element_size_in_octets_when_element_size_is_illegal_zero_test);
    RUN_TEST(octaspire_container_vector_insert_element_before_the_element_at_index_minus_one_test);
    RUN_TEST(octaspire_container_vector_insert_element_before_the_element_at_index_zero_test);
    RUN_TEST(octaspire_container_vector_insert_element_before_the_element_at_index_called_on_empty_vector_test);
    RUN_TEST(octaspire_container_vector_insert_element_before_the_element_at_index_the_end_test);
    RUN_TEST(octaspire_container_vector_insert_element_before_the_element_at_index_past_the_end_test);
    RUN_TEST(octaspire_container_vector_insert_element_before_the_element_at_index_allocation_failure_test);
    RUN_TEST(octaspire_container_vector_insert_element_before_the_element_at_index_the_middle_test);
    RUN_TEST(octaspire_container_vector_insert_element_at_test);

    RUN_TEST(octaspire_container_vector_replace_element_at_index_or_push_back_test);

    RUN_TEST(octaspire_container_vector_insert_element_at_index_100_of_empty_vector_test);
    RUN_TEST(octaspire_container_vector_insert_element_at_failure_test);
    RUN_TEST(octaspire_container_vector_push_front_element_test);
    RUN_TEST(octaspire_container_vector_push_back_element_test);
    RUN_TEST(octaspire_container_vector_push_back_char_test);
    RUN_TEST(octaspire_container_vector_push_back_char_to_vector_containing_floats_test);
    RUN_TEST(octaspire_container_vector_for_each_called_on_empty_vector_test);
    RUN_TEST(octaspire_container_vector_for_each_called_on_vector_with_one_element_test);
    RUN_TEST(octaspire_container_vector_for_each_called_on_vector_with_hundred_elements_test);
    RUN_TEST(octaspire_container_vector_for_each_called_on_vector_that_grows_during_iteration_test);
    RUN_TEST(octaspire_container_vector_for_each_called_on_vector_that_shrinks_during_iteration_test);
    RUN_TEST(octaspire_container_vector_pop_back_element_called_on_empty_vector_test);
    RUN_TEST(octaspire_container_vector_pop_back_element_test);
    RUN_TEST(octaspire_container_vector_peek_back_element_called_on_empty_vector_test);
    RUN_TEST(octaspire_container_vector_peek_back_element_test);
    RUN_TEST(octaspire_container_vector_peek_back_element_const_called_on_empty_vector_test);
    RUN_TEST(octaspire_container_vector_peek_back_element_const_test);
    RUN_TEST(octaspire_container_vector_pop_front_element_called_on_empty_vector_test);
    RUN_TEST(octaspire_container_vector_pop_front_element_test);
    RUN_TEST(octaspire_container_vector_peek_front_element_called_on_empty_vector_test);
    RUN_TEST(octaspire_container_vector_peek_front_element_test);
    RUN_TEST(octaspire_container_vector_peek_front_element_const_called_on_empty_vector_test);
    RUN_TEST(octaspire_container_vector_peek_front_element_const_test);
    RUN_TEST(octaspire_container_vector_get_element_release_callback_const_when_it_is_null_test);
    RUN_TEST(octaspire_container_vector_get_element_release_callback_const_test);
    RUN_TEST(octaspire_container_vector_clear_test);
    RUN_TEST(octaspire_container_vector_clear_called_on_empty_vector_test);

    octaspire_memory_allocator_release(octaspireContainerVectorTestAllocator);
    octaspireContainerVectorTestAllocator = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_container_vector.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_container_list.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_memory_allocator_t *octaspireContainerListTestAllocator = 0;

TEST octaspire_container_list_new_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_new_allocation_failure_on_first_allocation_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerListTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerListTestAllocator));

    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT_EQ(0, list);

    ASSERT_EQ(
        0,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerListTestAllocator));

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_release_called_with_null_pointer_test(void)
{
    octaspire_container_list_release(0);

    PASS();
}

TEST octaspire_container_list_get_front_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_container_list_get_front(list));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_front(list, &i));

        octaspire_container_list_node_t const * const front =
            octaspire_container_list_get_front(list);

        ASSERT_EQ(i, *((size_t const * const)octaspire_container_list_node_get_element_const(front)));
    }

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_get_front_const_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_container_list_get_front_const(list));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_front(list, &i));

        octaspire_container_list_node_t const * const front =
            octaspire_container_list_get_front_const(list);

        ASSERT_EQ(i, *((size_t const * const)octaspire_container_list_node_get_element_const(front)));
    }

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_get_back_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_container_list_get_back(list));

    size_t const numElements = 10;

    octaspire_container_list_node_t const *first = 0;
    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_back(list, &i));

        octaspire_container_list_node_t const * const back =
            octaspire_container_list_get_back(list);

        if (i == 0)
        {
            first = back;
        }

        ASSERT_EQ(first, octaspire_container_list_get_front(list));
        ASSERT_EQ(i, *((size_t const * const)octaspire_container_list_node_get_element_const(back)));
    }

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_get_back_const_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_container_list_get_back_const(list));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_back(list, &i));

        octaspire_container_list_node_t const * const back =
            octaspire_container_list_get_back_const(list);

        ASSERT_EQ(i, *((size_t const * const)octaspire_container_list_node_get_element_const(back)));
    }

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_clear_called_on_empty_list_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
            sizeof(size_t),
            false,
            0,
            octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_container_list_get_length(list));

    ASSERT(octaspire_container_list_clear(list));

    ASSERT_EQ(0, octaspire_container_list_get_length(list));

    ASSERT_EQ(0, list->numElements);

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_clear_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_back(list, &i));
    }

    ASSERT_EQ(numElements, list->numElements);

    ASSERT(octaspire_container_list_clear(list));

    ASSERT_EQ(0, octaspire_container_list_get_length(list));
    ASSERT_EQ(0, list->numElements);

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_push_back_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_container_list_get_length(list));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_back(list, &i));

        ASSERT_EQ(i + 1, octaspire_container_list_get_length(list));
        octaspire_container_list_node_t const * front = octaspire_container_list_get_front(list);
        octaspire_container_list_node_t const * back  = octaspire_container_list_get_back(list);

        ASSERT_EQ(0,     *((size_t const * const)octaspire_container_list_node_get_element_const(front)));
        ASSERT_EQ(i,     *((size_t const * const)octaspire_container_list_node_get_element_const(back)));
    }

    ASSERT_EQ(numElements, list->numElements);

    octaspire_container_list_node_t const * node = octaspire_container_list_get_front(list);

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(node);
        ASSERT_EQ(i, *((size_t const * const)octaspire_container_list_node_get_element_const(node)));
        node = octaspire_container_list_node_get_next_const(node);
    }

    ASSERT(node == 0);

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_push_front_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    ASSERT_EQ(0, octaspire_container_list_get_length(list));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_front(list, &i));

        ASSERT_EQ(i + 1, octaspire_container_list_get_length(list));
        octaspire_container_list_node_t const * front = octaspire_container_list_get_front(list);
        octaspire_container_list_node_t const * back  = octaspire_container_list_get_back(list);

        ASSERT_EQ(i,     *((size_t const * const)octaspire_container_list_node_get_element_const(front)));
        ASSERT_EQ(0,     *((size_t const * const)octaspire_container_list_node_get_element_const(back)));
    }

    ASSERT_EQ(numElements, list->numElements);

    octaspire_container_list_node_t const * node = octaspire_container_list_get_front(list);

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(node);
        ASSERT_EQ(numElements - 1 - i, *((size_t const * const)octaspire_container_list_node_get_element_const(node)));
        node = octaspire_container_list_node_get_next_const(node);
    }

    ASSERT(node == 0);

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_pop_front_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_back(list, &i));
    }

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_container_list_node_t const * node = octaspire_container_list_get_front(list);
        ASSERT(node);
        ASSERT_EQ(i, *((size_t const * const)octaspire_container_list_node_get_element_const(node)));

        ASSERT(octaspire_container_list_pop_front(list));
    }

    ASSERT_EQ(0, octaspire_container_list_get_length(list));
    ASSERT_EQ(0, octaspire_container_list_get_front(list));
    ASSERT_EQ(0, octaspire_container_list_get_back(list));

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_pop_back_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_back(list, &i));
    }

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_container_list_node_t const * const first1 =
            octaspire_container_list_get_front_const(list);

        ASSERT(first1);
        ASSERT_EQ(0, *((size_t const * const)octaspire_container_list_node_get_element_const(first1)));

        ASSERT(octaspire_container_list_pop_back(list));

        if (i < (numElements - 1))
        {
            // Make sure that front doesn't change
            octaspire_container_list_node_t const * const first2 =
                octaspire_container_list_get_front_const(list);

            ASSERT(first2);
            ASSERT_EQ(first1, first2);

            // Check back
            octaspire_container_list_node_t const * const last =
                octaspire_container_list_get_back_const(list);

            ASSERT(last);

            ASSERT_EQ(
                numElements - 2 - i,
                *((size_t const * const)octaspire_container_list_node_get_element_const(last)));
        }
    }

    ASSERT_EQ(0, octaspire_container_list_get_length(list));
    ASSERT_EQ(0, octaspire_container_list_get_front(list));
    ASSERT_EQ(0, octaspire_container_list_get_back(list));

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_remove_middle_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    size_t const numElements = 10;

    octaspire_container_list_node_t * node = 0;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_back(list, &i));

        if (i == 5)
        {
            node = octaspire_container_list_get_back(list);
        }
    }

    ASSERT(node);
    ASSERT(octaspire_container_list_remove(list, node));

    ASSERT_EQ(numElements - 1, octaspire_container_list_get_length(list));

    for (size_t i = 0; i < (numElements - 1); ++i)
    {
        node = octaspire_container_list_get_at(list, i);

        ASSERT(node);

        if (i < 5)
        {
            ASSERT_EQ(
                i < 5 ? i : (i + 1),
                *((size_t const * const)octaspire_container_list_node_get_element_const(node)));
        }
    }

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_remove_first_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    size_t const numElements = 10;

    octaspire_container_list_node_t * node = 0;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_back(list, &i));

        if (i == 0)
        {
            node = octaspire_container_list_get_back(list);
        }
    }

    ASSERT(node);
    ASSERT(octaspire_container_list_remove(list, node));

    ASSERT_EQ(numElements - 1, octaspire_container_list_get_length(list));

    for (size_t i = 0; i < (numElements - 1); ++i)
    {
        node = octaspire_container_list_get_at(list, i);

        ASSERT(node);

        ASSERT_EQ(
            (i + 1),
            *((size_t const * const)octaspire_container_list_node_get_element_const(node)));
    }

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_remove_last_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    size_t const numElements = 10;

    octaspire_container_list_node_t * node = 0;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_back(list, &i));

        if (i == (numElements - 1))
        {
            node = octaspire_container_list_get_back(list);
        }
    }

    ASSERT(node);
    ASSERT(octaspire_container_list_remove(list, node));

    ASSERT_EQ(numElements - 1, octaspire_container_list_get_length(list));

    for (size_t i = 0; i < (numElements - 1); ++i)
    {
        node = octaspire_container_list_get_at(list, i);

        ASSERT(node);

        ASSERT_EQ(
            i,
            *((size_t const * const)octaspire_container_list_node_get_element_const(node)));
    }

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_remove_even_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_back(list, &i));
    }

    octaspire_container_list_node_t *node = octaspire_container_list_get_front(list);
    size_t index = 0;

    while (node)
    {
        octaspire_container_list_node_t * const next = octaspire_container_list_node_get_next(node);

        if (index % 2 == 0)
        {
            octaspire_container_list_remove(list, node);
            node = 0;
        }

        ++index;

        node = next;
    }

    ASSERT_EQ(5, octaspire_container_list_get_length(list));

    node = octaspire_container_list_get_front(list);
    index = 0;

    while (node)
    {
        octaspire_container_list_node_t * const next = octaspire_container_list_node_get_next(node);

        if (index % 2 == 0)
        {
            ++index;
        }

        ASSERT_EQ(
            index,
            *((size_t const * const)octaspire_container_list_node_get_element_const(node)));

        ++index;

        node = next;
    }

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_get_at_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    size_t const numElements = 128;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_back(list, &i));
    }

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_container_list_node_t const * const node =
            octaspire_container_list_get_at(list, i);

        ASSERT_EQ(
            i,
            *((size_t const * const)octaspire_container_list_node_get_element_const(node)));
    }

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

TEST octaspire_container_list_get_at_const_test(void)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerListTestAllocator);

    ASSERT(list);

    size_t const numElements = 128;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_list_push_back(list, &i));
    }

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_container_list_node_t const * const node =
            octaspire_container_list_get_at_const(list, i);

        ASSERT_EQ(
            i,
            *((size_t const * const)octaspire_container_list_node_get_element_const(node)));
    }

    octaspire_container_list_release(list);
    list = 0;

    PASS();
}

GREATEST_SUITE(octaspire_container_list_suite)
{
    octaspireContainerListTestAllocator = octaspire_memory_allocator_new(0);
    assert(octaspireContainerListTestAllocator);

    RUN_TEST(octaspire_container_list_new_test);
    RUN_TEST(octaspire_container_list_new_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_container_list_release_called_with_null_pointer_test);
    RUN_TEST(octaspire_container_list_get_front_test);
    RUN_TEST(octaspire_container_list_get_front_const_test);
    RUN_TEST(octaspire_container_list_get_back_test);
    RUN_TEST(octaspire_container_list_get_back_const_test);
    RUN_TEST(octaspire_container_list_clear_called_on_empty_list_test);
    RUN_TEST(octaspire_container_list_clear_test);
    RUN_TEST(octaspire_container_list_push_back_test);
    RUN_TEST(octaspire_container_list_push_front_test);
    RUN_TEST(octaspire_container_list_pop_front_test);
    RUN_TEST(octaspire_container_list_pop_back_test);
    RUN_TEST(octaspire_container_list_remove_middle_test);
    RUN_TEST(octaspire_container_list_remove_first_test);
    RUN_TEST(octaspire_container_list_remove_last_test);
    RUN_TEST(octaspire_container_list_remove_even_test);
    RUN_TEST(octaspire_container_list_get_at_test);
    RUN_TEST(octaspire_container_list_get_at_const_test);

    octaspire_memory_allocator_release(octaspireContainerListTestAllocator);
    octaspireContainerListTestAllocator = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_container_list.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_container_queue.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_memory_allocator_t *octaspireContainerQueueTestAllocator = 0;

TEST octaspire_container_queue_new_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);
    ASSERT_EQ(0, octaspire_container_queue_get_max_length(queue));
    ASSERT_FALSE(octaspire_container_queue_has_max_length(queue));

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_new_allocation_failure_on_first_allocation_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerQueueTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerQueueTestAllocator));

    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT_EQ(0, queue);

    ASSERT_EQ(
        0,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerQueueTestAllocator));

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_new_with_max_length_of_56_with_size_t_elements_test(void)
{
    size_t const maxLength = 56;

    octaspire_container_queue_t *queue = octaspire_container_queue_new_with_max_length(
        maxLength,
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);
    ASSERT_EQ(maxLength, octaspire_container_queue_get_max_length(queue));
    ASSERT(octaspire_container_queue_has_max_length(queue));

    for (size_t i = 0; i < (3 * maxLength); ++i)
    {
        octaspire_container_queue_push(queue, &i);

        ASSERT(octaspire_container_queue_get_length(queue) <= maxLength);

        ASSERT_EQ(
            i < maxLength ? 0 : (i + 1 - maxLength),
            *(size_t const * const)octaspire_container_queue_peek(queue));

        size_t firstExpectedNumber = 0;

        if (i >= (maxLength-1))
        {
            firstExpectedNumber += (i - (maxLength - 1));
        }

        for (size_t j = 0; j < octaspire_container_queue_get_length(queue); ++j)
        {
            size_t const storedNum =
                *(size_t const * const)octaspire_container_queue_get_at_const(queue, j);

            size_t const expectedNum = firstExpectedNumber + j;

            ASSERT_EQ(expectedNum, storedNum);
        }
    }

    ASSERT_EQ(maxLength, octaspire_container_queue_get_length(queue));

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_new_with_max_length_of_10_with_ostring_ptr_elements_test(void)
{
    size_t const maxLength = 10;

    octaspire_container_queue_t *queue = octaspire_container_queue_new_with_max_length(
        maxLength,
        sizeof(octaspire_container_utf8_string_t*),
        true,
        (octaspire_container_queue_element_callback_t)octaspire_container_utf8_string_release,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);
    ASSERT_EQ(maxLength, octaspire_container_queue_get_max_length(queue));
    ASSERT(octaspire_container_queue_has_max_length(queue));

    for (size_t i = 0; i < (3 * maxLength); ++i)
    {
        octaspire_container_utf8_string_t * const str = octaspire_container_utf8_string_new_format(
            octaspireContainerQueueTestAllocator,
            "This is string %zu.",
            i);

        octaspire_container_queue_push(queue, &str);

        ASSERT(octaspire_container_queue_get_length(queue) <= maxLength);

        size_t firstExpectedNumber = 0;

        if (i >= maxLength)
        {
            firstExpectedNumber += (i - (maxLength - 1));
        }

        for (size_t j = 0; j < octaspire_container_queue_get_length(queue); ++j)
        {
            octaspire_container_utf8_string_t const * const storedStr =
                octaspire_container_queue_get_at_const(queue, j);

            octaspire_container_utf8_string_t * expectedStr =
                octaspire_container_utf8_string_new_format(
                    octaspireContainerQueueTestAllocator,
                    "This is string %zu.",
                    firstExpectedNumber + j);

            ASSERT(octaspire_container_utf8_string_is_equal(expectedStr, storedStr));

            octaspire_container_utf8_string_release(expectedStr);
            expectedStr = 0;
        }
    }

    ASSERT_EQ(maxLength, octaspire_container_queue_get_length(queue));

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_release_called_with_null_pointer_test(void)
{
    octaspire_container_queue_release(0);

    PASS();
}

TEST octaspire_container_queue_peek_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT_EQ(0, octaspire_container_queue_peek(queue));

    size_t const expected = 123;
    ASSERT(octaspire_container_queue_push(queue, &expected));
    ASSERT_EQ(expected, *(size_t const * const)octaspire_container_queue_peek(queue));

    size_t const next = 9876;
    ASSERT(octaspire_container_queue_push(queue, &next));
    ASSERT_EQ(expected, *(size_t const * const)octaspire_container_queue_peek(queue));

    ASSERT(octaspire_container_queue_pop(queue));
    ASSERT_EQ(next, *(size_t const * const)octaspire_container_queue_peek(queue));

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_peek_const_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT_EQ(0, octaspire_container_queue_peek_const(queue));

    size_t const expected = 123;
    ASSERT(octaspire_container_queue_push(queue, &expected));
    ASSERT_EQ(expected, *(size_t const * const)octaspire_container_queue_peek_const(queue));

    size_t const next = 9876;
    ASSERT(octaspire_container_queue_push(queue, &next));
    ASSERT_EQ(expected, *(size_t const * const)octaspire_container_queue_peek_const(queue));

    ASSERT(octaspire_container_queue_pop(queue));
    ASSERT_EQ(next, *(size_t const * const)octaspire_container_queue_peek_const(queue));

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_pop_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    size_t const numElements = 100;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_queue_push(queue, &i));
    }

    ASSERT_EQ(numElements, octaspire_container_queue_get_length(queue));

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_queue_pop(queue));
        size_t const * const ptr = (size_t const * const)octaspire_container_queue_peek(queue);

        if (i != (numElements -1))
        {
            ASSERT(ptr);
            ASSERT_EQ(i + 1, *ptr);
        }
        else
        {
            ASSERT_FALSE(ptr);
        }
    }

    ASSERT_EQ(0, octaspire_container_queue_get_length(queue));

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_push_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    size_t const numElements = 100;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT_EQ(i, octaspire_container_queue_get_length(queue));
        ASSERT(octaspire_container_queue_push(queue, &i));
        ASSERT_EQ(i + 1, octaspire_container_queue_get_length(queue));
        size_t const * const ptr = (size_t const * const)octaspire_container_queue_peek(queue);
        ASSERT_EQ(0, *ptr);

        for (size_t j = 0; j < octaspire_container_queue_get_length(queue); ++j)
        {
            size_t const * const jth =
                (size_t const * const)octaspire_container_queue_get_at(queue, j);

            ASSERT_EQ(j, *jth);
        }
    }

    ASSERT_EQ(numElements, octaspire_container_queue_get_length(queue));

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_queue_pop(queue));
        size_t const * const ptr = (size_t const * const)octaspire_container_queue_peek(queue);

        if (i != (numElements -1))
        {
            ASSERT(ptr);
            ASSERT_EQ(i + 1, *ptr);
        }
        else
        {
            ASSERT_FALSE(ptr);
        }
    }

    ASSERT_EQ(0, octaspire_container_queue_get_length(queue));

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_clear_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT(octaspire_container_queue_clear(queue));
    ASSERT(octaspire_container_queue_is_empty(queue));
    ASSERT_EQ(0, octaspire_container_queue_get_length(queue));
    ASSERT_FALSE(octaspire_container_queue_peek(queue));

    size_t const value = 10;
    ASSERT(octaspire_container_queue_push(queue, &value));

    ASSERT(octaspire_container_queue_clear(queue));
    ASSERT(octaspire_container_queue_is_empty(queue));
    ASSERT_EQ(0, octaspire_container_queue_get_length(queue));
    ASSERT_FALSE(octaspire_container_queue_peek(queue));

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_get_length_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT_EQ(0, octaspire_container_queue_get_length(queue));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_queue_push(queue, &i));
        ASSERT_EQ(i + 1, octaspire_container_queue_get_length(queue));
    }

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_queue_pop(queue));
        ASSERT_EQ(numElements - 1 - i, octaspire_container_queue_get_length(queue));
    }

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_is_empty_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT(octaspire_container_queue_is_empty(queue));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_queue_push(queue, &i));
        ASSERT_FALSE(octaspire_container_queue_is_empty(queue));
    }

    for (size_t i = 0; i < (numElements - 1); ++i)
    {
        ASSERT(octaspire_container_queue_pop(queue));
        ASSERT_FALSE(octaspire_container_queue_is_empty(queue));
    }

    ASSERT(octaspire_container_queue_pop(queue));
    ASSERT(octaspire_container_queue_is_empty(queue));

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_get_at_failure_on_too_large_index_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT_FALSE(octaspire_container_queue_get_at(queue, 0));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_queue_push(queue, &i));

        size_t j;
        for (j = 0; j < i; ++j)
        {
            ASSERT(octaspire_container_queue_get_at(queue, j));
        }

        ++j;
        ASSERT_FALSE(octaspire_container_queue_get_at(queue, j));
    }

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_get_at_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    size_t const numElements = 100;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_queue_push(queue, &i));

        for (size_t j = 0; j < i; ++j)
        {
            size_t const * const ptr = octaspire_container_queue_get_at(queue, j);
            ASSERT(ptr);
            ASSERT_EQ(j, *ptr);
        }
    }

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_get_at_const_failure_on_too_large_index_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    ASSERT_FALSE(octaspire_container_queue_get_at_const(queue, 0));

    size_t const numElements = 10;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_queue_push(queue, &i));

        size_t j;
        for (j = 0; j < i; ++j)
        {
            ASSERT(octaspire_container_queue_get_at_const(queue, j));
        }

        ++j;
        ASSERT_FALSE(octaspire_container_queue_get_at_const(queue, j));
    }

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_get_at_const_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT(queue);

    size_t const numElements = 100;

    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_queue_push(queue, &i));

        for (size_t j = 0; j < i; ++j)
        {
            size_t const * const ptr = octaspire_container_queue_get_at_const(queue, j);
            ASSERT(ptr);
            ASSERT_EQ(j, *ptr);
        }
    }

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

TEST octaspire_container_queue_get_set_has_max_length_test(void)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(size_t),
        false,
        0,
        octaspireContainerQueueTestAllocator);

    ASSERT_EQ(0, octaspire_container_queue_get_max_length(queue));
    ASSERT_FALSE(octaspire_container_queue_has_max_length(queue));

    size_t const value = 100;

    for (size_t i = 0; i < value; ++i)
    {
        ASSERT(octaspire_container_queue_set_max_length(queue, i));
        ASSERT_EQ(i, octaspire_container_queue_get_max_length(queue));
        ASSERT_EQ(0, octaspire_container_queue_get_length(queue));
    }

    size_t const numElements = 256;
    for (size_t i = 0; i < numElements; ++i)
    {
        ASSERT(octaspire_container_queue_push(queue, &i));
    }

    ASSERT_EQ(numElements, octaspire_container_queue_get_length(queue));
    ASSERT_FALSE(octaspire_container_queue_has_max_length(queue));

    for (size_t i = value; i > 0; --i)
    {
        ASSERT(octaspire_container_queue_set_max_length(queue, i));
        ASSERT(octaspire_container_queue_set_has_max_length(queue, true));
        ASSERT(octaspire_container_queue_has_max_length(queue));
        ASSERT_EQ(i, octaspire_container_queue_get_max_length(queue));
        ASSERT_EQ(i, octaspire_container_queue_get_length(queue));
    }

    octaspire_container_queue_release(queue);
    queue = 0;

    PASS();
}

GREATEST_SUITE(octaspire_container_queue_suite)
{
    octaspireContainerQueueTestAllocator = octaspire_memory_allocator_new(0);
    assert(octaspireContainerQueueTestAllocator);

    RUN_TEST(octaspire_container_queue_new_test);
    RUN_TEST(octaspire_container_queue_new_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_container_queue_new_with_max_length_of_56_with_size_t_elements_test);
    RUN_TEST(octaspire_container_queue_new_with_max_length_of_10_with_ostring_ptr_elements_test);
    RUN_TEST(octaspire_container_queue_release_called_with_null_pointer_test);
    RUN_TEST(octaspire_container_queue_peek_test);
    RUN_TEST(octaspire_container_queue_peek_const_test);
    RUN_TEST(octaspire_container_queue_pop_test);
    RUN_TEST(octaspire_container_queue_push_test);
    RUN_TEST(octaspire_container_queue_clear_test);
    RUN_TEST(octaspire_container_queue_get_length_test);
    RUN_TEST(octaspire_container_queue_is_empty_test);
    RUN_TEST(octaspire_container_queue_get_at_failure_on_too_large_index_test);
    RUN_TEST(octaspire_container_queue_get_at_test);
    RUN_TEST(octaspire_container_queue_get_at_const_failure_on_too_large_index_test);
    RUN_TEST(octaspire_container_queue_get_at_const_test);
    RUN_TEST(octaspire_container_queue_get_set_has_max_length_test);

    octaspire_memory_allocator_release(octaspireContainerQueueTestAllocator);
    octaspireContainerQueueTestAllocator = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_container_queue.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_container_utf8_string.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_memory_allocator_t *octaspireContainerUtf8StringTestAllocator = 0;

TEST octaspire_container_utf8_string_new_called_with_null_argument_test(void)
{
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(0, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(0, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("", octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_with_simple_ascii_string_test(void)
{
    char const * const expected = "Hello World!";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(expected, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(strlen((char const * const)expected), octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(strlen((char const * const)expected), octaspire_container_utf8_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ(expected, octaspire_container_utf8_string_get_c_string(str));

    for (size_t i = 0; i < octaspire_container_utf8_string_get_length_in_ucs_characters(str); ++i)
    {
        ASSERT_EQ((uint32_t)(expected[i]), octaspire_container_utf8_string_get_ucs_character_at_index(str, i));
    }

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_with_some_multioctet_ucs_characters_test(void)
{
    char const * const input = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_with_simple_ascii_string_with_error_test(void)
{
    char const * const input    = "Hello World\xC0\xB3";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_DECODING_ERROR, str->errorStatus);
    ASSERT_EQ(11,                                                          str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                                   str->allocator);

    ASSERT(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(11, octaspire_container_utf8_string_get_error_position_in_octets(str));

    char const * const expected = "Hello World";

    ASSERT_EQ(strlen((char const * const)expected), octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(strlen((char const * const)expected), octaspire_container_utf8_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ(expected, octaspire_container_utf8_string_get_c_string(str));

    for (size_t i = 0; i < octaspire_container_utf8_string_get_length_in_ucs_characters(str); ++i)
    {
        ASSERT_EQ((uint32_t)(expected[i]), octaspire_container_utf8_string_get_ucs_character_at_index(str, i));
    }

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_from_buffer_with_some_multioctet_ucs_characters_test(void)
{
    char const * const input               = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    size_t const       lengthInOctets      = strlen(input);
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_from_buffer(input, lengthInOctets, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_from_buffer_allocation_failure_on_first_allocation_test(void)
{
    char const * const input               = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    size_t const       lengthInOctets      = strlen(input);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator));

    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_from_buffer(input, lengthInOctets, octaspireContainerUtf8StringTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    ASSERT_FALSE(str);

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_from_buffer_allocation_failure_on_second_allocation_test(void)
{
    char const * const input               = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    size_t const       lengthInOctets      = strlen(input);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator));

    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_from_buffer(input, lengthInOctets, octaspireContainerUtf8StringTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    ASSERT_FALSE(str);

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_from_buffer_allocation_failure_on_third_allocation_test(void)
{
    char const * const input               = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    size_t const       lengthInOctets      = strlen(input);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 3, 0x03);
    ASSERT_EQ(3, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator));

    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_from_buffer(input, lengthInOctets, octaspireContainerUtf8StringTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    ASSERT_FALSE(str);

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_from_buffer_allocation_failure_on_fourth_allocation_test(void)
{
    char const * const input               = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    size_t const       lengthInOctets      = strlen(input);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 4, 0x07);
    ASSERT_EQ(4, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator));

    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_from_buffer(input, lengthInOctets, octaspireContainerUtf8StringTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    ASSERT_FALSE(str);

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_from_buffer_allocation_failure_on_sixth_1_allocation_test(void)
{
    char const * const input               = "êÄÄêÄÄêÄÄ";
    size_t const       lengthInOctets      = strlen(input);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 6, 0x1F);
    ASSERT_EQ(6, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator));

    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_from_buffer(input, lengthInOctets, octaspireContainerUtf8StringTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    ASSERT_FALSE(str);

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_from_buffer_allocation_failure_on_sixth_2_allocation_test(void)
{
    char const * const input               = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    size_t const       lengthInOctets      = strlen(input);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 6, 0x1F);
    ASSERT_EQ(6, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator));

    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_from_buffer(input, lengthInOctets, octaspireContainerUtf8StringTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    ASSERT_FALSE(str);

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_format_with_string_test(void)
{
    char const * const name  = "Mike";
    char const * const input = "Hello! My name is %s. What's yours?";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_format(octaspireContainerUtf8StringTestAllocator, input, name);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(37, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "Hello! My name is Mike. What's yours?";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_format_with_size_t_test(void)
{
    size_t const value = 62039;
    char const * const input = "¬©Hello World! ¬© ‚â†êÄÄHow are you? My age is %zu. What's yours?";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_format(octaspireContainerUtf8StringTestAllocator, input, value);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(68, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(61, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you? My age is 62039. What's yours?";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_format_with_doubles_test(void)
{
    double const value1 = 12.001;
    double const value2 = 2015.12;
    double const value3 = 4.9;
    char const * const input = "The doubles are %g, %g and %g\n";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_format(octaspireContainerUtf8StringTestAllocator, input, value1, value2, value3);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(40, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(40, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    char const * const expected = "The doubles are 12.001, 2015.12 and 4.9\n";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_format_with_string_and_size_t_test(void)
{
    size_t const value = 62039;
    char const * const name  = "¬©Hello";
    char const * const input = "¬©Hello World! ¬© ‚â†êÄÄHow are you? My name is \"%s\" and my age is %zu. What's yours?";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_format(octaspireContainerUtf8StringTestAllocator, input, name, value);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(93, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(85, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you? My name is \"\xC2\xA9Hello\" and my age is 62039. What's yours?";

    ASSERT_MEM_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str),
        octaspire_container_utf8_string_get_length_in_octets(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_format_with_string_and_size_t_on_otherwise_empty_format_string_test(void)
{
    size_t const value = 62039;
    char const * const name  = "Hello";
    char const * const input = "%s%zu";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_format(octaspireContainerUtf8StringTestAllocator, input, name, value);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(10, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(10, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "Hello62039";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_format_with_empty_format_string_test(void)
{
    char const * const input = "";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new_format(octaspireContainerUtf8StringTestAllocator, input);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(0, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_copy_test(void)
{
    char const * const input = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_t *cpy =
        octaspire_container_utf8_string_new_copy(str, octaspireContainerUtf8StringTestAllocator);

    ASSERT_EQ(
        octaspire_container_utf8_string_get_length_in_octets(str),
        octaspire_container_utf8_string_get_length_in_octets(cpy));

    ASSERT_MEM_EQ(
        octaspire_container_vector_get_element_at_const(str->octets, 0),
        octaspire_container_vector_get_element_at_const(cpy->octets, 0),
        octaspire_container_utf8_string_get_length_in_octets(str));

    ASSERT_EQ(
        octaspire_container_vector_get_length_in_octets(str->ucsCharacters),
        octaspire_container_vector_get_length_in_octets(cpy->ucsCharacters));

    ASSERT_MEM_EQ(
        octaspire_container_vector_get_element_at_const(str->ucsCharacters, 0),
        octaspire_container_vector_get_element_at_const(cpy->ucsCharacters, 0),
        octaspire_container_vector_get_length_in_octets(str->ucsCharacters));

    ASSERT_EQ(str->errorStatus,  cpy->errorStatus);
    ASSERT_EQ(str->errorAtOctet, cpy->errorAtOctet);

    ASSERT_EQ(cpy->allocator,     octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_release(str);
    str = 0;

    octaspire_container_utf8_string_release(cpy);
    cpy = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_copy_failure_test(void)
{
    char const * const input = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(str->octets);
    ASSERT(str->ucsCharacters);
    ASSERT_EQ(OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK, str->errorStatus);
    ASSERT_EQ(0,                                               str->errorAtOctet);
    ASSERT_EQ(octaspireContainerUtf8StringTestAllocator,                                       str->allocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator));

    ASSERT_FALSE(octaspire_container_utf8_string_new_copy(str, octaspireContainerUtf8StringTestAllocator));

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_get_length_in_ucs_characters_test(void)
{
    char const * const input = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    //ASSERT_EQ(37, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_get_length_in_ucs_characters_called_with_empty_string_test(void)
{
    char const * const input = "";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(0, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_get_length_in_octets_test(void)
{
    char const * const input = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_container_utf8_string_get_length_in_octets(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_get_length_in_octets_called_with_empty_string_test(void)
{
    char const * const input = "";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(0, octaspire_container_utf8_string_get_length_in_octets(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_get_ucs_character_at_index_test(void)
{
    char const * const input = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

#define EXPECTED_LENGTH 30

    ASSERT_EQ(EXPECTED_LENGTH, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    uint32_t expected[EXPECTED_LENGTH] =
    {
        0xA9,    // Copyright symbol
        0x48,    // H
        0x65,    // e
        0x6C,    // l
        0x6C,    // l
        0x6F,    // o
        0x20,    // SPACE
        0x57,    // W
        0x6F,    // o
        0x72,    // r
        0x6C,    // l
        0x64,    // d
        0x21,    // !
        0x20,    // SPACE
        0xA9,    // Copyright symbol
        0x20,    // SPACE
        0x2260,  // NOT EQUAL SIGN
        0x10000, // LINEAR B SYLLABLE B008 A
        0x48,    // H
        0x6F,    // o
        0x77,    // w
        0x20,    // SPACE
        0x61,    // a
        0x72,    // r
        0x65,    // e
        0x20,    // SPACE
        0x79,    // y
        0x6F,    // o
        0x75,    // u
        0x3F,    // ?
    };

    for (size_t i = 0; i < EXPECTED_LENGTH; ++i)
    {
        ASSERT_EQ(expected[i], octaspire_container_utf8_string_get_ucs_character_at_index(str, i));
    }

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_get_c_string_test(void)
{
    char const * const input    = "Hello World! ¬©";
    char const * const expected = "Hello World! \xc2\xa9";

    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(15, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(14, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_get_c_string_called_with_empty_string_test(void)
{
    char const * const input    = "";

    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(0, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    ASSERT_EQ('\0', *octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_is_error_false_case_test(void)
{
    char const * const input    = "Hello World";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_is_error_true_case_test(void)
{
    char const * const input    = "Hello World\xC0\xB3";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT(octaspire_container_utf8_string_is_error(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_get_error_position_in_octets_called_when_has_error_test(void)
{
    char const * const input    = "Hello World\xC0\xB3";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_EQ(11, octaspire_container_utf8_string_get_error_position_in_octets(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_get_error_position_in_octets_called_when_has_no_error_test(void)
{
    char const * const input    = "Hello World";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_reset_error_status_called_when_there_is_error_test(void)
{
    char const * const input    = "Hello World\xC0\xB3";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(11, octaspire_container_utf8_string_get_error_position_in_octets(str));

    octaspire_container_utf8_string_reset_error_status(str);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_reset_error_status_called_when_there_is_no_error_test(void)
{
    char const * const input    = "Hello World";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    octaspire_container_utf8_string_reset_error_status(str);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_concatenate_c_string_called_with_null_and_empty_string_arguments_test(void)
{
    char const * const input = "¬©Hello World! ¬© ‚â†êÄÄHow are you?";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_concatenate_c_string(str, 0);
    octaspire_container_utf8_string_concatenate_c_string(str, "");

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

// TODO XXX Add test cases for allocation failures in concatenate_c_string...

TEST octaspire_container_utf8_string_concatenate_c_string_test(void)
{
    char const * const input  = "¬©Hello World!";
    char const * const input2 = " ¬© ‚â†êÄÄHow are you?";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_concatenate_c_string(str, input2);

    ASSERT_FALSE(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_concatenate_c_string_with_decode_error_test(void)
{
    char const * const input  = "¬©Hello World!";
    char const * const input2 = " ¬© ‚â†êÄÄHow are you?\xC0\xB3";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_concatenate_c_string(str, input2);

    ASSERT(octaspire_container_utf8_string_is_error(str));
    ASSERT_EQ(23, octaspire_container_utf8_string_get_error_position_in_octets(str));

    ASSERT_EQ(37, octaspire_container_utf8_string_get_length_in_octets(str));
    ASSERT_EQ(30, octaspire_container_utf8_string_get_length_in_ucs_characters(str));

    char const * const expected = 
        "\xC2\xA9Hello World! \xC2\xA9 \xE2\x89\xA0\xF0\x90\x80\x80How are you?";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_concatenate_c_string_allocation_failure_one_test(void)
{
    char const * const input  = "¬©Hello World!";
    char const * const input2 = " ¬© ‚â†êÄÄHow are you?";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 1, 0);

    ASSERT_FALSE(octaspire_container_utf8_string_concatenate_c_string(str, input2));

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_concatenate_c_string_allocation_failure_two_test(void)
{
    char const * const input  = "a";
    char const * const input2 = "bcd";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerUtf8StringTestAllocator,
        2, 0x00000002);

    ASSERT_FALSE(octaspire_container_utf8_string_concatenate_c_string(str, input2));

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_concatenate_c_string_allocation_failure_three_test(void)
{
    char const * const input  = "a";
    char const * const input2 = "b";
    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(input, octaspireContainerUtf8StringTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerUtf8StringTestAllocator,
        2, 0x00000001);

    ASSERT_FALSE(octaspire_container_utf8_string_concatenate_c_string(str, input2));

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerUtf8StringTestAllocator, 0, 0x00);

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_c_strings_end_always_in_null_byte_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new("", octaspireContainerUtf8StringTestAllocator);
    ASSERT_FALSE(octaspire_container_vector_is_empty(str->octets));

    ASSERT_EQ(
        octaspire_container_utf8_string_private_null_octet,
        *(char const * const)octaspire_container_vector_get_element_at(
            str->octets,
            octaspire_container_vector_get_length(str->octets) - 1));

    octaspire_container_utf8_string_release(str);
    str = 0;


    str = octaspire_container_utf8_string_new("a", octaspireContainerUtf8StringTestAllocator);
    ASSERT_FALSE(octaspire_container_vector_is_empty(str->octets));

    ASSERT_EQ(
        octaspire_container_utf8_string_private_null_octet,
        *(char const * const)octaspire_container_vector_get_element_at(
            str->octets,
            octaspire_container_vector_get_length(str->octets) - 1));

    octaspire_container_utf8_string_release(str);
    str = 0;


    str = octaspire_container_utf8_string_new_format(octaspireContainerUtf8StringTestAllocator, "");
    ASSERT_FALSE(octaspire_container_vector_is_empty(str->octets));

    ASSERT_EQ(
        octaspire_container_utf8_string_private_null_octet,
        *(char const * const)octaspire_container_vector_get_element_at(
            str->octets,
            octaspire_container_vector_get_length(str->octets) - 1));

    octaspire_container_utf8_string_release(str);
    str = 0;


    size_t const size = 112;
    str = octaspire_container_utf8_string_new_format(octaspireContainerUtf8StringTestAllocator, "%zu", size);
    ASSERT_FALSE(octaspire_container_vector_is_empty(str->octets));

    ASSERT_EQ(
        octaspire_container_utf8_string_private_null_octet,
        *(char const * const)octaspire_container_vector_get_element_at(
            str->octets,
            octaspire_container_vector_get_length(str->octets) - 1));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_format_numbers_into_vector_test(void)
{
    octaspire_container_vector_t *vec = octaspire_container_vector_new(
        sizeof(octaspire_container_utf8_string_t*),
        true,
        (octaspire_container_vector_element_callback_t)octaspire_container_utf8_string_release,
        octaspireContainerUtf8StringTestAllocator);

    size_t const numElements = 256;

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new_format(
            octaspireContainerUtf8StringTestAllocator,
            "%zu",
            i);

        octaspire_container_vector_push_back_element(vec, &str);

    }

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_container_utf8_string_t const * const str =
            octaspire_container_vector_get_element_at_const(vec, i);

        ASSERT_EQ(i, (size_t)atoi(octaspire_container_utf8_string_get_c_string(str)));
    }

    octaspire_container_vector_release(vec);
    vec = 0;

    PASS();
}

TEST octaspire_container_utf8_string_new_format_number_test(void)
{
    size_t const i = 2000;
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new_format(
            octaspireContainerUtf8StringTestAllocator,
            "%zu",
            i);

    ASSERT_EQ(i, (size_t)atoi(octaspire_container_utf8_string_get_c_string(str)));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_char_a_from_string_a123a56a89a_using_index_zero_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "a123a56a89a",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *character =
        octaspire_container_utf8_string_new("a123",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && character);

    octaspire_container_vector_t *indices = octaspire_container_utf8_string_find_char(
        str,
        character,
        0);

    ASSERT(indices);

    ASSERT_EQ(4, octaspire_container_vector_get_length(indices));

    ASSERT_EQ(0,  *(size_t*)octaspire_container_vector_get_element_at(indices, 0));
    ASSERT_EQ(4,  *(size_t*)octaspire_container_vector_get_element_at(indices, 1));
    ASSERT_EQ(7,  *(size_t*)octaspire_container_vector_get_element_at(indices, 2));
    ASSERT_EQ(10, *(size_t*)octaspire_container_vector_get_element_at(indices, 3));

    octaspire_container_vector_release(indices);
    indices = 0;

    octaspire_container_utf8_string_release(character);
    character = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_char_q_from_string_a123a56q89q_using_index_one_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "a123a56q89q",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *character =
        octaspire_container_utf8_string_new("aq123",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && character);

    octaspire_container_vector_t *indices = octaspire_container_utf8_string_find_char(
        str,
        character,
        1);

    ASSERT(indices);

    ASSERT_EQ(2, octaspire_container_vector_get_length(indices));

    ASSERT_EQ(7,  *(size_t*)octaspire_container_vector_get_element_at(indices, 0));
    ASSERT_EQ(10, *(size_t*)octaspire_container_vector_get_element_at(indices, 1));

    octaspire_container_vector_release(indices);
    indices = 0;

    octaspire_container_utf8_string_release(character);
    character = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_char_c_from_string_a123c56q89q_using_index_two_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "a123c56q89q",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *character =
        octaspire_container_utf8_string_new("aqc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && character);

    octaspire_container_vector_t *indices = octaspire_container_utf8_string_find_char(
        str,
        character,
        2);

    ASSERT(indices);

    ASSERT_EQ(1, octaspire_container_vector_get_length(indices));

    ASSERT_EQ(4, *(size_t*)octaspire_container_vector_get_element_at(indices, 0));

    octaspire_container_vector_release(indices);
    indices = 0;

    octaspire_container_utf8_string_release(character);
    character = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_char_c_from_string_a123y56q89q_using_index_two_failure_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "a123y56q89q",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *character =
        octaspire_container_utf8_string_new("aqc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && character);

    octaspire_container_vector_t *indices = octaspire_container_utf8_string_find_char(
        str,
        character,
        2);

    ASSERT(indices);

    ASSERT_EQ(0, octaspire_container_vector_get_length(indices));

    octaspire_container_vector_release(indices);
    indices = 0;

    octaspire_container_utf8_string_release(character);
    character = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_string_cat_from_string_cat_dog_cat_zebra_car_kitten_cat_using_index_zero_and_length_of_3_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "cat dog cat zebra car kitten cat",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *lookFor =
        octaspire_container_utf8_string_new("cat",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_container_vector_t *indices = octaspire_container_utf8_string_find_string(
        str,
        lookFor,
        0,
        3);

    ASSERT(indices);

    ASSERT_EQ(3, octaspire_container_vector_get_length(indices));

    ASSERT_EQ(0,   *(size_t*)octaspire_container_vector_get_element_at(indices, 0));
    ASSERT_EQ(8,   *(size_t*)octaspire_container_vector_get_element_at(indices, 1));
    ASSERT_EQ(29,  *(size_t*)octaspire_container_vector_get_element_at(indices, 2));

    octaspire_container_vector_release(indices);
    indices = 0;

    octaspire_container_utf8_string_release(lookFor);
    lookFor = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_string_cat_from_string_cat_dog_cat_zebra_car_kitten_cat_using_index_one_and_length_of_3_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "cat dog cat zebra car kitten cat",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *lookFor =
        octaspire_container_utf8_string_new(">cat<",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_container_vector_t *indices = octaspire_container_utf8_string_find_string(
        str,
        lookFor,
        1,
        3);

    ASSERT(indices);

    ASSERT_EQ(3, octaspire_container_vector_get_length(indices));

    ASSERT_EQ(0,   *(size_t*)octaspire_container_vector_get_element_at(indices, 0));
    ASSERT_EQ(8,   *(size_t*)octaspire_container_vector_get_element_at(indices, 1));
    ASSERT_EQ(29,  *(size_t*)octaspire_container_vector_get_element_at(indices, 2));

    octaspire_container_vector_release(indices);
    indices = 0;

    octaspire_container_utf8_string_release(lookFor);
    lookFor = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_string_dog_from_string_dog_cat_zebra_using_index_zero_and_length_of_three_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "dog cat zebra",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *lookFor =
        octaspire_container_utf8_string_new("dog",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_container_vector_t *indices = octaspire_container_utf8_string_find_string(
        str,
        lookFor,
        0,
        3);

    ASSERT(indices);

    ASSERT_EQ(1, octaspire_container_vector_get_length(indices));

    ASSERT_EQ(0,   *(size_t*)octaspire_container_vector_get_element_at(indices, 0));

    octaspire_container_vector_release(indices);
    indices = 0;

    octaspire_container_utf8_string_release(lookFor);
    lookFor = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_string_dog_from_string_cat_zebra_dog_using_index_zero_and_length_of_three_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "cat zebra dog",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *lookFor =
        octaspire_container_utf8_string_new("dog",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_container_vector_t *indices = octaspire_container_utf8_string_find_string(
        str,
        lookFor,
        0,
        3);

    ASSERT(indices);

    ASSERT_EQ(1, octaspire_container_vector_get_length(indices));

    ASSERT_EQ(10,   *(size_t*)octaspire_container_vector_get_element_at(indices, 0));

    octaspire_container_vector_release(indices);
    indices = 0;

    octaspire_container_utf8_string_release(lookFor);
    lookFor = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_string_dog_from_string_cat_zebra_kitten_using_index_zero_and_length_of_three_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "cat zebra kitten",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *lookFor =
        octaspire_container_utf8_string_new("dog",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_container_vector_t *indices = octaspire_container_utf8_string_find_string(
        str,
        lookFor,
        0,
        3);

    ASSERT(indices);

    ASSERT_EQ(0, octaspire_container_vector_get_length(indices));

    octaspire_container_vector_release(indices);
    indices = 0;

    octaspire_container_utf8_string_release(lookFor);
    lookFor = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_string_kitten_from_string_cat_using_index_zero_and_length_of_six_failure_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "cat",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *lookFor =
        octaspire_container_utf8_string_new("kitten",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && lookFor);

    octaspire_container_vector_t *indices = octaspire_container_utf8_string_find_string(
        str,
        lookFor,
        0,
        6);

    ASSERT(indices);

    ASSERT_EQ(0, octaspire_container_vector_get_length(indices));

    octaspire_container_vector_release(indices);
    indices = 0;

    octaspire_container_utf8_string_release(lookFor);
    lookFor = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_private_check_substring_match_at_middle_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "123kitten456",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *substring =
        octaspire_container_utf8_string_new("kitten",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    for (size_t i = 0; i < octaspire_container_utf8_string_get_length_in_ucs_characters(str); ++i)
    {
        ASSERT_EQ(i == 3 ? true : false,
            octaspire_container_utf8_string_private_check_substring_match_at(
                str,
                i,
                substring));
    }

    octaspire_container_utf8_string_release(substring);
    substring = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_private_check_substring_match_at_the_beginning_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "kitten456",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *substring =
        octaspire_container_utf8_string_new("kitten",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    for (size_t i = 0; i < octaspire_container_utf8_string_get_length_in_ucs_characters(str); ++i)
    {
        ASSERT_EQ(i == 0 ? true : false,
            octaspire_container_utf8_string_private_check_substring_match_at(
                str,
                i,
                substring));
    }

    octaspire_container_utf8_string_release(substring);
    substring = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_private_check_substring_match_at_the_end_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "123kitten",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *substring =
        octaspire_container_utf8_string_new("kitten",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    for (size_t i = 0; i < octaspire_container_utf8_string_get_length_in_ucs_characters(str); ++i)
    {
        ASSERT_EQ(i == 3 ? true : false,
            octaspire_container_utf8_string_private_check_substring_match_at(
                str,
                i,
                substring));
    }

    octaspire_container_utf8_string_release(substring);
    substring = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_first_substring_abc_from_123abc456abc_starting_from_index_0_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "123abc456abc",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *substring =
        octaspire_container_utf8_string_new("abc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    ASSERT_EQ(
        3,
        octaspire_container_utf8_string_find_first_substring(
            str,
            0,
            substring));

    octaspire_container_utf8_string_release(substring);
    substring = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_first_substring_abc_from_123abc456abc_starting_from_index_4_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "123abc456abc",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *substring =
        octaspire_container_utf8_string_new("abc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    ASSERT_EQ(
        9,
        octaspire_container_utf8_string_find_first_substring(
            str,
            4,
            substring));

    octaspire_container_utf8_string_release(substring);
    substring = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_find_first_substring_abcd_from_123abc456abc_starting_from_index_0_failure_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "123abc456abc",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *substring =
        octaspire_container_utf8_string_new("abcd",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    ASSERT_EQ(
        -1,
        octaspire_container_utf8_string_find_first_substring(
            str,
            0,
            substring));

    octaspire_container_utf8_string_release(substring);
    substring = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_remove_character_at_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "0123456789",
            octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT(octaspire_container_utf8_string_remove_character_at(str, 1));
    ASSERT_STR_EQ("023456789", octaspire_container_utf8_string_get_c_string(str));

    ASSERT(octaspire_container_utf8_string_remove_character_at(str, 0));
    ASSERT_STR_EQ("23456789", octaspire_container_utf8_string_get_c_string(str));

    ASSERT(octaspire_container_utf8_string_remove_character_at(str, 7));
    ASSERT_STR_EQ("2345678", octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_remove_character_at_called_on_string_with_two_os_with_diaeresis_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "√∂√∂",
            octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);
    ASSERT_EQ(2, octaspire_container_utf8_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("√∂√∂", octaspire_container_utf8_string_get_c_string(str));

    ASSERT(octaspire_container_utf8_string_remove_character_at(str, 1));
    ASSERT_EQ(1, octaspire_container_utf8_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("√∂", octaspire_container_utf8_string_get_c_string(str));

    ASSERT(octaspire_container_utf8_string_remove_character_at(str, 0));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("", octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_remove_characters_at_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "0123456789",
            octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);

    ASSERT_EQ(3, octaspire_container_utf8_string_remove_characters_at(str, 7, 3));
    ASSERT_STR_EQ("0123456", octaspire_container_utf8_string_get_c_string(str));

    ASSERT_EQ(3, octaspire_container_utf8_string_remove_characters_at(str, 2, 3));
    ASSERT_STR_EQ("0156", octaspire_container_utf8_string_get_c_string(str));

    ASSERT_EQ(3, octaspire_container_utf8_string_remove_characters_at(str, 0, 3));
    ASSERT_STR_EQ("6", octaspire_container_utf8_string_get_c_string(str));

    ASSERT_EQ(1, octaspire_container_utf8_string_remove_characters_at(str, 0, 1));
    ASSERT_STR_EQ("", octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_remove_all_substrings_kitten_from_string_kitten_cat_kitten_dog_kitten_zebra_kitten_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
            "kitten cat kitten dog kitten zebra kitten",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *substring =
        octaspire_container_utf8_string_new("kitten",octaspireContainerUtf8StringTestAllocator);

    ASSERT(str && substring);

    ASSERT_EQ(4, octaspire_container_utf8_string_remove_all_substrings(str, substring));

    ASSERT_STR_EQ(
        " cat  dog  zebra ",
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(substring);
    substring = 0;

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_insert_string_to_bc_into_index_1_of_ade_test(void)
{
    octaspire_container_utf8_string_t *strTarget = octaspire_container_utf8_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *strAddition =
        octaspire_container_utf8_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_container_utf8_string_insert_string_to(strTarget, strAddition, 1));

    ASSERT_EQ(5, octaspire_container_utf8_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "abcde",
        octaspire_container_utf8_string_get_c_string(strTarget));

    octaspire_container_utf8_string_release(strAddition);
    strAddition = 0;

    octaspire_container_utf8_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_container_utf8_string_insert_string_to_bc_into_index_minus_1_of_ade_test(void)
{
    octaspire_container_utf8_string_t *strTarget = octaspire_container_utf8_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *strAddition =
        octaspire_container_utf8_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_container_utf8_string_insert_string_to(strTarget, strAddition, -1));

    ASSERT_EQ(5, octaspire_container_utf8_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "adbce",
        octaspire_container_utf8_string_get_c_string(strTarget));

    octaspire_container_utf8_string_release(strAddition);
    strAddition = 0;

    octaspire_container_utf8_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_container_utf8_string_insert_string_to_bc_into_index_minus_3_of_ade_test(void)
{
    octaspire_container_utf8_string_t *strTarget = octaspire_container_utf8_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *strAddition =
        octaspire_container_utf8_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_container_utf8_string_insert_string_to(strTarget, strAddition, -3));

    ASSERT_EQ(5, octaspire_container_utf8_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "bcade",
        octaspire_container_utf8_string_get_c_string(strTarget));

    octaspire_container_utf8_string_release(strAddition);
    strAddition = 0;

    octaspire_container_utf8_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_container_utf8_string_insert_string_to_bc_into_index_minus_4_of_ade_failure_test(void)
{
    octaspire_container_utf8_string_t *strTarget = octaspire_container_utf8_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *strAddition =
        octaspire_container_utf8_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT_FALSE(octaspire_container_utf8_string_insert_string_to(strTarget, strAddition, -4));

    ASSERT_EQ(3, octaspire_container_utf8_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "ade",
        octaspire_container_utf8_string_get_c_string(strTarget));

    octaspire_container_utf8_string_release(strAddition);
    strAddition = 0;

    octaspire_container_utf8_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_container_utf8_string_insert_string_to_bc_into_index_3_of_ade_failure_test(void)
{
    octaspire_container_utf8_string_t *strTarget = octaspire_container_utf8_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *strAddition =
        octaspire_container_utf8_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT_FALSE(octaspire_container_utf8_string_insert_string_to(strTarget, strAddition, 3));

    ASSERT_EQ(3, octaspire_container_utf8_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "ade",
        octaspire_container_utf8_string_get_c_string(strTarget));

    octaspire_container_utf8_string_release(strAddition);
    strAddition = 0;

    octaspire_container_utf8_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_container_utf8_string_insert_string_to_bc_into_index_0_of_ade_test(void)
{
    octaspire_container_utf8_string_t *strTarget = octaspire_container_utf8_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *strAddition =
        octaspire_container_utf8_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_container_utf8_string_insert_string_to(strTarget, strAddition, 0));

    ASSERT_EQ(5, octaspire_container_utf8_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "bcade",
        octaspire_container_utf8_string_get_c_string(strTarget));

    octaspire_container_utf8_string_release(strAddition);
    strAddition = 0;

    octaspire_container_utf8_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_container_utf8_string_insert_string_to_bc_into_index_2_of_ade_test(void)
{
    octaspire_container_utf8_string_t *strTarget = octaspire_container_utf8_string_new(
            "ade",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *strAddition =
        octaspire_container_utf8_string_new("bc",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_container_utf8_string_insert_string_to(strTarget, strAddition, 2));

    ASSERT_EQ(5, octaspire_container_utf8_string_get_length_in_ucs_characters(strTarget));

    ASSERT_STR_EQ(
        "adbce",
        octaspire_container_utf8_string_get_c_string(strTarget));

    octaspire_container_utf8_string_release(strAddition);
    strAddition = 0;

    octaspire_container_utf8_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_container_utf8_string_overwrite_with_string_at_first_test(void)
{
    octaspire_container_utf8_string_t *strTarget = octaspire_container_utf8_string_new(
            "",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *strAddition =
        octaspire_container_utf8_string_new("ab√∂",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_container_utf8_string_overwrite_with_string_at(strTarget, strAddition, 0));
    ASSERT_EQ(3, octaspire_container_utf8_string_get_length_in_ucs_characters(strTarget));
    ASSERT_EQ(4, octaspire_container_utf8_string_get_length_in_octets(strTarget));
    ASSERT_STR_EQ(
        "ab√∂",
        octaspire_container_utf8_string_get_c_string(strTarget));

    octaspire_container_utf8_string_release(strAddition);
    strAddition = 0;

    strAddition = octaspire_container_utf8_string_new("q",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_container_utf8_string_overwrite_with_string_at(strTarget, strAddition, 1));
    ASSERT_EQ(3, octaspire_container_utf8_string_get_length_in_ucs_characters(strTarget));
    ASSERT_EQ(4, octaspire_container_utf8_string_get_length_in_octets(strTarget));
    ASSERT_STR_EQ(
        "aq√∂",
        octaspire_container_utf8_string_get_c_string(strTarget));

    octaspire_container_utf8_string_release(strAddition);
    strAddition = 0;

    octaspire_container_utf8_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_container_utf8_string_overwrite_with_string_at_second_test(void)
{
    octaspire_container_utf8_string_t *strTarget = octaspire_container_utf8_string_new(
            "abc",
            octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *strAddition =
        octaspire_container_utf8_string_new("√∂",octaspireContainerUtf8StringTestAllocator);

    ASSERT(strTarget && strAddition);

    ASSERT(octaspire_container_utf8_string_overwrite_with_string_at(strTarget, strAddition, 1));
    ASSERT_EQ(3, octaspire_container_utf8_string_get_length_in_ucs_characters(strTarget));
    ASSERT_EQ(4, octaspire_container_utf8_string_get_length_in_octets(strTarget));
    ASSERT_STR_EQ(
        "a√∂c",
        octaspire_container_utf8_string_get_c_string(strTarget));

    octaspire_container_utf8_string_release(strAddition);
    strAddition = 0;

    octaspire_container_utf8_string_release(strTarget);
    strTarget = 0;

    PASS();
}

TEST octaspire_container_utf8_string_pop_back_ucs_character_test(void)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str);
    ASSERT_EQ(3, octaspire_container_utf8_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("abc", octaspire_container_utf8_string_get_c_string(str));

    ASSERT(octaspire_container_utf8_string_pop_back_ucs_character(str));
    ASSERT_EQ(2, octaspire_container_utf8_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("ab", octaspire_container_utf8_string_get_c_string(str));

    ASSERT(octaspire_container_utf8_string_pop_back_ucs_character(str));
    ASSERT_EQ(1, octaspire_container_utf8_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(str));

    ASSERT(octaspire_container_utf8_string_pop_back_ucs_character(str));
    ASSERT_EQ(0, octaspire_container_utf8_string_get_length_in_ucs_characters(str));
    ASSERT_STR_EQ("", octaspire_container_utf8_string_get_c_string(str));

    for (size_t i = 0; i < 10; ++i)
    {
        ASSERT_FALSE(octaspire_container_utf8_string_pop_back_ucs_character(str));
        ASSERT_EQ(0, octaspire_container_utf8_string_get_length_in_ucs_characters(str));
        ASSERT_STR_EQ("", octaspire_container_utf8_string_get_c_string(str));
    }

    octaspire_container_utf8_string_release(str);
    str = 0;

    PASS();
}

TEST octaspire_container_utf8_string_compare_with_two_empty_strings_test(void)
{
    octaspire_container_utf8_string_t *str1 =
        octaspire_container_utf8_string_new("", octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *str2 =
        octaspire_container_utf8_string_new("", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT_EQ(0, octaspire_container_utf8_string_compare(str1, str2));

    octaspire_container_utf8_string_release(str1);
    str1 = 0;

    octaspire_container_utf8_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_container_utf8_string_compare_with_abc_and_empty_string_test(void)
{
    octaspire_container_utf8_string_t *str1 =
        octaspire_container_utf8_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *str2 =
        octaspire_container_utf8_string_new("", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(octaspire_container_utf8_string_compare(str1, str2) > 0);

    octaspire_container_utf8_string_release(str1);
    str1 = 0;

    octaspire_container_utf8_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_container_utf8_string_compare_with_empty_string_and_abc_test(void)
{
    octaspire_container_utf8_string_t *str1 =
        octaspire_container_utf8_string_new("", octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *str2 =
        octaspire_container_utf8_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(octaspire_container_utf8_string_compare(str1, str2) < 0);

    octaspire_container_utf8_string_release(str1);
    str1 = 0;

    octaspire_container_utf8_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_container_utf8_string_compare_with_string_abc_and_abc_test(void)
{
    octaspire_container_utf8_string_t *str1 =
        octaspire_container_utf8_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *str2 =
        octaspire_container_utf8_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT_EQ(0, octaspire_container_utf8_string_compare(str1, str2));

    octaspire_container_utf8_string_release(str1);
    str1 = 0;

    octaspire_container_utf8_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_container_utf8_string_compare_with_string_abd_and_abc_test(void)
{
    octaspire_container_utf8_string_t *str1 =
        octaspire_container_utf8_string_new("abd", octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *str2 =
        octaspire_container_utf8_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(octaspire_container_utf8_string_compare(str1, str2) > 0);

    octaspire_container_utf8_string_release(str1);
    str1 = 0;

    octaspire_container_utf8_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_container_utf8_string_compare_with_string_abca_and_abc_test(void)
{
    octaspire_container_utf8_string_t *str1 =
        octaspire_container_utf8_string_new("abca", octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *str2 =
        octaspire_container_utf8_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(octaspire_container_utf8_string_compare(str1, str2) > 0);

    octaspire_container_utf8_string_release(str1);
    str1 = 0;

    octaspire_container_utf8_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_container_utf8_string_compare_with_string_abb_and_abc_test(void)
{
    octaspire_container_utf8_string_t *str1 =
        octaspire_container_utf8_string_new("abb", octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *str2 =
        octaspire_container_utf8_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(octaspire_container_utf8_string_compare(str1, str2) < 0);

    octaspire_container_utf8_string_release(str1);
    str1 = 0;

    octaspire_container_utf8_string_release(str2);
    str2 = 0;

    PASS();
}

TEST octaspire_container_utf8_string_compare_with_string_abc_and_abca_test(void)
{
    octaspire_container_utf8_string_t *str1 =
        octaspire_container_utf8_string_new("abc", octaspireContainerUtf8StringTestAllocator);

    octaspire_container_utf8_string_t *str2 =
        octaspire_container_utf8_string_new("abca", octaspireContainerUtf8StringTestAllocator);

    ASSERT(str1);
    ASSERT(str2);
    ASSERT(octaspire_container_utf8_string_compare(str1, str2) < 0);

    octaspire_container_utf8_string_release(str1);
    str1 = 0;

    octaspire_container_utf8_string_release(str2);
    str2 = 0;

    PASS();
}

GREATEST_SUITE(octaspire_container_utf8_string_suite)
{
    octaspireContainerUtf8StringTestAllocator = octaspire_memory_allocator_new(0);

    assert(octaspireContainerUtf8StringTestAllocator);

    RUN_TEST(octaspire_container_utf8_string_new_called_with_null_argument_test);
    RUN_TEST(octaspire_container_utf8_string_new_with_simple_ascii_string_test);
    RUN_TEST(octaspire_container_utf8_string_new_with_some_multioctet_ucs_characters_test);
    RUN_TEST(octaspire_container_utf8_string_new_with_simple_ascii_string_with_error_test);
    RUN_TEST(octaspire_container_utf8_string_new_from_buffer_with_some_multioctet_ucs_characters_test);
    RUN_TEST(octaspire_container_utf8_string_new_from_buffer_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_container_utf8_string_new_from_buffer_allocation_failure_on_second_allocation_test);
    RUN_TEST(octaspire_container_utf8_string_new_from_buffer_allocation_failure_on_third_allocation_test);
    RUN_TEST(octaspire_container_utf8_string_new_from_buffer_allocation_failure_on_fourth_allocation_test);



    RUN_TEST(octaspire_container_utf8_string_new_from_buffer_allocation_failure_on_sixth_1_allocation_test);
    RUN_TEST(octaspire_container_utf8_string_new_from_buffer_allocation_failure_on_sixth_2_allocation_test);
    RUN_TEST(octaspire_container_utf8_string_new_format_with_string_test);
    RUN_TEST(octaspire_container_utf8_string_new_format_with_size_t_test);
    RUN_TEST(octaspire_container_utf8_string_new_format_with_doubles_test);
    RUN_TEST(octaspire_container_utf8_string_new_format_with_string_and_size_t_test);
    RUN_TEST(octaspire_container_utf8_string_new_format_with_string_and_size_t_on_otherwise_empty_format_string_test);
    RUN_TEST(octaspire_container_utf8_string_new_format_with_empty_format_string_test);
    RUN_TEST(octaspire_container_utf8_string_new_copy_test);
    RUN_TEST(octaspire_container_utf8_string_new_copy_failure_test);
    RUN_TEST(octaspire_container_utf8_string_get_length_in_ucs_characters_test);
    RUN_TEST(octaspire_container_utf8_string_get_length_in_ucs_characters_called_with_empty_string_test);
    RUN_TEST(octaspire_container_utf8_string_get_length_in_octets_test);
    RUN_TEST(octaspire_container_utf8_string_get_length_in_octets_called_with_empty_string_test);
    RUN_TEST(octaspire_container_utf8_string_get_ucs_character_at_index_test);
    RUN_TEST(octaspire_container_utf8_string_get_c_string_test);
    RUN_TEST(octaspire_container_utf8_string_get_c_string_called_with_empty_string_test);
    RUN_TEST(octaspire_container_utf8_string_is_error_false_case_test);
    RUN_TEST(octaspire_container_utf8_string_is_error_true_case_test);
    RUN_TEST(octaspire_container_utf8_string_get_error_position_in_octets_called_when_has_error_test);
    RUN_TEST(octaspire_container_utf8_string_get_error_position_in_octets_called_when_has_no_error_test);
    RUN_TEST(octaspire_container_utf8_string_reset_error_status_called_when_there_is_error_test);
    RUN_TEST(octaspire_container_utf8_string_reset_error_status_called_when_there_is_no_error_test);
    RUN_TEST(octaspire_container_utf8_string_concatenate_c_string_called_with_null_and_empty_string_arguments_test);
    RUN_TEST(octaspire_container_utf8_string_concatenate_c_string_test);
    RUN_TEST(octaspire_container_utf8_string_concatenate_c_string_with_decode_error_test);
    RUN_TEST(octaspire_container_utf8_string_concatenate_c_string_allocation_failure_one_test);
    RUN_TEST(octaspire_container_utf8_string_concatenate_c_string_allocation_failure_two_test);
    RUN_TEST(octaspire_container_utf8_string_concatenate_c_string_allocation_failure_three_test);
    RUN_TEST(octaspire_container_utf8_string_c_strings_end_always_in_null_byte_test);
    RUN_TEST(octaspire_container_utf8_string_new_format_numbers_into_vector_test);
    RUN_TEST(octaspire_container_utf8_string_new_format_number_test);
    RUN_TEST(octaspire_container_utf8_string_find_char_a_from_string_a123a56a89a_using_index_zero_test);
    RUN_TEST(octaspire_container_utf8_string_find_char_q_from_string_a123a56q89q_using_index_one_test);
    RUN_TEST(octaspire_container_utf8_string_find_char_c_from_string_a123c56q89q_using_index_two_test);
    RUN_TEST(octaspire_container_utf8_string_find_char_c_from_string_a123y56q89q_using_index_two_failure_test);
    RUN_TEST(octaspire_container_utf8_string_find_string_cat_from_string_cat_dog_cat_zebra_car_kitten_cat_using_index_zero_and_length_of_3_test);
    RUN_TEST(octaspire_container_utf8_string_find_string_cat_from_string_cat_dog_cat_zebra_car_kitten_cat_using_index_one_and_length_of_3_test);
    RUN_TEST(octaspire_container_utf8_string_find_string_dog_from_string_dog_cat_zebra_using_index_zero_and_length_of_three_test);
    RUN_TEST(octaspire_container_utf8_string_find_string_dog_from_string_cat_zebra_dog_using_index_zero_and_length_of_three_test);
    RUN_TEST(octaspire_container_utf8_string_find_string_dog_from_string_cat_zebra_kitten_using_index_zero_and_length_of_three_test);
    RUN_TEST(octaspire_container_utf8_string_find_string_kitten_from_string_cat_using_index_zero_and_length_of_six_failure_test);
    RUN_TEST(octaspire_container_utf8_string_private_check_substring_match_at_middle_test);
    RUN_TEST(octaspire_container_utf8_string_private_check_substring_match_at_the_beginning_test);
    RUN_TEST(octaspire_container_utf8_string_private_check_substring_match_at_the_end_test);
    RUN_TEST(octaspire_container_utf8_string_find_first_substring_abc_from_123abc456abc_starting_from_index_0_test);
    RUN_TEST(octaspire_container_utf8_string_find_first_substring_abc_from_123abc456abc_starting_from_index_4_test);
    RUN_TEST(octaspire_container_utf8_string_find_first_substring_abcd_from_123abc456abc_starting_from_index_0_failure_test);
    RUN_TEST(octaspire_container_utf8_string_remove_character_at_test);
    RUN_TEST(octaspire_container_utf8_string_remove_character_at_called_on_string_with_two_os_with_diaeresis_test);
    RUN_TEST(octaspire_container_utf8_string_remove_characters_at_test);
    RUN_TEST(octaspire_container_utf8_string_remove_all_substrings_kitten_from_string_kitten_cat_kitten_dog_kitten_zebra_kitten_test);
    RUN_TEST(octaspire_container_utf8_string_insert_string_to_bc_into_index_1_of_ade_test);
    RUN_TEST(octaspire_container_utf8_string_insert_string_to_bc_into_index_minus_1_of_ade_test);
    RUN_TEST(octaspire_container_utf8_string_insert_string_to_bc_into_index_minus_3_of_ade_test);
    RUN_TEST(octaspire_container_utf8_string_insert_string_to_bc_into_index_minus_4_of_ade_failure_test);
    RUN_TEST(octaspire_container_utf8_string_insert_string_to_bc_into_index_3_of_ade_failure_test);
    RUN_TEST(octaspire_container_utf8_string_insert_string_to_bc_into_index_0_of_ade_test);
    RUN_TEST(octaspire_container_utf8_string_insert_string_to_bc_into_index_2_of_ade_test);

    RUN_TEST(octaspire_container_utf8_string_overwrite_with_string_at_first_test);
    RUN_TEST(octaspire_container_utf8_string_overwrite_with_string_at_second_test);

    RUN_TEST(octaspire_container_utf8_string_pop_back_ucs_character_test);

    RUN_TEST(octaspire_container_utf8_string_compare_with_two_empty_strings_test);
    RUN_TEST(octaspire_container_utf8_string_compare_with_abc_and_empty_string_test);
    RUN_TEST(octaspire_container_utf8_string_compare_with_empty_string_and_abc_test);
    RUN_TEST(octaspire_container_utf8_string_compare_with_string_abc_and_abc_test);
    RUN_TEST(octaspire_container_utf8_string_compare_with_string_abd_and_abc_test);
    RUN_TEST(octaspire_container_utf8_string_compare_with_string_abca_and_abc_test);
    RUN_TEST(octaspire_container_utf8_string_compare_with_string_abb_and_abc_test);
    RUN_TEST(octaspire_container_utf8_string_compare_with_string_abc_and_abca_test);

    octaspire_memory_allocator_release(octaspireContainerUtf8StringTestAllocator);
    octaspireContainerUtf8StringTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_container_utf8_string.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_container_pair.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_memory_allocator_t *octaspireContainerPairTestAllocator = 0;

TEST octaspire_container_pair_new_short_and_long_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    ASSERT(p->first);
    ASSERT(p->second);

    ASSERT_EQ(0, *(short const*)p->first);
    ASSERT_EQ(0, *(long const*)p->second);

    ASSERT_EQ(sizeof(short), p->firstSize);
    ASSERT_EQ(sizeof(long),  p->secondSize);
    ASSERT_EQ(0,             p->firstReleaseCallback);
    ASSERT_EQ(0,             p->secondReleaseCallback);
    ASSERT_EQ(octaspireContainerPairTestAllocator,     p->allocator);

    short const expectedFirst  = 11;
    long  const expectedSecond = 12;
    octaspire_container_pair_set(p, &expectedFirst, &expectedSecond);

    ASSERT_EQ(expectedFirst,  *(short const *)p->first);
    ASSERT_EQ(expectedSecond, *(long const *) p->second);

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_new_long_and_short_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    ASSERT(p->first);
    ASSERT(p->second);

    ASSERT_EQ(0, *(long const*)p->first);
    ASSERT_EQ(0, *(short const*)p->second);

    ASSERT_EQ(sizeof(long), p->firstSize);
    ASSERT_EQ(sizeof(short),  p->secondSize);
    ASSERT_EQ(0,             p->firstReleaseCallback);
    ASSERT_EQ(0,             p->secondReleaseCallback);
    ASSERT_EQ(octaspireContainerPairTestAllocator,     p->allocator);

    long  const expectedFirst  = 11;
    short const expectedSecond = 12;
    octaspire_container_pair_set(p, &expectedFirst, &expectedSecond);

    ASSERT_EQ(expectedFirst,  *(long const*) p->first);
    ASSERT_EQ(expectedSecond, *(short const*)p->second);

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_new_uint32_t_and_double_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(uint32_t),
        false,
        sizeof(double),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    ASSERT(p->first);
    ASSERT(p->second);

    ASSERT_IN_RANGE(0, *(uint32_t*)p->first, 0.000001);
    ASSERT_IN_RANGE(0, *(double*)p->second,  0.000001);

    ASSERT_EQ(sizeof(uint32_t), p->firstSize);
    ASSERT_EQ(sizeof(double),   p->secondSize);
    ASSERT_EQ(0,                p->firstReleaseCallback);
    ASSERT_EQ(0,                p->secondReleaseCallback);
    ASSERT_EQ(octaspireContainerPairTestAllocator,        p->allocator);

    uint32_t  const expectedFirst  = 11;
    double    const expectedSecond = 12.12;
    octaspire_container_pair_set(p, &expectedFirst, &expectedSecond);

    ASSERT_EQ(expectedFirst,  *(uint32_t const*)p->first);
    ASSERT_IN_RANGE(expectedSecond, *(double const*)p->second, 0.000001);

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_new_allocation_failure_on_first_allocation_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerPairTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerPairTestAllocator));

    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerPairTestAllocator, 0, 0x00);

    ASSERT_FALSE(p);

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_new_allocation_failure_on_second_allocation_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerPairTestAllocator,
        2,
        0x01);

    ASSERT_EQ(
        2,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerPairTestAllocator));

    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerPairTestAllocator, 0, 0x00);

    ASSERT_FALSE(p);

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_new_allocation_failure_on_third_allocation_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerPairTestAllocator,
        3,
        0x03);

    ASSERT_EQ(
        3,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerPairTestAllocator));

    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerPairTestAllocator, 0, 0x00);

    ASSERT_FALSE(p);

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_new_shallow_copy_uint32_t_and_double_test(void)
{
    octaspire_container_pair_t *expected = octaspire_container_pair_new(
        sizeof(uint32_t),
        false,
        sizeof(double),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(expected);

    uint32_t  const expectedFirst  = 11;
    double    const expectedSecond = 12.12;
    octaspire_container_pair_set(expected, &expectedFirst, &expectedSecond);

    octaspire_container_pair_t *p = octaspire_container_pair_new_shallow_copy(
        expected,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    ASSERT(p->first);
    ASSERT(p->second);

    ASSERT_EQ(*(uint32_t const*)expected->first,  *(uint32_t const*)p->first);
    ASSERT_IN_RANGE(*(double const*)expected->second, *(double const*)p->second, 0.000001);

    ASSERT_EQ(sizeof(uint32_t), p->firstSize);
    ASSERT_EQ(sizeof(double),   p->secondSize);
    ASSERT_EQ(0,                p->firstReleaseCallback);
    ASSERT_EQ(0,                p->secondReleaseCallback);
    ASSERT_EQ(octaspireContainerPairTestAllocator,        p->allocator);

    octaspire_container_pair_release(p);
    p = 0;

    octaspire_container_pair_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_container_pair_new_shallow_copy_failure_on_first_allocation_test(void)
{
    octaspire_container_pair_t *expected = octaspire_container_pair_new(
        sizeof(uint32_t),
        false,
        sizeof(double),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(expected);

    uint32_t  const expectedFirst  = 11;
    double    const expectedSecond = 12.12;
    octaspire_container_pair_set(expected, &expectedFirst, &expectedSecond);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerPairTestAllocator,
        1,
        0);

    ASSERT_EQ(
        1,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerPairTestAllocator));

    octaspire_container_pair_t *p = octaspire_container_pair_new_shallow_copy(
        expected,
        octaspireContainerPairTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerPairTestAllocator, 0, 0x00);

    ASSERT_FALSE(p);

    octaspire_container_pair_release(p);
    p = 0;

    octaspire_container_pair_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_container_pair_new_shallow_copy_failure_on_second_allocation_test(void)
{
    octaspire_container_pair_t *expected = octaspire_container_pair_new(
        sizeof(uint32_t),
        false,
        sizeof(double),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(expected);

    uint32_t  const expectedFirst  = 11;
    double    const expectedSecond = 12.12;
    octaspire_container_pair_set(expected, &expectedFirst, &expectedSecond);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerPairTestAllocator,
        2,
        0x1);

    ASSERT_EQ(
        2,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerPairTestAllocator));

    octaspire_container_pair_t *p = octaspire_container_pair_new_shallow_copy(
        expected,
        octaspireContainerPairTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerPairTestAllocator, 0, 0x00);

    ASSERT_FALSE(p);

    octaspire_container_pair_release(p);
    p = 0;

    octaspire_container_pair_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_container_pair_new_shallow_copy_failure_on_third_allocation_test(void)
{
    octaspire_container_pair_t *expected = octaspire_container_pair_new(
        sizeof(uint32_t),
        false,
        sizeof(double),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(expected);

    uint32_t  const expectedFirst  = 11;
    double    const expectedSecond = 12.12;
    octaspire_container_pair_set(expected, &expectedFirst, &expectedSecond);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(
        octaspireContainerPairTestAllocator,
        3,
        0x3);

    ASSERT_EQ(
        3,
        octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(
            octaspireContainerPairTestAllocator));

    octaspire_container_pair_t *p = octaspire_container_pair_new_shallow_copy(
        expected,
        octaspireContainerPairTestAllocator);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerPairTestAllocator, 0, 0x00);

    ASSERT_FALSE(p);

    octaspire_container_pair_release(p);
    p = 0;

    octaspire_container_pair_release(expected);
    expected = 0;

    PASS();
}

static size_t octaspire_container_pair_release_test_private_release_callback_for_first_callcount = 0;

static void octaspire_container_pair_release_test_private_release_callback_for_first(void *element)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(element);
    ++octaspire_container_pair_release_test_private_release_callback_for_first_callcount;
}

static size_t octaspire_container_pair_release_test_private_release_callback_for_second_callcount = 0;

static void octaspire_container_pair_release_test_private_release_callback_for_second(void *element)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(element);
    ++octaspire_container_pair_release_test_private_release_callback_for_second_callcount;
}

TEST octaspire_container_pair_release_test(void)
{
    octaspire_container_pair_release_test_private_release_callback_for_first_callcount  = 0;
    octaspire_container_pair_release_test_private_release_callback_for_second_callcount = 0;

    octaspire_container_utf8_string_t *second = octaspire_container_utf8_string_new(
        "second element of the pair in octaspire_container_pair_release_test",
        octaspireContainerPairTestAllocator);

    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(size_t),
        false,
        sizeof(octaspire_container_utf8_string_t*),
        true,
        octaspire_container_pair_release_test_private_release_callback_for_first,
        octaspire_container_pair_release_test_private_release_callback_for_second,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    size_t const first  = 11;
    octaspire_container_pair_set(p, &first, &second);

    ASSERT_EQ(first,  *(size_t const *)p->first);
    ASSERT_EQ(second, *(octaspire_container_utf8_string_t **)p->second);

    octaspire_container_pair_release(p);
    p = 0;

    octaspire_container_utf8_string_release(second);
    second = 0;

    ASSERT_EQ(1, octaspire_container_pair_release_test_private_release_callback_for_first_callcount);
    ASSERT_EQ(1, octaspire_container_pair_release_test_private_release_callback_for_second_callcount);

    PASS();
}

TEST octaspire_container_pair_get_first_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    long  const expectedFirst = -11;
    short const second        =  12;
    octaspire_container_pair_set(p, &expectedFirst, &second);

    ASSERT_EQ(expectedFirst, *(long const*)octaspire_container_pair_get_first(p));

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_get_first_const_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    long  const expectedFirst = -11;
    short const second        =  12;
    octaspire_container_pair_set(p, &expectedFirst, &second);

    ASSERT_EQ(expectedFirst, *(long const*)octaspire_container_pair_get_first_const(p));

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_get_second_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    long  const first           =  11;
    short const expectedSecond  = -12;
    octaspire_container_pair_set(p, &first, &expectedSecond);

    ASSERT_EQ(expectedSecond, *(short const*)octaspire_container_pair_get_second(p));

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_get_second_const_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    long  const first           =  11;
    short const expectedSecond  = -12;
    octaspire_container_pair_set(p, &first, &expectedSecond);

    ASSERT_EQ(expectedSecond, *(short const*)octaspire_container_pair_get_second_const(p));

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_get_size_of_first_element_in_octets_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    ASSERT_EQ(sizeof(long), octaspire_container_pair_get_size_of_first_element_in_octets(p));

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_get_size_of_second_element_in_octets_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(long),
        false,
        sizeof(short),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    ASSERT_EQ(sizeof(short), octaspire_container_pair_get_size_of_second_element_in_octets(p));

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_set_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    short const expectedFirst  = 11;
    long  const expectedSecond = 12;
    octaspire_container_pair_set(p, &expectedFirst, &expectedSecond);

    ASSERT_EQ(expectedFirst,  *(short const *)p->first);
    ASSERT_EQ(expectedSecond, *(long const *) p->second);

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_set_first_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    short const expectedFirst  = 11;
    long  const expectedSecond = 0;
    octaspire_container_pair_set_first(p, &expectedFirst);

    ASSERT_EQ(expectedFirst,  *(short const *)p->first);
    ASSERT_EQ(expectedSecond, *(long const *) p->second);

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_set_second_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    short const expectedFirst  = 0;
    long  const expectedSecond = 11;
    octaspire_container_pair_set_second(p, &expectedSecond);

    ASSERT_EQ(expectedFirst,  *(short const *)p->first);
    ASSERT_EQ(expectedSecond, *(long const *) p->second);

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_set_first_to_void_pointer_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(void*),
        true,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    void *expectedFirst = p;
    long  const expectedSecond = 0;
    ASSERT(octaspire_container_pair_set_first_to_void_pointer(p, expectedFirst));

    ASSERT_EQ(expectedFirst,  *(void **)p->first);
    ASSERT_EQ(expectedSecond, *(long const *)p->second);

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_set_first_to_void_pointer_failure_on_element_size_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(char),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    void *ptr = 0;
    ASSERT_FALSE(octaspire_container_pair_set_first_to_void_pointer(p, ptr));

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_set_second_to_void_pointer_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(long),
        false,
        sizeof(void*),
        true,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    void *expectedSecond = p;
    long  const expectedFirst = 0;
    ASSERT(octaspire_container_pair_set_second_to_void_pointer(p, expectedSecond));

    ASSERT_EQ(expectedFirst,  *(long const *)p->first);
    ASSERT_EQ(expectedSecond, *(void const **)p->second);

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_set_second_to_void_pointer_failure_on_element_size_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(long),
        false,
        sizeof(char),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    void *ptr = 0;
    ASSERT_FALSE(octaspire_container_pair_set_second_to_void_pointer(p, ptr));

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

TEST octaspire_container_pair_clear_test(void)
{
    octaspire_container_pair_t *p = octaspire_container_pair_new(
        sizeof(short),
        false,
        sizeof(long),
        false,
        0,
        0,
        octaspireContainerPairTestAllocator);

    ASSERT(p);

    short const expectedFirst  = 11;
    long  const expectedSecond = 12;
    octaspire_container_pair_set(p, &expectedFirst, &expectedSecond);

    ASSERT_EQ(11, *(short const*)p->first);
    ASSERT_EQ(12, *(long const*)p->second);

    octaspire_container_pair_clear(p);

    ASSERT_EQ(0, *(short const*)p->first);
    ASSERT_EQ(0, *(long const*)p->second);

    octaspire_container_pair_release(p);
    p = 0;

    PASS();
}

GREATEST_SUITE(octaspire_container_pair_suite)
{
    octaspireContainerPairTestAllocator = octaspire_memory_allocator_new(0);
    assert(octaspireContainerPairTestAllocator);

    RUN_TEST(octaspire_container_pair_new_short_and_long_test);
    RUN_TEST(octaspire_container_pair_new_long_and_short_test);
    RUN_TEST(octaspire_container_pair_new_uint32_t_and_double_test);
    RUN_TEST(octaspire_container_pair_new_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_container_pair_new_allocation_failure_on_second_allocation_test);
    RUN_TEST(octaspire_container_pair_new_allocation_failure_on_third_allocation_test);
    RUN_TEST(octaspire_container_pair_new_shallow_copy_uint32_t_and_double_test);
    RUN_TEST(octaspire_container_pair_new_shallow_copy_failure_on_first_allocation_test);
    RUN_TEST(octaspire_container_pair_new_shallow_copy_failure_on_second_allocation_test);
    RUN_TEST(octaspire_container_pair_new_shallow_copy_failure_on_third_allocation_test);
    RUN_TEST(octaspire_container_pair_release_test);
    RUN_TEST(octaspire_container_pair_get_first_test);
    RUN_TEST(octaspire_container_pair_get_first_const_test);
    RUN_TEST(octaspire_container_pair_get_second_test);
    RUN_TEST(octaspire_container_pair_get_second_const_test);
    RUN_TEST(octaspire_container_pair_get_size_of_first_element_in_octets_test);
    RUN_TEST(octaspire_container_pair_get_size_of_second_element_in_octets_test);
    RUN_TEST(octaspire_container_pair_set_test);
    RUN_TEST(octaspire_container_pair_set_first_test);
    RUN_TEST(octaspire_container_pair_set_second_test);
    RUN_TEST(octaspire_container_pair_set_first_to_void_pointer_test);
    RUN_TEST(octaspire_container_pair_set_first_to_void_pointer_failure_on_element_size_test);
    RUN_TEST(octaspire_container_pair_set_second_to_void_pointer_test);
    RUN_TEST(octaspire_container_pair_set_second_to_void_pointer_failure_on_element_size_test);
    RUN_TEST(octaspire_container_pair_clear_test);

    octaspire_memory_allocator_release(octaspireContainerPairTestAllocator);
    octaspireContainerPairTestAllocator = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_container_pair.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_container_hash_map.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Core - Containers and other utility libraries in standard C99
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_memory_allocator_t *octaspireContainerHashMapTestAllocator = 0;



TEST octaspire_container_hash_map_element_new_allocation_failure_on_first_allocation_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator));

    size_t const value = 0;
    octaspire_container_hash_map_element_t *element = octaspire_container_hash_map_element_new(
        0,
        sizeof(value),
        false,
        &value,
        sizeof(value),
        false,
        &value,
        octaspireContainerHashMapTestAllocator);

    ASSERT_FALSE(element);
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 0, 0x00);

    octaspire_container_hash_map_element_release(element);
    element = 0;

    PASS();
}

TEST octaspire_container_hash_map_element_new_allocation_failure_on_second_allocation_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator));

    size_t const value = 0;
    octaspire_container_hash_map_element_t *element = octaspire_container_hash_map_element_new(
        0,
        sizeof(value),
        false,
        &value,
        sizeof(value),
        false,
        &value,
        octaspireContainerHashMapTestAllocator);

    ASSERT_FALSE(element);
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 0, 0x00);

    octaspire_container_hash_map_element_release(element);
    element = 0;

    PASS();
}

TEST octaspire_container_hash_map_element_new_allocation_failure_on_third_allocation_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 3, 0x03);
    ASSERT_EQ(3, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator));

    size_t const value = 0;
    octaspire_container_hash_map_element_t *element = octaspire_container_hash_map_element_new(
        0,
        sizeof(value),
        false,
        &value,
        sizeof(value),
        false,
        &value,
        octaspireContainerHashMapTestAllocator);

    ASSERT_FALSE(element);
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 0, 0x00);

    octaspire_container_hash_map_element_release(element);
    element = 0;

    PASS();
}

static bool octaspire_container_hash_map_new_test_key_compare_function_for_size_t_keys(
    void const * const key1,
    void const * const key2);

static uint32_t octaspire_container_hash_map_new_test_key_hash_function_for_size_t_keys(
    void const * const key);

static bool octaspire_container_hash_map_new_test_key_compare_function_for_size_t_keys(
    void const * const key1,
    void const * const key2)
{
    return *(size_t const * const)key1 == *(size_t const * const)key2;
}

static uint32_t octaspire_container_hash_map_new_test_key_hash_function_for_size_t_keys(
    void const * const key)
{
    size_t const value = *(size_t const * const)key;
    return (uint32_t)value;
}

TEST octaspire_container_hash_map_private_rehash_allocation_failure_on_first_allocation_test(void)
{
    octaspire_container_hash_map_t *hashMap = octaspire_container_hash_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_container_hash_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_container_hash_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT(hashMap);

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 1, 0x00);
    ASSERT_EQ(1, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator));

    ASSERT_FALSE(octaspire_container_hash_map_private_rehash(hashMap));
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 0, 0x00);

    octaspire_container_hash_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_container_hash_map_new_keys_uint32_t_and_values_size_t_test(void)
{
    octaspire_container_hash_map_t *hashMap = octaspire_container_hash_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_container_hash_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_container_hash_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT(hashMap);

    size_t const numElements = 128;

    for (size_t i = 0; i < numElements; ++i)
    {
        uint32_t hash = (uint32_t)i;

        octaspire_container_hash_map_put(hashMap, hash, &i, &i);
    }

    ASSERT_EQ(numElements, octaspire_container_hash_map_get_number_of_elements(hashMap));

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_container_hash_map_element_t *element =
            octaspire_container_hash_map_get(hashMap, (uint32_t)i, &i);

        ASSERT_EQ(i,   octaspire_container_hash_map_element_get_hash(element));
        ASSERT_EQ(i,   *(size_t*)octaspire_container_hash_map_element_get_key(element));
        ASSERT_EQ(i,   *(size_t*)octaspire_container_hash_map_element_get_value(element));
    }

    octaspire_container_hash_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_container_hash_map_add_same_key_many_times_test(void)
{
    octaspire_container_hash_map_t *hashMap = octaspire_container_hash_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_container_hash_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_container_hash_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT(hashMap);

    size_t const key = 1024;

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT(octaspire_container_hash_map_put(
            hashMap,
            octaspire_helpers_calculate_hash_for_size_t_argument(key),
            &key,
            &i));

        octaspire_container_hash_map_element_t * const element = octaspire_container_hash_map_get(
            hashMap,
            octaspire_helpers_calculate_hash_for_size_t_argument(key),
            &key);

        ASSERT(element);

        ASSERT_EQ(key, *(size_t*)octaspire_container_hash_map_element_get_key(element));

        octaspire_container_vector_t * const values =
            octaspire_container_hash_map_element_get_values(element);

        ASSERT_EQ(i + 1,   octaspire_container_vector_get_length(values));

        for (size_t j = 0; j < octaspire_container_vector_get_length(values) ; ++j)
        {
            ASSERT_EQ(j,   *(size_t*)octaspire_container_vector_get_element_at(values, j));
        }
    }

    octaspire_container_hash_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_container_hash_map_new_allocation_failure_on_first_allocation_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator));

    octaspire_container_hash_map_t *hashMap = octaspire_container_hash_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_container_hash_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_container_hash_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT_FALSE(hashMap);
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 0, 0x00);

    octaspire_container_hash_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_container_hash_map_new_allocation_failure_on_second_allocation_test(void)
{
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator));

    octaspire_container_hash_map_t *hashMap = octaspire_container_hash_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_container_hash_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_container_hash_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT_FALSE(hashMap);
    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireContainerHashMapTestAllocator, 0, 0x00);

    octaspire_container_hash_map_release(hashMap);
    hashMap = 0;

    PASS();
}

static bool octaspire_container_hash_map_new_test_key_compare_function_for_ostring_t_keys(
    void const * const key1,
    void const * const key2);

static uint32_t octaspire_container_hash_map_new_test_key_hash_function_for_ostring_t_keys(
    void const * const key);

static bool octaspire_container_hash_map_new_test_key_compare_function_for_ostring_t_keys(
    void const * const key1,
    void const * const key2)
{
    assert(key1);
    assert(key2);

    return octaspire_container_utf8_string_is_equal(
        (octaspire_container_utf8_string_t const * const)key1,
        (octaspire_container_utf8_string_t const * const)key2);
}

static uint32_t octaspire_container_hash_map_new_test_key_hash_function_for_ostring_t_keys(
    void const * const key)
{
    assert(key);
    return octaspire_container_utf8_string_get_hash((octaspire_container_utf8_string_t const * const)key);
}

TEST octaspire_container_hash_map_new_keys_ostring_t_and_values_ostring_t_test(void)
{
    octaspire_container_hash_map_t *hashMap = octaspire_container_hash_map_new(
        sizeof(octaspire_container_utf8_string_t *),
        true,
        sizeof(octaspire_container_utf8_string_t *),
        true,
        octaspire_container_hash_map_new_test_key_compare_function_for_ostring_t_keys,
        octaspire_container_hash_map_new_test_key_hash_function_for_ostring_t_keys,
        (octaspire_container_hash_map_element_callback_function_t)octaspire_container_utf8_string_release,
        (octaspire_container_hash_map_element_callback_function_t)octaspire_container_utf8_string_release,
        octaspireContainerHashMapTestAllocator);

    size_t const numElements = 32;

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new_format(
            octaspireContainerHashMapTestAllocator,
            "%zu",
            i);

        uint32_t const hash = octaspire_container_utf8_string_get_hash(str);

        octaspire_container_utf8_string_t *cpyStr = octaspire_container_utf8_string_new_copy(str, octaspireContainerHashMapTestAllocator);
        ASSERT(octaspire_container_utf8_string_is_equal(str, cpyStr));
        octaspire_container_hash_map_put(hashMap, hash, &cpyStr, &str);

        ASSERT_EQ(i+1, octaspire_container_hash_map_get_number_of_elements(hashMap));
    }

    ASSERT_EQ(numElements, octaspire_container_hash_map_get_number_of_elements(hashMap));

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new_format(
            octaspireContainerHashMapTestAllocator,
            "%zu",
            i);

        uint32_t hash = octaspire_container_utf8_string_get_hash(str);

        octaspire_container_hash_map_element_t *element =
            octaspire_container_hash_map_get(hashMap, hash, &str);

        ASSERT(element);

        ASSERT_EQ(hash, octaspire_container_hash_map_element_get_hash(element));

        ASSERT(octaspire_container_utf8_string_is_equal(str, (octaspire_container_utf8_string_t*)octaspire_container_hash_map_element_get_key(element)));

        ASSERT(octaspire_container_utf8_string_is_equal(str, (octaspire_container_utf8_string_t*)octaspire_container_hash_map_element_get_value(element)));

        octaspire_container_utf8_string_release(str);
        str = 0;
    }

    octaspire_container_hash_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_container_hash_map_new_with_octaspire_container_utf8_string_keys_test(void)
{
    octaspire_container_hash_map_t *hashMap =
        octaspire_container_hash_map_new_with_octaspire_container_utf8_string_keys(
            sizeof(octaspire_container_utf8_string_t *),
            true,
            (octaspire_container_hash_map_element_callback_function_t)
                octaspire_container_utf8_string_release,
            octaspireContainerHashMapTestAllocator);

    size_t const numElements = 32;

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new_format(
            octaspireContainerHashMapTestAllocator,
            "%zu",
            i);

        uint32_t const hash = octaspire_container_utf8_string_get_hash(str);

        octaspire_container_utf8_string_t *cpyStr = octaspire_container_utf8_string_new_copy(str, octaspireContainerHashMapTestAllocator);
        ASSERT(octaspire_container_utf8_string_is_equal(str, cpyStr));
        octaspire_container_hash_map_put(hashMap, hash, &cpyStr, &str);

        ASSERT_EQ(i+1, octaspire_container_hash_map_get_number_of_elements(hashMap));
    }

    ASSERT_EQ(numElements, octaspire_container_hash_map_get_number_of_elements(hashMap));

    for (size_t i = 0; i < numElements; ++i)
    {
        octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new_format(
            octaspireContainerHashMapTestAllocator,
            "%zu",
            i);

        uint32_t hash = octaspire_container_utf8_string_get_hash(str);

        octaspire_container_hash_map_element_t *element =
            octaspire_container_hash_map_get(hashMap, hash, &str);

        ASSERT(element);

        ASSERT_EQ(hash, octaspire_container_hash_map_element_get_hash(element));

        ASSERT(octaspire_container_utf8_string_is_equal(str, (octaspire_container_utf8_string_t*)octaspire_container_hash_map_element_get_key(element)));

        ASSERT(octaspire_container_utf8_string_is_equal(str, (octaspire_container_utf8_string_t*)octaspire_container_hash_map_element_get_value(element)));

        octaspire_container_utf8_string_release(str);
        str = 0;
    }

    octaspire_container_hash_map_release(hashMap);
    hashMap = 0;

    PASS();
}

TEST octaspire_container_hash_map_element_iterator_test(void)
{
    octaspire_container_hash_map_t *hashMap = octaspire_container_hash_map_new(
        sizeof(size_t),
        false,
        sizeof(size_t),
        false,
        octaspire_container_hash_map_new_test_key_compare_function_for_size_t_keys,
        octaspire_container_hash_map_new_test_key_hash_function_for_size_t_keys,
        0,
        0,
        octaspireContainerHashMapTestAllocator);

    ASSERT(hashMap);

    octaspire_container_hash_map_element_iterator_t iterator =
        octaspire_container_hash_map_element_iterator_init(hashMap);

    ASSERT_EQ(hashMap, iterator.hashMap);
    ASSERT_EQ(0,       iterator.element);

    for (size_t i = 0; i < 100; ++i)
    {
        ASSERT_FALSE(octaspire_container_hash_map_element_iterator_next(&iterator));

        ASSERT_EQ(hashMap, iterator.hashMap);
        ASSERT_EQ(0,       iterator.element);
    }

    size_t const numElements = 128;

    for (size_t i = 0; i < numElements; ++i)
    {
        uint32_t hash = (uint32_t)i;

        octaspire_container_hash_map_put(hashMap, hash, &i, &i);
    }

    ASSERT_EQ(numElements, octaspire_container_hash_map_get_number_of_elements(hashMap));

    iterator =
        octaspire_container_hash_map_element_iterator_init(hashMap);

    ASSERT_EQ(hashMap, iterator.hashMap);

    size_t counter = 0;
    while (iterator.element)
    {
        ASSERT_EQ(hashMap, iterator.hashMap);
        ASSERT_EQ(counter, octaspire_container_hash_map_element_get_hash(iterator.element));
        ASSERT_EQ(counter, *(size_t*)octaspire_container_hash_map_element_get_key(iterator.element));
        ASSERT_EQ(counter, *(size_t*)octaspire_container_hash_map_element_get_value(iterator.element));

        ++counter;
        octaspire_container_hash_map_element_iterator_next(&iterator);
    }

    ASSERT_EQ(numElements, counter);

    octaspire_container_hash_map_release(hashMap);
    hashMap = 0;

    PASS();
}

GREATEST_SUITE(octaspire_container_hash_map_suite)
{
    octaspireContainerHashMapTestAllocator = octaspire_memory_allocator_new(0);

    assert(octaspireContainerHashMapTestAllocator);

    RUN_TEST(octaspire_container_hash_map_element_new_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_container_hash_map_element_new_allocation_failure_on_second_allocation_test);
    RUN_TEST(octaspire_container_hash_map_element_new_allocation_failure_on_third_allocation_test);
    RUN_TEST(octaspire_container_hash_map_private_rehash_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_container_hash_map_new_keys_uint32_t_and_values_size_t_test);
    RUN_TEST(octaspire_container_hash_map_add_same_key_many_times_test);
    RUN_TEST(octaspire_container_hash_map_new_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_container_hash_map_new_allocation_failure_on_second_allocation_test);
    RUN_TEST(octaspire_container_hash_map_new_keys_ostring_t_and_values_ostring_t_test);
    RUN_TEST(octaspire_container_hash_map_new_with_octaspire_container_utf8_string_keys_test);
    RUN_TEST(octaspire_container_hash_map_element_iterator_test);

    octaspire_memory_allocator_release(octaspireContainerHashMapTestAllocator);
    octaspireContainerHashMapTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_container_hash_map.c
//////////////////////////////////////////////////////////////////////////////////////////////////





void octaspire_core_amalgamated_write_test_file(
    char const * const name,
    char const * const buffer,
    size_t const bufferSize)
{
    FILE *stream = fopen(name, "wb");

    if (!stream)
    {
        abort();
    }

    if (!buffer || !bufferSize)
    {
        if (fclose(stream) != 0)
        {
            abort();
        }

        stream = 0;

        printf("  Wrote empty file '%s'\n", name);

        return;
    }
    else
    {
        if (fwrite(buffer, sizeof(char), bufferSize, stream) != bufferSize)
        {
            fclose(stream);
            stream = 0;
            abort();
        }
    }

    if (fclose(stream) != 0)
    {
        abort();
    }

    printf("  Wrote file '%s'\n", name);
}

GREATEST_MAIN_DEFS();

int main(int argc, char **argv)
{
    // This banner is created with figlet using font 'small'
    unsigned char octaspire_core_amalgamated_version_banner[] = {
      0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x2f, 0x20,
      0x5f, 0x20, 0x5c, 0x20, 0x5f, 0x5f, 0x7c, 0x20, 0x7c, 0x5f, 0x20, 0x5f,
      0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x5f, 0x5f, 0x20, 0x5f, 0x5f, 0x28,
      0x5f, 0x29, 0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20,
      0x2f, 0x20, 0x5f, 0x5f, 0x7c, 0x5f, 0x5f, 0x5f, 0x20, 0x5f, 0x20, 0x5f,
      0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x0a, 0x7c, 0x20, 0x28, 0x5f, 0x29, 0x20,
      0x2f, 0x20, 0x5f, 0x7c, 0x20, 0x20, 0x5f, 0x2f, 0x20, 0x5f, 0x60, 0x20,
      0x28, 0x5f, 0x2d, 0x3c, 0x20, 0x27, 0x5f, 0x20, 0x5c, 0x20, 0x7c, 0x20,
      0x27, 0x5f, 0x2f, 0x20, 0x2d, 0x5f, 0x29, 0x20, 0x7c, 0x20, 0x28, 0x5f,
      0x5f, 0x2f, 0x20, 0x5f, 0x20, 0x5c, 0x20, 0x27, 0x5f, 0x2f, 0x20, 0x2d,
      0x5f, 0x29, 0x0a, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x2f, 0x5c, 0x5f, 0x5f,
      0x7c, 0x5c, 0x5f, 0x5f, 0x5c, 0x5f, 0x5f, 0x2c, 0x5f, 0x2f, 0x5f, 0x5f,
      0x2f, 0x20, 0x2e, 0x5f, 0x5f, 0x2f, 0x5f, 0x7c, 0x5f, 0x7c, 0x20, 0x5c,
      0x5f, 0x5f, 0x5f, 0x7c, 0x20, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x5c, 0x5f,
      0x5f, 0x5f, 0x2f, 0x5f, 0x7c, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x7c, 0x0a,
      0x20, 0x20, 0x41, 0x6d, 0x61, 0x6c, 0x67, 0x61, 0x6d, 0x61, 0x74, 0x65,
      0x64, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x7c, 0x5f, 0x7c,
      0x73, 0x74, 0x61, 0x6e, 0x64, 0x2d, 0x61, 0x6c, 0x6f, 0x6e, 0x65, 0x20,
      0x75, 0x6e, 0x69, 0x74, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x72, 0x75,
      0x6e, 0x6e, 0x65, 0x72, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x0a, '\0'
    };

    printf(
        "%s  %s\n\n",
        octaspire_core_amalgamated_version_banner,
        OCTASPIRE_CORE_CONFIG_VERSION_STR);

    printf(
        "  This is stand-alone unit test runner for the amalgamated version of\n"
        "  Octaspire Core. Some of the unit tests test reading of files from\n"
        "  the filesystem. The full source distribution has these files in\n"
        "  the 'test/resource' directory. But because this amalgamated\n"
        "  distribution can have only one file, to be able to run all\n"
        "  the tests succesfully something must be done. What do you\n"
        "  want to do? Select 'a', 'b', 'c' or any other key:\n"
        "\n"
        "  a) Let this program to write those files to disk to the current working\n"
        "     directory. All existing files with the same name will be OVERWRITTEN.\n"
        "     The files to be written are of form 'octaspire_XYZ_test', where XYZ\n"
        "     is the name of the test.\n"
        "\n"
        "  b) Let those tests to fail on missing files, or succeed if the files are\n"
        "     already present in the current working directory.\n"
        "\n"
        "  c) Abort and quit this program.\n"
        "\n"
        "  > ");

    int const c = getchar();

    switch (c)
    {
        case 'a':
        {
            printf("Writing test files to current working directory...\n");

            octaspire_core_amalgamated_write_test_file(
                "octaspire_helpers_path_to_buffer_failure_on_empty_file_test", 0, 0);



            char const octaspire_helpers_path_to_buffer_test[] = {
                0xc2, 0xa9, 0xe2, 0x89, 0xa0, 0xf0, 0x90, 0x80, 0x80
            };
            size_t const octaspire_helpers_path_to_buffer_test_len = 9;

            octaspire_core_amalgamated_write_test_file(
                "octaspire_helpers_path_to_buffer_test",
                octaspire_helpers_path_to_buffer_test,
                octaspire_helpers_path_to_buffer_test_len);


            char const octaspire_input_new_from_path_test[] = {
              0x61, 0x62, 0x63, 0xc2, 0xa9, 0xe2, 0x89, 0xa0, 0xf0, 0x90, 0x80, 0x80
            };
            size_t const octaspire_input_new_from_path_test_len = 12;

            octaspire_core_amalgamated_write_test_file(
                "octaspire_input_new_from_path_test",
                octaspire_input_new_from_path_test,
                octaspire_input_new_from_path_test_len);



            char const octaspire_stdio_fread_test[] = {
              0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x71, 0x77,
              0x65, 0x72, 0x74, 0x79, 0x75, 0x69, 0x6f, 0x70, 0x0a
            };
            size_t const octaspire_stdio_fread_test_len = 21;

            octaspire_core_amalgamated_write_test_file(
                "octaspire_stdio_fread_test",
                octaspire_stdio_fread_test,
                octaspire_stdio_fread_test_len);




            printf("Done.\n");
        }
        break;

        case 'b':
        {
            printf("Tests reading files will fail, if the required files are not available.\n");
        }
        break;

        case 'c':
        default:
        {
            printf("Going to quit now, as requested\n");
            return EXIT_FAILURE;
        }
        break;
    }

    GREATEST_MAIN_BEGIN();
    RUN_SUITE(octaspire_helpers_suite);
    RUN_SUITE(octaspire_utf8_suite);
    RUN_SUITE(octaspire_memory_suite);
    RUN_SUITE(octaspire_stdio_suite);
    RUN_SUITE(octaspire_input_suite);
    RUN_SUITE(octaspire_container_vector_suite);
    RUN_SUITE(octaspire_container_list_suite);
    RUN_SUITE(octaspire_container_queue_suite);
    RUN_SUITE(octaspire_container_utf8_string_suite);
    RUN_SUITE(octaspire_container_pair_suite);
    RUN_SUITE(octaspire_container_hash_map_suite);
    GREATEST_MAIN_END();
}


#endif // OCTASPIRE_CORE_AMALGAMATED_UNIT_TEST_IMPLEMENTATION

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../external/octaspire_core/etc/octaspire_core_amalgamated.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../build/include/octaspire/dern/octaspire_dern_config.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_CONFIG_H
#define OCTASPIRE_DERN_CONFIG_H

#define OCTASPIRE_DERN_CONFIG_VERSION_MAJOR "0"
#define OCTASPIRE_DERN_CONFIG_VERSION_MINOR "191"
#define OCTASPIRE_DERN_CONFIG_VERSION_PATCH "0"

#define OCTASPIRE_DERN_CONFIG_VERSION_STR   "Octaspire Dern version 0.191.0"



#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../build/include/octaspire/dern/octaspire_dern_config.h
//////////////////////////////////////////////////////////////////////////////////////////////////




#define OCTASPIRE_DERN_CONFIG_TEST_RES_PATH ""

//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/dern/octaspire_dern_lexer.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_LEXER_H
#define OCTASPIRE_DERN_LEXER_H


#ifdef __cplusplus
extern "C" {
#endif

typedef enum
{
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED,
    OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT
}
octaspire_dern_lexer_token_tag_t;

typedef struct octaspire_dern_lexer_token_t octaspire_dern_lexer_token_t;

typedef struct octaspire_dern_lexer_token_position_t
{
    size_t start;
    size_t end;
}
octaspire_dern_lexer_token_position_t;

octaspire_dern_lexer_token_position_t octaspire_dern_lexer_token_position_init(
    size_t const start, size_t const end);

bool octaspire_dern_lexer_token_position_is_equal(
    octaspire_dern_lexer_token_position_t const * const self,
    octaspire_dern_lexer_token_position_t const * const other);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_token_new(
    octaspire_dern_lexer_token_tag_t const typeTag,
    void const * const value,
    octaspire_dern_lexer_token_position_t const line,
    octaspire_dern_lexer_token_position_t const column,
    octaspire_dern_lexer_token_position_t const ucsIndex,
    octaspire_memory_allocator_t *allocator);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_token_new_format(
    octaspire_dern_lexer_token_tag_t const typeTag,
    octaspire_dern_lexer_token_position_t const line,
    octaspire_dern_lexer_token_position_t const column,
    octaspire_dern_lexer_token_position_t const ucsIndex,
    octaspire_memory_allocator_t *allocator,
    void const * const format,
    ...);

void octaspire_dern_lexer_token_release(
    octaspire_dern_lexer_token_t *self);

octaspire_dern_lexer_token_tag_t octaspire_dern_lexer_token_get_type_tag(
    octaspire_dern_lexer_token_t const * const self);

char const *octaspire_dern_lexer_token_get_type_tag_as_c_string(
    octaspire_dern_lexer_token_t const * const self);

int32_t octaspire_dern_lexer_token_get_integer_value(
    octaspire_dern_lexer_token_t const * const self);

double octaspire_dern_lexer_token_get_real_value(
    octaspire_dern_lexer_token_t const * const self);

char const *octaspire_dern_lexer_token_get_string_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self);

char const *octaspire_dern_lexer_token_get_character_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self);

char const *octaspire_dern_lexer_token_get_symbol_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self);

char const *octaspire_dern_lexer_token_get_error_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self);

char const *octaspire_dern_lexer_token_get_multiline_comment_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self);







octaspire_dern_lexer_token_position_t *octaspire_dern_lexer_token_get_position_line(
    octaspire_dern_lexer_token_t const * const self);

octaspire_dern_lexer_token_position_t *octaspire_dern_lexer_token_get_position_column(
    octaspire_dern_lexer_token_t const * const self);

octaspire_dern_lexer_token_position_t *octaspire_dern_lexer_token_get_position_ucs_index(
    octaspire_dern_lexer_token_t const * const self);




bool octaspire_dern_lexer_token_is_equal(
    octaspire_dern_lexer_token_t const * const self,
    octaspire_dern_lexer_token_t const * const other);


octaspire_container_utf8_string_t *octaspire_dern_lexer_token_to_string(
    octaspire_dern_lexer_token_t const * const self);

void octaspire_dern_lexer_token_print(
    octaspire_dern_lexer_token_t const * const self);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_pop_next_token(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/dern/octaspire_dern_lexer.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/dern/octaspire_dern_c_data.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_C_DATA_H
#define OCTASPIRE_DERN_C_DATA_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct octaspire_dern_c_data_t octaspire_dern_c_data_t;

struct octaspire_dern_lib_t;

octaspire_dern_c_data_t *octaspire_dern_c_data_new(
    char const * const pluginName,
    struct octaspire_dern_lib_t * const library,
    char const * const typeNameForPayload,
    void * const payload,
    char const * const cleanUpCallbackName,
    char const * const stdLibLenCallbackName,
    char const * const stdLibNthCallbackName,
    bool const copyingAllowed,
    octaspire_memory_allocator_t *allocator);

octaspire_dern_c_data_t *octaspire_dern_c_data_new_copy(
    octaspire_dern_c_data_t * const other,
    octaspire_memory_allocator_t *allocator);

void octaspire_dern_c_data_release(octaspire_dern_c_data_t *self);

octaspire_container_utf8_string_t *octaspire_dern_c_data_to_string(
    octaspire_dern_c_data_t const * const self,
    octaspire_memory_allocator_t * const allocator);

bool octaspire_dern_c_data_is_equal(
    octaspire_dern_c_data_t const * const self,
    octaspire_dern_c_data_t const * const other);

int octaspire_dern_c_data_compare(
    octaspire_dern_c_data_t const * const self,
    octaspire_dern_c_data_t const * const other);

bool octaspire_dern_c_data_is_plugin_and_payload_type_name(
    octaspire_dern_c_data_t const * const self,
    char const * const pluginName,
    char const * const typeNameForPayload);

char const *octaspire_dern_c_data_get_plugin_name(
    octaspire_dern_c_data_t const * const self);

char const *octaspire_dern_c_data_get_payload_typename(
    octaspire_dern_c_data_t const * const self);

void *octaspire_dern_c_data_get_payload(
    octaspire_dern_c_data_t const * const self);

bool octaspire_dern_c_data_is_copying_allowed(
    octaspire_dern_c_data_t const * const self);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/dern/octaspire_dern_c_data.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/dern/octaspire_dern_port.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_PORT_H
#define OCTASPIRE_DERN_PORT_H


#ifdef __cplusplus
extern "C" {
#endif

typedef enum
{
    OCTASPIRE_DERN_PORT_TAG_NOT_OPEN,
    OCTASPIRE_DERN_PORT_TAG_INPUT_FILE,
    OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE,
    OCTASPIRE_DERN_PORT_TAG_IO_FILE
}
octaspire_dern_port_tag_t;

typedef struct octaspire_dern_port_t octaspire_dern_port_t;

octaspire_dern_port_t *octaspire_dern_port_new_copy(
    octaspire_dern_port_t * const other,
    octaspire_memory_allocator_t *allocator);

octaspire_dern_port_t *octaspire_dern_port_new_input_file(
    char const * const path,
    octaspire_memory_allocator_t *allocator);

octaspire_dern_port_t *octaspire_dern_port_new_output_file(
    char const * const path,
    octaspire_memory_allocator_t *allocator);

octaspire_dern_port_t *octaspire_dern_port_new_io_file(
    char const * const path,
    octaspire_memory_allocator_t *allocator);

void octaspire_dern_port_release(octaspire_dern_port_t *self);

ptrdiff_t octaspire_dern_port_write(
    octaspire_dern_port_t * const self,
    void const * const buffer,
    size_t const bufferSizeInOctets);

ptrdiff_t octaspire_dern_port_read(
    octaspire_dern_port_t * const self,
    void * const buffer,
    size_t const bufferSizeInOctets);

bool octaspire_dern_port_close(
    octaspire_dern_port_t * const self);

ptrdiff_t octaspire_dern_port_get_length_in_octets(octaspire_dern_port_t const * const self);

octaspire_container_utf8_string_t *octaspire_dern_port_to_string(
    octaspire_dern_port_t const * const self,
    octaspire_memory_allocator_t * const allocator);

bool octaspire_dern_port_seek(
    octaspire_dern_port_t * const self,
    ptrdiff_t const amount,
    bool const fromCurrentPos);

bool octaspire_dern_port_flush(octaspire_dern_port_t * const self);
ptrdiff_t octaspire_dern_port_distance(octaspire_dern_port_t const * const self);

bool octaspire_dern_port_supports_output(
    octaspire_dern_port_t const * const self);

bool octaspire_dern_port_supports_input(
    octaspire_dern_port_t const * const self);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/dern/octaspire_dern_port.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/dern/octaspire_dern_value.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_VALUE_H
#define OCTASPIRE_DERN_VALUE_H


#ifdef __cplusplus
extern "C" {
#endif

typedef enum
{
    OCTASPIRE_DERN_VALUE_TAG_ILLEGAL,
    OCTASPIRE_DERN_VALUE_TAG_NIL,
    OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,
    OCTASPIRE_DERN_VALUE_TAG_INTEGER,
    OCTASPIRE_DERN_VALUE_TAG_REAL,
    OCTASPIRE_DERN_VALUE_TAG_STRING,
    OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT,
    OCTASPIRE_DERN_VALUE_TAG_CHARACTER,
    OCTASPIRE_DERN_VALUE_TAG_SYMBOL,
    OCTASPIRE_DERN_VALUE_TAG_ERROR,
    OCTASPIRE_DERN_VALUE_TAG_VECTOR,
    OCTASPIRE_DERN_VALUE_TAG_HASH_MAP,
    OCTASPIRE_DERN_VALUE_TAG_QUEUE,
    OCTASPIRE_DERN_VALUE_TAG_LIST,
    OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT,
    OCTASPIRE_DERN_VALUE_TAG_FUNCTION,
    OCTASPIRE_DERN_VALUE_TAG_SPECIAL,
    OCTASPIRE_DERN_VALUE_TAG_BUILTIN,
    OCTASPIRE_DERN_VALUE_TAG_PORT,
    OCTASPIRE_DERN_VALUE_TAG_C_DATA
}
octaspire_dern_value_tag_t;

struct octaspire_dern_vm_t;

char const * octaspire_dern_value_helper_get_type_as_c_string(octaspire_dern_value_tag_t const typeTag);

typedef struct octaspire_dern_value_t octaspire_dern_value_t;

typedef octaspire_dern_value_t *(*octaspire_dern_c_function)(
    struct octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

typedef struct octaspire_dern_function_t
{
    struct octaspire_dern_value_t *formals;
    struct octaspire_dern_value_t *body;
    struct octaspire_dern_value_t *definitionEnvironment;
    octaspire_memory_allocator_t  *allocator;
}
octaspire_dern_function_t;

octaspire_dern_function_t *octaspire_dern_function_new(
    struct octaspire_dern_value_t *formals,
    struct octaspire_dern_value_t *body,
    struct octaspire_dern_value_t *definitionEnvironment,
    octaspire_memory_allocator_t  *allocator);

void octaspire_dern_function_release(octaspire_dern_function_t *self);

size_t octaspire_dern_function_get_number_of_required_arguments(
    octaspire_dern_function_t const * const self);

octaspire_container_utf8_string_t *octaspire_dern_function_are_all_formals_mentioned_in_docvec(
    octaspire_dern_function_t const * const self,
    octaspire_dern_value_t const * const docvec);

typedef struct octaspire_dern_special_t
{
    octaspire_dern_c_function          cFunction;
    octaspire_memory_allocator_t      *allocator;
    size_t                             numRequiredActualArguments;
}
octaspire_dern_special_t;

octaspire_dern_special_t *octaspire_dern_special_new(
    octaspire_dern_c_function const cFunction,
    octaspire_memory_allocator_t *allocator,
    size_t const numRequiredActualArguments);

void octaspire_dern_special_release(octaspire_dern_special_t *self);

size_t octaspire_dern_special_get_number_of_required_arguments(
    octaspire_dern_special_t const * const self);

typedef struct octaspire_dern_builtin_t
{
    octaspire_dern_c_function          cFunction;
    octaspire_memory_allocator_t      *allocator;
    size_t                             numRequiredActualArguments;
}
octaspire_dern_builtin_t;

octaspire_dern_builtin_t *octaspire_dern_builtin_new(
    octaspire_dern_c_function const cFunction,
    octaspire_memory_allocator_t *allocator,
    size_t const numRequiredActualArguments);

void octaspire_dern_builtin_release(octaspire_dern_builtin_t *self);

size_t octaspire_dern_builtin_get_number_of_required_arguments(
    octaspire_dern_builtin_t const * const self);

struct octaspire_dern_environment_t;

struct octaspire_dern_value_t
{
    bool                         mark;
    octaspire_dern_value_tag_t   typeTag;
    octaspire_dern_value_t      *docstr;
    octaspire_dern_value_t      *docvec;
    struct octaspire_dern_vm_t  *vm;
    uintmax_t                    uniqueId;

    union
    {
        bool                                boolean;
        int32_t                             integer;
        double                              real;
        octaspire_container_utf8_string_t   *string;
        octaspire_container_utf8_string_t   *comment;
        octaspire_container_utf8_string_t   *character;
        octaspire_container_utf8_string_t   *symbol;
        octaspire_container_utf8_string_t   *error;
        octaspire_container_vector_t        *vector;
        octaspire_container_hash_map_t      *hashMap;
        octaspire_container_queue_t         *queue;
        octaspire_container_list_t          *list;
        struct octaspire_dern_environment_t *environment;
        octaspire_dern_function_t           *function;
        octaspire_dern_special_t            *special;
        octaspire_dern_builtin_t            *builtin;
        octaspire_dern_port_t               *port;
        octaspire_dern_c_data_t             *cData;
    }
    value;
};

bool octaspire_dern_value_set(
    octaspire_dern_value_t  * const self,
    octaspire_dern_value_t  * const value);

bool octaspire_dern_value_set_collection(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t const * const indexOrKey,
    octaspire_dern_value_t * const value);

uint32_t octaspire_dern_value_get_hash(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_equal(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other);

bool octaspire_dern_value_is_less_than(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other);

bool octaspire_dern_value_is_greater_than(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other);

bool octaspire_dern_value_is_less_than_or_equal(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other);

bool octaspire_dern_value_is_greater_than_or_equal(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other);

octaspire_container_utf8_string_t *octaspire_dern_value_to_string(
    octaspire_dern_value_t const * const self,
    octaspire_memory_allocator_t * const allocator);

octaspire_container_utf8_string_t *octaspire_dern_value_to_string_plain(
    octaspire_dern_value_t const * const self,
    octaspire_memory_allocator_t * const allocator);

bool octaspire_dern_value_is_integer(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_real(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_number(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_nil(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_boolean(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_character(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_string(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_symbol(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_text(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_vector(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_hash_map(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_queue(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_list(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_port(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_environment(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_function(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_is_c_data(
    octaspire_dern_value_t const * const self);

void octaspire_dern_value_print(
    octaspire_dern_value_t const * const self,
    octaspire_memory_allocator_t *allocator);

uintmax_t octaspire_dern_value_get_unique_id(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_as_boolean_get_value(
    octaspire_dern_value_t const * const self);

int32_t octaspire_dern_value_as_integer_get_value(
    octaspire_dern_value_t const * const self);

double octaspire_dern_value_as_real_get_value(
    octaspire_dern_value_t const * const self);

double octaspire_dern_value_as_number_get_value(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_as_hash_map_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const toBeAdded1,
    octaspire_dern_value_t * const toBeAdded2);

bool octaspire_dern_value_as_hash_map_remove(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const keyValue);

bool octaspire_dern_value_as_queue_push(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const toBeAdded);

bool octaspire_dern_value_as_queue_pop(octaspire_dern_value_t * const self);

bool octaspire_dern_value_as_list_push_back(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const toBeAdded);

bool octaspire_dern_value_as_list_pop_back(octaspire_dern_value_t * const self);

bool octaspire_dern_value_as_character_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other);

bool octaspire_dern_value_as_character_subtract(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other);

bool octaspire_dern_value_as_integer_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other);

bool octaspire_dern_value_as_integer_subtract(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other);

bool octaspire_dern_value_as_real_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other);

bool octaspire_dern_value_as_real_subtract(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other);

char const *octaspire_dern_value_as_character_get_c_string(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_as_string_push_back(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const value);

bool octaspire_dern_value_as_symbol_push_back(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const value);

bool octaspire_dern_value_as_string_pop_back_ucs_character(
    octaspire_dern_value_t * const self);

bool octaspire_dern_value_as_string_remove_all_substrings(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const value);

char const *octaspire_dern_value_as_string_get_c_string(
    octaspire_dern_value_t const * const self);

char const *octaspire_dern_value_as_symbol_get_c_string(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_as_symbol_is_equal_to_c_string(
    octaspire_dern_value_t const * const self,
    char const * const str);

char const *octaspire_dern_value_as_text_get_c_string(
    octaspire_dern_value_t const * const self);

size_t octaspire_dern_value_as_text_get_length_in_octets(
    octaspire_dern_value_t const * const self);

size_t octaspire_dern_value_as_vector_get_length(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_as_vector_is_valid_index(
    octaspire_dern_value_t const * const self,
    ptrdiff_t const index);

bool octaspire_dern_value_as_vector_push_front_element(
    octaspire_dern_value_t *self,
    void const *element);

bool octaspire_dern_value_as_vector_push_back_element(
    octaspire_dern_value_t *self,
    void const *element);

bool octaspire_dern_value_as_vector_remove_element_at(
    octaspire_dern_value_t *self,
    size_t const index);

bool octaspire_dern_value_as_vector_pop_back_element(octaspire_dern_value_t *self);

octaspire_dern_value_t *octaspire_dern_value_as_vector_get_element_at(
    octaspire_dern_value_t * const self,
    size_t const index);

octaspire_dern_value_t const *octaspire_dern_value_as_vector_get_element_at_const(
    octaspire_dern_value_t const * const self,
    size_t const index);

octaspire_dern_value_t *octaspire_dern_value_as_vector_get_element_of_type_at(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_tag_t const typeTag,
    size_t const index);

octaspire_dern_value_t const *octaspire_dern_value_as_vector_get_element_of_type_at_const(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_tag_t const typeTag,
    size_t const index);

// TODO how about as_vector, should it have void* replaced with octaspire_dern_value_t*?
bool octaspire_dern_value_as_hash_map_put(
    octaspire_dern_value_t *self,
    uint32_t const hash,
    octaspire_dern_value_t const * const key,
    octaspire_dern_value_t *value);

size_t octaspire_dern_value_as_hash_map_get_number_of_elements(
    octaspire_dern_value_t const * const self);

octaspire_container_hash_map_element_t *octaspire_dern_value_as_hash_map_get_at_index(
    octaspire_dern_value_t * const self,
    size_t const index);

octaspire_container_hash_map_element_t *octaspire_dern_value_as_hash_map_get(
    octaspire_dern_value_t * const self,
    uint32_t const hash,
    octaspire_dern_value_t const * const key);

octaspire_container_hash_map_element_t const *octaspire_dern_value_as_hash_map_get_const(
    octaspire_dern_value_t const * const self,
    uint32_t const hash,
    octaspire_dern_value_t const * const key);

octaspire_dern_value_t *octaspire_dern_value_as_hash_map_get_value_for_symbol_key_using_c_string(
    octaspire_dern_value_t * const self,
    char const * const keySymbolsContentAsCString);

octaspire_dern_value_t const *octaspire_dern_value_as_hash_map_get_value_for_symbol_key_using_c_string_const(
    octaspire_dern_value_t const * const self,
    char const * const keySymbolsContentAsCString);

size_t octaspire_dern_value_get_length(
    octaspire_dern_value_t const * const self);

bool octaspire_dern_value_mark(octaspire_dern_value_t *self);

int octaspire_dern_value_compare(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other);

bool octaspire_dern_value_is_atom(octaspire_dern_value_t const * const self);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/dern/octaspire_dern_value.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/dern/octaspire_dern_environment.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_ENVIRONMENT_H
#define OCTASPIRE_DERN_ENVIRONMENT_H


#ifdef __cplusplus
extern "C" {
#endif

struct octaspire_dern_vm_t;

typedef struct octaspire_dern_environment_t
{
    octaspire_container_hash_map_t      *bindings;
    struct octaspire_dern_value_t       *enclosing;
    struct octaspire_dern_vm_t          *vm;
    octaspire_memory_allocator_t        *allocator;
}
octaspire_dern_environment_t;

struct octaspire_dern_vm_t;

octaspire_dern_environment_t *octaspire_dern_environment_new(
    octaspire_dern_value_t *enclosing,
    struct octaspire_dern_vm_t *vm,
    octaspire_memory_allocator_t *allocator);

void octaspire_dern_environment_release(octaspire_dern_environment_t *self);

// Returns 0 or error
octaspire_dern_value_t *octaspire_dern_environment_extend(
    octaspire_dern_environment_t *self,
    octaspire_dern_value_t *formals,
    octaspire_dern_value_t *arguments);

octaspire_dern_value_t *octaspire_dern_environment_get(
    octaspire_dern_environment_t *self,
    octaspire_dern_value_t const * const key);

bool octaspire_dern_environment_set(
    octaspire_dern_environment_t *self,
    octaspire_dern_value_t const * const key,
    octaspire_dern_value_t *value);

octaspire_container_utf8_string_t *octaspire_dern_environment_to_string(
    octaspire_dern_environment_t const * const self);

bool octaspire_dern_environment_print(
    octaspire_dern_environment_t const * const self);

size_t octaspire_dern_environment_get_length(
    octaspire_dern_environment_t const * const self);

octaspire_container_hash_map_element_t *octaspire_dern_environment_get_at_index(
    octaspire_dern_environment_t *self,
    size_t const index);

bool octaspire_dern_environment_mark(octaspire_dern_environment_t *self);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/dern/octaspire_dern_environment.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/dern/octaspire_dern_lib.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_LIB_H
#define OCTASPIRE_DERN_LIB_H


#ifdef __cplusplus
extern "C" {
#endif

typedef enum
{
    OCTASPIRE_DERN_LIB_TAG_SOURCE,
    OCTASPIRE_DERN_LIB_TAG_BINARY,
}
octaspire_dern_lib_tag_t;

typedef struct octaspire_dern_lib_t octaspire_dern_lib_t;
struct octaspire_dern_vm_t;

octaspire_dern_lib_t *octaspire_dern_lib_new_source(
    char const * const name,
    octaspire_input_t * const input,
    struct octaspire_dern_vm_t *vm,
    octaspire_memory_allocator_t *allocator);

octaspire_dern_lib_t *octaspire_dern_lib_new_binary(
    char const * const name,
    char const * const fileName,
    struct octaspire_dern_vm_t *vm,
    octaspire_memory_allocator_t *allocator);

void octaspire_dern_lib_release(octaspire_dern_lib_t *self);

bool octaspire_dern_lib_is_good(octaspire_dern_lib_t const * const self);

char const *octaspire_dern_lib_get_error_message(octaspire_dern_lib_t const * const self);

void *octaspire_dern_lib_get_handle(octaspire_dern_lib_t * const self);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/dern/octaspire_dern_lib.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/dern/octaspire_dern_vm.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_VM_H
#define OCTASPIRE_DERN_VM_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct octaspire_dern_vm_config_t
{
    bool fileSystemAccessAllowed;
}
octaspire_dern_vm_config_t;

octaspire_dern_vm_config_t octaspire_dern_vm_config_default(void);

typedef struct octaspire_dern_vm_t octaspire_dern_vm_t;
struct octaspire_dern_value_t;

octaspire_dern_vm_t *octaspire_dern_vm_new(
    octaspire_memory_allocator_t *allocator,
    octaspire_stdio_t *octaspireStdio);

octaspire_dern_vm_t *octaspire_dern_vm_new_with_config(
    octaspire_memory_allocator_t *allocator,
    octaspire_stdio_t *octaspireStdio,
    octaspire_dern_vm_config_t const config);

void octaspire_dern_vm_release(octaspire_dern_vm_t *self);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_copy(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *valueToBeCopied);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_input_file(
    octaspire_dern_vm_t *self,
    char const * const path);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_output_file(
    octaspire_dern_vm_t *self,
    char const * const path);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_io_file(
    octaspire_dern_vm_t *self,
    char const * const path);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_nil       (octaspire_dern_vm_t *self);
struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_boolean   (octaspire_dern_vm_t *self, bool    const value);
struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_integer   (octaspire_dern_vm_t *self, int32_t const value);
struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_real      (octaspire_dern_vm_t *self, double  const value);
struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_string    (octaspire_dern_vm_t *self, octaspire_container_utf8_string_t * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_multiline_comment    (octaspire_dern_vm_t *self, octaspire_container_utf8_string_t * const value);


octaspire_dern_value_t *octaspire_dern_vm_create_new_value_string_format(
    octaspire_dern_vm_t *self,
    char const * const fmt,
    ...);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_string_from_c_string     (octaspire_dern_vm_t *self, char const * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_character (octaspire_dern_vm_t *self, octaspire_container_utf8_string_t * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_character_from_uint32t (octaspire_dern_vm_t *self, uint32_t const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_symbol    (octaspire_dern_vm_t *self, octaspire_container_utf8_string_t * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_symbol_from_c_string    (octaspire_dern_vm_t *self, char const * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_error     (octaspire_dern_vm_t *self, octaspire_container_utf8_string_t * const value);

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_error_format(
    octaspire_dern_vm_t *self,
    char const * const fmt,
    ...);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_error_from_c_string(
    octaspire_dern_vm_t *self,
    char const * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_vector_from_vector(
    octaspire_dern_vm_t *self,
    octaspire_container_vector_t * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_vector_from_values(
    octaspire_dern_vm_t *self,
    size_t const numArgs,
    ...);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_vector      (octaspire_dern_vm_t *self);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_hash_map    (octaspire_dern_vm_t *self);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_queue       (octaspire_dern_vm_t *self);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_queue_with_max_length (
        octaspire_dern_vm_t * const self,
        size_t const maxLength);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_list        (octaspire_dern_vm_t *self);

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_hash_map_from_hash_map(octaspire_dern_vm_t *self, octaspire_container_hash_map_t * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_environment (octaspire_dern_vm_t *self, octaspire_dern_value_t *enclosing);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_environment_from_environment (octaspire_dern_vm_t *self, octaspire_dern_environment_t * const value);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_function(
    octaspire_dern_vm_t *self,
    octaspire_dern_function_t * const value,
    char const * const docstr,
    octaspire_container_vector_t *docVec);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_special     (octaspire_dern_vm_t *self, octaspire_dern_special_t * const value, char const * const docstr);
struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_builtin     (octaspire_dern_vm_t *self, octaspire_dern_builtin_t * const value, char const * const docstr);

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_c_data(
    octaspire_dern_vm_t * const self,
    char const * const pluginName,
    char const * const typeNameForPayload,
    char const * const cleanUpCallbackName,
    char const * const stdLibLenCallbackName,
    char const * const stdLibNthCallbackName,
    bool const copyingAllowed,
    void * const payload);

bool octaspire_dern_vm_push_value(octaspire_dern_vm_t *self, struct octaspire_dern_value_t *value);
bool octaspire_dern_vm_pop_value (octaspire_dern_vm_t *self, struct octaspire_dern_value_t *valueForBalanceCheck);
    void const * octaspire_dern_vm_get_top_value(octaspire_dern_vm_t const * const self);

struct octaspire_dern_value_t *octaspire_dern_vm_peek_value(octaspire_dern_vm_t *self);

bool octaspire_dern_vm_gc(octaspire_dern_vm_t *self);

octaspire_dern_value_t *octaspire_dern_vm_parse(octaspire_dern_vm_t *self, octaspire_input_t *input);

octaspire_dern_value_t *octaspire_dern_vm_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value);

octaspire_dern_value_t *octaspire_dern_vm_eval(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_read_from_octaspire_input_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    octaspire_input_t * const input);

octaspire_dern_value_t *octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    char const * const str);

octaspire_dern_value_t *octaspire_dern_vm_read_from_buffer_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    char const * const buffer,
    size_t const lengthInOctets);

octaspire_dern_value_t *octaspire_dern_vm_read_from_path_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    char const * const path);

octaspire_dern_value_t *octaspire_dern_vm_get_value_nil(
    octaspire_dern_vm_t *self);

octaspire_dern_value_t *octaspire_dern_vm_get_value_true(
    octaspire_dern_vm_t *self);

octaspire_dern_value_t *octaspire_dern_vm_get_value_false(
    octaspire_dern_vm_t *self);

octaspire_memory_allocator_t *octaspire_dern_vm_get_allocator(
    octaspire_dern_vm_t *self);

void octaspire_dern_vm_set_exit_code(
    octaspire_dern_vm_t *self,
    int32_t const code);

int32_t octaspire_dern_vm_get_exit_code(
    octaspire_dern_vm_t const * const self);

bool octaspire_dern_vm_is_quit(
    octaspire_dern_vm_t const * const self);

void octaspire_dern_vm_quit(
    octaspire_dern_vm_t *self);

bool octaspire_dern_vm_create_and_register_new_builtin(
    octaspire_dern_vm_t * const self,
    char const * const name,
    octaspire_dern_c_function const funcPointer,
    size_t const numRequiredActualArguments,
    char const * const docStr,
    octaspire_dern_environment_t * const targetEnv);

bool octaspire_dern_vm_create_and_register_new_special(
    octaspire_dern_vm_t * const self,
    char const * const name,
    octaspire_dern_c_function const funcPointer,
    size_t const numRequiredActualArguments,
    char const * const docStr,
    octaspire_dern_environment_t * const targetEnv);

bool octaspire_dern_vm_create_and_define_new_integer(
    octaspire_dern_vm_t * const self,
    char const * const name,
    char const * const docstr,
    int32_t const value);

size_t octaspire_dern_vm_get_stack_length(
    octaspire_dern_vm_t const * const self);


void octaspire_dern_vm_print_stack(
    octaspire_dern_vm_t const * const self);

octaspire_dern_value_t *octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
    octaspire_dern_vm_t * const self,
    octaspire_container_vector_t const * const vectorContainingSizeTs);

octaspire_dern_value_t *octaspire_dern_vm_find_from_value(
    octaspire_dern_vm_t * const self,
    octaspire_dern_value_t * const value,
    octaspire_dern_value_t const * const key);

octaspire_dern_value_t *octaspire_dern_vm_get_global_environment(
    octaspire_dern_vm_t *self);

octaspire_dern_value_t const *octaspire_dern_vm_get_global_environment_const(
    octaspire_dern_vm_t const * const self);

void  octaspire_dern_vm_set_user_data(octaspire_dern_vm_t * const self, void *userData);
void *octaspire_dern_vm_get_user_data(octaspire_dern_vm_t const * const self);

void octaspire_dern_vm_clear_value_to_nil(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value);

octaspire_dern_value_t *octaspire_dern_vm_get_function_return(
    octaspire_dern_vm_t * const self);

void octaspire_dern_vm_set_function_return(
    octaspire_dern_vm_t * const self,
    octaspire_dern_value_t * const value);

void octaspire_dern_vm_set_prevent_gc(octaspire_dern_vm_t * const self, bool const prevent);

void octaspire_dern_vm_set_gc_trigger_limit(
    octaspire_dern_vm_t * const self,
    size_t const numAllocs);

bool octaspire_dern_vm_is_file_system_access_allowed(octaspire_dern_vm_t const * const self);

bool octaspire_dern_vm_add_library(
    octaspire_dern_vm_t *self,
    char const * const name,
    octaspire_dern_lib_t *library);

bool octaspire_dern_vm_has_library(
    octaspire_dern_vm_t const * const self,
    char const * const name);

octaspire_dern_lib_t *octaspire_dern_vm_get_library(
    octaspire_dern_vm_t * const self,
    char const * const name);

octaspire_stdio_t *octaspire_dern_vm_get_stdio(octaspire_dern_vm_t * const self);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/dern/octaspire_dern_vm.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../include/octaspire/dern/octaspire_dern_stdlib.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/
#ifndef OCTASPIRE_DERN_STDLIB_H
#define OCTASPIRE_DERN_STDLIB_H


#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#endif

#ifdef __cplusplus
extern "C" {
#endif

octaspire_dern_value_t *octaspire_dern_vm_builtin_input_file_open(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_output_file_open(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_io_file_open(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_supports_output_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_supports_input_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_close(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_read(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_write(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_seek(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_dist(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_length(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_flush(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_not(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_abort(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_return(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_vector(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_and(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_or(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_do(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_nth(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_exit(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_doc(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_len(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_read_and_eval_path(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_read_and_eval_string(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_string_format(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_to_string(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_to_integer(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_print(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_println(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_env_new(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_env_current(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_env_global(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_plus_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_plus_plus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus_minus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_pop_front(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_mod(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_slash(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_times(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_plus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_find(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_split(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_hash_map(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_queue(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_queue_with_max_length(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_list(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_define(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_eval(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_quote(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_select(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_if(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_while(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_for(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

// TODO move to other builtins
octaspire_dern_value_t *octaspire_dern_vm_builtin_starts_with_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

// TODO move to other builtins
octaspire_dern_value_t *octaspire_dern_vm_builtin_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

// TODO move to other builtins
octaspire_dern_value_t *octaspire_dern_vm_builtin_equals_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

// TODO move to other builtins
octaspire_dern_value_t *octaspire_dern_vm_builtin_exclamation_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_less_than(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_greater_than(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_less_than_or_equal(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_greater_than_or_equal(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_special_fn(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_uid(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_require(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_integer_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_real_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_number_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_nil_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_boolean_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_character_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_string_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_symbol_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_vector_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_hash_map_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

octaspire_dern_value_t *octaspire_dern_vm_builtin_copy(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment);

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../include/octaspire/dern/octaspire_dern_stdlib.h
//////////////////////////////////////////////////////////////////////////////////////////////////



#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif

#endif







#ifdef OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_dern_environment.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_container_utf8_string_t *octaspire_dern_environment_private_to_string(
    octaspire_dern_environment_t const * const self,
    size_t const depth);

octaspire_memory_allocator_t *gallocator = 0;


octaspire_dern_environment_t *octaspire_dern_environment_new(
    octaspire_dern_value_t *enclosing,
    octaspire_dern_vm_t *vm,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_dern_environment_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_environment_t));

    if (!self)
    {
        return 0;
    }

    self->allocator = allocator;
    self->vm        = vm;
    self->enclosing = enclosing;

    self->bindings  = octaspire_container_hash_map_new(
        sizeof(octaspire_dern_value_t*),
        true,
        sizeof(octaspire_dern_value_t*),
        true,
        (octaspire_container_hash_map_key_compare_function_t)octaspire_dern_value_is_equal,
        (octaspire_container_hash_map_key_hash_function_t)octaspire_dern_value_get_hash,
        0,
        0,
        allocator);

    return self;
}

void octaspire_dern_environment_release(octaspire_dern_environment_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_container_hash_map_release(self->bindings);
    //octaspire_dern_environment_release(self->enclosing);
    octaspire_memory_allocator_free(self->allocator, self);
}

// Returns 0 or error
octaspire_dern_value_t *octaspire_dern_environment_extend(
    octaspire_dern_environment_t *self,
    octaspire_dern_value_t *formals,
    octaspire_dern_value_t *arguments)
{
    assert(formals->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    assert(arguments->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_container_vector_t *formalsVec   = formals->value.vector;
    octaspire_container_vector_t *argumentsVec = arguments->value.vector;

    assert(formalsVec && argumentsVec);

    size_t const numFormalArgs   = octaspire_container_vector_get_length(formalsVec);

    size_t numDotArgs            = 0;
    size_t numNormalArgs         = 0;
    size_t numNormalArgsAfterDot = 0;

    for (size_t i = 0; i < numFormalArgs; ++i)
    {
        octaspire_dern_value_t *formal = octaspire_container_vector_get_element_at(formalsVec, i);

        assert(formal->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

        octaspire_container_utf8_string_t const * const formalAsStr = formal->value.string;

        if (octaspire_container_utf8_string_is_equal_to_c_string(formalAsStr, "..."))
        {
            ++numDotArgs;
        }
        else
        {
            if (numDotArgs)
            {
                ++numNormalArgsAfterDot;
            }
            else
            {
                ++numNormalArgs;
            }
        }
    }

    if (numDotArgs > 1)
    {
        return octaspire_dern_vm_create_new_value_error_format(
            self->vm,
            "Function can have only one formal ... argument for varargs. Now %zu were given.",
            numDotArgs);
    }

    if (numNormalArgsAfterDot > 0)
    {
        return octaspire_dern_vm_create_new_value_error_format(
            self->vm,
            "Function can have no formal arguments after ... "
            "for varargs. Now %zu formals were given after ...",
            numNormalArgsAfterDot);
    }

    if (numDotArgs)
    {
        assert(numNormalArgs);
        // for the vector name
        --numNormalArgs;
    }

    if (numDotArgs == 0 && numNormalArgs != numFormalArgs)
    {
        return octaspire_dern_vm_create_new_value_error_format(
            self->vm,
            "Number of formal and actual arguments must be equal for functions without "
            "varargs using the ...-formal. Now %zu formal and %zu actual arguments were given.",
            numFormalArgs,
            numNormalArgs);
    }

    size_t const numActualArgumentsGiven = octaspire_container_vector_get_length(argumentsVec);

    // If varargs, subtract 2 for the ... and the formal name before it.
    size_t const numArgumentsRequiredAtLeast = numFormalArgs - (numDotArgs ? 2 : 0);

    if (numActualArgumentsGiven < numArgumentsRequiredAtLeast)
    {
        return octaspire_dern_vm_create_new_value_error_format(
            self->vm,
            "Function expects %zu arguments. Now %zu arguments were given.",
            numArgumentsRequiredAtLeast,
            numActualArgumentsGiven);
    }

    for (size_t i = 0; i < numNormalArgs; ++i)
    {
        assert(i < octaspire_container_vector_get_length(formalsVec));
        assert(i < octaspire_container_vector_get_length(argumentsVec));

        octaspire_dern_value_t *formal = octaspire_container_vector_get_element_at(formalsVec, i);

        octaspire_dern_value_t *actual = octaspire_container_vector_get_element_at(argumentsVec, i);

        if (!octaspire_dern_environment_set(self, formal, actual))
        {
            abort();
        }
    }

    size_t const numActualRestArgs = numActualArgumentsGiven - numNormalArgs;

    if (numActualRestArgs)
    {
        if (numDotArgs != 1)
        {
            // TODO XXX better error message
            return octaspire_dern_vm_create_new_value_error_format(
                self->vm,
                "Function can have zero or one dot args. Now %zu dot-arguments were given.",
                numDotArgs);
        }

        octaspire_dern_value_t *formal = octaspire_container_vector_get_element_at(
            formalsVec,
            octaspire_container_vector_get_length(formalsVec) - 2);

        octaspire_container_vector_t *actualVec = octaspire_container_vector_new_with_preallocated_elements(
            sizeof(octaspire_dern_value_t*),
            true,
            numNormalArgsAfterDot,
            0,
            self->allocator);

        octaspire_dern_value_t *actual = octaspire_dern_vm_create_new_value_vector_from_vector(self->vm, actualVec);

        //octaspire_dern_vm_push_value(self->vm, actual);

        for (size_t i = numNormalArgs; i < octaspire_container_vector_get_length(argumentsVec); ++i)
        {
            octaspire_dern_value_t *actualAfterDot = octaspire_container_vector_get_element_at(
                argumentsVec,
                i);

            if (!octaspire_container_vector_push_back_element(actualVec, &actualAfterDot))
            {
                abort();
            }
        }

        if (!octaspire_dern_environment_set(self, formal, actual))
        {
            abort();
        }
        //octaspire_dern_vm_pop_value(self->vm, actual); // actual
    }
    else if (numDotArgs > 0)
    {
        // Add empty rest-vector

        assert(numDotArgs == 1);

        octaspire_dern_value_t *formal = octaspire_container_vector_get_element_at(
            formalsVec,
            octaspire_container_vector_get_length(formalsVec) - 2);

        octaspire_dern_value_t *actual = octaspire_dern_vm_create_new_value_vector(self->vm);

        //octaspire_dern_vm_push_value(self->vm, actual);

        if (!octaspire_dern_environment_set(self, formal, actual))
        {
            abort();
        }
        //octaspire_dern_vm_pop_value(self->vm, actual); // actual
    }

    return 0;
}

octaspire_dern_value_t *octaspire_dern_environment_get(
    octaspire_dern_environment_t *self,
    octaspire_dern_value_t const * const key)
{
    gallocator = self->allocator;
    octaspire_container_hash_map_element_t *element = octaspire_container_hash_map_get(
        self->bindings,
        octaspire_dern_value_get_hash(key),
        &key);

    if (!element)
    {
        if (self->enclosing)
        {
            assert(self->enclosing->value.environment);
            return octaspire_dern_environment_get(self->enclosing->value.environment, key);
        }

        return 0;
    }

    return octaspire_container_hash_map_element_get_value(element);
}

bool octaspire_dern_environment_set(
    octaspire_dern_environment_t *self,
    octaspire_dern_value_t const * const key,
    octaspire_dern_value_t *value)
{
    uint32_t const hash = octaspire_dern_value_get_hash(key);

    // TODO XXX should this be made more efficient? Now the element is searched
    // twice. There could be a method octaspire_container_hash_map_put_overwriting etc.
    octaspire_container_hash_map_remove(self->bindings, hash, &key);

    return octaspire_container_hash_map_put(
        self->bindings,
        octaspire_dern_value_get_hash(key),
        &key,
        &value);
}

int octaspire_dern_environment_helper_compare_function(void const *a, void const *b)
{
    octaspire_container_hash_map_element_t *elemA = *(octaspire_container_hash_map_element_t**)a;
    octaspire_container_hash_map_element_t *elemB = *(octaspire_container_hash_map_element_t**)b;

    octaspire_dern_value_t const * const keyA =
       (octaspire_dern_value_t*)octaspire_container_hash_map_element_get_key(elemA);

    octaspire_dern_value_t const * const keyB =
       (octaspire_dern_value_t*)octaspire_container_hash_map_element_get_key(elemB);

    return octaspire_dern_value_compare(keyA, keyB);
}

static octaspire_container_utf8_string_t *octaspire_dern_environment_private_to_string(
    octaspire_dern_environment_t const * const self,
    size_t const depth)
{
    octaspire_container_utf8_string_t *indent = octaspire_container_utf8_string_new("", self->allocator);

    for (size_t i = 0; i < depth; ++i)
    {
        octaspire_container_utf8_string_concatenate_c_string(indent, "\t");
    }

    octaspire_container_utf8_string_t *result = octaspire_container_utf8_string_new_format(
        self->allocator,
        "%s---------- environment ----------\n",
        octaspire_container_utf8_string_get_c_string(indent));

    if (self->enclosing)
    {
        octaspire_container_utf8_string_t *enclosing =
            octaspire_dern_environment_private_to_string(self->enclosing->value.environment, depth + 1);

        octaspire_container_utf8_string_concatenate_format(
            result,
            "%s",
            octaspire_container_utf8_string_get_c_string(enclosing));

        octaspire_container_utf8_string_release(enclosing);
        enclosing = 0;
    }

    octaspire_container_vector_t *sortVec = octaspire_container_vector_new(
        sizeof(octaspire_container_hash_map_element_t*),
        true,
        0,
        self->allocator);

    size_t numCharsInLongestKey = 0;
    for (size_t i = 0; i < octaspire_container_hash_map_get_number_of_elements(self->bindings); ++i)
    {
        octaspire_container_hash_map_element_t const * const element =
            octaspire_container_hash_map_get_at_index(self->bindings, i);

        assert(element);

        numCharsInLongestKey = octaspire_helpers_max_size_t(
            numCharsInLongestKey,
            octaspire_dern_value_get_length(octaspire_container_hash_map_element_get_key(element)));

        if (!octaspire_container_vector_push_back_element(sortVec, &element))
        {
            abort();
        }
    }

    octaspire_container_vector_sort(
        sortVec,
        (octaspire_container_vector_element_compare_function_t)octaspire_dern_environment_helper_compare_function);

    for (size_t i = 0; i < octaspire_container_vector_get_length(sortVec); ++i)
    {
        octaspire_container_hash_map_element_t const * const element = octaspire_container_vector_get_element_at(sortVec, i);

        octaspire_dern_value_t const * const key =
            octaspire_container_hash_map_element_get_key(element);

        octaspire_dern_value_t const * const value =
            octaspire_container_hash_map_element_get_value(element);

        octaspire_container_utf8_string_t *keyAsStr = octaspire_dern_value_to_string(key, self->allocator);

        octaspire_container_utf8_string_t *valueAsStr =
            octaspire_dern_value_to_string(value, self->allocator);

        octaspire_container_utf8_string_concatenate_format(
            result,
            "%s%-*s -> %s\n",
            octaspire_container_utf8_string_get_c_string(indent),
            (int)numCharsInLongestKey,
            octaspire_container_utf8_string_get_c_string(keyAsStr),
            octaspire_container_utf8_string_get_c_string(valueAsStr));

        octaspire_container_utf8_string_release(keyAsStr);
        keyAsStr = 0;

        octaspire_container_utf8_string_release(valueAsStr);
        valueAsStr = 0;
    }

    octaspire_container_utf8_string_concatenate_format(
        result,
        "%s---------------------------------\n",
        octaspire_container_utf8_string_get_c_string(indent));

    octaspire_container_utf8_string_release(indent);
    indent = 0;

    octaspire_container_vector_release(sortVec);
    sortVec = 0;

    return result;
}

octaspire_container_utf8_string_t *octaspire_dern_environment_to_string(
    octaspire_dern_environment_t const * const self)
{
    return octaspire_dern_environment_private_to_string(self, 0);
}

bool octaspire_dern_environment_print(
    octaspire_dern_environment_t const * const self)
{
    octaspire_container_utf8_string_t *str = octaspire_dern_environment_to_string(self);

    if (!str)
    {
        return false;
    }

    if (printf("%s", octaspire_container_utf8_string_get_c_string(str)) < 0)
    {
        return false;
    }

    return true;
}


size_t octaspire_dern_environment_get_length(
    octaspire_dern_environment_t const * const self)
{
    return octaspire_container_hash_map_get_number_of_elements(self->bindings);
}

octaspire_container_hash_map_element_t *octaspire_dern_environment_get_at_index(
    octaspire_dern_environment_t *self,
    size_t const index)
{
    return octaspire_container_hash_map_get_at_index(self->bindings, index);
}

bool octaspire_dern_environment_mark(octaspire_dern_environment_t *self)
{
    if (!self)
    {
        return true;
    }

    bool statusKey = true;
    bool statusVal = true;

    octaspire_container_hash_map_element_iterator_t iter =
        octaspire_container_hash_map_element_iterator_init(self->bindings);

    while (iter.element)
    {
        octaspire_dern_value_t * const key =
            octaspire_container_hash_map_element_get_key(iter.element);

        octaspire_dern_value_t * const val =
            octaspire_container_hash_map_element_get_value(iter.element);

        statusKey = octaspire_dern_value_mark(key);
        statusVal = octaspire_dern_value_mark(val);

        octaspire_container_hash_map_element_iterator_next(&iter);
    }

    if (self->enclosing && self->enclosing->value.environment != self)
    {
        return octaspire_dern_value_mark(self->enclosing) && statusKey && statusVal;
    }

    return true;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_dern_environment.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_dern_lexer.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_dern_lexer_token_t
{
    octaspire_memory_allocator_t          *allocator;
    octaspire_dern_lexer_token_position_t *line;
    octaspire_dern_lexer_token_position_t *column;
    octaspire_dern_lexer_token_position_t *ucsIndex;
    octaspire_dern_lexer_token_tag_t       typeTag;

    union
    {
        octaspire_container_utf8_string_t *string;
        octaspire_container_utf8_string_t *character;
        octaspire_container_utf8_string_t *comment;
        octaspire_container_utf8_string_t *symbol;
        octaspire_container_utf8_string_t *error;
        octaspire_container_utf8_string_t *moreInputRequired;
        int32_t                            integer;
        double                             real;
    }
    value;
};

static char const * const octaspire_dern_lexer_private_token_tag_types_as_c_strings[] =
{
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED",
    "OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT"
};

void octaspire_dern_lexer_private_pop_whitespace(
    octaspire_input_t *input);

void octaspire_dern_lexer_private_pop_rest_of_line(
    octaspire_input_t *input);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_multiline_comment(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_left_parenthesis(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_right_parenthesis(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_quote(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_integer_or_real_number(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_string(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_character(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_true_or_false_or_nil_or_symbol(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput);

bool octaspire_dern_lexer_private_is_delimeter(uint32_t const c);



octaspire_dern_lexer_token_position_t octaspire_dern_lexer_token_position_init(
    size_t const start, size_t const end)
{
    octaspire_dern_lexer_token_position_t result;
    result.start = start;
    result.end   = end;
    return result;
}

bool octaspire_dern_lexer_token_position_is_equal(
    octaspire_dern_lexer_token_position_t const * const self,
    octaspire_dern_lexer_token_position_t const * const other)
{
    return self->start == other->start &&
           self->end   == other->end;
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_token_new(
    octaspire_dern_lexer_token_tag_t const typeTag,
    void const * const value,
    octaspire_dern_lexer_token_position_t const line,
    octaspire_dern_lexer_token_position_t const column,
    octaspire_dern_lexer_token_position_t const ucsIndex,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_dern_lexer_token_t *self = octaspire_memory_allocator_malloc(
        allocator,
        sizeof(octaspire_dern_lexer_token_t));

    if (!self)
    {
        return self;
    }

    self->allocator = allocator;

    self->line =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_lexer_token_position_t));

    self->column =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_lexer_token_position_t));

    self->ucsIndex = 
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_lexer_token_position_t));

    if (!self->line || !self->column || !self->ucsIndex)
    {
        octaspire_dern_lexer_token_release(self);
        self = 0;
        return 0;
    }

    self->line->start = line.start;
    self->line->end   = line.end;

    self->column->start = column.start;
    self->column->end   = column.end;

    self->ucsIndex->start = ucsIndex.start;
    self->ucsIndex->end   = ucsIndex.end;

    self->typeTag   = typeTag;

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE:
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL:
        {
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER:
        {
            self->value.integer = *(int32_t const * const)value;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL:
        {
            self->value.real = *(double const * const)value;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING:
        {
            self->value.string = octaspire_container_utf8_string_new(
                (char const * const)value,
                allocator);

            if (!self->value.string)
            {
                octaspire_dern_lexer_token_release(self);
                self = 0;
                return 0;
            }

            assert(octaspire_container_utf8_string_get_error_status(self->value.string) == OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT:
        {
            self->value.comment = octaspire_container_utf8_string_new(
                (char const * const)value,
                allocator);

            if (!self->value.comment)
            {
                octaspire_dern_lexer_token_release(self);
                self = 0;
                return 0;
            }

            assert(octaspire_container_utf8_string_get_error_status(self->value.comment) == OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED:
        {
            self->value.moreInputRequired = octaspire_container_utf8_string_new(
                (char const * const)value,
                allocator);

            if (!self->value.moreInputRequired)
            {
                octaspire_dern_lexer_token_release(self);
                self = 0;
                return 0;
            }

            assert(octaspire_container_utf8_string_get_error_status(self->value.moreInputRequired) == OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER:
        {
            self->value.character = octaspire_container_utf8_string_new(
                (char const * const)value,
                allocator);

            if (!self->value.character)
            {
                octaspire_dern_lexer_token_release(self);
                self = 0;
                return 0;
            }

            assert(octaspire_container_utf8_string_get_error_status(self->value.character) == OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK);

        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL:
        {
            self->value.symbol = octaspire_container_utf8_string_new(
                (char const * const)value,
                allocator);

            if (!self->value.symbol)
            {
                octaspire_dern_lexer_token_release(self);
                self = 0;
                return 0;
            }

            assert(octaspire_container_utf8_string_get_error_status(self->value.symbol) == OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR:
        {
            self->value.error = octaspire_container_utf8_string_new(
                (char const * const)value,
                allocator);

            if (!self->value.error)
            {
                octaspire_dern_lexer_token_release(self);
                self = 0;
                return 0;
            }

            assert(octaspire_container_utf8_string_get_error_status(self->value.error) == OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK);
        }
        break;

        default:
        {
            octaspire_dern_lexer_token_release(self);
            self = 0;
            return 0;
        }
        break;
    }

    return self;
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_token_new_format(
    octaspire_dern_lexer_token_tag_t const typeTag,
    octaspire_dern_lexer_token_position_t const line,
    octaspire_dern_lexer_token_position_t const column,
    octaspire_dern_lexer_token_position_t const ucsIndex,
    octaspire_memory_allocator_t *allocator,
    void const * const format,
    ...)
{
    va_list arguments;
    va_start(arguments, format);
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new_vformat(
        allocator,
        format,
        arguments);
    va_end(arguments);

    assert(
        typeTag == OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING ||
        typeTag == OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR);

    octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
        typeTag,
        octaspire_container_utf8_string_get_c_string(str),
        line,
        column,
        ucsIndex,
        allocator);

    octaspire_container_utf8_string_release(str);
    str = 0;

    return result;
}


void octaspire_dern_lexer_token_release(
    octaspire_dern_lexer_token_t *self)
{
    if (!self)
    {
        return;
    }

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING:
        {
            octaspire_container_utf8_string_release(self->value.string);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER:
        {
            octaspire_container_utf8_string_release(self->value.character);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL:
        {
            octaspire_container_utf8_string_release(self->value.symbol);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR:
        {
            octaspire_container_utf8_string_release(self->value.error);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED:
        {
            octaspire_container_utf8_string_release(self->value.moreInputRequired);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT:
        {
            octaspire_container_utf8_string_release(self->value.comment);
        }
        break;

        default:
        {
            // Nothing to be done here
        }
        break;
    }

    octaspire_memory_allocator_free(self->allocator, self->line);
    self->line = 0;

    octaspire_memory_allocator_free(self->allocator, self->column);
    self->column = 0;

    octaspire_memory_allocator_free(self->allocator, self->ucsIndex);
    self->ucsIndex = 0;

    octaspire_memory_allocator_free(self->allocator, self);
}

octaspire_dern_lexer_token_tag_t octaspire_dern_lexer_token_get_type_tag(
    octaspire_dern_lexer_token_t const * const self)
{
    assert(self);
    return self->typeTag;
}

char const *octaspire_dern_lexer_token_get_type_tag_as_c_string(
    octaspire_dern_lexer_token_t const * const self)
{
    octaspire_dern_lexer_token_tag_t const tag = octaspire_dern_lexer_token_get_type_tag(self);

    assert(
        (size_t)tag <
            (sizeof(octaspire_dern_lexer_private_token_tag_types_as_c_strings) /
                sizeof(octaspire_dern_lexer_private_token_tag_types_as_c_strings[0])));
    return
        octaspire_dern_lexer_private_token_tag_types_as_c_strings[tag];
}

char const *octaspire_dern_lexer_token_get_string_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self)
{
    return octaspire_container_utf8_string_get_c_string(self->value.string);
}

char const *octaspire_dern_lexer_token_get_character_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self)
{
    return octaspire_container_utf8_string_get_c_string(self->value.character);
}

char const *octaspire_dern_lexer_token_get_symbol_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self)
{
    return octaspire_container_utf8_string_get_c_string(self->value.symbol);
}

int32_t octaspire_dern_lexer_token_get_integer_value(
    octaspire_dern_lexer_token_t const * const self)
{
    return self->value.integer;
}

double octaspire_dern_lexer_token_get_real_value(
    octaspire_dern_lexer_token_t const * const self)
{
    return self->value.real;
}

char const *octaspire_dern_lexer_token_get_error_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self)
{
    return octaspire_container_utf8_string_get_c_string(self->value.error);
}

char const *octaspire_dern_lexer_token_get_multiline_comment_value_as_c_string(
    octaspire_dern_lexer_token_t const * const self)
{
    return octaspire_container_utf8_string_get_c_string(self->value.comment);
}

octaspire_dern_lexer_token_position_t *octaspire_dern_lexer_token_get_position_line(
    octaspire_dern_lexer_token_t const * const self)
{
    return self->line;
}

octaspire_dern_lexer_token_position_t *octaspire_dern_lexer_token_get_position_column(
    octaspire_dern_lexer_token_t const * const self)
{
    return self->column;
}

octaspire_dern_lexer_token_position_t *octaspire_dern_lexer_token_get_position_ucs_index(
    octaspire_dern_lexer_token_t const * const self)
{
    return self->ucsIndex;
}

bool octaspire_dern_lexer_token_is_equal(
    octaspire_dern_lexer_token_t const * const self,
    octaspire_dern_lexer_token_t const * const other)
{
    if (self->allocator != other->allocator)
    {
        return false;
    }

    if (!octaspire_dern_lexer_token_position_is_equal(self->line, other->line))
    {
        return false;
    }

    if (!octaspire_dern_lexer_token_position_is_equal(self->column, other->column))
    {
        return false;
    }

    if (!octaspire_dern_lexer_token_position_is_equal(self->ucsIndex, other->ucsIndex))
    {
        return false;
    }

    if (self->typeTag != other->typeTag)
    {
        return false;
    }

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING:
        {
            return octaspire_container_utf8_string_is_equal(self->value.string, other->value.string);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER:
        {
            return octaspire_container_utf8_string_is_equal(self->value.character, other->value.character);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL:
        {
            return octaspire_container_utf8_string_is_equal(self->value.symbol, other->value.symbol);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR:
        {
            return octaspire_container_utf8_string_is_equal(self->value.error, other->value.error);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED:
        {
            return octaspire_container_utf8_string_is_equal(
                self->value.moreInputRequired,
                other->value.moreInputRequired);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER:
        {
            return self->value.integer == other->value.integer;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL:
        {
            return self->value.real == other->value.real;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT:
        {
            return octaspire_container_utf8_string_is_equal(self->value.comment, other->value.comment);
        }
        break;

        default:
        {
            return true;
        }
    }
}

octaspire_container_utf8_string_t *octaspire_dern_lexer_token_to_string(
    octaspire_dern_lexer_token_t const * const self)
{
    assert(self);

    octaspire_container_utf8_string_t *result = octaspire_container_utf8_string_new_format(
        (void*)self->allocator,
        "token: line=%zu,%zu column=%zu,%zu ucsIndex=%zu,%zu type=%s value=",
        self->line->start, self->line->end,
        self->column->start, self->column->end,
        self->ucsIndex->start, self->ucsIndex->end,
        octaspire_dern_lexer_token_get_type_tag_as_c_string(self));

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN:
        {
            if (!octaspire_container_utf8_string_concatenate_c_string(result, "left parenthesis"))
            {
                return 0;
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN:
        {
            if (!octaspire_container_utf8_string_concatenate_c_string(result, "right parenthesis"))
            {
                return 0;
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE:
        {
            if (!octaspire_container_utf8_string_concatenate_c_string(result, "quote"))
            {
                return 0;
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE:
        {
            if (!octaspire_container_utf8_string_concatenate_c_string(result, "true"))
            {
                return 0;
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE:
        {
            if (!octaspire_container_utf8_string_concatenate_c_string(result, "false"))
            {
                return 0;
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL:
        {
            if (!octaspire_container_utf8_string_concatenate_c_string(result, "nil"))
            {
                return 0;
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER:
        {
            if (!octaspire_container_utf8_string_concatenate_format(
                result,
                "integer %" PRId32 "",
                self->value.integer))
            {
                return 0;
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL:
        {
            if (!octaspire_container_utf8_string_concatenate_format(
                result,
                "real %g", 
                self->value.real))
            {
                return 0;
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING:
        {
            if (!octaspire_container_utf8_string_concatenate_format(
                result,
                "[%s]",
                octaspire_container_utf8_string_get_c_string(self->value.string)))
            {
                return 0;
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER:
        {
            if (octaspire_container_utf8_string_is_equal_to_c_string(self->value.character, "|"))
            {
                if (!octaspire_container_utf8_string_concatenate_c_string(result, "|bar|"))
                {
                    return 0;
                }
            }
            else if (octaspire_container_utf8_string_is_equal_to_c_string(self->value.character, "\n"))
            {
                if (!octaspire_container_utf8_string_concatenate_c_string(result, "|newline|"))
                {
                    return 0;
                }
            }
            else if (octaspire_container_utf8_string_is_equal_to_c_string(self->value.character, "\t"))
            {
                if (!octaspire_container_utf8_string_concatenate_c_string(result, "|tab|"))
                {
                    return 0;
                }
            }
            else
            {
                if (!octaspire_container_utf8_string_concatenate_format(
                            result,
                            "|%s|",
                            octaspire_container_utf8_string_get_c_string(self->value.character)))
                {
                    return 0;
                }
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL:
        {
            if (!octaspire_container_utf8_string_concatenate_format(
                result,
                "%s",
                octaspire_container_utf8_string_get_c_string(self->value.symbol)))
            {
                return 0;
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR:
        {
            if (!octaspire_container_utf8_string_concatenate_format(
                result,
                "error: %s",
                octaspire_container_utf8_string_get_c_string(self->value.error)))
            {
                return 0;
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT:
        {
            if (!octaspire_container_utf8_string_concatenate_format(
                result,
                "%s",
                octaspire_container_utf8_string_get_c_string(self->value.comment)))
            {
                return 0;
            }

            return result;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED:
        {
            if (!octaspire_container_utf8_string_concatenate_format(
                result,
                "more input required: %s",
                octaspire_container_utf8_string_get_c_string(self->value.moreInputRequired)))
            {
                return 0;
            }

            return result;
        }
        break;
    }

    if (!octaspire_container_utf8_string_concatenate_format(
        result,
        "unknown token type %i",
        (int)self->typeTag))
    {
        return 0;
    }

    return result;
}

void octaspire_dern_lexer_token_print(
    octaspire_dern_lexer_token_t const * const self)
{
    octaspire_container_utf8_string_t *str = octaspire_dern_lexer_token_to_string(self);
    printf("%s\n", octaspire_container_utf8_string_get_c_string(str));
    octaspire_container_utf8_string_release(str);
    str = 0;
}

void octaspire_dern_lexer_private_pop_whitespace(
    octaspire_input_t *input)
{
    while (octaspire_input_is_good(input))
    {
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (!isspace((int const)c))
        {
            break;
        }

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }
    }
}

void octaspire_dern_lexer_private_pop_rest_of_line(
    octaspire_input_t *input)
{
    while (octaspire_input_is_good(input))
    {
        if (octaspire_input_peek_next_ucs_character(input) == '\n')
        {
            if (!octaspire_input_pop_next_ucs_character(input))
            {
                abort();
            }

            return;
        }

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }
    }
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_multiline_comment(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    if (octaspire_input_peek_next_ucs_character(input) != '#')
    {
        size_t const endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Number sign '#' expected to start multiline comment",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }

    if (!octaspire_input_pop_next_ucs_character(input))
    {
        abort();
    }

    if (octaspire_input_peek_next_ucs_character(input) != '!')
    {
        size_t const endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Exclamation mark '!' expected after '#' to start multiline comment",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }

    if (!octaspire_input_pop_next_ucs_character(input))
    {
        abort();
    }

    octaspire_container_utf8_string_t *commentStr =
        octaspire_container_utf8_string_new("", allocator);

    while (octaspire_input_is_good(input))
    {
        uint32_t currentChar = octaspire_input_peek_next_ucs_character(input);

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }

        if (currentChar == '!')
        {
            if (!octaspire_input_is_good(input))
            {
                octaspire_container_utf8_string_release(commentStr);
                commentStr = 0;

                size_t const endIndexInInput  = octaspire_input_get_ucs_character_index(input) - 1;
                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED,
                    "Number sign '#' expected after '!' to close multiline comment",
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startIndexInInput,
                        endIndexInInput),
                    allocator);
            }

            currentChar = octaspire_input_peek_next_ucs_character(input);

            if (currentChar == '#')
            {
                size_t const endIndexInInput  = octaspire_input_get_ucs_character_index(input);
                octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT,
                    octaspire_container_utf8_string_get_c_string(commentStr),
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        //octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startIndexInInput,
                        endIndexInInput),
                    allocator);

                if (!octaspire_input_pop_next_ucs_character(input))
                {
                    abort();
                }

                octaspire_container_utf8_string_release(commentStr);
                commentStr = 0;

                return result;
            }
            else
            {
                octaspire_container_utf8_string_push_back_ucs_character(commentStr, currentChar);
            }
        }
        else
        {
            octaspire_container_utf8_string_push_back_ucs_character(commentStr, currentChar);
        }
    }

    octaspire_container_utf8_string_release(commentStr);
    commentStr = 0;

    size_t const endIndexInInput  = octaspire_input_get_ucs_character_index(input) - 1;
    return octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED,
        "Multiline comment that is not closed with !#",
        octaspire_dern_lexer_token_position_init(
            startLine,
            octaspire_input_get_line_number(input)),
        octaspire_dern_lexer_token_position_init(
            startColumn,
            octaspire_input_get_column_number(input)),
        octaspire_dern_lexer_token_position_init(
            startIndexInInput,
            endIndexInInput),
        allocator);
}

bool octaspire_dern_lexer_private_is_delimeter(uint32_t const c)
{
    return (
        isspace(c) ||
        c == '|'   ||
        c == '['   ||
        c == ']'   ||
        c == '('   ||
        c == ')'   ||
        c == '\''  ||
        c == '\n'
    );
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_left_parenthesis(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   endIndexInInput = startIndexInInput;

    if (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (c == '(')
        {
            octaspire_dern_lexer_token_t * result = octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
                0,
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);

            if (!octaspire_input_pop_next_ucs_character(input))
            {
                abort();
            }

            return result;
        }
        else
        {
            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Left parenthesis '(' expected",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
    }
    else
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Left parenthesis '(' expected",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_right_parenthesis(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   endIndexInInput = startIndexInInput;

    if (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (c == ')')
        {
            octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN,
                0,
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);

            if (!octaspire_input_pop_next_ucs_character(input))
            {
                abort();
            }

            return result;
        }
        else
        {
            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Right parenthesis ')' expected",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
    }
    else
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Right parenthesis ')' expected",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_quote(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   endIndexInInput = startIndexInInput;

    if (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (c == '\'')
        {
            octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE,
                0,
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);

            if (!octaspire_input_pop_next_ucs_character(input))
            {
                abort();
            }

            return result;
        }
        else
        {
            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Quote ' expected",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
    }
    else
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Quote ' expected",
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }
}




octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_integer_or_real_number(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   charsRead       = 0;
    bool     minusRead       = false;
    bool     dotRead         = false;

    size_t   endIndexInInput = startIndexInInput;
    bool     endsInDelimiter = false;

    octaspire_container_utf8_string_t *tmpStr =
        octaspire_container_utf8_string_new("", allocator);

    if (!tmpStr)
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Memory allocation failed",
            octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);
    }

    uint32_t prevChar        = 0;

    while (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (c == '-')
        {
            if (minusRead)
            {
                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "Number can contain only one '-' character",
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startIndexInInput,
                        endIndexInInput),
                    allocator);
            }

            if (charsRead > 0)
            {
                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "Number can have '-' character only in the beginning",
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startIndexInInput,
                        endIndexInInput),
                    allocator);
            }

            minusRead = true;
            if (!octaspire_container_utf8_string_push_back_ucs_character(tmpStr, c))
            {
                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "Memory allocation failed",
                    octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                    allocator);
            }
        }
        else if (c == '.')
        {
            if (dotRead)
            {
                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "Number can contain only one '.' character",
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startIndexInInput,
                        endIndexInInput),
                    allocator);
            }

            if (charsRead == 0)
            {
                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "Character '.' cannot start a number",
                    octaspire_dern_lexer_token_position_init(
                        startLine,
                        octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startColumn,
                        octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(
                        startIndexInInput,
                        endIndexInInput),
                    allocator);
            }

            dotRead = true;
            if (!octaspire_container_utf8_string_push_back_ucs_character(tmpStr, c))
            {
                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "Memory allocation failed",
                    octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                    allocator);
            }
        }
        else if (isdigit((int const)c))
        {
            if (!octaspire_container_utf8_string_push_back_ucs_character(tmpStr, c))
            {
                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "Memory allocation failed",
                    octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                    allocator);
            }
        }
        else if (octaspire_dern_lexer_private_is_delimeter(c))
        {
            --endIndexInInput;
            endsInDelimiter = true;
            break;
        }
        else
        {
            octaspire_container_utf8_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new_format(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator,
                "Number cannot contain character '%c'",
                c);
        }

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }

        ++charsRead;
        prevChar = c;
    }

    if (prevChar == '.')
    {
        octaspire_container_utf8_string_release(tmpStr);
        tmpStr = 0;

        return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Character '.' cannot end a number",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
    }

    if (prevChar == '-')
    {
        octaspire_container_utf8_string_release(tmpStr);
        tmpStr = 0;

        return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Character '-' cannot end a number",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
    }

    if (dotRead)
    {
        double const resultValue = atof(octaspire_container_utf8_string_get_c_string(tmpStr));

        octaspire_container_utf8_string_release(tmpStr);
        tmpStr = 0;

        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL,
            &resultValue,
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }

    int32_t const resultValue = atol(octaspire_container_utf8_string_get_c_string(tmpStr));

    octaspire_container_utf8_string_release(tmpStr);
    tmpStr = 0;

    return octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER,
        &resultValue,
        octaspire_dern_lexer_token_position_init(
            startLine,
            octaspire_input_get_line_number(input)),
        octaspire_dern_lexer_token_position_init(
            startColumn,
            octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
        octaspire_dern_lexer_token_position_init(
            startIndexInInput,
            endIndexInInput),
        allocator);
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_string(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   charsRead       = 0;
    bool     lastDelimiterRead = false;
    bool     endsInDelimiter = false;

    size_t   endIndexInInput = startIndexInInput;

    octaspire_container_utf8_string_t *tmpStr =
        octaspire_container_utf8_string_new("", allocator);

    if (!tmpStr)
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Memory allocation failed",
            octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);
    }

    while (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t c = octaspire_input_peek_next_ucs_character(input);

        if (lastDelimiterRead)
        {
            if (octaspire_dern_lexer_private_is_delimeter(c))
            {
                --endIndexInInput;
                endsInDelimiter = true;
                break;
            }
            else
            {
                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "After last ']' of string there must be dern delimiter",
                    octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                    allocator);
            }
        }

        if (charsRead == 0)
        {
            if (c == '[')
            {
            }
            else
            {
                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "String must begin with character '['",
                    octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                    allocator);
            }
        }
        else
        {
            if (c == ']')
            {
                lastDelimiterRead = true;
            }
            else if (c == '|')
            {
                octaspire_dern_lexer_token_t *charToken =
                    octaspire_dern_lexer_private_pop_character(
                        input,
                        allocator,
                        startLine,
                        startColumn,
                        startIndexInInput);

                if (!charToken)
                {
                    octaspire_container_utf8_string_release(tmpStr);
                    tmpStr = 0;

                    return octaspire_dern_lexer_token_new(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        "Problem with a character embedded in string: (character is not complete)",
                        octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                        allocator);
                }

                if (octaspire_dern_lexer_token_get_type_tag(charToken) == OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR)
                {
                    octaspire_container_utf8_string_release(tmpStr);
                    tmpStr = 0;

                    octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new_format(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                        allocator,
                        "Problem with a character embedded in string: (%s)",
                        octaspire_dern_lexer_token_get_error_value_as_c_string(charToken));

                    octaspire_dern_lexer_token_release(charToken);
                    charToken = 0;

                    return result;
                }

                // TODO check that char available
                c = octaspire_container_utf8_string_get_ucs_character_at_index(charToken->value.character, 0);
                if (!octaspire_container_utf8_string_push_back_ucs_character(tmpStr, c))
                {
                    octaspire_container_utf8_string_release(tmpStr);
                    tmpStr = 0;

                    octaspire_dern_lexer_token_release(charToken);
                    charToken = 0;

                    return octaspire_dern_lexer_token_new(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        "Memory allocation failed",
                        octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                        allocator);
                }

                octaspire_dern_lexer_token_release(charToken);
                charToken = 0;
                // TODO should charsRead be incremented by some amount? (length of embedded string,
                // including the ||, etc.)
                goto loopEnd;
            }
            else
            {
                if (!octaspire_container_utf8_string_push_back_ucs_character(tmpStr, c))
                {
                    octaspire_container_utf8_string_release(tmpStr);
                    tmpStr = 0;

                    return octaspire_dern_lexer_token_new(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        "Memory allocation failed",
                        octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                        allocator);
                }
            }
        }

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }

loopEnd:
        ++charsRead;
    }

    if (!lastDelimiterRead)
    {
        octaspire_container_utf8_string_release(tmpStr);
        tmpStr = 0;

        if (!octaspire_input_is_good(input))
        {
            return 0; // Out of input
        }

        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "String must end with character ']'",
            octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);
    }

    octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING,
        octaspire_container_utf8_string_get_c_string(tmpStr),
        octaspire_dern_lexer_token_position_init(
            startLine,
            octaspire_input_get_line_number(input)),
        octaspire_dern_lexer_token_position_init(
            startColumn,
            octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
        octaspire_dern_lexer_token_position_init(
            startIndexInInput,
            endIndexInInput),
        allocator);

    octaspire_container_utf8_string_release(tmpStr);
    tmpStr = 0;

    return result;
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_character(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   charsRead       = 0;
    bool     lastDelimiterRead = false;
    bool     endsInDelimiter = false;

    size_t   endIndexInInput = startIndexInInput;

    octaspire_container_utf8_string_t *tmpStr =
        octaspire_container_utf8_string_new("", allocator);

    if (!tmpStr)
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Memory allocation failed",
            octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);
    }

    while (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (lastDelimiterRead)
        {
            if (octaspire_dern_lexer_private_is_delimeter(c))
            {
                --endIndexInInput;
                endsInDelimiter = true;
                break;
            }
            else
            {
                // NOP
                break;
            }
        }

        if (charsRead == 0)
        {
            if (c == '|')
            {
            }
            else
            {
                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                return octaspire_dern_lexer_token_new(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    "Character must begin with character '|'",
                    octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                    allocator);
            }
        }
        else
        {
            if (c == '|')
            {
                lastDelimiterRead = true;
            }
            else
            {
                if (!octaspire_container_utf8_string_push_back_ucs_character(tmpStr, c))
                {
                    octaspire_container_utf8_string_release(tmpStr);
                    tmpStr = 0;

                    return octaspire_dern_lexer_token_new(
                        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                        "Memory allocation failed",
                        octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                        octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                        octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                        allocator);
                }
            }
        }

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }

        ++charsRead;
    }

    if (!lastDelimiterRead)
    {
        octaspire_container_utf8_string_release(tmpStr);
        tmpStr = 0;

        if (!octaspire_input_is_good(input))
        {
            return 0; // Out of input
        }

        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Character must end with character '|'",
            octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);
    }

    if (octaspire_container_utf8_string_get_length_in_ucs_characters(tmpStr) > 1)
    {
        if (octaspire_container_utf8_string_is_equal_to_c_string(tmpStr, "bar"))
        {
            octaspire_container_utf8_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                "|",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
        else if (octaspire_container_utf8_string_is_equal_to_c_string(tmpStr, "newline"))
        {
            octaspire_container_utf8_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                "\n",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
        else if (octaspire_container_utf8_string_is_equal_to_c_string(tmpStr, "tab"))
        {
            octaspire_container_utf8_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                "\t",
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);
        }
        else if (
            strspn(
                octaspire_container_utf8_string_get_c_string(tmpStr),
                "0123456789abcdefABCDEF") == octaspire_container_utf8_string_get_length_in_ucs_characters(tmpStr))
        {
            if (octaspire_container_utf8_string_get_length_in_ucs_characters(tmpStr) > 8)
            {
                octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new_format(
                    OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                    octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                    octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                    octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                    allocator,
                    "Number of hex digits (%zu) in character definition may not be larger than eight",
                    octaspire_container_utf8_string_get_length_in_ucs_characters(tmpStr));

                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                return result;
            }

            octaspire_container_utf8_string_t *unicodeChar =
                octaspire_container_utf8_string_new("", allocator);

            if (!octaspire_container_utf8_string_push_back_ucs_character(
                unicodeChar,
                strtol(octaspire_container_utf8_string_get_c_string(tmpStr), 0, 16)))
            {
                abort();
            }

            if (octaspire_container_utf8_string_get_error_status(unicodeChar) !=
                OCTASPIRE_CONTAINER_UTF8_STRING_ERROR_STATUS_OK)
            {
                abort();
            }

            assert(unicodeChar);

            octaspire_dern_lexer_token_t * result = octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                octaspire_container_utf8_string_get_c_string(unicodeChar),
                octaspire_dern_lexer_token_position_init(
                    startLine,
                    octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(
                    startColumn,
                    octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
                octaspire_dern_lexer_token_position_init(
                    startIndexInInput,
                    endIndexInInput),
                allocator);

            octaspire_container_utf8_string_release(unicodeChar);
            unicodeChar = 0;

            octaspire_container_utf8_string_release(tmpStr);
            tmpStr = 0;

            return result;
        }
        else
        {
            octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new_format(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                allocator,
                "Unknown character constant |%s|",
                octaspire_container_utf8_string_get_c_string(tmpStr));

            octaspire_container_utf8_string_release(tmpStr);
            tmpStr = 0;

            return result;
        }
    }

    if (octaspire_container_utf8_string_is_empty(tmpStr))
    {
        octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Character cannot be empty: ||",
            octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);

        octaspire_container_utf8_string_release(tmpStr);
        tmpStr = 0;

        return result;
    }

    octaspire_dern_lexer_token_t *result = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
        octaspire_container_utf8_string_get_c_string(tmpStr),
        octaspire_dern_lexer_token_position_init(
            startLine,
            octaspire_input_get_line_number(input)),
        octaspire_dern_lexer_token_position_init(
            startColumn,
            octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
        octaspire_dern_lexer_token_position_init(
            startIndexInInput,
            endIndexInInput),
        allocator);

    octaspire_container_utf8_string_release(tmpStr);
    tmpStr = 0;

    return result;
}

octaspire_dern_lexer_token_t *octaspire_dern_lexer_private_pop_true_or_false_or_nil_or_symbol(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator,
    size_t const startLine,
    size_t const startColumn,
    size_t const startIndexInInput)
{
    size_t   charsRead       = 0;
    bool     endsInDelimiter = false;

    size_t   endIndexInInput = startIndexInInput;

    octaspire_container_utf8_string_t *tmpStr =
        octaspire_container_utf8_string_new("", allocator);

    if (!tmpStr)
    {
        return octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
            "Memory allocation failed",
            octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
            octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
            allocator);
    }

    while (octaspire_input_is_good(input))
    {
        endIndexInInput  = octaspire_input_get_ucs_character_index(input);
        uint32_t const c = octaspire_input_peek_next_ucs_character(input);

        if (octaspire_dern_lexer_private_is_delimeter(c))
        {
            --endIndexInInput;
            endsInDelimiter = true;
            break;
        }

        if (!octaspire_container_utf8_string_push_back_ucs_character(tmpStr, c))
        {
            octaspire_container_utf8_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Memory allocation failed",
                octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                allocator);
        }

        if (!octaspire_input_pop_next_ucs_character(input))
        {
            abort();
        }

        ++charsRead;
    }

    if (octaspire_container_utf8_string_is_empty(tmpStr))
    {
            octaspire_container_utf8_string_release(tmpStr);
            tmpStr = 0;

            return octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
                "Symbol cannot be empty",
                octaspire_dern_lexer_token_position_init(startLine,   octaspire_input_get_line_number(input)),
                octaspire_dern_lexer_token_position_init(startColumn, octaspire_input_get_column_number(input)),
                octaspire_dern_lexer_token_position_init(startIndexInInput, endIndexInInput),
                allocator);
    }

    octaspire_dern_lexer_token_t *result = 0;

    if (octaspire_container_utf8_string_is_equal_to_c_string(tmpStr, "true"))
    {
        result = octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE,
            0,
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }
    else if (octaspire_container_utf8_string_is_equal_to_c_string(tmpStr, "false"))
    {
        result = octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE,
            0,
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }
    else if (octaspire_container_utf8_string_is_equal_to_c_string(tmpStr, "nil"))
    {
        result = octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL,
            0,
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }
    else
    {
        result = octaspire_dern_lexer_token_new(
            OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL,
            octaspire_container_utf8_string_get_c_string(tmpStr),
            octaspire_dern_lexer_token_position_init(
                startLine,
                octaspire_input_get_line_number(input)),
            octaspire_dern_lexer_token_position_init(
                startColumn,
                octaspire_input_get_column_number(input) - (endsInDelimiter ? 1 : 0)),
            octaspire_dern_lexer_token_position_init(
                startIndexInInput,
                endIndexInInput),
            allocator);
    }

    octaspire_container_utf8_string_release(tmpStr);
    tmpStr = 0;

    return result;
}


octaspire_dern_lexer_token_t *octaspire_dern_lexer_pop_next_token(
    octaspire_input_t *input,
    octaspire_memory_allocator_t *allocator)
{
    while (octaspire_input_is_good(input))
    {
        octaspire_dern_lexer_private_pop_whitespace(input);

        if (!octaspire_input_is_good(input))
        {
            return 0;
        }

        size_t const startLine         = octaspire_input_get_line_number(input);
        size_t const startColumn       = octaspire_input_get_column_number(input);
        size_t const startIndexInInput = octaspire_input_get_ucs_character_index(input);

        switch (octaspire_input_peek_next_ucs_character(input))
        {
            case ';':
            {
                octaspire_dern_lexer_private_pop_rest_of_line(input);
            }
            break;

            case '#':
            {
                switch (octaspire_input_peek_next_next_ucs_character(input))
                {
                    case '!':
                    {
                        return octaspire_dern_lexer_private_pop_multiline_comment(
                            input,
                            allocator,
                            startLine,
                            startColumn,
                            startIndexInInput);
                    }
                    break;

                    default:
                    {
                        return octaspire_dern_lexer_private_pop_true_or_false_or_nil_or_symbol(
                            input,
                            allocator,
                            startLine,
                            startColumn,
                            startIndexInInput);
                    }
                    break;
                }
            }
            break;

            case '(':
            {
                return octaspire_dern_lexer_private_pop_left_parenthesis(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }
            break;

            case ')':
            {
                return octaspire_dern_lexer_private_pop_right_parenthesis(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }
            break;

            case '\'':
            {
                return octaspire_dern_lexer_private_pop_quote(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }
            break;

            case '-':
            {
                switch (octaspire_input_peek_next_next_ucs_character(input))
                {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    {
                        return octaspire_dern_lexer_private_pop_integer_or_real_number(
                            input,
                            allocator,
                            startLine,
                            startColumn,
                            startIndexInInput);
                    }
                    break;

                    default:
                    {
                        return octaspire_dern_lexer_private_pop_true_or_false_or_nil_or_symbol(
                            input,
                            allocator,
                            startLine,
                            startColumn,
                            startIndexInInput);
                    }
                    break;
                }
            }
            break;

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                return octaspire_dern_lexer_private_pop_integer_or_real_number(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }
            break;

            /*
            case '|':
            {
                return octaspire_dern_lexer_private_pop_string_or_character(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }
            break;
            */

            case '[':
            {
                return octaspire_dern_lexer_private_pop_string(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }
            break;

            case '|':
            {
                return octaspire_dern_lexer_private_pop_character(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }
            break;

            case 't':
            case 'f':
            case 'n':
            default:
            {
                return octaspire_dern_lexer_private_pop_true_or_false_or_nil_or_symbol(
                    input,
                    allocator,
                    startLine,
                    startColumn,
                    startIndexInInput);
            }
            break;
        }
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_dern_lexer.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_dern_lib.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#endif

struct octaspire_dern_lib_t
{
    octaspire_memory_allocator_t      *allocator;
    octaspire_dern_vm_t               *vm;
    octaspire_container_utf8_string_t *name;
    octaspire_dern_lib_tag_t           typeTag;
    octaspire_container_utf8_string_t *errorMessage;
    void                              *binaryLibHandle;
};

octaspire_dern_lib_t *octaspire_dern_lib_new_source(
    char const * const name,
    octaspire_input_t * const input,
    octaspire_dern_vm_t *vm,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_dern_lib_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_lib_t));

    if (!self)
    {
        return self;
    }

    self->allocator       = allocator;
    self->vm              = vm;
    self->name            = octaspire_container_utf8_string_new(name, self->allocator);
    self->typeTag         = OCTASPIRE_DERN_LIB_TAG_SOURCE;
    self->binaryLibHandle = 0;

    octaspire_dern_value_t *value =
        octaspire_dern_vm_read_from_octaspire_input_and_eval_in_global_environment(vm, input);

    octaspire_helpers_verify_not_null(value);

    if (value->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
    {
        self->errorMessage =
            octaspire_container_utf8_string_new_copy(value->value.error, self->allocator);

        octaspire_helpers_verify_not_null(self->errorMessage);
    }

    return self;
}

octaspire_dern_lib_t *octaspire_dern_lib_new_binary(
    char const * const name,
    char const * const fileName,
    octaspire_dern_vm_t *vm,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_dern_lib_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_lib_t));

    if (!self)
    {
        return self;
    }

    self->allocator       = allocator;
    self->vm              = vm;
    self->name            = octaspire_container_utf8_string_new(name, self->allocator);
    self->typeTag         = OCTASPIRE_DERN_LIB_TAG_BINARY;
    self->binaryLibHandle = 0;


#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS

        // Clear any old errors
        dlerror();

        self->binaryLibHandle = dlopen(fileName, RTLD_LAZY);

        if (!self->binaryLibHandle)
        {
            self->errorMessage =
                octaspire_container_utf8_string_new_format(
                    self->allocator,
                    "Binary library (name='%s' fileName='%s')\n"
                    "cannot be loaded/opened with dlopen. dlerror is: %s",
                    name,
                    fileName,
                    dlerror());

            octaspire_helpers_verify_not_null(self->errorMessage);
        }
        else
        {
            bool (*libInitFunc)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const);

            octaspire_container_utf8_string_t *libInitFuncName =
                octaspire_container_utf8_string_new_format(self->allocator, "%s_init", name);

            octaspire_helpers_verify_not_null(libInitFuncName);

            libInitFunc =
                (bool (*)(octaspire_dern_vm_t * const, octaspire_dern_environment_t * const))dlsym(
                    self->binaryLibHandle,
                    octaspire_container_utf8_string_get_c_string(libInitFuncName));

            octaspire_container_utf8_string_release(libInitFuncName);
            libInitFuncName = 0;

            char *error = dlerror();

            if (error)
            {
                self->errorMessage =
                    octaspire_container_utf8_string_new_format(
                        self->allocator,
                        "Binary library (name='%s' fileName='%s'):\n"
                        "dlsym failed on the init function for the library. dlerror is: %s",
                        name,
                        fileName,
                        error);

                octaspire_helpers_verify_not_null(self->errorMessage);

                //dlclose(self->binaryLibHandle);
                //self->binaryLibHandle = 0;
            }
            else
            {
                if (!(*libInitFunc)(
                        vm,
                        octaspire_dern_vm_get_global_environment(vm)->value.environment))
                {
                    self->errorMessage =
                        octaspire_container_utf8_string_new_format(
                            self->allocator,
                            "Binary library (name='%s' fileName='%s'):\n"
                            "init function failed.",
                            name,
                            fileName);

                    octaspire_helpers_verify_not_null(self->errorMessage);

                    //dlclose(self->binaryLibHandle);
                    //self->binaryLibHandle = 0;
                }
            }
        }

#else

        self->errorMessage =
            octaspire_container_utf8_string_new_format(
                self->allocator,
                "Your version of Octaspire Dern is compiled\n"
                "WITHOUT support for binary libraries and this binary library\n"
                "(name='%s' fileName='%s')\n"
                "cannot thus be loaded. Use source-code libraries instead\n"
                "or compile Dern again with binary library support.\n",
                name,
                fileName);

        octaspire_helpers_verify_not_null(self->errorMessage);

#endif

        return self;
}

void octaspire_dern_lib_release(octaspire_dern_lib_t *self)
{
    if (!self)
    {
        return;
    }

    if (self->typeTag == OCTASPIRE_DERN_LIB_TAG_BINARY && self->binaryLibHandle)
    {
#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
        dlclose(self->binaryLibHandle);
#endif
        self->binaryLibHandle = 0;
    }

    octaspire_container_utf8_string_release(self->name);
    self->name = 0;

    octaspire_container_utf8_string_release(self->errorMessage);
    self->errorMessage = 0;

    octaspire_memory_allocator_free(self->allocator, self);
}

bool octaspire_dern_lib_is_good(octaspire_dern_lib_t const * const self)
{
    return (self->errorMessage == 0);
}

char const *octaspire_dern_lib_get_error_message(octaspire_dern_lib_t const * const self)
{
    if (!self->errorMessage)
    {
        return 0;
    }

    return octaspire_container_utf8_string_get_c_string(self->errorMessage);
}

void *octaspire_dern_lib_get_handle(octaspire_dern_lib_t * const self)
{
    return self->binaryLibHandle;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_dern_lib.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_dern_c_data.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#endif

struct octaspire_dern_c_data_t
{
    octaspire_container_utf8_string_t         *pluginName;
    octaspire_dern_lib_t                      *library;
    octaspire_container_utf8_string_t         *typeNameForPayload;
    void                                      *payload;
    octaspire_container_utf8_string_t         *cleanUpCallbackName;
    octaspire_container_utf8_string_t         *stdLibLenCallbackName;
    octaspire_container_utf8_string_t         *stdLibNthCallbackName;
    bool                                       copyingAllowed;
    octaspire_memory_allocator_t              *allocator;
};

octaspire_dern_c_data_t *octaspire_dern_c_data_new(
    char const * const pluginName,
    octaspire_dern_lib_t * const library,
    char const * const typeNameForPayload,
    void * const payload,
    char const * const cleanUpCallbackName,
    char const * const stdLibLenCallbackName,
    char const * const stdLibNthCallbackName,
    bool const copyingAllowed,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_dern_c_data_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_c_data_t));

    if (!self)
    {
        return self;
    }

    self->allocator             = allocator;
    self->pluginName            = octaspire_container_utf8_string_new(pluginName,         self->allocator);
    self->library               = library;
    self->typeNameForPayload    = octaspire_container_utf8_string_new(typeNameForPayload, self->allocator);
    self->payload               = payload;
    self->cleanUpCallbackName   = octaspire_container_utf8_string_new(cleanUpCallbackName, self->allocator);
    self->stdLibLenCallbackName = octaspire_container_utf8_string_new(stdLibLenCallbackName, self->allocator);
    self->stdLibNthCallbackName = octaspire_container_utf8_string_new(stdLibNthCallbackName, self->allocator);
    self->copyingAllowed        = copyingAllowed;

    return self;
}

octaspire_dern_c_data_t *octaspire_dern_c_data_new_copy(
    octaspire_dern_c_data_t * const other,
    octaspire_memory_allocator_t *allocator)
{
    return octaspire_dern_c_data_new(
        octaspire_container_utf8_string_get_c_string(other->pluginName),
        other->library,
        octaspire_container_utf8_string_get_c_string(other->typeNameForPayload),
        other->payload,
        octaspire_container_utf8_string_get_c_string(other->cleanUpCallbackName),
        octaspire_container_utf8_string_get_c_string(other->stdLibLenCallbackName),
        octaspire_container_utf8_string_get_c_string(other->stdLibNthCallbackName),
        other->copyingAllowed,
        allocator);
}

void octaspire_dern_c_data_release(octaspire_dern_c_data_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_helpers_verify_not_null(self->cleanUpCallbackName);

#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
    if (!octaspire_container_utf8_string_is_empty(self->cleanUpCallbackName))
    {
        void * const handle = octaspire_dern_lib_get_handle(self->library);
        void (*func)(void * const payload);
        func = (void (*)(void * const))dlsym(handle, octaspire_container_utf8_string_get_c_string(self->cleanUpCallbackName));
        octaspire_helpers_verify_not_null(func);
        func(self->payload);
    }
#endif

    octaspire_container_utf8_string_release(self->cleanUpCallbackName);
    self->cleanUpCallbackName = 0;

    octaspire_container_utf8_string_release(self->stdLibLenCallbackName);
    self->stdLibLenCallbackName = 0;

    octaspire_container_utf8_string_release(self->stdLibNthCallbackName);
    self->stdLibNthCallbackName = 0;

    octaspire_container_utf8_string_release(self->pluginName);
    self->pluginName = 0;

    octaspire_container_utf8_string_release(self->typeNameForPayload);
    self->typeNameForPayload = 0;

    octaspire_memory_allocator_free(self->allocator, self);
}

octaspire_container_utf8_string_t *octaspire_dern_c_data_to_string(
    octaspire_dern_c_data_t const * const self,
    octaspire_memory_allocator_t * const allocator)
{
    return octaspire_container_utf8_string_new_format(
        allocator,
        "C data (%s : %s) payload=%p cleanUpCallbackName=%s stdLibLenCallbackName=%s "
        "stdLibNthCallbackName=%s",
        octaspire_container_utf8_string_get_c_string(self->pluginName),
        octaspire_container_utf8_string_get_c_string(self->typeNameForPayload),
        (void*)self->payload,
        octaspire_container_utf8_string_get_c_string(self->cleanUpCallbackName),
        octaspire_container_utf8_string_get_c_string(self->stdLibLenCallbackName),
        octaspire_container_utf8_string_get_c_string(self->stdLibNthCallbackName));
}

bool octaspire_dern_c_data_is_equal(
    octaspire_dern_c_data_t const * const self,
    octaspire_dern_c_data_t const * const other)
{
    if (self->payload != other->payload)
    {
        return false;
    }

    if (octaspire_container_utf8_string_is_equal(self->pluginName, other->pluginName))
    {
        return false;
    }

    if (octaspire_container_utf8_string_is_equal(self->typeNameForPayload, other->typeNameForPayload))
    {
        return false;
    }

    return true;
}

int octaspire_dern_c_data_compare(
    octaspire_dern_c_data_t const * const self,
    octaspire_dern_c_data_t const * const other)
{
    int tmp = octaspire_container_utf8_string_compare(self->pluginName, other->pluginName);

    if (tmp != 0)
    {
        return tmp;
    }

    tmp = octaspire_container_utf8_string_compare(
        self->typeNameForPayload,
        other->typeNameForPayload);

    if (tmp != 0)
    {
        return tmp;
    }

    ptrdiff_t const diff = self - other;

    if (diff == 0)
    {
        return 0;
    }

    if (diff < 0)
    {
        return -1;
    }

    return 1;
}

bool octaspire_dern_c_data_is_plugin_and_payload_type_name(
    octaspire_dern_c_data_t const * const self,
    char const * const pluginName,
    char const * const typeNameForPayload)
{
    if (!octaspire_container_utf8_string_is_equal_to_c_string(self->pluginName, pluginName))
    {
        return false;
    }

    if (!octaspire_container_utf8_string_is_equal_to_c_string(
            self->typeNameForPayload,
            typeNameForPayload))
    {
        return false;
    }

    return true;
}

char const *octaspire_dern_c_data_get_plugin_name(
    octaspire_dern_c_data_t const * const self)
{
    return octaspire_container_utf8_string_get_c_string(self->pluginName);
}

char const *octaspire_dern_c_data_get_payload_typename(
    octaspire_dern_c_data_t const * const self)
{
    return octaspire_container_utf8_string_get_c_string(self->typeNameForPayload);
}

void *octaspire_dern_c_data_get_payload(
    octaspire_dern_c_data_t const * const self)
{
    return self->payload;
}

bool octaspire_dern_c_data_is_copying_allowed(
    octaspire_dern_c_data_t const * const self)
{
    return self->copyingAllowed;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_dern_c_data.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_dern_port.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

struct octaspire_dern_port_t
{
    octaspire_memory_allocator_t      *allocator;
    octaspire_container_utf8_string_t *name;
    size_t                             lengthInOctets;
    octaspire_dern_port_tag_t          typeTag;

    union
    {
        FILE *file;
    }
    value;
};

octaspire_dern_port_t *octaspire_dern_port_new_copy(
    octaspire_dern_port_t * const other,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_dern_port_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_port_t));

    if (!self)
    {
        return self;
    }

    self->allocator      = allocator;
    self->name           = octaspire_container_utf8_string_new_copy(other->name, self->allocator);
    self->typeTag        = other->typeTag;
    self->lengthInOctets = other->lengthInOctets;

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        {
            self->value.file =
                fopen(octaspire_container_utf8_string_get_c_string(self->name), "a+b");

            if (self->value.file == 0)
            {
                self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
            }

            octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_END) == 0);
            self->lengthInOctets = ftell(self->value.file);
            octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_SET) == 0);
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        {
            self->value.file =
                fopen(octaspire_container_utf8_string_get_c_string(self->name), "rb");

            if (self->value.file == 0)
            {
                self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
            }

            octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_END) == 0);
            self->lengthInOctets = ftell(self->value.file);
            octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_SET) == 0);
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        {
            self->value.file =
                fopen(octaspire_container_utf8_string_get_c_string(self->name), "a");

            if (self->value.file == 0)
            {
                self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
            }

            octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_END) == 0);
            self->lengthInOctets = ftell(self->value.file);
            octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_SET) == 0);
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            // NOP
        }
        break;
    }

    return self;
}

octaspire_dern_port_t *octaspire_dern_port_new_input_file(
    char const * const path,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_dern_port_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_port_t));

    if (!self)
    {
        return self;
    }

    self->allocator  = allocator;
    self->name       = octaspire_container_utf8_string_new(path, self->allocator);
    self->typeTag    = OCTASPIRE_DERN_PORT_TAG_INPUT_FILE;
    self->lengthInOctets = -1;
    self->value.file = fopen(path, "rb");

    if (self->value.file == 0)
    {
        self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
        return self;
    }

    octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_END) == 0);
    self->lengthInOctets = ftell(self->value.file);
    octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_SET) == 0);

    return self;
}

octaspire_dern_port_t *octaspire_dern_port_new_output_file(
    char const * const path,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_dern_port_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_port_t));

    if (!self)
    {
        return self;
    }

    self->allocator  = allocator;
    self->name       = octaspire_container_utf8_string_new(path, self->allocator);
    self->typeTag    = OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE;
    self->lengthInOctets = -1;
    self->value.file = fopen(path, "a");

    if (self->value.file == 0)
    {
        self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
        return self;
    }

    octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_END) == 0);
    self->lengthInOctets = ftell(self->value.file);
    octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_SET) == 0);

    return self;
}

octaspire_dern_port_t *octaspire_dern_port_new_io_file(
    char const * const path,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_dern_port_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_port_t));

    if (!self)
    {
        return self;
    }

    self->allocator  = allocator;
    self->name       = octaspire_container_utf8_string_new(path, self->allocator);
    self->typeTag    = OCTASPIRE_DERN_PORT_TAG_IO_FILE;
    self->lengthInOctets = -1;
    self->value.file = fopen(path, "a+b");

    if (self->value.file == 0)
    {
        self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
        return self;
    }

    octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_END) == 0);
    self->lengthInOctets = ftell(self->value.file);
    octaspire_helpers_verify_true(fseek(self->value.file, 0, SEEK_SET) == 0);

    return self;
}

void octaspire_dern_port_release(octaspire_dern_port_t *self)
{
    if (!self)
    {
        return;
    }

    if (self->typeTag == OCTASPIRE_DERN_PORT_TAG_INPUT_FILE  ||
        self->typeTag == OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE ||
        self->typeTag == OCTASPIRE_DERN_PORT_TAG_IO_FILE)
    {
        int const res = fclose(self->value.file);
        self->value.file = 0;
        self->lengthInOctets = -1;
        octaspire_helpers_verify_true(res == 0);
    }

    octaspire_container_utf8_string_release(self->name);
    self->name = 0;

    octaspire_memory_allocator_free(self->allocator, self);
}

ptrdiff_t octaspire_dern_port_write(
    octaspire_dern_port_t * const self,
    void const * const buffer,
    size_t const bufferSizeInOctets)
{
    octaspire_helpers_verify_not_null(self);

    if (self->typeTag == OCTASPIRE_DERN_PORT_TAG_IO_FILE ||
        self->typeTag == OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE)
    {
        octaspire_helpers_verify_not_null(self->value.file);
        size_t const numItemsWritten = fwrite(buffer, sizeof(char), bufferSizeInOctets, self->value.file);
        return (ptrdiff_t)numItemsWritten;
    }

    return -1;
}

ptrdiff_t octaspire_dern_port_read(
    octaspire_dern_port_t * const self,
    void * const buffer,
    size_t const bufferSizeInOctets)
{
    octaspire_helpers_verify_not_null(self);

    if (self->typeTag == OCTASPIRE_DERN_PORT_TAG_INPUT_FILE ||
        self->typeTag == OCTASPIRE_DERN_PORT_TAG_IO_FILE)
    {
        octaspire_helpers_verify_not_null(self->value.file);
        size_t const numItemsRead = fread(buffer, sizeof(char), bufferSizeInOctets, self->value.file);
        return (ptrdiff_t)numItemsRead;
    }

    return -1;
}

bool octaspire_dern_port_close(
    octaspire_dern_port_t * const self)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        {
            int const res = fclose(self->value.file);
            self->value.file = 0;
            self->lengthInOctets = -1;
            self->typeTag = OCTASPIRE_DERN_PORT_TAG_NOT_OPEN;
            return (res == 0);
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return false;
        }
        break;
    }

    abort();
    return false;
}

ptrdiff_t octaspire_dern_port_get_length_in_octets(octaspire_dern_port_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->lengthInOctets;
}

octaspire_container_utf8_string_t *octaspire_dern_port_to_string(
    octaspire_dern_port_t const * const self,
    octaspire_memory_allocator_t * const allocator)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        {
            return octaspire_container_utf8_string_new_format(
                allocator,
                "<input-port:%s (%td octets)>",
                octaspire_container_utf8_string_get_c_string(self->name),
                self->lengthInOctets);
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        {
            return octaspire_container_utf8_string_new_format(
                allocator,
                "<output-port:%s (%td octets)>",
                octaspire_container_utf8_string_get_c_string(self->name),
                self->lengthInOctets);
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        {
            return octaspire_container_utf8_string_new_format(
                allocator,
                "<input-output-port:%s (%td octets)>",
                octaspire_container_utf8_string_get_c_string(self->name),
                self->lengthInOctets);
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return octaspire_container_utf8_string_new_format(
                allocator,
                "<NOT-OPEN-port:%s (%td octets)>",
                octaspire_container_utf8_string_get_c_string(self->name),
                self->lengthInOctets);
        }
        break;
    }

    abort();
    return 0;
}

bool octaspire_dern_port_seek(
    octaspire_dern_port_t * const self,
    ptrdiff_t const amount,
    bool const fromCurrentPos)
{
    octaspire_helpers_verify_not_null(self);

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        {
            octaspire_helpers_verify_not_null(self->value.file);

            if (amount < 0)
            {
                // Seek backwards from the end
                // TODO XXX check that amount fits into long and report error if it doesn't
                long const offset = fromCurrentPos ? amount : (amount + 1);
                return fseek(self->value.file, offset, fromCurrentPos ? SEEK_CUR : SEEK_END) == 0;
            }
            else
            {
                // Seek forward from the beginning
                // TODO XXX check that amount fits into long and report error if it doesn't
                long const offset = amount;
                return fseek(self->value.file, offset, fromCurrentPos ? SEEK_CUR : SEEK_SET) == 0;
            }
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return false;
        }
        break;
    }

    return false;
}

bool octaspire_dern_port_flush(octaspire_dern_port_t * const self)
{
    octaspire_helpers_verify_not_null(self);

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        {
            octaspire_helpers_verify_not_null(self->value.file);

            return fflush(self->value.file) == 0;
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return false;
        }
        break;
    }

    return false;
}

ptrdiff_t octaspire_dern_port_distance(octaspire_dern_port_t const * const self)
{
    octaspire_helpers_verify_not_null(self);

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        {
            octaspire_helpers_verify_not_null(self->value.file);

            return (ptrdiff_t)ftell(self->value.file);
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return -1;
        }
        break;
    }

    return -1;
}

bool octaspire_dern_port_supports_output(
    octaspire_dern_port_t const * const self)
{
    octaspire_helpers_verify_not_null(self);

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        {
            octaspire_helpers_verify_not_null(self->value.file);
            return true;
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return false;
        }
        break;
    }

    return false;
}

bool octaspire_dern_port_supports_input(
    octaspire_dern_port_t const * const self)
{
    octaspire_helpers_verify_not_null(self);

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_PORT_TAG_IO_FILE:
        case OCTASPIRE_DERN_PORT_TAG_INPUT_FILE:
        {
            octaspire_helpers_verify_not_null(self->value.file);
            return true;
        }
        break;

        case OCTASPIRE_DERN_PORT_TAG_OUTPUT_FILE:
        case OCTASPIRE_DERN_PORT_TAG_NOT_OPEN:
        {
            return false;
        }
        break;
    }

    return false;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_dern_port.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_dern_stdlib.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#ifdef OCTASPIRE_DERN_CONFIG_BINARY_PLUGINS
#endif

octaspire_dern_value_t *octaspire_dern_stdlib_private_validate_function(
    octaspire_dern_vm_t* vm,
    octaspire_dern_function_t *function);

octaspire_dern_value_t *octaspire_dern_vm_private_special_define_with_four_arguments(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    octaspire_helpers_verify_true(octaspire_container_vector_get_length(vec) == 4);

    octaspire_dern_value_t *targetEnv = octaspire_container_vector_get_element_at(vec, 0);

    octaspire_helpers_verify_true(targetEnv && targetEnv->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_dern_value_t *name = octaspire_container_vector_get_element_at(vec, 1);

    bool nameIsEvaluated = false;

    if (name->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        nameIsEvaluated = true;

        if (name->typeTag != OCTASPIRE_DERN_VALUE_TAG_VECTOR)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define': (define [optional-target-env] symbol...) name to be defined should be symbol or vector to be evaluated. Type '%s' was given.",
                octaspire_dern_value_helper_get_type_as_c_string(name->typeTag));
        }

        name = octaspire_dern_vm_eval(vm, name, environment);

        if (name->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define': (define [optional-target-env] symbol...) vector for name to be defined should evaluate into symbol. Type '%s' was result of evaluation.",
                octaspire_dern_value_helper_get_type_as_c_string(name->typeTag));
        }

        octaspire_dern_vm_push_value(vm, name);
    }

    octaspire_dern_value_t *docstr = octaspire_container_vector_get_element_at(vec, 2);

    if (docstr->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        if (nameIsEvaluated)
        {
            octaspire_dern_vm_pop_value(vm, name);
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'define': (define [optional-target-env] symbol docstring...) docstring must be string. Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(docstr->typeTag));
    }

    octaspire_dern_value_t *valueToBeDefined = octaspire_container_vector_get_element_at(vec, 3);

    octaspire_dern_value_t * const valueToBeDefinedToBePopped = valueToBeDefined;

    octaspire_dern_vm_push_value(vm, environment);
    octaspire_dern_vm_push_value(vm, valueToBeDefined);

    valueToBeDefined = octaspire_dern_vm_eval(vm, valueToBeDefined, environment);

    octaspire_dern_vm_pop_value(vm, valueToBeDefinedToBePopped);

    if (octaspire_dern_value_is_atom(valueToBeDefined))
    {
        octaspire_dern_vm_push_value(vm, valueToBeDefined);
        octaspire_dern_value_t * const valueToBeDefinedToBePopped = valueToBeDefined;
        valueToBeDefined = octaspire_dern_vm_create_new_value_copy(vm, valueToBeDefined);
        octaspire_dern_vm_pop_value(vm, valueToBeDefinedToBePopped);
    }

    octaspire_dern_vm_pop_value(vm, environment);

    if (valueToBeDefined->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
    {
        if (nameIsEvaluated)
        {
            octaspire_dern_vm_pop_value(vm, name);
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return valueToBeDefined;
    }
    else if (valueToBeDefined->typeTag == OCTASPIRE_DERN_VALUE_TAG_FUNCTION)
    {
        if (nameIsEvaluated)
        {
            octaspire_dern_vm_pop_value(vm, name);
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "At definition of function '%s': functions cannot be defined with "
            "the three-argument function. Use four-argument function.",
            octaspire_dern_value_as_symbol_get_c_string(name));
    }

    valueToBeDefined->docstr = docstr;

    bool const status = octaspire_dern_environment_set(
        targetEnv->value.environment,
        name,
        valueToBeDefined);

    if (nameIsEvaluated)
    {
        octaspire_dern_vm_pop_value(vm, name);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, status);
}

octaspire_dern_value_t *octaspire_dern_vm_private_special_define_with_five_arguments(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    octaspire_helpers_verify_true(octaspire_container_vector_get_length(vec) == 5);

    octaspire_dern_value_t *targetEnv = octaspire_container_vector_get_element_at(vec, 0);

    octaspire_helpers_verify_true(targetEnv && targetEnv->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_dern_value_t *name = octaspire_container_vector_get_element_at(vec, 1);

    bool nameIsEvaluated = false;

    if (name->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        nameIsEvaluated = true;

        if (name->typeTag != OCTASPIRE_DERN_VALUE_TAG_VECTOR)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define': (define [optional-target-env] name...) Name must be symbol or vector to be evaluated. Type '%s' was given.",
                octaspire_dern_value_helper_get_type_as_c_string(name->typeTag));
        }

        name = octaspire_dern_vm_eval(vm, name, environment);


        if (name->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Special 'define': (define [optional-target-env] name...) Vector for name must evaluate into symbol. Now it evaluated into type '%s'.",
                octaspire_dern_value_helper_get_type_as_c_string(name->typeTag));
        }

        octaspire_dern_vm_push_value(vm, name);
    }

    octaspire_dern_value_t *docstr = octaspire_container_vector_get_element_at(vec, 2);

    if (docstr->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        if (nameIsEvaluated)
        {
            octaspire_dern_vm_pop_value(vm, name);
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'define': (define [optional-target-env] name docstring...) docstring must be string. Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(docstr->typeTag));
    }

    octaspire_dern_value_t *docVecArg = octaspire_container_vector_get_element_at(vec, 3);

    octaspire_dern_vm_push_value(vm, docVecArg);
    octaspire_dern_vm_push_value(vm, environment);

    octaspire_dern_value_t *docVec = octaspire_dern_vm_eval(vm, docVecArg, environment);

    octaspire_dern_vm_pop_value(vm, environment);
    octaspire_dern_vm_pop_value(vm, docVecArg);

    if (docVec->typeTag != OCTASPIRE_DERN_VALUE_TAG_VECTOR)
    {
        if (nameIsEvaluated)
        {
            octaspire_dern_vm_pop_value(vm, name);
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

        if (docVec->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            return docVec;
        }

        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'define': (define [optional-target-env] name docstring docvec...). DocVec must be vector. Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(docVec->typeTag));
    }

    octaspire_dern_value_t *valueToBeDefined = octaspire_container_vector_get_element_at(vec, 4);

    if (octaspire_dern_value_is_atom(valueToBeDefined))
    {
        valueToBeDefined = octaspire_dern_vm_create_new_value_copy(vm, valueToBeDefined);
    }

    octaspire_dern_vm_push_value(vm, docVec);
    octaspire_dern_vm_push_value(vm, valueToBeDefined);

    octaspire_dern_value_t *oldValueToBeDefined = valueToBeDefined;

    valueToBeDefined = octaspire_dern_vm_eval(vm, valueToBeDefined, environment);

    octaspire_dern_vm_pop_value(vm, oldValueToBeDefined);
    octaspire_dern_vm_pop_value(vm, docVec);

    if (valueToBeDefined->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
    {
        if (nameIsEvaluated)
        {
            octaspire_dern_vm_pop_value(vm, name);
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return valueToBeDefined;
    }
    else if (valueToBeDefined->typeTag == OCTASPIRE_DERN_VALUE_TAG_FUNCTION)
    {
        octaspire_container_utf8_string_t *errorMessage =
            octaspire_dern_function_are_all_formals_mentioned_in_docvec(
                valueToBeDefined->value.function,
                docVec);

        octaspire_helpers_verify_not_null(errorMessage);

        if (!octaspire_container_utf8_string_is_empty(errorMessage))
        {
            if (nameIsEvaluated)
            {
                octaspire_dern_vm_pop_value(vm, name);
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error(vm, errorMessage);
        }
        else
        {
            octaspire_container_utf8_string_release(errorMessage);
            errorMessage = 0;

            octaspire_container_utf8_string_t *strToModify = docstr->value.string;

            if (!octaspire_container_utf8_string_concatenate_c_string(
                strToModify,
                "\nArguments are:"))
            {
                abort();
            }


            for (size_t i = 0; i < octaspire_dern_value_get_length(docVec); i += 2)
            {
                if (!octaspire_container_utf8_string_concatenate_c_string(
                    strToModify,
                    "\n"))
                {
                    abort();
                }

                octaspire_dern_value_t const * const formalSym =
                    octaspire_dern_value_as_vector_get_element_of_type_at_const(
                        docVec,
                        OCTASPIRE_DERN_VALUE_TAG_SYMBOL,
                        i);

                octaspire_helpers_verify_not_null(formalSym);

                octaspire_dern_value_t const * const formalDocStr =
                    octaspire_dern_value_as_vector_get_element_of_type_at_const(
                        docVec,
                        OCTASPIRE_DERN_VALUE_TAG_STRING,
                        i + 1);

                octaspire_helpers_verify_not_null(formalDocStr);

                if (!octaspire_container_utf8_string_concatenate_format(
                    strToModify,
                    "%s -> %s",
                    octaspire_container_utf8_string_get_c_string(formalSym->value.symbol),
                    octaspire_container_utf8_string_get_c_string(formalDocStr->value.string)))
                {
                    abort();
                }
            }
        }
    }
    else
    {
        if (nameIsEvaluated)
        {
            octaspire_dern_vm_pop_value(vm, name);
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Four/Five argument 'define' must be used to define functions. Definition of type '%s' was tried.",
            octaspire_dern_value_helper_get_type_as_c_string(valueToBeDefined->typeTag));
    }

    valueToBeDefined->docstr = docstr;
    valueToBeDefined->docvec = docVec;

    bool const status = octaspire_dern_environment_set(
        targetEnv->value.environment,
        name,
        valueToBeDefined);

    if (nameIsEvaluated)
    {
        octaspire_dern_vm_pop_value(vm, name);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, status);
}

octaspire_dern_value_t *octaspire_dern_vm_special_define(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    size_t const numArgs = octaspire_container_vector_get_length(vec);

    if (numArgs != 3 && numArgs != 4 && numArgs != 5)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'define' expects three, four, or five arguments. %zu arguments were given.",
            numArgs);
    }

    // TODO XXX is there need to push arguments?
    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_container_vector_get_element_at(vec, 0);
    octaspire_helpers_verify_not_null(firstArg);
    octaspire_dern_value_t *evaluatedFirstArg = octaspire_dern_vm_eval(vm, firstArg, environment);
    octaspire_helpers_verify_not_null(evaluatedFirstArg);

    if (evaluatedFirstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
    {
        if (!octaspire_dern_value_as_vector_push_front_element(arguments, &environment))
        {
            abort();
        }

        if (numArgs == 3)
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_private_special_define_with_four_arguments(
                vm,
                arguments,
                environment);

            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }
        else if (numArgs == 4)
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_private_special_define_with_five_arguments(
                vm,
                arguments,
                environment);

            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }
        else
        {
            abort();
        }
    }
    else
    {
        // TODO if it would be checked that is the first already an env, there would not
        // be need to replace it with evaluated one (itself).
        // TODO should there be octaspire_dern_value_as_vector_replace_element_at...?
        if (!octaspire_container_vector_replace_element_at(arguments->value.vector, 0, &evaluatedFirstArg))
        {
            abort();
        }

        if (numArgs == 4)
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_private_special_define_with_four_arguments(
                vm,
                arguments,
                environment);

            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }
        else if (numArgs == 5)
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_private_special_define_with_five_arguments(
                vm,
                arguments,
                environment);

            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }
        else
        {
            abort();
        }
    }

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_special_eval(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) != 1 &&
        octaspire_container_vector_get_length(vec) != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'eval' expects one or two arguments. %zu arguments were given.",
            octaspire_container_vector_get_length(vec));
    }

    octaspire_dern_value_t *valueToBeEvaluated = octaspire_container_vector_get_element_at(vec, 0);
    octaspire_helpers_verify_not_null(valueToBeEvaluated);

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *result = 0;

    if (octaspire_container_vector_get_length(vec) == 2)
    {
        octaspire_dern_value_t *envVal = octaspire_container_vector_get_element_at(vec, 1);
        octaspire_helpers_verify_not_null(envVal);

        if (envVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
        {
            result = octaspire_dern_vm_eval(vm, valueToBeEvaluated, envVal);
            octaspire_dern_vm_push_value(vm, result);
            octaspire_dern_value_t *tmpResult = octaspire_dern_vm_eval(vm, result, envVal);
            octaspire_dern_vm_pop_value(vm, result);
            result = tmpResult;
        }
        else
        {
            envVal = octaspire_dern_vm_eval(vm, envVal, environment);

            octaspire_helpers_verify_not_null(envVal);

            if (envVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
            {
                octaspire_dern_vm_pop_value(vm, arguments);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

                return envVal;
            }

            if (envVal->typeTag != OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
            {
                octaspire_dern_vm_pop_value(vm, arguments);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Second argument to special 'eval' must evaluate into environment value.\n"
                    "Now it evaluated into type %s.",
                    octaspire_dern_value_helper_get_type_as_c_string(envVal->typeTag));
            }

            octaspire_dern_vm_push_value(vm, envVal);
            result = octaspire_dern_vm_eval(vm, valueToBeEvaluated, envVal);
            octaspire_dern_vm_push_value(vm, result);
            octaspire_dern_value_t *tmpResult = octaspire_dern_vm_eval(vm, result, envVal);
            octaspire_dern_vm_pop_value(vm, result);
            octaspire_dern_vm_pop_value(vm, envVal);
            result = tmpResult;
        }
    }
    else
    {
        result = octaspire_dern_vm_eval(vm, valueToBeEvaluated, environment);
        octaspire_dern_vm_push_value(vm, result);
        octaspire_dern_value_t *tmpResult = octaspire_dern_vm_eval(vm, result, environment);
        octaspire_dern_vm_pop_value(vm, result);
        result = tmpResult;
    }

    octaspire_helpers_verify_not_null(result);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_special_quote(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'quote' expects one argument. %zu arguments were given.",
            octaspire_container_vector_get_length(vec));
    }

    octaspire_dern_value_t *quotedValue = octaspire_container_vector_get_element_at(vec, 0);

    octaspire_helpers_verify_not_null(quotedValue);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return quotedValue;
}

octaspire_dern_value_t *octaspire_dern_vm_special_select(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2 || numArgs % 2 != 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'select' expects at least two arguments and the number of arguments must be "
            "multiple of two. Now %zu arguments were given.",
            numArgs);
    }

    octaspire_dern_vm_push_value(vm, arguments);

    for (size_t i = 0; i < numArgs; i += 2)
    {
        octaspire_dern_value_t * testResult =
            octaspire_dern_value_as_vector_get_element_at(arguments, i);

        octaspire_helpers_verify_not_null(testResult);

        if (testResult->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL &&
            octaspire_container_utf8_string_is_equal_to_c_string(testResult->value.symbol, "default"))
        {
            if (i != (numArgs-2))
            {
                octaspire_dern_vm_pop_value(vm, arguments);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_from_c_string(
                    vm,
                    "'default' must be the last selector in special 'select'.");
            }
            else
            {
                octaspire_dern_value_t * result = octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(arguments, i + 1),
                    environment);

                octaspire_dern_vm_pop_value(vm, arguments);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return result;
            }
        }
        else
        {
            testResult = octaspire_dern_vm_eval(
                vm,
                octaspire_dern_value_as_vector_get_element_at(arguments, i),
                environment);

            octaspire_helpers_verify_not_null(testResult);

            if (testResult->typeTag != OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
            {
                if (testResult->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_dern_vm_pop_value(vm, arguments);
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                    return testResult;
                }
                else
                {
                    octaspire_dern_vm_pop_value(vm, arguments);
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                    return octaspire_dern_vm_create_new_value_error_format(
                        vm,
                        "Selectors of special 'select' must evaluate into booleans. Type '%s' was given.",
                        octaspire_dern_value_helper_get_type_as_c_string(testResult->typeTag));
                }
            }

            if (testResult->value.boolean)
            {
                octaspire_dern_value_t * result = octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(arguments, i + 1),
                    environment);

                octaspire_dern_vm_pop_value(vm, arguments);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return result;
            }
        }
    }

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_nil(vm);
}

octaspire_dern_value_t *octaspire_dern_vm_special_if(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 2 && numArgs != 3)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'if' expects two or three arguments. %zu arguments were given.",
            octaspire_dern_value_get_length(arguments));
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t * testResult = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_helpers_verify_not_null(testResult);
    octaspire_dern_vm_push_value(vm, testResult);

    if (testResult->typeTag == OCTASPIRE_DERN_VALUE_TAG_FUNCTION)
    {
        // Allow calling with   (fn () x)  instead of   ((fn (x) x))
        octaspire_dern_value_t *wrapperVecVal = octaspire_dern_vm_create_new_value_vector(vm);
        octaspire_dern_vm_push_value(vm, wrapperVecVal);
        octaspire_dern_value_as_vector_push_back_element(wrapperVecVal, &testResult);

        octaspire_dern_value_t * tmpVal = octaspire_dern_vm_eval(
            vm,
            wrapperVecVal,
            environment);

        octaspire_dern_vm_pop_value(vm, wrapperVecVal);
        // TODO is this needed, or does vector popping pop this too? Check...
        //octaspire_dern_vm_pop_value(vm, testResult);
        octaspire_dern_vm_pop_value(vm, testResult);
        testResult = tmpVal;
    }
    else
    {
        octaspire_dern_vm_pop_value(vm, testResult);
    }

    octaspire_helpers_verify_not_null(testResult);

    if (testResult->typeTag != OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
    {
        octaspire_dern_vm_pop_value(vm, arguments);

        if (testResult->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return testResult;
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "First argument to special 'if' must evaluate into boolean value. "
            "Now it evaluated into type %s.",
            octaspire_dern_value_helper_get_type_as_c_string(testResult->typeTag));
    }

    octaspire_dern_value_t *result = 0;

    if (octaspire_dern_value_get_length(arguments) == 2)
    {
        if (testResult->value.boolean)
        {
            result = octaspire_dern_vm_eval(
                vm,
                octaspire_dern_value_as_vector_get_element_at(arguments, 1),
                environment);
        }
        else
        {
            result = octaspire_dern_vm_get_value_nil(vm);
        }
    }
    else
    {
        result = octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, (testResult->value.boolean) ? 1 : 2),
            environment);
    }

    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_not_null(result);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_special_while(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'while' expects at least two arguments. %zu arguments were given.",
            octaspire_dern_value_get_length(arguments));
    }

    octaspire_dern_vm_push_value(vm, arguments);

    bool testStat = false;
    int32_t counter = 0;

    while (true)
    {
        octaspire_dern_value_t * const testResult = octaspire_dern_vm_eval(
            vm,
            octaspire_dern_value_as_vector_get_element_at(arguments, 0),
            environment);

        octaspire_helpers_verify_not_null(testResult);

        if (testResult->typeTag != OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
        {
            octaspire_dern_vm_pop_value(vm, arguments);

            if (testResult->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return testResult;
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to special 'while' must evaluate into boolean value. "
                "Now it evaluated into type %s.",
                octaspire_dern_value_helper_get_type_as_c_string(testResult->typeTag));
        }

        testStat = testResult->value.boolean;

        if (!testStat)
        {
            break;
        }

        for (size_t i = 1; i < numArgs; ++i)
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                vm,
                octaspire_dern_value_as_vector_get_element_at(arguments, i),
                environment);

            octaspire_helpers_verify_not_null(result);

            if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
            {
                octaspire_dern_vm_pop_value(vm, arguments);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return result;

            }

            if (octaspire_dern_vm_get_function_return(vm))
            {
                result = octaspire_dern_vm_get_function_return(vm);
                //octaspire_dern_vm_set_function_return(vm, 0);
                octaspire_dern_vm_pop_value(vm, arguments);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return result;
            }
        }

        ++counter;
    };

    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_integer(vm, counter);
}

octaspire_dern_value_t *octaspire_dern_vm_special_for(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t stepSize = 1; // Used for containers and numerical iteration.

    octaspire_dern_vm_push_value(vm, arguments);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 4)
    {
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'for' expects at least four (for iterating container or port) or five (for iterating numeric range) arguments. %zu arguments were given.",
            numArgs);
    }

    // 1. argument: counter symbol
    octaspire_dern_value_t *counterSymbol =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(counterSymbol);

    if (counterSymbol->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "First argument to special 'for' must be symbol value. "
            "Now it has type %s.",
            octaspire_dern_value_helper_get_type_as_c_string(counterSymbol->typeTag));
    }

    // 2. argument: 'in' or 'from' symbol
    octaspire_dern_value_t const * const inOrFromSymbol =
        octaspire_dern_value_as_vector_get_element_at(arguments, 1);

    octaspire_helpers_verify_not_null(inOrFromSymbol);

    if (inOrFromSymbol->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Second argument to special 'for' must be symbol 'in' or 'from'. "
            "Now it has type %s.",
            octaspire_dern_value_helper_get_type_as_c_string(inOrFromSymbol->typeTag));
    }

    if (octaspire_container_utf8_string_is_equal_to_c_string(inOrFromSymbol->value.symbol, "in"))
    {
        // (for i in '(1 2 3))
        // (for i in (hash-map a 1 b 2))
        // (for i in [kissa])

        // container
        octaspire_dern_value_t *container =
            octaspire_dern_value_as_vector_get_element_at(arguments, 2);

        octaspire_helpers_verify_not_null(container);

        container = octaspire_dern_vm_eval(vm, container, environment);

        octaspire_helpers_verify_not_null(container);

        octaspire_dern_vm_push_value(vm, container);

        if (container->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING      && 
            container->typeTag != OCTASPIRE_DERN_VALUE_TAG_VECTOR      &&
            container->typeTag != OCTASPIRE_DERN_VALUE_TAG_LIST        &&
            container->typeTag != OCTASPIRE_DERN_VALUE_TAG_QUEUE       &&
            container->typeTag != OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT &&
            container->typeTag != OCTASPIRE_DERN_VALUE_TAG_HASH_MAP    &&
            container->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Third argument to special 'for' using 'in' must be a container "
                "(string, vector, list, queue, hash map or environment) or a port. "
                "Now it has type %s.",
                octaspire_dern_value_helper_get_type_as_c_string(container->typeTag));

            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }




        // Check if there are optional 'step' and then integer
        size_t currentArgIdx = 3;

        // Optional 3 and 4. arguments: step integer
        octaspire_dern_value_t const * const optionalStep =
            octaspire_dern_value_as_vector_get_element_at(arguments, currentArgIdx);

        octaspire_helpers_verify_not_null(optionalStep);

        if (optionalStep->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL &&
            octaspire_container_utf8_string_is_equal_to_c_string(optionalStep->value.symbol, "step"))
        {
            if (numArgs < 5)
            {
                octaspire_dern_vm_pop_value(vm, container);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Special 'for' expects at least five arguments for iterating containers or ports with "
                    "a given step size. %zu arguments were given.",
                    numArgs);
            }

            // There is 'step'. Now an integer is required next
            ++currentArgIdx;

            octaspire_dern_value_t const * const requiredStepSize =
                octaspire_dern_value_as_vector_get_element_at(arguments, currentArgIdx);

            octaspire_helpers_verify_not_null(requiredStepSize);

            if (requiredStepSize->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
            {
                octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Fifth argument to special 'for' using 'step' with containers must be "
                    "an integer step size. Now it has type %s.",
                    octaspire_dern_value_helper_get_type_as_c_string(requiredStepSize->typeTag));

                octaspire_dern_vm_pop_value(vm, container);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return result;
            }

            if (requiredStepSize->value.integer <= 0)
            {
                octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "The 'step' of special 'for' must be larger than zero. "
                    "Now it is %" PRId32 ".",
                    requiredStepSize->value.integer);

                octaspire_dern_vm_pop_value(vm, container);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return result;
            }

            stepSize = requiredStepSize->value.integer;
        }




        // Extend env for the counter variable
        octaspire_dern_environment_t *extendedEnvironment =
            octaspire_dern_environment_new(
                environment,
                vm,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_helpers_verify_not_null(extendedEnvironment);

        octaspire_dern_value_t *extendedEnvVal =
            octaspire_dern_vm_create_new_value_environment_from_environment(vm, extendedEnvironment);

        octaspire_helpers_verify_not_null(extendedEnvVal);

        octaspire_dern_vm_push_value(vm, extendedEnvVal);





        if (container->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING)
        {
            octaspire_container_utf8_string_t const * const str = container->value.string;
            size_t const strLen = octaspire_container_utf8_string_get_length_in_ucs_characters(str);

            int32_t counter = 0;

            for (size_t i = 0; i < strLen; i += stepSize)
            {
                octaspire_container_utf8_string_t *charStr = octaspire_container_utf8_string_new(
                    "",
                    octaspire_dern_vm_get_allocator(vm));

                octaspire_container_utf8_string_push_back_ucs_character(
                    charStr,
                    octaspire_container_utf8_string_get_ucs_character_at_index(str, i));

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_dern_vm_create_new_value_character(vm, charStr));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(arguments, j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else if (container->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR)
        {
            octaspire_container_vector_t * const vec = container->value.vector;
            size_t const vecLen = octaspire_container_vector_get_length(vec);

            int32_t counter = 0;

            for (size_t i = 0; i < vecLen; i += stepSize)
            {
                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_container_vector_get_element_at(vec, i));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(arguments, j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }



        else if (container->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST)
        {
            octaspire_container_list_t * const list = container->value.list;
            size_t const listLen = octaspire_container_list_get_length(list);

            int32_t counter = 0;

            // TODO more efficient iteration of list
            for (size_t i = 0; i < listLen; i += stepSize)
            {
                octaspire_container_list_node_t *node =
                    octaspire_container_list_get_at(list, i);

                octaspire_helpers_verify_not_null(node);

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_container_list_node_get_element(node));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(arguments, j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else if (container->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE)
        {
            octaspire_container_queue_t * const queue = container->value.queue;
            size_t const queueLen = octaspire_container_queue_get_length(queue);

            int32_t counter = 0;

            // TODO more efficient iteration of queue
            for (size_t i = 0; i < queueLen; i += stepSize)
            {
                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_container_queue_get_at(queue, i));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(arguments, j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }










        else if (container->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
        {
            octaspire_dern_environment_t * const env = container->value.environment;
            size_t const envLen = octaspire_dern_environment_get_length(env);

            int32_t counter = 0;

            for (size_t i = 0; i < envLen; i += stepSize)
            {
                octaspire_container_hash_map_element_t *element =
                    octaspire_dern_environment_get_at_index(env, i);

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_dern_vm_create_new_value_vector_from_values(
                        vm,
                        2,
                        octaspire_container_hash_map_element_get_key(element),
                        octaspire_container_hash_map_element_get_value(element)));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(arguments, j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else if(container->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP)
        {
            octaspire_container_hash_map_t * const hashMap = container->value.hashMap;
            size_t const hashMapLen = octaspire_container_hash_map_get_number_of_elements(hashMap);

            int32_t counter = 0;

            for (size_t i = 0; i < hashMapLen; i += stepSize)
            {
                octaspire_container_hash_map_element_t *element =
                    octaspire_container_hash_map_get_at_index(hashMap, i);

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_dern_vm_create_new_value_vector_from_values(
                        vm,
                        2,
                        octaspire_container_hash_map_element_get_key(element),
                        octaspire_container_hash_map_element_get_value(element)));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(arguments, j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else if(container->typeTag == OCTASPIRE_DERN_VALUE_TAG_PORT)
        {
            octaspire_dern_port_t * const port = container->value.port;

            int32_t counter = 0;
            size_t  skip    = 0;

            bool noMoreInput = false;

            while (!noMoreInput)
            {
                char buffer[1];

                for (size_t i = 0; i < skip; ++i)
                {
                    if (octaspire_dern_port_read(port, buffer, sizeof(char)) < 1)
                    {
                        noMoreInput = true;
                        break;
                    }
                }

                if (noMoreInput)
                {
                    break;
                }

                if (octaspire_dern_port_read(port, buffer, sizeof(char)) < 1)
                {
                    noMoreInput = true;
                    break;
                }

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    octaspire_dern_vm_create_new_value_integer(vm, (int32_t)buffer[0]));

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(arguments, j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, container);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }

                }

                skip = (stepSize - 1);

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, container);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else
        {
            abort();
        }
    }
    else if (octaspire_container_utf8_string_is_equal_to_c_string(inOrFromSymbol->value.symbol, "from"))
    {
        // (for i from 0 to 100)
        // TODO XXX



        // 0
        octaspire_dern_value_t *fromValue =
            octaspire_dern_value_as_vector_get_element_at(arguments, 2);

        octaspire_helpers_verify_not_null(fromValue);

        fromValue = octaspire_dern_vm_eval(vm, fromValue, environment);

        octaspire_helpers_verify_not_null(fromValue);

        octaspire_dern_vm_push_value(vm, fromValue);

        if (fromValue->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Third argument to special 'for' using 'from' must be integer. "
                "Now it has type %s.",
                octaspire_dern_value_helper_get_type_as_c_string(fromValue->typeTag));

            octaspire_dern_vm_pop_value(vm, fromValue);
            octaspire_dern_vm_pop_value(vm, arguments);

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }




        // 100
        octaspire_dern_value_t *toValue =
            octaspire_dern_value_as_vector_get_element_at(arguments, 4);

        octaspire_helpers_verify_not_null(toValue);

        toValue = octaspire_dern_vm_eval(vm, toValue, environment);

        octaspire_helpers_verify_not_null(toValue);

        octaspire_dern_vm_push_value(vm, toValue);

        if (toValue->typeTag != fromValue->typeTag)
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Fifth argument to special 'for' using 'from' must be of same type than the third (%s). "
                "Now it has type %s.",
                octaspire_dern_value_helper_get_type_as_c_string(fromValue->typeTag),
                octaspire_dern_value_helper_get_type_as_c_string(toValue->typeTag));

            octaspire_dern_vm_pop_value(vm, toValue);
            octaspire_dern_vm_pop_value(vm, fromValue);
            octaspire_dern_vm_pop_value(vm, arguments);

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }




        // Check if there are optional 'step' and then integer
        size_t currentArgIdx = 5;

        // Optional 5. and 6. arguments: step integer
        octaspire_dern_value_t const * const optionalStep =
            octaspire_dern_value_as_vector_get_element_at(arguments, currentArgIdx);

        octaspire_helpers_verify_not_null(optionalStep);

        if (optionalStep->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL &&
            octaspire_container_utf8_string_is_equal_to_c_string(optionalStep->value.symbol, "step"))
        {
            if (numArgs < 7)
            {
                octaspire_dern_vm_pop_value(vm, toValue);
                octaspire_dern_vm_pop_value(vm, fromValue);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Special 'for' expects at least seven arguments in numeric form with "
                    "a given step size. %zu arguments were given.",
                    numArgs);
            }

            // There is 'step'. Now an integer is required next
            ++currentArgIdx;

            octaspire_dern_value_t const * const requiredStepSize =
                octaspire_dern_value_as_vector_get_element_at(arguments, currentArgIdx);

            octaspire_helpers_verify_not_null(requiredStepSize);

            if (requiredStepSize->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
            {
                octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Seventh argument to special 'for' using 'step' with numeric iteration must be "
                    "an integer step size. Now it has type %s.",
                    octaspire_dern_value_helper_get_type_as_c_string(requiredStepSize->typeTag));

                octaspire_dern_vm_pop_value(vm, toValue);
                octaspire_dern_vm_pop_value(vm, fromValue);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return result;
            }

            if (requiredStepSize->value.integer <= 0)
            {
                octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "The 'step' of special 'for' must be larger than zero. "
                    "Now it is %" PRId32 ".",
                    requiredStepSize->value.integer);

                octaspire_dern_vm_pop_value(vm, toValue);
                octaspire_dern_vm_pop_value(vm, fromValue);
                octaspire_dern_vm_pop_value(vm, arguments);

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return result;
            }


            stepSize = requiredStepSize->value.integer;
        }









        // Extend env for the counter variable
        octaspire_dern_environment_t *extendedEnvironment =
            octaspire_dern_environment_new(
                environment,
                vm,
                octaspire_dern_vm_get_allocator(vm));

        octaspire_helpers_verify_not_null(extendedEnvironment);

        octaspire_dern_value_t *extendedEnvVal =
            octaspire_dern_vm_create_new_value_environment_from_environment(vm, extendedEnvironment);

        octaspire_helpers_verify_not_null(extendedEnvVal);

        octaspire_dern_vm_push_value(vm, extendedEnvVal);

        bool const fromIsSmaller = octaspire_dern_value_is_less_than_or_equal(fromValue, toValue);

        if (fromIsSmaller)
        {
            size_t const numIterations = (toValue->value.integer - fromValue->value.integer) + 1;

            int32_t counter = 0;

            for (size_t i = 0; i < numIterations; i += stepSize)
            {
                octaspire_dern_value_t *iterator =
                    octaspire_dern_vm_create_new_value_copy(vm, fromValue);

                iterator->value.integer += i;

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    iterator);

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(arguments, j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, toValue);
                        octaspire_dern_vm_pop_value(vm, fromValue);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, toValue);
                        octaspire_dern_vm_pop_value(vm, fromValue);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, toValue);
            octaspire_dern_vm_pop_value(vm, fromValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
        else
        {
            size_t const numIterations = (fromValue->value.integer - toValue->value.integer) + 1;

            int32_t counter = 0;

            for (size_t i = 0; i < numIterations; i += stepSize)
            {
                octaspire_dern_value_t *iterator =
                    octaspire_dern_vm_create_new_value_copy(vm, fromValue);

                iterator->value.integer -= i;

                octaspire_dern_environment_set(
                    extendedEnvironment,
                    counterSymbol,
                    iterator);

                for (size_t j = currentArgIdx; j < numArgs; ++j)
                {
                    octaspire_dern_value_t *result = octaspire_dern_vm_eval(
                        vm,
                        octaspire_dern_value_as_vector_get_element_at(arguments, j),
                        extendedEnvVal);

                    octaspire_helpers_verify_not_null(result);

                    if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                    {
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, toValue);
                        octaspire_dern_vm_pop_value(vm, fromValue);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }

                    if (octaspire_dern_vm_get_function_return(vm))
                    {
                        result = octaspire_dern_vm_get_function_return(vm);
                        //octaspire_dern_vm_set_function_return(vm, 0);
                        octaspire_dern_vm_pop_value(vm, extendedEnvVal);
                        octaspire_dern_vm_pop_value(vm, toValue);
                        octaspire_dern_vm_pop_value(vm, fromValue);
                        octaspire_dern_vm_pop_value(vm, arguments);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return result;
                    }
                }

                ++counter;
            }

            octaspire_dern_vm_pop_value(vm, extendedEnvVal);
            octaspire_dern_vm_pop_value(vm, toValue);
            octaspire_dern_vm_pop_value(vm, fromValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_integer(vm, counter);
        }
    }

    abort();
    return 0;
}

// TODO move to other builtins
octaspire_dern_value_t *octaspire_dern_vm_builtin_starts_with_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'starts-with?' expects two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    octaspire_dern_value_t *secondArg = octaspire_dern_value_as_vector_get_element_at(arguments, 1);
    octaspire_helpers_verify_not_null(secondArg);

    if (firstArg->typeTag != secondArg->typeTag)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_get_value_false(vm);
    }

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        // TODO XXX implement rest of the fitting types
        abort();
    }

    bool const result = octaspire_container_utf8_string_starts_with(
        firstArg->value.string,
        secondArg->value.string);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, result);
}

/*
    (= num 10)                         ; set variable to
    (= vec 1 [kissa])                  ; set vector index to
    (= map [john] [305-3848506428])    ; set map for key to
    (= str 1 |a|)                      ; set character of string at index to
*/
octaspire_dern_value_t *octaspire_dern_vm_builtin_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2 || numArgs > 3)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '=' expects two or three arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (numArgs == 2)
    {
        octaspire_dern_value_t *secondArg = octaspire_dern_value_as_vector_get_element_at(arguments, 1);
        octaspire_helpers_verify_not_null(secondArg);

        if (octaspire_dern_value_set(firstArg, secondArg))
        {
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            //return octaspire_dern_vm_get_value_true(vm);
            return firstArg;
        }

        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(vm, "Builtin '=' failed");
    }
    else
    {
        octaspire_dern_value_t *secondArg = octaspire_dern_value_as_vector_get_element_at(arguments, 1);
        octaspire_helpers_verify_not_null(secondArg);

        octaspire_dern_value_t *thirdArg = octaspire_dern_value_as_vector_get_element_at(arguments, 2);
        octaspire_helpers_verify_not_null(thirdArg);

        if (octaspire_dern_value_set_collection(firstArg, secondArg, thirdArg))
        {
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            //return octaspire_dern_vm_get_value_true(vm);
            return firstArg;
        }

        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(vm, "Builtin '=' failed");
    }
}


octaspire_dern_value_t *octaspire_dern_vm_builtin_equals_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '==' expects at least two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstValue = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_dern_vm_push_value(vm, firstValue);

    for (size_t i = 1; i < numArgs; ++i)
    {
        if (!octaspire_dern_value_is_equal(
                firstValue,
                octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(arguments, i),
                    environment)))
        {
            octaspire_dern_vm_pop_value(vm, firstValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_get_value_false(vm);
        }
    }

    octaspire_dern_vm_pop_value(vm, firstValue);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}

// TODO move to other builtins
octaspire_dern_value_t *octaspire_dern_vm_builtin_exclamation_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    octaspire_dern_value_t *tmpVal =
        octaspire_dern_vm_builtin_equals_equals(vm, arguments, environment);

    if (tmpVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
    {
        return tmpVal;
    }

    if (tmpVal->typeTag != OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
    {
        abort();
    }

    return octaspire_dern_vm_create_new_value_boolean(vm, !tmpVal->value.boolean);
}

octaspire_dern_value_t *octaspire_dern_vm_special_less_than_or_equal(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Special '<=' expects at least two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstValue = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_dern_vm_push_value(vm, firstValue);

    for (size_t i = 1; i < numArgs; ++i)
    {
        if (!octaspire_dern_value_is_less_than_or_equal(
                firstValue,
                octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(arguments, i),
                    environment)))
        {
            octaspire_dern_vm_pop_value(vm, firstValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_get_value_false(vm);
        }
    }

    octaspire_dern_vm_pop_value(vm, firstValue);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}

octaspire_dern_value_t *octaspire_dern_vm_special_less_than(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Special '<' expects at least two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstValue = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_dern_vm_push_value(vm, firstValue);

    for (size_t i = 1; i < numArgs; ++i)
    {
        if (!octaspire_dern_value_is_less_than(
                firstValue,
                octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(arguments, i),
                    environment)))
        {
            octaspire_dern_vm_pop_value(vm, firstValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_get_value_false(vm);
        }
    }

    octaspire_dern_vm_pop_value(vm, firstValue);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}

octaspire_dern_value_t *octaspire_dern_vm_special_greater_than(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Special '>' expects at least two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstValue = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_dern_vm_push_value(vm, firstValue);

    for (size_t i = 1; i < numArgs; ++i)
    {
        if (!octaspire_dern_value_is_greater_than(
                firstValue,
                octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(arguments, i),
                    environment)))
        {
            octaspire_dern_vm_pop_value(vm, firstValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_get_value_false(vm);
        }
    }

    octaspire_dern_vm_pop_value(vm, firstValue);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}

octaspire_dern_value_t *octaspire_dern_vm_special_greater_than_or_equal(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Special '>=' expects at least two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstValue = octaspire_dern_vm_eval(
        vm,
        octaspire_dern_value_as_vector_get_element_at(arguments, 0),
        environment);

    octaspire_dern_vm_push_value(vm, firstValue);

    for (size_t i = 1; i < numArgs; ++i)
    {
        if (!octaspire_dern_value_is_greater_than_or_equal(
                firstValue,
                octaspire_dern_vm_eval(
                    vm,
                    octaspire_dern_value_as_vector_get_element_at(arguments, i),
                    environment)))
        {
            octaspire_dern_vm_pop_value(vm, firstValue);
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_get_value_false(vm);
        }
    }

    octaspire_dern_vm_pop_value(vm, firstValue);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}

octaspire_dern_value_t *octaspire_dern_stdlib_private_validate_function(
    octaspire_dern_vm_t* vm,
    octaspire_dern_function_t *function)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_not_null(function);
    octaspire_helpers_verify_not_null(function->formals);
    octaspire_helpers_verify_true(function->formals->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_not_null(function->body);
    octaspire_helpers_verify_true(function->body->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_not_null(function->definitionEnvironment);
    octaspire_helpers_verify_true(function->definitionEnvironment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);
    octaspire_helpers_verify_not_null(function->allocator);

    size_t const numFormalArgs = octaspire_container_vector_get_length(
        function->formals->value.vector);

    size_t numDotArgs            = 0;
    size_t numNormalArgs         = 0;
    size_t numNormalArgsAfterDot = 0;

    for (size_t i = 0; i < numFormalArgs; ++i)
    {
        octaspire_dern_value_t *formal = octaspire_container_vector_get_element_at(
            function->formals->value.vector,
            i);

        octaspire_helpers_verify_true(formal->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

        octaspire_container_utf8_string_t const * const formalAsStr = formal->value.string;

        if (octaspire_container_utf8_string_is_equal_to_c_string(formalAsStr, "."))
        {
            ++numDotArgs;
        }
        else
        {
            if (numDotArgs)
            {
                ++numNormalArgsAfterDot;
            }
            else
            {
                ++numNormalArgs;
            }
        }
    }

    if (numDotArgs > 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Function can have only one formal . for varargs. Now %zu dots were given.",
            numDotArgs);
    }

    if (numNormalArgsAfterDot > 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Function can have only one formal argument after . "
            "for varargs. Now %zu formals were given after dot.",
            numNormalArgsAfterDot);
    }

    if (numDotArgs == 0 && numNormalArgs != numFormalArgs)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Number of formal and actual arguments must be equal for functions without "
            "varargs using the dot-formal. Now %zu formal and %zu actual arguments were given.",
            numFormalArgs,
            numNormalArgs);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_special_fn(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_dern_vm_push_value(vm, arguments);
    octaspire_dern_vm_push_value(vm, environment);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) < 2)
    {
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'fn' expects at least two arguments. %zu arguments were given.",
            octaspire_container_vector_get_length(vec));
    }

    octaspire_dern_value_t *formals = octaspire_container_vector_get_element_at(vec, 0);

    if (formals->typeTag != OCTASPIRE_DERN_VALUE_TAG_VECTOR)
    {
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "First argument to special 'fn' must be vector (formals). Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(formals->typeTag));
    }

    octaspire_dern_value_t *body = octaspire_dern_vm_create_new_value_vector(vm);

    octaspire_dern_vm_push_value(vm, body);

    for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
    {
        octaspire_dern_value_t *tmpPtr = octaspire_container_vector_get_element_at(vec, i);

        if (tmpPtr->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_dern_vm_pop_value(vm, body);
            octaspire_dern_vm_pop_value(vm, environment);
            octaspire_dern_vm_pop_value(vm, arguments);

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return tmpPtr;
        }

        if (!octaspire_dern_value_as_vector_push_back_element(
            body,
            &tmpPtr))
        {
            abort();
        }
    }

    octaspire_dern_function_t *function = octaspire_dern_function_new(
        formals,
        body,
        environment,
        octaspire_dern_vm_get_allocator(vm));

    if (!function)
    {
        octaspire_dern_vm_pop_value(vm, body);
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Allocation failure when creating function.");
    }

    octaspire_dern_value_t *error = octaspire_dern_stdlib_private_validate_function(vm, function);

    if (error)
    {
        octaspire_dern_vm_pop_value(vm, body);
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return error;
    }

    // Real docstring is set by define
    octaspire_dern_value_t * result = octaspire_dern_vm_create_new_value_function(vm, function, "", 0);

    octaspire_dern_vm_pop_value(vm, body);
    octaspire_dern_vm_pop_value(vm, environment);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_uid(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_dern_vm_push_value(vm, arguments);
    octaspire_dern_vm_push_value(vm, environment);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) != 1)
    {
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Special 'uid' expects exactly one argument. %zu arguments were given.",
            octaspire_container_vector_get_length(vec));
    }

    uintmax_t const uid =
        octaspire_dern_value_get_unique_id(octaspire_container_vector_get_element_at(vec, 0));

    if (uid > INT32_MAX)
    {
        abort();
    }

    octaspire_dern_value_t * result =
        octaspire_dern_vm_create_new_value_integer(vm, (int32_t)uid);

    octaspire_dern_vm_pop_value(vm, environment);
    octaspire_dern_vm_pop_value(vm, arguments);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_abort(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'abort' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    octaspire_dern_value_print(firstArg, octaspire_dern_vm_get_allocator(vm));

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    abort();
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_input_file_open(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    if (!octaspire_dern_vm_is_file_system_access_allowed(vm))
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'input-file-open' cannot be executed; file system access is denied by VM. "
            "Enable file system access in VM before trying to run this code.");
    }

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'input-file-open' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'input-file-open' expects string argument.");
    }

    octaspire_dern_value_t * const result = octaspire_dern_vm_create_new_value_input_file(
        vm,
        octaspire_dern_value_as_string_get_c_string(firstArg));

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_output_file_open(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    if (!octaspire_dern_vm_is_file_system_access_allowed(vm))
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'output-file-open' cannot be executed; file system access is denied by VM. "
            "Enable file system access in VM before trying to run this code.");
    }

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'output-file-open' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'output-file-open' expects string argument.");
    }

    octaspire_dern_value_t * const result = octaspire_dern_vm_create_new_value_output_file(
        vm,
        octaspire_dern_value_as_string_get_c_string(firstArg));

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_io_file_open(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    if (!octaspire_dern_vm_is_file_system_access_allowed(vm))
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'io-file-open' cannot be executed; file system access is denied by VM. "
            "Enable file system access in VM before trying to run this code.");
    }

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'io-file-open' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'io-file-open' expects string argument.");
    }

    octaspire_dern_value_t * const result = octaspire_dern_vm_create_new_value_io_file(
        vm,
        octaspire_dern_value_as_string_get_c_string(firstArg));

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_supports_output_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-supports-output?' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-supports-output?' expects port argument.");
    }

    bool const result = octaspire_dern_port_supports_output(firstArg->value.port);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, result);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_supports_input_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-supports-input?' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-supports-input?' expects port argument.");
    }

    bool const result = octaspire_dern_port_supports_input(firstArg->value.port);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, result);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_close(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-close' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-close' expects port argument.");
    }

    bool const wasClosed = octaspire_dern_port_close(firstArg->value.port);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, wasClosed);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_read(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1 && numArgs != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-read' expects one or two arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'port-read' must be a port. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    octaspire_dern_value_t *result = 0;

    if (numArgs == 2)
    {
        octaspire_dern_value_t *secondArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, 1);

        octaspire_helpers_verify_not_null(secondArg);

        if (secondArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
        {
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "The second argument to builtin 'port-read' must be an integer. Now type %s was given.",
                octaspire_dern_value_helper_get_type_as_c_string(secondArg->typeTag));
        }

        result = octaspire_dern_vm_create_new_value_vector(vm);

        octaspire_helpers_verify_not_null(result);

        octaspire_dern_vm_push_value(vm, result);

        // TODO better implementation
        for (ptrdiff_t i = 0; i < secondArg->value.integer; ++i)
        {
            char buffer[1];

            ptrdiff_t const numOctetsRead =
                octaspire_dern_port_read(firstArg->value.port, buffer, sizeof(buffer));

            if (numOctetsRead != 1)
            {
                break;
            }

            octaspire_dern_value_t *elem =
                octaspire_dern_vm_create_new_value_integer(vm, (int32_t)buffer[0]);

            octaspire_helpers_verify_not_null(elem);

            octaspire_dern_vm_push_value(vm, elem);
            octaspire_dern_value_as_vector_push_back_element(result, &elem);
            octaspire_dern_vm_pop_value(vm, elem);
        }

        octaspire_helpers_verify_not_null(result);

        octaspire_dern_vm_pop_value(vm, result);
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }
    else
    {
        char buffer[1];

        ptrdiff_t const numOctetsRead =
            octaspire_dern_port_read(firstArg->value.port, buffer, sizeof(buffer));

        if (numOctetsRead != 1)
        {
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'port-read' failed to read the requested one octet.");
        }

        result = octaspire_dern_vm_create_new_value_integer(vm, (int32_t)buffer[0]);

        octaspire_helpers_verify_not_null(result);

        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_write(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'port-write' expects exactly two arguments. %zu argument were given.",
            numArgs);
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'port-write' must be a port. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    if (!octaspire_dern_port_supports_output(firstArg->value.port))
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "The first argument to builtin 'port-write' must be a port supporting writing.");
    }

    octaspire_dern_value_t *secondArg = octaspire_dern_value_as_vector_get_element_at(arguments, 1);
    octaspire_helpers_verify_not_null(secondArg);

    if (secondArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER)
    {
        // TODO XXX check that value fits into one octet and report
        // error otherwise
        char buffer[1];
        buffer[0] = (char)secondArg->value.integer;

        ptrdiff_t const numWritten =
            octaspire_dern_port_write(firstArg->value.port, buffer, sizeof(buffer));

        octaspire_helpers_verify_true(numWritten >= 0);

        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_integer(vm, (int32_t)numWritten);
    }
    else if (secondArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER)
    {
        octaspire_container_utf8_string_t *str = secondArg->value.character;
        char const * const buffer = octaspire_container_utf8_string_get_c_string(str);
        size_t bufferLen = octaspire_container_utf8_string_get_length_in_octets(str);

        ptrdiff_t const numWritten =
            octaspire_dern_port_write(firstArg->value.port, buffer, bufferLen);

            if (numWritten < 0 || (size_t)numWritten != bufferLen)
            {
                octaspire_dern_vm_pop_value(vm, arguments);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Writing of %zu octets of character failed. Only %zu octets were written.",
                    bufferLen,
                    numWritten);
            }
            else
            {
                octaspire_dern_vm_pop_value(vm, arguments);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_integer(vm, bufferLen);
            }
    }
    else if (secondArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_container_utf8_string_t *str = secondArg->value.string;
        char const * const buffer = octaspire_container_utf8_string_get_c_string(str);
        size_t bufferLen = octaspire_container_utf8_string_get_length_in_octets(str);

        ptrdiff_t const numWritten =
            octaspire_dern_port_write(firstArg->value.port, buffer, bufferLen);

            if (numWritten < 0 || (size_t)numWritten != bufferLen)
            {
                octaspire_dern_vm_pop_value(vm, arguments);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Writing of %zu octets of string failed. Only %zu octets were written.",
                    bufferLen,
                    numWritten);
            }
            else
            {
                octaspire_dern_vm_pop_value(vm, arguments);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_integer(vm, bufferLen);
            }
    }
    else if (secondArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR)
    {
        int32_t counter = 0;
        for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(secondArg); ++i)
        {
            octaspire_dern_value_t * const elem =
                octaspire_dern_value_as_vector_get_element_at(secondArg, i);

            octaspire_helpers_verify_not_null(elem);

            octaspire_dern_value_t *tmpArgs = octaspire_dern_vm_create_new_value_vector(vm);
            octaspire_dern_vm_push_value(vm, tmpArgs);

            octaspire_dern_value_as_vector_push_back_element(tmpArgs, &firstArg);
            octaspire_dern_value_as_vector_push_back_element(tmpArgs, &elem);

            octaspire_dern_value_t * const countVal =
                octaspire_dern_vm_builtin_port_write(vm, tmpArgs, environment);

            octaspire_dern_vm_pop_value(vm, tmpArgs);

            octaspire_helpers_verify_not_null(countVal);

            if (countVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
            {
                octaspire_dern_vm_pop_value(vm, arguments);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return countVal;
            }

            octaspire_helpers_verify_true(countVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER);

            counter += countVal->value.integer;
        }

        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_integer(vm, counter);
    }
    else
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The second argument to builtin 'port-write' must be an integer, character, string\n"
            "or a vector of these types. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(secondArg->typeTag));
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_seek(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 2 && numArgs != 3)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-seek' expects two or three arguments.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'port-seek' must be a port. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    octaspire_dern_value_t *secondArg = octaspire_dern_value_as_vector_get_element_at(arguments, 1);
    octaspire_helpers_verify_not_null(secondArg);

    if (secondArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The second argument to builtin 'port-seek' must be an integer. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(secondArg->typeTag));
    }

    bool seekFromCurrentPosition = false;

    if (numArgs == 3)
    {
        octaspire_dern_value_t *thirdArg = octaspire_dern_value_as_vector_get_element_at(arguments, 2);
        octaspire_helpers_verify_not_null(thirdArg);

        if (thirdArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
        {
            octaspire_dern_vm_pop_value(vm, arguments);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "The third argument to builtin 'port-seek' must be symbol 'from-current'. "
                "Now type %s was given.",
                octaspire_dern_value_helper_get_type_as_c_string(thirdArg->typeTag));
        }

        seekFromCurrentPosition = true;
    }

    bool const success = octaspire_dern_port_seek(
        firstArg->value.port,
        secondArg->value.integer,
        seekFromCurrentPosition);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, success);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_dist(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-dist' expects exactly one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'port-dist' must be a port. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    ptrdiff_t dist = octaspire_dern_port_distance(firstArg->value.port);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    // TODO check that dist fits into int32_t and report error if it doesn'tk
    return octaspire_dern_vm_create_new_value_integer(vm, (int32_t)dist);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_length(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-length' expects exactly one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'port-length' must be a port. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    ptrdiff_t length  = octaspire_dern_port_get_length_in_octets(firstArg->value.port);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    // TODO check that length fits into int32_t and report error if it doesn'tk
    return octaspire_dern_vm_create_new_value_integer(vm, (int32_t)length);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_port_flush(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'port-flush' expects exactly one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_PORT)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'port-flush' must be a port. Now type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    bool const success = octaspire_dern_port_flush(firstArg->value.port);

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, success);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_not(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'not' expects one argument.");
    }

    octaspire_dern_vm_push_value(vm, arguments);

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
    {
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'not' expects boolean argument.");
    }

    bool const given = firstArg->value.boolean;

    octaspire_dern_vm_pop_value(vm, arguments);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, !given);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_return(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs > 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'return' expects zero or one arguments. %zu arguments were given.",
            numArgs);
    }

    if (numArgs == 1)
    {
        octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
        octaspire_helpers_verify_not_null(firstArg);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        octaspire_helpers_verify_true(octaspire_dern_vm_get_function_return(vm) == 0);

        octaspire_dern_vm_set_function_return(vm, firstArg);
        return firstArg;
    }
    else
    {
        octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_nil(vm);
        octaspire_helpers_verify_not_null(result);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        octaspire_helpers_verify_true(octaspire_dern_vm_get_function_return(vm) == 0);

        octaspire_dern_vm_set_function_return(vm, result);
        return result;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_vector(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_vector(vm);

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(arguments); ++i)
    {
        octaspire_dern_value_t * arg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                i);

        if (octaspire_dern_value_is_atom(arg))
        {
            arg = octaspire_dern_vm_create_new_value_copy(vm, arg);
        }

        octaspire_dern_value_as_vector_push_back_element(result, &arg);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_special_and(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_boolean(vm, true);
    }

    octaspire_dern_value_t *result = 0;

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(arguments); ++i)
    {
        octaspire_dern_value_t * const arg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                i);

        octaspire_helpers_verify_not_null(arg);

        result = octaspire_dern_vm_eval(vm, arg, environment);

        if (octaspire_dern_vm_get_function_return(vm))
        {
            result = octaspire_dern_vm_get_function_return(vm);
            break;
        }

        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
        {
            if (!result->value.boolean)
            {
                break;
            }
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_special_or(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_boolean(vm, false);
    }

    octaspire_dern_value_t *result = 0;

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(arguments); ++i)
    {
        octaspire_dern_value_t * const arg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                i);

        octaspire_helpers_verify_not_null(arg);

        result = octaspire_dern_vm_eval(vm, arg, environment);

        if (octaspire_dern_vm_get_function_return(vm))
        {
            result = octaspire_dern_vm_get_function_return(vm);
            break;
        }

        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_BOOLEAN)
        {
            if (result->value.boolean)
            {
                break;
            }
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_special_do(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Special 'do' expects at least one argument.");
    }

    octaspire_dern_value_t *result = 0;

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(arguments); ++i)
    {
        octaspire_dern_value_t * const arg =
            octaspire_dern_value_as_vector_get_element_at(
                arguments,
                i);

        octaspire_helpers_verify_not_null(arg);

        result = octaspire_dern_vm_eval(vm, arg, environment);

        if (octaspire_dern_vm_get_function_return(vm))
        {
            result = octaspire_dern_vm_get_function_return(vm);
            //octaspire_dern_vm_set_function_return(vm, 0);
            break;
        }

        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_container_utf8_string_t *tmpStr =
                octaspire_dern_value_to_string(arg, octaspire_dern_vm_get_allocator(vm));

            octaspire_container_utf8_string_concatenate_format(
                result->value.string,
                "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                octaspire_container_utf8_string_get_c_string(tmpStr));

            octaspire_container_utf8_string_release(tmpStr);
            tmpStr = 0;

            break;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_nth(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'nth' expects two arguments.");
    }

    octaspire_dern_value_t const * const firstArg =
        octaspire_dern_value_as_vector_get_element_at_const(
            arguments,
            0);

    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "First argument to builtin 'nth' must be integer. Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    size_t const index = firstArg->value.integer;

    octaspire_dern_value_t * const secondArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 1);

    octaspire_helpers_verify_not_null(secondArg);

    if (secondArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        if (index >= octaspire_container_utf8_string_get_length_in_ucs_characters(secondArg->value.string))
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Builtin 'nth' cannot index string of length %zu from index %zu.",
                octaspire_container_utf8_string_get_length_in_ucs_characters(secondArg->value.string),
                index);
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_character_from_uint32t(
            vm, octaspire_container_utf8_string_get_ucs_character_at_index(secondArg->value.string, index));
    }
    else if (secondArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR)
    {
        if (index >= octaspire_container_vector_get_length(secondArg->value.vector))
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Builtin 'nth' cannot index vector of length %zu from index %zu.",
                octaspire_container_vector_get_length(secondArg->value.vector),
                index);
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_container_vector_get_element_at(secondArg->value.vector, index);
    }
    else if (secondArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP)
    {
        if (index >= octaspire_container_hash_map_get_number_of_elements(secondArg->value.hashMap))
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Builtin 'nth' cannot index hash map of length %zu from index %zu.",
                octaspire_container_hash_map_get_number_of_elements(secondArg->value.hashMap),
                index);
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

        octaspire_container_hash_map_element_t *element =
            octaspire_container_hash_map_get_at_index(secondArg->value.hashMap, index);

        octaspire_helpers_verify_not_null(element);

        return octaspire_container_hash_map_element_get_value(element);
    }
    else
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Second argument to builtin 'nth' must be one of the collection types. Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(secondArg->typeTag));
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_exit(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) > 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'exit' expects zero or one argument.");
    }

    if (octaspire_container_vector_get_length(vec) == 1)
    {
        octaspire_dern_value_t *value = octaspire_container_vector_get_element_at(vec, 0);

        if (value->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Builtin 'exit' expects integer argument. Type %s was given.",
                octaspire_dern_value_helper_get_type_as_c_string(value->typeTag));
        }

        octaspire_dern_vm_set_exit_code(vm, value->value.integer);
    }

    octaspire_dern_vm_quit(vm);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}


octaspire_dern_value_t *octaspire_dern_vm_builtin_doc(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'doc' expects at least one argument.");
    }

    if (octaspire_container_vector_get_length(vec) == 1)
    {
        octaspire_dern_value_t *value = octaspire_container_vector_get_element_at(vec, 0);

        if (value->docstr)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return value->docstr;
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_get_value_nil(vm);
    }
    else
    {
        octaspire_container_vector_t *resultVec = octaspire_container_vector_new(
            sizeof(octaspire_dern_value_t*),
            true,
            0,
            octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t *resultVal = octaspire_dern_vm_create_new_value_vector_from_vector(vm, resultVec);

        octaspire_dern_vm_push_value(vm, resultVal);

        for (size_t i = 0; i < octaspire_container_vector_get_length(vec); ++i)
        {
            octaspire_dern_value_t *value = octaspire_container_vector_get_element_at(vec, i);

            if (value->docstr)
            {
                octaspire_container_vector_push_back_element(resultVec, &(value->docstr));
            }
            else
            {
                octaspire_dern_value_t *valueNil = octaspire_dern_vm_get_value_nil(vm);
                octaspire_container_vector_push_back_element(resultVec, &valueNil);
            }
        }

        octaspire_dern_vm_pop_value(vm, resultVal);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return resultVal;
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_len(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'len' expects at least one argument.");
    }

    if (octaspire_container_vector_get_length(vec) == 1)
    {
        octaspire_dern_value_t *value = octaspire_container_vector_get_element_at(vec, 0);

        // TODO XXX check number ranges for too large size_t value for int32_t?
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_integer(vm, (int32_t)octaspire_dern_value_get_length(value));
    }
    else
    {
        octaspire_dern_value_t *resultVal = octaspire_dern_vm_create_new_value_vector(vm);

        octaspire_dern_vm_push_value(vm, resultVal);

        for (size_t i = 0; i < octaspire_container_vector_get_length(vec); ++i)
        {
            octaspire_dern_value_t *value = octaspire_container_vector_get_element_at(vec, i);

            // TODO XXX check number ranges for too large size_t value for int32_t?
            octaspire_dern_value_t *valueLen = octaspire_dern_vm_create_new_value_integer(
                vm,
                (int32_t)octaspire_dern_value_get_length(value));

            // TODO & or not?
            if (!octaspire_dern_value_as_vector_push_back_element(
                resultVal,
                &valueLen))
            {
                abort();
            }
        }

        octaspire_dern_vm_pop_value(vm, resultVal);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return resultVal;
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_read_and_eval_path(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'read-and-eval-path' expects one argument. %zu arguments were given.",
            octaspire_container_vector_get_length(vec));
    }

    octaspire_dern_value_t *path = octaspire_container_vector_get_element_at(vec, 0);

    if (path->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "First argument to builtin 'read-and-eval-path' must be string (path). Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(path->typeTag));
    }

    octaspire_dern_value_t *result = octaspire_dern_vm_read_from_path_and_eval_in_global_environment(
        vm,
        octaspire_container_utf8_string_get_c_string(path->value.string));

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_read_and_eval_string(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'read-and-eval-string' expects one argument. %zu arguments were given.",
            octaspire_container_vector_get_length(vec));
    }

    octaspire_dern_value_t *stringToEval = octaspire_container_vector_get_element_at(vec, 0);

    if (stringToEval->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "First argument to builtin 'read-and-eval-string' must be string (to be evaluated). Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(stringToEval->typeTag));
    }

    octaspire_dern_value_t *result = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        octaspire_container_utf8_string_get_c_string(stringToEval->value.string));

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_string_format(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'string-format' expects one or more arguments.");
    }

    octaspire_dern_value_t const * const fmtStr =
        octaspire_dern_value_as_vector_get_element_at_const(arguments, 0);

    octaspire_helpers_verify_not_null(fmtStr);

    octaspire_container_utf8_string_t *resultStr = 0;

    if (numArgs == 1)
    {
        octaspire_container_utf8_string_t *str =
            octaspire_dern_value_to_string_plain(fmtStr, octaspire_dern_vm_get_allocator(vm));

        octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_string(vm, str);

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }
    else
    {
        if (fmtStr->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to builtin 'string-format' must be format string if there are more "
                "than one argument. Type '%s' was given.",
                octaspire_dern_value_helper_get_type_as_c_string(fmtStr->typeTag));

        }

        resultStr = octaspire_container_utf8_string_new(
            "",
            octaspire_dern_vm_get_allocator(vm));

        size_t const fmtStrLen = octaspire_container_utf8_string_get_length_in_ucs_characters(fmtStr->value.string);

        uint32_t prevChar = 0;
        uint32_t curChar = 0;
        uint32_t nextChar = 0;

        size_t fmtValueIndex = 1;

        for (size_t c = 0; c < fmtStrLen; ++c)
        {
            curChar = octaspire_container_utf8_string_get_ucs_character_at_index(fmtStr->value.string, c);

            if ((c + 1) < fmtStrLen)
            {
                nextChar = octaspire_container_utf8_string_get_ucs_character_at_index(fmtStr->value.string, c + 1);
            }
            else
            {
                nextChar = 0;
            }

            if (curChar == '\'' && prevChar == '\'')
            {
                octaspire_container_utf8_string_push_back_ucs_character(resultStr, '\'');
                curChar = 0; // To prevent prevChar from becoming '
            }
            else if (curChar == '{' && prevChar != '\'')
            {
                if (nextChar == '}')
                {
                    if (fmtValueIndex >= numArgs)
                    {
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return octaspire_dern_vm_create_new_value_error_from_c_string(
                            vm,
                            "Not enough arguments for the format string of 'string-format'.");
                    }

                    octaspire_container_utf8_string_t *tmpStr = octaspire_dern_value_to_string_plain(
                        octaspire_dern_value_as_vector_get_element_at(
                            arguments,
                            fmtValueIndex),
                        octaspire_dern_vm_get_allocator(vm));

                    octaspire_container_utf8_string_concatenate(resultStr, tmpStr);

                    octaspire_container_utf8_string_release(tmpStr);
                    tmpStr = 0;

                    ++c;
                    ++fmtValueIndex;
                }
                else
                {
                    octaspire_container_utf8_string_push_back_ucs_character(resultStr, (char)curChar);
                }
            }
            else
            {
                octaspire_container_utf8_string_push_back_ucs_character(resultStr, (char)curChar);
            }

            prevChar = curChar;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_string(vm, resultStr);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_to_string(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'to-string' expects one or more arguments.");
    }
    else if (numArgs == 1)
    {
        octaspire_container_utf8_string_t * str =
            octaspire_dern_value_to_string(octaspire_dern_value_as_vector_get_element_at_const(
                arguments,
                0), octaspire_dern_vm_get_allocator(vm));

        return octaspire_dern_vm_create_new_value_string(vm, str);
    }
    else
    {
        // TODO XXX
        abort();
    }

    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_to_integer(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'to-integer' expects one or more arguments.");
    }
    else if (numArgs == 1)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_at_const(
                arguments,
                0);

        // TODO other types
        if (octaspire_dern_value_is_number(value))
        {
            return octaspire_dern_vm_create_new_value_integer(
                vm,
                (int32_t)octaspire_dern_value_as_number_get_value(value));
        }
        else if (octaspire_dern_value_is_string(value))
        {
            int32_t valueAsInt = (int32_t)strtoimax(
                octaspire_dern_value_as_string_get_c_string(value),
                0,
                10);

            return octaspire_dern_vm_create_new_value_integer(vm, valueAsInt);
        }
        else
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to 'to-integer' is currently unsupported type. "
                "Type '%s' was given.",
                octaspire_dern_value_helper_get_type_as_c_string(value->typeTag));
        }
    }
    else
    {
        // TODO XXX
        abort();
    }

    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_print(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'println' one or more arguments.");
    }

    octaspire_dern_value_t const * const fmtStr =
        octaspire_dern_value_as_vector_get_element_at_const(arguments, 0);

    octaspire_helpers_verify_not_null(fmtStr);

    if (fmtStr->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        octaspire_dern_value_print(fmtStr, octaspire_dern_vm_get_allocator(vm));

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_get_value_true(vm);
    }

    if (numArgs == 1)
    {
        printf("%s", octaspire_container_utf8_string_get_c_string(fmtStr->value.string));
    }
    else
    {
        size_t const fmtStrLen = octaspire_container_utf8_string_get_length_in_ucs_characters(fmtStr->value.string);

        uint32_t prevChar = 0;
        uint32_t curChar = 0;
        uint32_t nextChar = 0;

        size_t fmtValueIndex = 1;

        for (size_t c = 0; c < fmtStrLen; ++c)
        {
            curChar = octaspire_container_utf8_string_get_ucs_character_at_index(fmtStr->value.string, c);

            if ((c + 1) < fmtStrLen)
            {
                nextChar = octaspire_container_utf8_string_get_ucs_character_at_index(fmtStr->value.string, c + 1);
            }
            else
            {
                nextChar = 0;
            }

            if (curChar == '\'' && prevChar == '\'')
            {
                printf("'");
                curChar = 0; // To prevent prevChar from becoming '
            }
            else if (curChar == '{' && prevChar != '\'')
            {
                if (nextChar == '}')
                {
                    if (fmtValueIndex >= numArgs)
                    {
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                        return octaspire_dern_vm_create_new_value_error_from_c_string(
                            vm,
                            "Not enough arguments for the format string of 'println'.");
                    }

                    octaspire_container_utf8_string_t *tmpStr = octaspire_dern_value_to_string(
                        octaspire_dern_value_as_vector_get_element_at(
                            arguments,
                            fmtValueIndex),
                        octaspire_dern_vm_get_allocator(vm));

                    printf("%s", octaspire_container_utf8_string_get_c_string(tmpStr));

                    octaspire_container_utf8_string_release(tmpStr);
                    tmpStr = 0;

                    ++c;
                    ++fmtValueIndex;
                }
                else
                {
                    printf("%c",(char)curChar);
                }
            }
            else
            {
                printf("%c",(char)curChar);
            }

            prevChar = curChar;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_get_value_true(vm);
}


octaspire_dern_value_t *octaspire_dern_vm_builtin_println(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    if (octaspire_dern_value_as_vector_get_length(arguments) == 0)
    {
        printf("\n");
        return octaspire_dern_vm_get_value_true(vm);
    }
    else
    {
        octaspire_dern_value_t *result = octaspire_dern_vm_builtin_print(vm, arguments, environment);
        printf("\n");
        return result;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_env_new(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_environment(vm, 0);
    }
    else if (octaspire_container_vector_get_length(vec) == 1)
    {
        octaspire_dern_value_t *value = octaspire_container_vector_get_element_at(vec, 0);
        octaspire_helpers_verify_not_null(value);

        if (value->typeTag != OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Argument to builtin 'env-new' must be an environment. Now argument has type '%s'.",
                octaspire_dern_value_helper_get_type_as_c_string(value->typeTag));
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_environment(vm, value);
    }
    else
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'env-new' expects zero or one arguments.");
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_env_current(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) != 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'env-current' expects zero arguments.");
    }

    return environment;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_env_global(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) != 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'env-global' expects zero arguments.");
    }

    return octaspire_dern_vm_get_global_environment(vm);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '-=' expects at least one argument.");
    }

    octaspire_dern_value_t * const firstArg = octaspire_container_vector_get_element_at(vec, 0);

    switch (firstArg->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                if (i == 1)
                {
                    octaspire_dern_value_as_character_subtract(firstArg, anotherArg);
                }
                else
                {
                    octaspire_dern_value_as_string_pop_back_ucs_character(firstArg);
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                octaspire_dern_value_as_real_subtract(firstArg, anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                octaspire_dern_value_as_integer_subtract(firstArg, anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                // TODO XXX remove the need for '&' in &another for vectors!!!!!
                for (size_t j = 0; j < octaspire_dern_value_as_vector_get_length(firstArg); /*NOP*/)
                {
                    octaspire_dern_value_t * const val =
                        octaspire_dern_value_as_vector_get_element_at(firstArg, j);

                    if (octaspire_dern_value_is_equal(anotherArg, val))
                    {
                        octaspire_dern_value_as_vector_remove_element_at(firstArg, j);
                    }
                    else
                    {
                        ++j;
                    }
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                if (!octaspire_dern_value_as_string_remove_all_substrings(firstArg, anotherArg))
                {
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "Builtin '-=' failed");
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                if (!octaspire_dern_value_as_hash_map_remove(firstArg, anotherArg))
                {
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "Builtin '-=' failed");
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return firstArg;
        }

        default:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to builtin '-=' cannot be of type '%s'.",
                octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return firstArg;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_plus_equals(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '+=' expects at least one argument.");
    }

    octaspire_dern_value_t * const firstArg = octaspire_container_vector_get_element_at(vec, 0);

    switch (firstArg->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                if (i == 1)
                {
                    octaspire_dern_value_as_character_add(firstArg, anotherArg);
                }
                else
                {
                    octaspire_dern_value_as_string_push_back(firstArg, anotherArg);
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                octaspire_dern_value_as_real_add(firstArg, anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                octaspire_dern_value_as_integer_add(firstArg, anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                // TODO XXX remove the need for '&' in &another for vectors!!!!!
                octaspire_dern_value_as_vector_push_back_element(firstArg, &anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                octaspire_dern_value_as_list_push_back(firstArg, anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                octaspire_dern_value_as_queue_push(firstArg, anotherArg);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        {
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                octaspire_dern_value_t *tmpArgs = octaspire_dern_vm_create_new_value_vector(vm);

                octaspire_dern_vm_push_value(vm, tmpArgs);

                octaspire_dern_value_as_vector_push_back_element(tmpArgs, &firstArg);
                octaspire_dern_value_as_vector_push_back_element(tmpArgs, &anotherArg);

                octaspire_dern_vm_builtin_port_write(vm, tmpArgs, environment);

                octaspire_dern_vm_pop_value(vm, tmpArgs);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            //bool success = true;
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                if (!octaspire_dern_value_as_string_push_back(firstArg, anotherArg))
                {
                    //success = false;
                }
            }

            // TODO report possible error?
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            //bool success = true;
            for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
            {
                octaspire_dern_value_t * const anotherArg =
                    octaspire_container_vector_get_element_at(vec, i);

                if (!octaspire_dern_value_as_symbol_push_back(firstArg, anotherArg))
                {
                    //success = false;
                }
            }

            // TODO report possible error?
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            if (octaspire_container_vector_get_length(vec) == 2)
            {
                if (!octaspire_dern_value_as_hash_map_add(
                        firstArg,
                        octaspire_container_vector_get_element_at(vec, 1),
                        0))
                {
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "Builtin '+=' failed");
                }
            }
            else if (octaspire_container_vector_get_length(vec) == 3)
            {
                if (!octaspire_dern_value_as_hash_map_add(
                        firstArg,
                        octaspire_container_vector_get_element_at(vec, 1),
                        octaspire_container_vector_get_element_at(vec, 2)))
                {
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "Builtin '+=' failed");
                }
            }
            else
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_from_c_string(
                    vm,
                    "Builtin '+=' expects one or two additional arguments for hash map");
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return firstArg;
        }

        default:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "First argument to builtin '+=' cannot be of type '%s'.",
                octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return firstArg;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_plus_plus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '++' expects at least one argument.");
    }

    octaspire_dern_value_t *value = 0;

    for (size_t i = 0; i < octaspire_container_vector_get_length(vec); ++i)
    {
        value = octaspire_container_vector_get_element_at(vec, i);

        if (!octaspire_dern_value_is_number(value))
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Arguments to builtin '++' must be numbers. %zuth argument has type '%s'.",
                i + 1,
                octaspire_dern_value_helper_get_type_as_c_string(value->typeTag));
        }

        if (value->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER)
        {
            ++(value->value.integer);
        }
        else
        {
            ++(value->value.real);
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return value;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus_minus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_container_vector_t * const vec = arguments->value.vector;

    if (octaspire_container_vector_get_length(vec) < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '--' expects at least one argument.");
    }

    octaspire_dern_value_t *value = 0;

    for (size_t i = 0; i < octaspire_container_vector_get_length(vec); ++i)
    {
        value = octaspire_container_vector_get_element_at(vec, i);

        if (octaspire_dern_value_is_integer(value))
        {
            --(value->value.integer);
        }
        else if (octaspire_dern_value_is_real(value))
        {
            --(value->value.real);
        }
        else if (octaspire_dern_value_is_queue(value))
        {
            if (!octaspire_dern_value_as_queue_pop(value))
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '--' failed on %zuth argument (queue)",
                    i + 1);
            }
        }
        else if (octaspire_dern_value_is_list(value))
        {
            if (!octaspire_dern_value_as_list_pop_back(value))
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '--' failed on %zuth argument (list)",
                    i + 1);
            }
        }
        else if (octaspire_dern_value_is_vector(value))
        {
            if (!octaspire_dern_value_as_vector_pop_back_element(value))
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '--' failed on %zuth argument (vector)",
                    i + 1);
            }
        }
        else if (octaspire_dern_value_is_string(value))
        {
            if (!octaspire_dern_value_as_string_pop_back_ucs_character(value))
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '--' failed on %zuth argument (string)",
                    i + 1);
            }
        }
        else
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "%zuth argument to builtin '--' has unsupported type '%s'.",
                i + 1,
                octaspire_dern_value_helper_get_type_as_c_string(value->typeTag));
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return value;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_pop_front(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'pop_front' expects exactly one argument.");
    }

    octaspire_dern_value_t *value = octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    if (value->typeTag != OCTASPIRE_DERN_VALUE_TAG_VECTOR)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'pop_front' expects vector argument.");
    }

    octaspire_container_vector_t *vec = value->value.vector;

    octaspire_helpers_verify_not_null(vec);

    bool const result = octaspire_container_vector_pop_front_element(vec);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_boolean(vm, result);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_mod(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'mod' expects two arguments (integers). %zu arguments were given.",
            numArgs);
    }

    octaspire_dern_value_t * const firstArgVal =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    if (firstArgVal->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
    {
        if (firstArgVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return firstArgVal;
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'mod' must be integer. Type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArgVal->typeTag));
    }

    octaspire_dern_value_t * const secondArgVal =
        octaspire_dern_value_as_vector_get_element_at(arguments, 1);

    if (secondArgVal->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
    {
        if (secondArgVal->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return secondArgVal;
        }

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The second argument to builtin 'mod' must be integer. Type %s was given.",
            octaspire_dern_value_helper_get_type_as_c_string(secondArgVal->typeTag));
    }

    if (secondArgVal->value.integer == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "The second argument to builtin 'mod' cannot be zero. "
            "It would cause division by zero.");
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_integer(
        vm,
        firstArgVal->value.integer % secondArgVal->value.integer);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_slash(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin '/' expects at least one numeric argument (integer or real).");
    }

    if (numArgs == 1)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, 0);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

                double const currentArgAsReal = currentArg->value.integer;

                if (currentArgAsReal == 0)
                {
                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "First argument to builtin '/' cannot be zero. "
                        "It would cause division by zero.");
                }
                else
                {
                    return octaspire_dern_vm_create_new_value_real(vm, 1.0 / currentArgAsReal);
                }
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

                double const currentArgAsReal = currentArg->value.real;

                if (currentArgAsReal == 0)
                {
                    return octaspire_dern_vm_create_new_value_error_from_c_string(
                        vm,
                        "First argument to builtin '/' cannot be zero. "
                        "It would cause division by zero.");
                }
                else
                {
                    return octaspire_dern_vm_create_new_value_real(vm, 1.0 / currentArgAsReal);
                }
            }
            break;

            default:
            {
                if (currentArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                    return currentArg;
                }

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '/' expects numeric arguments (integer or real). First argument has type %s.",
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
            break;
        }
    }

    double realResult = 1;

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, i);

        octaspire_helpers_verify_not_null(currentArg);

        double currentValueAsNumber = 0;

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            {
                currentValueAsNumber = currentArg->value.integer;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            {
                currentValueAsNumber = currentArg->value.real;
            }
            break;

            default:
            {
                if (currentArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                    return currentArg;
                }

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '/' expects numeric arguments (integer or real). %zuth argument has type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
            break;
        }

        if (i == 0)
        {
            realResult = currentValueAsNumber;
        }
        else
        {
            if (currentValueAsNumber == 0)
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Argument number %zu to builtin '/' cannot be zero. "
                    "It would cause division by zero.",
                    i + 1);
            }

            realResult /= currentValueAsNumber;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_real(vm, realResult);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_times(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    bool allArgsAreIntegers = true;
    double realResult = 1;
    int32_t integerResult = 1;

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            {
                integerResult *= currentArg->value.integer;
                realResult    *= (double)currentArg->value.integer;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            {
                allArgsAreIntegers = false;

                integerResult *= currentArg->value.real;
                realResult    *= currentArg->value.real;
            }
            break;

            default:
            {
                if (currentArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                    return currentArg;
                }

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '*' expects numeric arguments (integer or real). %zuth argument has type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
            break;
        }
    }

    if (allArgsAreIntegers)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_integer(vm, integerResult);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_real(vm, realResult);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_numerical(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    bool allArgsAreIntegers = true;
    double realResult = 0;
    int32_t integerResult = 0;

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            {
                integerResult += currentArg->value.integer;
                realResult    += (double)currentArg->value.integer;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            {
                allArgsAreIntegers = false;

                integerResult += currentArg->value.real;
                realResult    += currentArg->value.real;
            }
            break;

            default:
            {
                if (currentArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                    return currentArg;
                }

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '+' expects numeric arguments (integer or real). %zuth argument has type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
            break;
        }
    }

    if (allArgsAreIntegers)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_integer(vm, integerResult);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_real(vm, realResult);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_plus_textual(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t *firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);
    octaspire_helpers_verify_true(firstArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);

    for (size_t i = 1; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            {
                octaspire_container_utf8_string_concatenate(
                    firstArg->value.string,
                    currentArg->value.string);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            {
                octaspire_container_utf8_string_concatenate(
                    firstArg->value.string,
                    currentArg->value.character);
            }
            break;

            // TODO Add symbol and maybe automatic conversion from number -> string

            default:
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '+' expects textual arguments if the first argument is textual. %zuth argument has type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
            break;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    // TODO what to return? Count of removals or the modified string-value?
    return firstArg;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_minus_numerical(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    bool allArgsAreIntegers = true;
    double realResult = 0;
    int32_t integerResult = 0;

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            {
                if (numArgs == 1)
                {
                    integerResult = -currentArg->value.integer;
                    realResult    = -(double)currentArg->value.integer;
                }
                else
                {
                    if (i == 0)
                    {
                        integerResult = currentArg->value.integer;
                        realResult    = (double)currentArg->value.integer;
                    }
                    else
                    {
                        integerResult -= currentArg->value.integer;
                        realResult    -= (double)currentArg->value.integer;
                    }
                }
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            {
                allArgsAreIntegers = false;

                if (numArgs == 1)
                {
                    integerResult = -currentArg->value.real;
                    realResult    = -currentArg->value.real;
                }
                else
                {
                    if (i == 0)
                    {
                        integerResult = currentArg->value.real;
                        realResult    = currentArg->value.real;
                    }
                    else
                    {
                        integerResult -= currentArg->value.real;
                        realResult    -= currentArg->value.real;
                    }
                }
            }
            break;

            default:
            {
                if (currentArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                    return currentArg;
                }

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '-' expects numeric arguments (integer or real). %zuth argument has type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
            break;
        }
    }

    if (allArgsAreIntegers)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_integer(vm, integerResult);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_real(vm, realResult);
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_minus_textual(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t *firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);
    octaspire_helpers_verify_true(firstArg->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);

    for (size_t i = 1; i < numArgs; ++i)
    {
        octaspire_dern_value_t *currentArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, i);

        octaspire_helpers_verify_not_null(currentArg);

        switch (currentArg->typeTag)
        {
            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            {
                octaspire_container_utf8_string_remove_all_substrings(
                    firstArg->value.string,
                    currentArg->value.string);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            {
                octaspire_container_utf8_string_remove_all_substrings(
                    firstArg->value.string,
                    currentArg->value.character);
            }
            break;

            // TODO Add symbol and maybe automatic conversion from number -> string

            default:
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "Builtin '-' expects textual arguments if the first argument is textual. %zuth argument has type %s.",
                    i + 1,
                    octaspire_dern_value_helper_get_type_as_c_string(currentArg->typeTag));
            }
            break;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    // TODO what to return? Count of removals or the modified string-value?
    return firstArg;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_plus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_builtin_private_plus_numerical(vm, arguments, environment);
    }

    octaspire_dern_value_t *firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    switch (firstArg->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_builtin_private_plus_textual(vm, arguments, environment);
        }
        break;

        default:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_builtin_private_plus_numerical(vm, arguments, environment);
        }
        break;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_minus(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs == 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_builtin_private_minus_numerical(vm, arguments, environment);
    }

    octaspire_dern_value_t *firstArg =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    switch (firstArg->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_builtin_private_minus_textual(vm, arguments, environment);
        }
        break;

        default:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_builtin_private_minus_numerical(vm, arguments, environment);
        }
        break;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_find(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_dern_vm_push_value(vm, arguments);
    octaspire_dern_vm_push_value(vm, environment);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 2)
    {
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'find' expects at least two arguments. %zu arguments was given.",
            numArgs);
    }

    octaspire_dern_value_t *container = octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(container);

    octaspire_dern_value_t *result = 0;

    if (numArgs > 2)
    {
        result = octaspire_dern_vm_create_new_value_vector(vm);
        octaspire_dern_vm_push_value(vm, result);

        for (size_t i = 1; i < numArgs; ++i)
        {
            octaspire_dern_value_t *keyArg =
                octaspire_dern_value_as_vector_get_element_at(arguments, i);

            octaspire_helpers_verify_not_null(keyArg);

            octaspire_dern_value_t *tmpVal = octaspire_dern_vm_find_from_value(vm, container, keyArg);
            octaspire_dern_value_as_vector_push_back_element(
                result,
                &tmpVal);
        }

        octaspire_dern_vm_pop_value(vm, result);
        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }
    else
    {
        octaspire_dern_value_t *keyArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, 1);

        octaspire_helpers_verify_not_null(keyArg);

        result = octaspire_dern_vm_find_from_value(vm, container, keyArg);

        octaspire_dern_vm_pop_value(vm, environment);
        octaspire_dern_vm_pop_value(vm, arguments);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_split(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs != 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'split' expects two arguments. %zu arguments was given.",
            numArgs);
    }

    octaspire_dern_value_t *container = octaspire_dern_value_as_vector_get_element_at(arguments, 0);
    octaspire_helpers_verify_not_null(container);

    octaspire_dern_value_t *splitByArg = octaspire_dern_value_as_vector_get_element_at(arguments, 1);
    octaspire_helpers_verify_not_null(splitByArg);

    switch (container->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            if (!octaspire_dern_value_is_character(splitByArg))
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_error_format(
                    vm,
                    "The second argument to builtin 'split' must be a character when the first "
                    "is a string. Type '%s' was given.",
                    octaspire_dern_value_helper_get_type_as_c_string(splitByArg->typeTag));
            }

            octaspire_dern_value_t * const result = octaspire_dern_vm_create_new_value_vector(vm);
            octaspire_helpers_verify_not_null(result);

            octaspire_dern_vm_push_value(vm, result);

            octaspire_container_utf8_string_t *containerAsStr = container->value.string;
            octaspire_helpers_verify_not_null(containerAsStr);

            octaspire_container_vector_t *tokens = octaspire_container_utf8_string_split(
                containerAsStr,
                octaspire_dern_value_as_character_get_c_string(splitByArg));

            octaspire_helpers_verify_not_null(tokens);

            for (size_t i = 0; i < octaspire_container_vector_get_length(tokens); ++i)
            {
                octaspire_container_utf8_string_t const * const token =
                    (octaspire_container_utf8_string_t const * const)
                        octaspire_container_vector_get_element_at(tokens, i);

                octaspire_helpers_verify_not_null(token);

                octaspire_container_utf8_string_t * const copy =
                    octaspire_container_utf8_string_new_copy(
                        token,
                        octaspire_dern_vm_get_allocator(vm));

                octaspire_dern_value_t * const copyVal = octaspire_dern_vm_create_new_value_string(
                    vm,
                    copy);

                octaspire_dern_value_as_vector_push_back_element(result, &copyVal);
            }

            octaspire_container_vector_release(tokens);
            tokens = 0;

            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }
        break;

        default:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "The first argument to builtin 'split' must be a container. Currently only "
                "strings are supported. Type '%s' was given.",
                octaspire_dern_value_helper_get_type_as_c_string(container->typeTag));
        }
        break;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_hash_map(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_hash_map(vm);
    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 0; i < numArgs; i += 2)
    {
        octaspire_dern_value_t *keyArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, i);

        if (!keyArg)
        {
            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'hash-map' expects key here.");
        }

        octaspire_dern_value_t *valArg =
            octaspire_dern_value_as_vector_get_element_at(arguments, i + 1);

        if (!valArg)
        {
            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'hash-map' expects key here.");
        }

        if (!octaspire_dern_value_as_hash_map_put(
            result,
            octaspire_dern_value_get_hash(keyArg),
            keyArg,
            valArg))
        {
            abort();
        }
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_queue(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_queue(vm);
    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *arg =
            octaspire_dern_value_as_vector_get_element_at(arguments, i);

        if (!arg)
        {
            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'queue' expects value here.");
        }

        if (!octaspire_dern_value_as_queue_push(result, arg))
        {
            abort();
        }
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_queue_with_max_length(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    if (numArgs < 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Builtin 'queue-with-max-length' expects at least one argument. "
            "Now %zu arguments were given.",
            numArgs);
    }

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    if (!octaspire_dern_value_is_integer(firstArg))
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'queue-with-max-length' must be integer. Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    int32_t const maxQueueLen = octaspire_dern_value_as_integer_get_value(firstArg);

    if (maxQueueLen < 0)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'queue-with-max-length' must be non negative integer. "
            "Negative integer %" PRId32 " was given.",
            maxQueueLen);
    }

    octaspire_dern_value_t *result =
        octaspire_dern_vm_create_new_value_queue_with_max_length(vm, maxQueueLen);

    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 1; i < numArgs; ++i)
    {
        octaspire_dern_value_t *arg =
            octaspire_dern_value_as_vector_get_element_at(arguments, i);

        if (!arg)
        {
            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'queue-with-max-length' expects value here.");
        }

        if (!octaspire_dern_value_as_queue_push(result, arg))
        {
            abort();
        }
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_list(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_get_length(arguments);

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_list(vm);
    octaspire_dern_vm_push_value(vm, result);

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *arg =
            octaspire_dern_value_as_vector_get_element_at(arguments, i);

        if (!arg)
        {
            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_from_c_string(
                vm,
                "Builtin 'list' expects value here.");
        }

        if (!octaspire_dern_value_as_list_push_back(result, arg))
        {
            abort();
        }
    }

    octaspire_dern_vm_pop_value(vm, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_require_is_already_loaded(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'require' expects exactly one argument.");
    }

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'require' must be a symbol. Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    char const * const name = octaspire_dern_value_as_symbol_get_c_string(firstArg);

    octaspire_helpers_verify_not_null(name);

    if (octaspire_dern_vm_has_library(vm, name))
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_boolean(vm, true);
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return 0;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_require_source_file(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'require' expects exactly one argument.");
    }

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'require' must be a symbol. Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    char const * const name = octaspire_dern_value_as_symbol_get_c_string(firstArg);

    octaspire_helpers_verify_not_null(name);

    octaspire_container_utf8_string_t *fileName = octaspire_container_utf8_string_new_format(
        octaspire_dern_vm_get_allocator(vm),
        "%s.dern",
        name);

    octaspire_helpers_verify_not_null(fileName);

    octaspire_input_t *input = octaspire_input_new_from_path(
        octaspire_container_utf8_string_get_c_string(fileName),
        octaspire_dern_vm_get_allocator(vm),
        octaspire_dern_vm_get_stdio(vm));

    if (!input)
    {
        octaspire_container_utf8_string_release(fileName);
        fileName = 0;

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return 0;
    }

    octaspire_dern_lib_t *library = octaspire_dern_lib_new_source(
        name,
        input,
        vm,
        octaspire_dern_vm_get_allocator(vm));

    octaspire_helpers_verify_not_null(library);

    if (!octaspire_dern_lib_is_good(library))
    {
        octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Source library '%s' failed to load: %s",
            name,
            octaspire_dern_lib_get_error_message(library));

        octaspire_helpers_verify_not_null(result);

        octaspire_container_utf8_string_release(fileName);
        fileName = 0;

        octaspire_input_release(input);
        input = 0;

        octaspire_dern_lib_release(library);
        library = 0;

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }

    octaspire_input_release(input);
    input = 0;

    if (!octaspire_dern_vm_add_library(vm, name, library))
    {
        abort();
    }

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_string(vm, fileName);

    octaspire_helpers_verify_not_null(result);

    octaspire_container_utf8_string_release(fileName);
    fileName = 0;

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_private_require_binary_file(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (octaspire_dern_value_as_vector_get_length(arguments) != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'require' expects exactly one argument.");
    }

    octaspire_dern_value_t *firstArg = octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_not_null(firstArg);

    if (firstArg->typeTag != OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_format(
            vm,
            "The first argument to builtin 'require' must be a symbol. Type '%s' was given.",
            octaspire_dern_value_helper_get_type_as_c_string(firstArg->typeTag));
    }

    char const * const name = octaspire_dern_value_as_symbol_get_c_string(firstArg);

    octaspire_helpers_verify_not_null(name);

    octaspire_container_utf8_string_t *fileName = octaspire_container_utf8_string_new_format(
        octaspire_dern_vm_get_allocator(vm),
        "lib%s.so",
        name);

    octaspire_helpers_verify_not_null(fileName);

    octaspire_dern_lib_t *library = octaspire_dern_lib_new_binary(
        name,
        octaspire_container_utf8_string_get_c_string(fileName),
        vm,
        octaspire_dern_vm_get_allocator(vm));

    octaspire_helpers_verify_not_null(library);

    if (!octaspire_dern_lib_is_good(library))
    {
        octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error_format(
            vm,
            "Binary library '%s' failed to load: %s",
            name,
            octaspire_dern_lib_get_error_message(library));

        octaspire_helpers_verify_not_null(result);

        octaspire_container_utf8_string_release(fileName);
        fileName = 0;

        octaspire_dern_lib_release(library);
        library = 0;

        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }

    if (!octaspire_dern_vm_add_library(vm, name, library))
    {
        abort();
    }

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_string(vm, fileName);

    octaspire_helpers_verify_not_null(result);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_require(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    octaspire_dern_value_t *result =
        octaspire_dern_vm_builtin_private_require_is_already_loaded(
            vm,
            arguments,
            environment);

    if (result)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }

    result =
        octaspire_dern_vm_builtin_private_require_source_file(
            vm,
            arguments,
            environment);

    if (result)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }

    result =
        octaspire_dern_vm_builtin_private_require_binary_file(
            vm,
            arguments,
            environment);

    if (result)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return result;
    }

    octaspire_dern_value_t * const nameVal =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
    return octaspire_dern_vm_create_new_value_error_format(
        vm,
        "Builtin 'require': '%s' could not be loaded.",
        octaspire_dern_value_as_symbol_get_c_string(nameVal));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_integer_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'integer?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_integer(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_real_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'real?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_real(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_number_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'number?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_number(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_nil_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'nil?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_nil(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_boolean_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'boolean?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_boolean(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_character_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'character?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_character(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_string_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'string?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_string(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_symbol_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'symbol?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_symbol(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_vector_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'vector?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_vector(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_hash_map_question_mark(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs != 1)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'hash-map?' expects one argument.");
    }

    octaspire_dern_value_t const * const value =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));

    return octaspire_dern_vm_create_new_value_boolean(vm, octaspire_dern_value_is_hash_map(value));
}

octaspire_dern_value_t *octaspire_dern_vm_builtin_copy(
    octaspire_dern_vm_t *vm,
    octaspire_dern_value_t *arguments,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(vm);

    octaspire_helpers_verify_true(arguments->typeTag   == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    size_t const numArgs = octaspire_dern_value_as_vector_get_length(arguments);

    if (numArgs < 1 || numArgs > 2)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
        return octaspire_dern_vm_create_new_value_error_from_c_string(
            vm,
            "Builtin 'copy' expects one or two arguments.");
    }

    octaspire_dern_value_t * const collectionVal =
        octaspire_dern_value_as_vector_get_element_at(arguments, 0);

    octaspire_dern_value_t * predicateVal = 0;

    if (numArgs == 2)
    {
        predicateVal = octaspire_dern_value_as_vector_get_element_at(arguments, 1);
        octaspire_helpers_verify_not_null(predicateVal);

        if (!octaspire_dern_value_is_function(predicateVal))
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Builtin 'copy' expects function (predicate) as second argument. "
                "Now type '%s' was given.",
                octaspire_dern_value_helper_get_type_as_c_string(predicateVal->typeTag));
        }
    }

    switch (collectionVal->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            octaspire_container_vector_t * const copyVec =
                octaspire_container_vector_new(
                    sizeof(octaspire_dern_value_t*),
                    true,
                    0,
                    octaspire_dern_vm_get_allocator(vm));

            octaspire_helpers_verify_not_null(copyVec);

            octaspire_dern_value_t * const result =
                octaspire_dern_vm_create_new_value_vector_from_vector(vm, copyVec);

            octaspire_dern_vm_push_value(vm, result);

            for (size_t i = 0; i < octaspire_dern_value_get_length(collectionVal); ++i)
            {
                bool doCopy = true;

                octaspire_dern_value_t * valueThatMightBeCopied =
                    octaspire_dern_value_as_vector_get_element_at(collectionVal, i);

                if (predicateVal)
                {
                    octaspire_dern_value_t * callVec =
                        octaspire_dern_vm_create_new_value_vector(vm);

                    octaspire_helpers_verify_not_null(callVec);

                    octaspire_dern_vm_push_value(vm, callVec);

                    octaspire_dern_value_as_vector_push_back_element(
                        callVec,
                        &predicateVal);

                    octaspire_dern_value_as_vector_push_back_element(
                        callVec,
                        &valueThatMightBeCopied);

                    octaspire_dern_value_t * const counterVal =
                        octaspire_dern_vm_create_new_value_integer(vm, (int32_t)i);

                    octaspire_dern_value_as_vector_push_back_element(
                        callVec,
                        &counterVal);

                    octaspire_dern_value_t * resultValFromPredicate =
                        octaspire_dern_vm_eval(vm, callVec, environment);

                    octaspire_dern_vm_pop_value(vm, callVec);

                    octaspire_helpers_verify_not_null(resultValFromPredicate);

                    if (!octaspire_dern_value_is_boolean(resultValFromPredicate))
                    {
                        octaspire_dern_vm_pop_value(vm, result);

                        octaspire_helpers_verify_true(stackLength ==
                            octaspire_dern_vm_get_stack_length(vm));

                        return octaspire_dern_vm_create_new_value_error_format(
                            vm,
                            "Second argument to builtin 'copy' must be a function that returns "
                            "boolean value. Now type '%s' was returned.",
                            octaspire_dern_value_helper_get_type_as_c_string(
                                resultValFromPredicate->typeTag));
                    }

                    doCopy = resultValFromPredicate->value.boolean;
                }

                if (doCopy)
                {
                    octaspire_dern_value_t *copyVal =
                        octaspire_dern_vm_create_new_value_copy(
                            vm,
                            valueThatMightBeCopied);

                    octaspire_helpers_verify_true(
                        octaspire_dern_value_as_vector_push_back_element(result, &copyVal));
                }
            }

            octaspire_dern_vm_pop_value(vm, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return result;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            if (numArgs == 1)
            {
                octaspire_container_utf8_string_t * const copyStr =
                    octaspire_container_utf8_string_new_copy(
                        collectionVal->value.string,
                        octaspire_dern_vm_get_allocator(vm));

                octaspire_helpers_verify_not_null(copyStr);

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
                return octaspire_dern_vm_create_new_value_string(vm, copyStr);
            }

            octaspire_container_utf8_string_t * const copyStr =
                octaspire_container_utf8_string_new("", octaspire_dern_vm_get_allocator(vm));

            octaspire_helpers_verify_not_null(copyStr);

            for (size_t i = 0; i < octaspire_dern_value_get_length(collectionVal); ++i)
            {
                bool doCopy = true;

                octaspire_dern_value_t * valueThatMightBeCopied =
                    octaspire_dern_vm_create_new_value_character_from_uint32t(
                        vm,
                        octaspire_container_utf8_string_get_ucs_character_at_index(
                            collectionVal->value.string,
                            i));

                octaspire_helpers_verify_not_null(predicateVal);

                octaspire_dern_vm_push_value(vm, valueThatMightBeCopied);

                octaspire_dern_value_t * callVec =
                    octaspire_dern_vm_create_new_value_vector(vm);

                octaspire_helpers_verify_not_null(callVec);

                octaspire_dern_vm_push_value(vm, callVec);

                octaspire_dern_value_as_vector_push_back_element(
                    callVec,
                    &predicateVal);

                octaspire_dern_value_as_vector_push_back_element(
                    callVec,
                    &valueThatMightBeCopied);

                octaspire_dern_value_t * const counterVal =
                    octaspire_dern_vm_create_new_value_integer(vm, (int32_t)i);

                octaspire_dern_value_as_vector_push_back_element(
                    callVec,
                    &counterVal);

                octaspire_dern_value_t * resultValFromPredicate =
                    octaspire_dern_vm_eval(vm, callVec, environment);

                octaspire_dern_vm_pop_value(vm, callVec);

                octaspire_helpers_verify_not_null(resultValFromPredicate);

                if (!octaspire_dern_value_is_boolean(resultValFromPredicate))
                {
                    octaspire_dern_vm_pop_value(vm, valueThatMightBeCopied);

                    octaspire_helpers_verify_true(stackLength ==
                        octaspire_dern_vm_get_stack_length(vm));

                    return octaspire_dern_vm_create_new_value_error_format(
                        vm,
                        "Second argument to builtin 'copy' must be a function that returns "
                        "boolean value. Now type '%s' was returned.",
                        octaspire_dern_value_helper_get_type_as_c_string(
                            resultValFromPredicate->typeTag));
                }

                octaspire_dern_vm_pop_value(vm, valueThatMightBeCopied);

                doCopy = resultValFromPredicate->value.boolean;

                if (doCopy)
                {
                    octaspire_helpers_verify_true(
                        octaspire_container_utf8_string_push_back_ucs_character(
                            copyStr,
                            octaspire_container_utf8_string_get_ucs_character_at_index(
                                collectionVal->value.string,
                                i)));
                }
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_string(vm, copyStr);
        }
        break;

        default:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(vm));
            return octaspire_dern_vm_create_new_value_error_format(
                vm,
                "Builtin 'copy' does not support copying of type '%s' at the moment.",
                octaspire_dern_value_helper_get_type_as_c_string(collectionVal->typeTag));
        }
        break;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_dern_stdlib.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_dern_value.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static char const * const octaspire_dern_value_helper_type_tags_as_c_strings[] =
{
    "illegal",
    "nil",
    "boolean",
    "integer",
    "real",
    "string",
    "multiline comment",
    "character",
    "symbol",
    "error",
    "vector",
    "hash map",
    "queue",
    "list",
    "environment",
    "function",
    "special",
    "builtin",
    "port",
    "C data"
};

octaspire_dern_function_t *octaspire_dern_function_new(
    struct octaspire_dern_value_t *formals,
    struct octaspire_dern_value_t *body,
    struct octaspire_dern_value_t *definitionEnvironment,
    octaspire_memory_allocator_t  *allocator)
{
    octaspire_dern_function_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_function_t));

    if (!self)
    {
        return 0;
    }

    self->formals               = formals;
    self->body                  = body;
    self->definitionEnvironment = definitionEnvironment;
    self->allocator             = allocator;

    return self;
}

void octaspire_dern_function_release(octaspire_dern_function_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_memory_allocator_free(self->allocator, self);
}

size_t octaspire_dern_function_get_number_of_required_arguments(
    octaspire_dern_function_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(self->formals);
    octaspire_helpers_verify_true(self->formals->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    size_t const numFormalArgs = octaspire_container_vector_get_length(
        self->formals->value.vector);

    size_t numNormalArgs         = 0;

    for (size_t i = 0; i < numFormalArgs; ++i)
    {
        octaspire_dern_value_t *formal = octaspire_container_vector_get_element_at(
            self->formals->value.vector,
            i);

        octaspire_helpers_verify_true(formal->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

        octaspire_container_utf8_string_t const * const formalAsStr = formal->value.string;

        if (octaspire_container_utf8_string_is_equal_to_c_string(formalAsStr, "."))
        {
            return numNormalArgs;
        }

        ++numNormalArgs;
    }

    return numNormalArgs;
}

octaspire_container_utf8_string_t *octaspire_dern_function_private_is_string_in_vector(
    octaspire_memory_allocator_t *allocator,
    octaspire_container_utf8_string_t const * const str,
    octaspire_container_vector_t const * const vec)
{
    octaspire_helpers_verify_true(str && vec);

    // (symbol docstrforit symbol docstrforit symbol docstrforit ...)

    for (size_t i = 0; i < octaspire_container_vector_get_length(vec); i += 2)
    {
        octaspire_dern_value_t const * const symbol =
            octaspire_container_vector_get_element_at_const(vec, i);

        octaspire_helpers_verify_true(symbol && symbol->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

        if (octaspire_container_utf8_string_is_equal(str, symbol->value.symbol))
        {
            if ((i+1) >= octaspire_container_vector_get_length(vec))
            {
                // No docstring for the formal
                return octaspire_container_utf8_string_new_format(
                    allocator,
                    "formal '%s' doesn't have docstring in docvec",
                    octaspire_container_utf8_string_get_c_string(str));
            }

            octaspire_dern_value_t const * const docstr =
                octaspire_container_vector_get_element_at_const(vec, i + 1);

            if (!docstr)
            {
                abort();
            }
            else if (docstr->typeTag != OCTASPIRE_DERN_VALUE_TAG_STRING)
            {
                return octaspire_container_utf8_string_new_format(
                    allocator,
                    "type of docstring for formal '%s' is not string. It has type %s",
                    octaspire_container_utf8_string_get_c_string(str),
                    octaspire_dern_value_helper_get_type_as_c_string(docstr->typeTag));
            }

            if (octaspire_container_utf8_string_is_equal_to_c_string(symbol->value.symbol, "..."))
            {
                if (!octaspire_container_utf8_string_is_equal_to_c_string(docstr->value.string, "varargs"))
                {
                    return octaspire_container_utf8_string_new_format(
                        allocator,
                        "docstring for ... should be varargs, not it is '%s'",
                        octaspire_container_utf8_string_get_c_string(docstr->value.string));
                }
            }

            return 0;
        }
    }

    return octaspire_container_utf8_string_new_format(
        allocator,
        "formal '%s' is not mentioned in docvec",
        octaspire_container_utf8_string_get_c_string(str));
}

octaspire_container_utf8_string_t *octaspire_dern_function_are_all_formals_mentioned_in_docvec(
    octaspire_dern_function_t const * const self,
    octaspire_dern_value_t const * const docvec)
{
    octaspire_helpers_verify_true(docvec && docvec->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_true(self && self->formals && self->formals->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    octaspire_container_utf8_string_t *result =
        octaspire_container_utf8_string_new("", self->allocator);

    if (!result)
    {
        return octaspire_container_utf8_string_new("Allocation failure", self->allocator);
    }

    for (size_t i = 0; i < octaspire_dern_value_get_length(self->formals); ++i)
    {
        octaspire_dern_value_t const * const formal = octaspire_dern_value_as_vector_get_element_at_const(
            self->formals,
            i);

        octaspire_helpers_verify_true(formal && formal->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

        octaspire_container_utf8_string_t *errorString = octaspire_dern_function_private_is_string_in_vector(
                self->allocator,
                formal->value.symbol,
                docvec->value.vector);

        if (errorString)
        {
            if (!octaspire_container_utf8_string_concatenate_format(
                result,
                "formal '%s' is not handled correctly in docvec: %s\n",
                octaspire_container_utf8_string_get_c_string(formal->value.symbol),
                octaspire_container_utf8_string_get_c_string(errorString)))
            {
                abort();
            }

            octaspire_container_utf8_string_release(errorString);
            errorString = 0;
        }
    }

    return result;
}



octaspire_dern_special_t *octaspire_dern_special_new(
    octaspire_dern_c_function const cFunction,
    octaspire_memory_allocator_t *allocator,
    size_t const numRequiredActualArguments)
{
    octaspire_dern_special_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_special_t));

    if (!self)
    {
        return 0;
    }

    self->cFunction = cFunction;
    self->allocator = allocator;
    self->numRequiredActualArguments = numRequiredActualArguments;

    return self;
}

void octaspire_dern_special_release(octaspire_dern_special_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_memory_allocator_free(self->allocator, self);
}

size_t octaspire_dern_special_get_number_of_required_arguments(
    octaspire_dern_special_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->numRequiredActualArguments;
}






octaspire_dern_builtin_t *octaspire_dern_builtin_new(
    octaspire_dern_c_function const cFunction,
    octaspire_memory_allocator_t *allocator,
    size_t const numRequiredActualArguments)
{
    octaspire_dern_builtin_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_builtin_t));

    if (!self)
    {
        return 0;
    }

    self->cFunction = cFunction;
    self->allocator = allocator;
    self->numRequiredActualArguments = numRequiredActualArguments;

    return self;
}

void octaspire_dern_builtin_release(octaspire_dern_builtin_t *self)
{
    if (!self)
    {
        return;
    }

    octaspire_memory_allocator_free(self->allocator, self);
}

size_t octaspire_dern_builtin_get_number_of_required_arguments(
    octaspire_dern_builtin_t const * const self)
{
    octaspire_helpers_verify_not_null(self);
    return self->numRequiredActualArguments;
}




char const * octaspire_dern_value_helper_get_type_as_c_string(octaspire_dern_value_tag_t const typeTag)
{
    octaspire_helpers_verify_true(typeTag <
        (octaspire_dern_value_tag_t)(sizeof(octaspire_dern_value_helper_type_tags_as_c_strings) /
         sizeof(octaspire_dern_value_helper_type_tags_as_c_strings[0])));

    return octaspire_dern_value_helper_type_tags_as_c_strings[typeTag];
}

bool octaspire_dern_value_set(
    octaspire_dern_value_t  * const self,
    octaspire_dern_value_t  * const value)
{
    if (self == value)
    {
        return true;
    }

    octaspire_dern_vm_clear_value_to_nil(self->vm, self);

    self->typeTag = value->typeTag;

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        {
            // NOP
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        {
            self->value.boolean = value->value.boolean;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            self->value.integer = value->value.integer;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            self->value.real = value->value.real;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            self->value.string =
                octaspire_container_utf8_string_new_copy(
                    value->value.string,
                    octaspire_dern_vm_get_allocator(self->vm));
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT:
        {
            self->value.comment =
                octaspire_container_utf8_string_new_copy(
                    value->value.comment,
                    octaspire_dern_vm_get_allocator(self->vm));
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            self->value.character =
                octaspire_container_utf8_string_new_copy(
                    value->value.character,
                    octaspire_dern_vm_get_allocator(self->vm));
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            self->value.symbol =
                octaspire_container_utf8_string_new_copy(
                    value->value.symbol,
                    octaspire_dern_vm_get_allocator(self->vm));
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            self->value.error =
                octaspire_container_utf8_string_new_copy(
                    value->value.error,
                    octaspire_dern_vm_get_allocator(self->vm));
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            self->value.vector = octaspire_container_vector_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                octaspire_dern_vm_get_allocator(self->vm));

            for (size_t i = 0; i < octaspire_container_vector_get_length(value->value.vector); ++i)
            {
                octaspire_dern_value_t * tmpVal =
                    octaspire_container_vector_get_element_at(value->value.vector, i);

                if (octaspire_dern_value_is_atom(tmpVal))
                {
                    tmpVal = octaspire_dern_vm_create_new_value_copy(self->vm, tmpVal);
                }

                octaspire_dern_vm_push_value(self->vm, tmpVal);

                if (!octaspire_container_vector_push_back_element(self->value.vector, &tmpVal))
                {
                    abort();
                }

                octaspire_dern_vm_pop_value(self->vm, tmpVal);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            self->value.hashMap = octaspire_container_hash_map_new(
                sizeof(octaspire_dern_value_t*),
                true,
                sizeof(octaspire_dern_value_t*),
                true,
                (octaspire_container_hash_map_key_compare_function_t)octaspire_dern_value_is_equal,
                (octaspire_container_hash_map_key_hash_function_t)octaspire_dern_value_get_hash,
                0,
                0,
                octaspire_dern_vm_get_allocator(self->vm));

            for (size_t i = 0;
                 i < octaspire_container_hash_map_get_number_of_elements(value->value.hashMap);
                 ++i)
            {
                octaspire_container_hash_map_element_t * const element =
                    octaspire_container_hash_map_get_at_index(value->value.hashMap, i);

                octaspire_dern_value_t *key = octaspire_container_hash_map_element_get_key(element);
                octaspire_dern_value_t *val = octaspire_container_hash_map_element_get_value(element);

                if (octaspire_dern_value_is_atom(key))
                {
                    key = octaspire_dern_vm_create_new_value_copy(self->vm, key);
                }

                octaspire_dern_vm_push_value(self->vm, key);

                if (octaspire_dern_value_is_atom(val))
                {
                    val = octaspire_dern_vm_create_new_value_copy(self->vm, val);
                }

                octaspire_dern_vm_push_value(self->vm, val);

                // Any previous value must be removed, because hash map
                // can contain multiple values per key, and we must replace, not
                // add the value.
                octaspire_container_hash_map_remove(
                    self->value.hashMap,
                    octaspire_container_hash_map_element_get_hash(element),
                    &key);

                if (!octaspire_container_hash_map_put(
                    self->value.hashMap,
                    octaspire_container_hash_map_element_get_hash(element),
                    &key,
                    &val))
                {
                    abort();
                }

                octaspire_dern_vm_pop_value(self->vm, val);
                octaspire_dern_vm_pop_value(self->vm, key);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            self->value.queue = octaspire_container_queue_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                octaspire_dern_vm_get_allocator(self->vm));

            // TODO Add iterator to queue and use it here
            for (size_t i = 0; i < octaspire_container_queue_get_length(value->value.queue); ++i)
            {
                octaspire_dern_value_t * tmpVal =
                    octaspire_container_queue_get_at(value->value.queue, i);

                if (octaspire_dern_value_is_atom(tmpVal))
                {
                    tmpVal = octaspire_dern_vm_create_new_value_copy(self->vm, tmpVal);
                }

                octaspire_dern_vm_push_value(self->vm, tmpVal);

                if (!octaspire_container_queue_push(self->value.queue, &tmpVal))
                {
                    abort();
                }

                octaspire_dern_vm_pop_value(self->vm, tmpVal);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            self->value.list = octaspire_container_list_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                octaspire_dern_vm_get_allocator(self->vm));

            // TODO more efficient iteration
            for (size_t i = 0; i < octaspire_container_list_get_length(value->value.list); ++i)
            {
                octaspire_dern_value_t * tmpVal = octaspire_container_list_node_get_element(
                    octaspire_container_list_get_at(value->value.list, i));

                if (octaspire_dern_value_is_atom(tmpVal))
                {
                    tmpVal = octaspire_dern_vm_create_new_value_copy(self->vm, tmpVal);
                }

                octaspire_dern_vm_push_value(self->vm, tmpVal);

                if (!octaspire_container_list_push_back(self->value.list, &tmpVal))
                {
                    abort();
                }

                octaspire_dern_vm_pop_value(self->vm, tmpVal);
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            if (!octaspire_dern_c_data_is_copying_allowed(value->value.cData))
            {
                return false;
            }

            self->value.cData =
                octaspire_dern_c_data_new_copy(
                    value->value.cData,
                    octaspire_dern_vm_get_allocator(self->vm));
        }
        break;
    }

    if (value->docstr)
    {
        // GC releases old if created
        self->docstr = octaspire_dern_vm_create_new_value_copy(self->vm, value->docstr);
    }

    if (value->docvec)
    {
        // GC releases old if created
        self->docvec = octaspire_dern_vm_create_new_value_copy(self->vm, value->docvec);
    }

    return true;
}

bool octaspire_dern_value_set_collection(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t const * const indexOrKey,
    octaspire_dern_value_t * const value)
{
    octaspire_helpers_verify_true(self && indexOrKey && value);

    if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING)
    {
        if (value->typeTag      != OCTASPIRE_DERN_VALUE_TAG_CHARACTER ||
            indexOrKey->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
        {
            return false;
        }

        return octaspire_container_utf8_string_overwrite_with_string_at(
            self->value.string,
            value->value.character,
            indexOrKey->value.integer);
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR)
    {
        if (indexOrKey->typeTag != OCTASPIRE_DERN_VALUE_TAG_INTEGER)
        {
            return false;
        }

        //bool const result = octaspire_container_vector_insert_element_before_the_element_at_index(

        if (indexOrKey->value.integer < 0)
        {
            // TODO index from back?
            return false;
        }

        // TODO XXX is this correct?
        if (octaspire_container_vector_get_length(self->value.vector) <= (size_t)indexOrKey->value.integer)
        {

            // octaspire_container_vector_insert_element_at cannot be used here, because
            // it fills the missing indices with 0. Now those must be nil-values.

            for (size_t i = octaspire_container_vector_get_length(self->value.vector);
                 i < (size_t)indexOrKey->value.integer;
                 ++i)
            {
                octaspire_dern_value_t *nilValue = octaspire_dern_vm_get_value_nil(self->vm);

                if (!octaspire_container_vector_push_back_element(
                    self->value.vector,
                    &nilValue))
                {
                    abort();
                }
            }

            octaspire_dern_value_t * const tmpValueForInsertion =
                octaspire_dern_value_is_atom(value) ?
                    octaspire_dern_vm_create_new_value_copy(self->vm, value) :
                    value;

            return octaspire_container_vector_push_back_element(
                self->value.vector,
                &tmpValueForInsertion);
        }
        else
        {
            octaspire_dern_value_t * const tmpValueForInsertion =
                octaspire_dern_value_is_atom(value) ?
                    octaspire_dern_vm_create_new_value_copy(self->vm, value) :
                    value;

            return octaspire_container_vector_replace_element_at(
                self->value.vector,
                indexOrKey->value.integer,
                &tmpValueForInsertion);
        }
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP)
    {
        octaspire_dern_value_t * const tmpValueForInsertion =
            octaspire_dern_value_is_atom(value) ?
            octaspire_dern_vm_create_new_value_copy(self->vm, value) :
            value;

        // Any previous value must be removed, because hash map
        // can contain multiple values per key, and we must replace, not
        // add the value.
        octaspire_container_hash_map_remove(
            self->value.hashMap,
            octaspire_dern_value_get_hash(indexOrKey),
            &indexOrKey);

        return octaspire_container_hash_map_put(
            self->value.hashMap,
            octaspire_dern_value_get_hash(indexOrKey),
            &indexOrKey,
            &tmpValueForInsertion);
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE)
    {
        // TODO XXX
        abort();
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST)
    {
        // TODO XXX
        abort();
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
    {
        // TODO XXX Should here a copy of atom be made or not?
        return octaspire_dern_environment_set(
            self->value.environment,
            indexOrKey,
            value);
    }

    return false;
}


uint32_t octaspire_dern_value_get_hash(
    octaspire_dern_value_t const * const self)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:         return octaspire_helpers_calculate_hash_for_bool_argument(false);
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:     return octaspire_helpers_calculate_hash_for_bool_argument(self->value.boolean);
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:     return octaspire_helpers_calculate_hash_for_int32_t_argument(self->value.integer);
        case OCTASPIRE_DERN_VALUE_TAG_REAL:        return octaspire_helpers_calculate_hash_for_double_argument(self->value.real);
        case OCTASPIRE_DERN_VALUE_TAG_STRING:      return octaspire_container_utf8_string_get_hash(self->value.string);
        case OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT:      return octaspire_container_utf8_string_get_hash(self->value.comment);
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:   return octaspire_container_utf8_string_get_hash(self->value.character);
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:      return octaspire_container_utf8_string_get_hash(self->value.symbol);
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:       return octaspire_container_utf8_string_get_hash(self->value.error);
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:      return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.vector);
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:    return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.hashMap);
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:       return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.queue);
        case OCTASPIRE_DERN_VALUE_TAG_LIST:        return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.list);
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT: return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.environment);
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:    return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.function);
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:     return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.special);
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:     return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.builtin);
        case OCTASPIRE_DERN_VALUE_TAG_PORT:        return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.port);
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:      return octaspire_helpers_calculate_hash_for_void_pointer_argument(self->value.cData);
    }

    abort();
    return 0;
}

bool octaspire_dern_value_is_equal(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    if (octaspire_dern_value_is_number(self))
    {
        if (!octaspire_dern_value_is_number(other))
        {
            return false;
        }
    }
    else if (self->typeTag != other->typeTag)
    {
        return false;
    }

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:         return true;
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:     return self->value.boolean == other->value.boolean;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            if (other->typeTag == self->typeTag)
            {
                return self->value.integer == other->value.integer;
            }

            return self->value.integer == other->value.real;
        }

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            if (other->typeTag == self->typeTag)
            {
                return self->value.real == other->value.real;
            }

            return self->value.real == other->value.integer;
        }

        case OCTASPIRE_DERN_VALUE_TAG_STRING:      return octaspire_container_utf8_string_is_equal(self->value.string, other->value.string);
        case OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT:      return octaspire_container_utf8_string_is_equal(self->value.comment, other->value.comment);
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:   return octaspire_container_utf8_string_is_equal(self->value.character, other->value.character);
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:      return octaspire_container_utf8_string_is_equal(self->value.symbol, other->value.symbol);
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:       return octaspire_container_utf8_string_is_equal(self->value.error, other->value.error);
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:      return self->value.vector == other->value.vector;
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:    return self->value.hashMap == other->value.hashMap;
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:       return self->value.queue == other->value.queue;
        case OCTASPIRE_DERN_VALUE_TAG_LIST:        return self->value.list == other->value.list;
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT: return self->value.environment == other->value.environment;
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:    return self->value.function == other->value.function;
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:     return self->value.special == other->value.special;
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:     return self->value.builtin == other->value.builtin;
        case OCTASPIRE_DERN_VALUE_TAG_PORT:        return self->value.port    == other->value.port;

        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            return octaspire_dern_c_data_is_equal(self->value.cData, other->value.cData);
        }
    }

    abort();
    return false;
}

bool octaspire_dern_value_is_less_than(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    if (octaspire_dern_value_is_number(self))
    {
        if (!octaspire_dern_value_is_number(other))
        {
            return false;
        }
    }
    else if (self->typeTag != other->typeTag)
    {
        return false;
    }

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:         return false;
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:     return self->value.boolean < other->value.boolean;
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            if (other->typeTag == self->typeTag)
            {
                return self->value.integer < other->value.integer;
            }

            return self->value.integer < other->value.real;

        }
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            if (other->typeTag == self->typeTag)
            {
                return self->value.real < other->value.real;
            }

            return self->value.real < other->value.integer;
        }

        // TODO XXX implement below
        /*
        case OCTASPIRE_DERN_VALUE_TAG_STRING:      return octaspire_container_utf8_string_is_equal(self->value.string, other->value.string);
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:   return octaspire_container_utf8_string_is_equal(self->value.character, other->value.character);
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:      return octaspire_container_utf8_string_is_equal(self->value.symbol, other->value.symbol);
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:       return octaspire_container_utf8_string_is_equal(self->value.error, other->value.error);
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:      return self->value.vector == other->value.vector;
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT: return self->value.environment == other->value.environment;
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:    return self->value.function == other->value.function;
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:     return self->value.special == other->value.special;
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:     return self->value.builtin == other->value.builtin;
        */
        default:
        {
            octaspire_helpers_verify_not_null(false);
        }
        break;
    }

    abort();
    return false;
}

bool octaspire_dern_value_is_greater_than(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    if (octaspire_dern_value_is_number(self))
    {
        if (!octaspire_dern_value_is_number(other))
        {
            return false;
        }
    }
    else if (self->typeTag != other->typeTag)
    {
        return false;
    }

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:         return false;
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:     return self->value.boolean > other->value.boolean;
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            if (other->typeTag == self->typeTag)
            {
                return self->value.integer > other->value.integer;
            }

            return self->value.integer > other->value.real;
        }

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            if (other->typeTag == self->typeTag)
            {
                return self->value.real > other->value.real;
            }

            return self->value.real > other->value.integer;
        }

        // TODO XXX implement below
        /*
        case OCTASPIRE_DERN_VALUE_TAG_STRING:      return octaspire_container_utf8_string_is_equal(self->value.string, other->value.string);
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:   return octaspire_container_utf8_string_is_equal(self->value.character, other->value.character);
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:      return octaspire_container_utf8_string_is_equal(self->value.symbol, other->value.symbol);
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:       return octaspire_container_utf8_string_is_equal(self->value.error, other->value.error);
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:      return self->value.vector == other->value.vector;
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT: return self->value.environment == other->value.environment;
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:    return self->value.function == other->value.function;
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:     return self->value.special == other->value.special;
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:     return self->value.builtin == other->value.builtin;
        */
        default:
        {
            octaspire_helpers_verify_not_null(false);
        }
        break;
    }

    abort();
    return false;
}

bool octaspire_dern_value_is_less_than_or_equal(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    if (octaspire_dern_value_is_number(self))
    {
        if (!octaspire_dern_value_is_number(other))
        {
            return false;
        }
    }
    else if (self->typeTag != other->typeTag)
    {
        return false;
    }

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:         return true;
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:     return self->value.boolean <= other->value.boolean;
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            if (other->typeTag == self->typeTag)
            {
                return self->value.integer <= other->value.integer;
            }

            return self->value.integer <= other->value.real;
        }

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            if (other->typeTag == self->typeTag)
            {
                return self->value.real <= other->value.real;
            }

            return self->value.real <= other->value.integer;
        }

        // TODO XXX implement below
        /*
        case OCTASPIRE_DERN_VALUE_TAG_STRING:      return octaspire_container_utf8_string_is_equal(self->value.string, other->value.string);
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:   return octaspire_container_utf8_string_is_equal(self->value.character, other->value.character);
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:      return octaspire_container_utf8_string_is_equal(self->value.symbol, other->value.symbol);
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:       return octaspire_container_utf8_string_is_equal(self->value.error, other->value.error);
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:      return self->value.vector == other->value.vector;
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT: return self->value.environment == other->value.environment;
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:    return self->value.function == other->value.function;
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:     return self->value.special == other->value.special;
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:     return self->value.builtin == other->value.builtin;
        */
        default:
        {
            octaspire_helpers_verify_not_null(false);
        }
        break;
    }

    abort();
    return false;
}

bool octaspire_dern_value_is_greater_than_or_equal(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    if (octaspire_dern_value_is_number(self))
    {
        if (!octaspire_dern_value_is_number(other))
        {
            return false;
        }
    }
    else if (self->typeTag != other->typeTag)
    {
        return false;
    }

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:         return true;
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:     return self->value.boolean >= other->value.boolean;
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            if (other->typeTag == self->typeTag)
            {
                return self->value.integer >= other->value.integer;
            }

            return self->value.integer >= other->value.real;
        }

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            if (other->typeTag == self->typeTag)
            {
                return self->value.real >= other->value.real;
            }

            return self->value.real >= other->value.integer;
        }

        // TODO XXX implement below
        /*
        case OCTASPIRE_DERN_VALUE_TAG_STRING:      return octaspire_container_utf8_string_is_equal(self->value.string, other->value.string);
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:   return octaspire_container_utf8_string_is_equal(self->value.character, other->value.character);
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:      return octaspire_container_utf8_string_is_equal(self->value.symbol, other->value.symbol);
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:       return octaspire_container_utf8_string_is_equal(self->value.error, other->value.error);
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:      return self->value.vector == other->value.vector;
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT: return self->value.environment == other->value.environment;
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:    return self->value.function == other->value.function;
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:     return self->value.special == other->value.special;
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:     return self->value.builtin == other->value.builtin;
        */
        default:
        {
            octaspire_helpers_verify_not_null(false);
        }
        break;
    }

    abort();
    return false;
}

octaspire_container_utf8_string_t *octaspire_dern_private_value_to_string(
    octaspire_dern_value_t const * const self,
    bool const plain,
    octaspire_memory_allocator_t * const allocator)
{
    octaspire_helpers_verify_not_null(self);

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        {
            return octaspire_container_utf8_string_new("nil", allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        {
            return octaspire_container_utf8_string_new_format(allocator, "%s", self->value.boolean ? "true" : "false");
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
            {
                return octaspire_container_utf8_string_new_format(allocator, "%" PRId32 "", self->value.integer);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_REAL:
            {
                return octaspire_container_utf8_string_new_format(allocator, "%g", self->value.real);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_STRING:
            {
                return octaspire_container_utf8_string_new_format(allocator, plain ? "%s" :"[%s]",
                    octaspire_container_utf8_string_get_c_string(self->value.string));
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT:
            {
                return octaspire_container_utf8_string_new_format(allocator, "#!\n%s\n!#",
                    octaspire_container_utf8_string_get_c_string(self->value.comment));
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
            {
                if (octaspire_container_utf8_string_is_equal_to_c_string(self->value.character, "|"))
                {
                    return octaspire_container_utf8_string_new(plain ? "|" : "|bar|", allocator);
                }
                else if (octaspire_container_utf8_string_is_equal_to_c_string(self->value.character, "\n"))
                {
                    return octaspire_container_utf8_string_new(plain ? "\n" : "|newline|", allocator);
                }
                else if (octaspire_container_utf8_string_is_equal_to_c_string(self->value.character, "\t"))
                {
                    return octaspire_container_utf8_string_new(plain ? "\t" :"|tab|", allocator);
                }
                else
                {
                    return octaspire_container_utf8_string_new_format(
                        allocator,
                        plain ? "%s" : "|%s|",
                        octaspire_container_utf8_string_get_c_string(self->value.character));
                }
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
            {
                return octaspire_container_utf8_string_new_format(allocator, "%s",
                    octaspire_container_utf8_string_get_c_string(self->value.symbol));
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_ERROR:
            {
                return octaspire_container_utf8_string_new_format(allocator, "<error>: %s",
                    octaspire_container_utf8_string_get_c_string(self->value.error));
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
            {
                octaspire_container_utf8_string_t *result = octaspire_container_utf8_string_new("(", allocator);
                octaspire_helpers_verify_not_null(result);

                for (size_t i = 0; i < octaspire_container_vector_get_length(self->value.vector); ++i)
                {
                    octaspire_dern_value_t *tmpValue =
                        octaspire_container_vector_get_element_at(self->value.vector, i);

                    octaspire_helpers_verify_not_null(tmpValue);

                    octaspire_container_utf8_string_t *tmpStr = octaspire_dern_value_to_string(
                        tmpValue,
                        allocator);

                    octaspire_helpers_verify_not_null(tmpStr);

                    if (!octaspire_container_utf8_string_concatenate_c_string(
                        result,
                        octaspire_container_utf8_string_get_c_string(tmpStr)))
                    {
                        abort();
                    }

                    octaspire_container_utf8_string_release(tmpStr);
                    tmpStr = 0;

                    if ((i+1) < octaspire_container_vector_get_length(self->value.vector))
                    {
                        octaspire_container_utf8_string_concatenate_c_string(result, " ");
                    }
                }

                if (!octaspire_container_utf8_string_concatenate_c_string(
                    result,
                    ")"))
                {
                    abort();
                }

                return result;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
            {
                octaspire_container_utf8_string_t *result =
                    octaspire_container_utf8_string_new("(hash-map ",allocator);

                octaspire_helpers_verify_not_null(result);

                for (size_t i = 0;
                    i < octaspire_container_hash_map_get_number_of_elements(self->value.hashMap);
                    ++i)
                {
                    octaspire_container_hash_map_element_t *element = 
                        octaspire_container_hash_map_get_at_index(self->value.hashMap, i);

                    // Key
                    octaspire_container_utf8_string_t *tmpStr = octaspire_dern_value_to_string(
                        octaspire_container_hash_map_element_get_key(element),
                        allocator);

                    octaspire_helpers_verify_not_null(tmpStr);

                    if (!octaspire_container_utf8_string_concatenate_c_string(
                        result,
                        octaspire_container_utf8_string_get_c_string(tmpStr)))
                    {
                        abort();
                    }

                    octaspire_container_utf8_string_release(tmpStr);
                    tmpStr = 0;

                    // " "
                    if (!octaspire_container_utf8_string_concatenate_c_string(
                        result,
                        " "))
                    {
                        abort();
                    }

                    // Value
                    tmpStr = octaspire_dern_value_to_string(
                        octaspire_container_hash_map_element_get_value(element),
                        allocator);

                    octaspire_helpers_verify_not_null(tmpStr);

                    if (!octaspire_container_utf8_string_concatenate_c_string(
                        result,
                        octaspire_container_utf8_string_get_c_string(tmpStr)))
                    {
                        abort();
                    }

                    octaspire_container_utf8_string_release(tmpStr);
                    tmpStr = 0;


                    if ((i+1) < octaspire_container_hash_map_get_number_of_elements(self->value.hashMap))
                    {
                        octaspire_container_utf8_string_concatenate_c_string(result, "\n          ");
                    }
                }

                if (!octaspire_container_utf8_string_concatenate_c_string(
                    result,
                    ")"))
                {
                    abort();
                }

                return result;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
            {
                octaspire_container_utf8_string_t *result = octaspire_container_utf8_string_new("(queue ", allocator);
                octaspire_helpers_verify_not_null(result);

                // Add iterator into queue and use it here
                for (size_t i = 0; i < octaspire_container_queue_get_length(self->value.queue); ++i)
                {
                    octaspire_dern_value_t *tmpValue =
                        octaspire_container_queue_get_at(self->value.queue, i);

                    octaspire_helpers_verify_not_null(tmpValue);

                    octaspire_container_utf8_string_t *tmpStr = octaspire_dern_value_to_string(
                        tmpValue,
                        allocator);

                    octaspire_helpers_verify_not_null(tmpStr);

                    if (!octaspire_container_utf8_string_concatenate_c_string(
                        result,
                        octaspire_container_utf8_string_get_c_string(tmpStr)))
                    {
                        abort();
                    }

                    octaspire_container_utf8_string_release(tmpStr);
                    tmpStr = 0;

                    if ((i+1) < octaspire_container_queue_get_length(self->value.queue))
                    {
                        octaspire_container_utf8_string_concatenate_c_string(result, " ");
                    }
                }

                if (!octaspire_container_utf8_string_concatenate_c_string(
                    result,
                    ")"))
                {
                    abort();
                }

                return result;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_LIST:
            {
                octaspire_container_utf8_string_t *result = octaspire_container_utf8_string_new("(list ", allocator);
                octaspire_helpers_verify_not_null(result);

                // More efficient iteration
                for (size_t i = 0; i < octaspire_container_list_get_length(self->value.list); ++i)
                {
                    octaspire_dern_value_t *tmpValue = octaspire_container_list_node_get_element(
                        octaspire_container_list_get_at(self->value.list, i));

                    octaspire_helpers_verify_not_null(tmpValue);

                    octaspire_container_utf8_string_t *tmpStr = octaspire_dern_value_to_string(
                        tmpValue,
                        allocator);

                    octaspire_helpers_verify_not_null(tmpStr);

                    if (!octaspire_container_utf8_string_concatenate_c_string(
                        result,
                        octaspire_container_utf8_string_get_c_string(tmpStr)))
                    {
                        abort();
                    }

                    octaspire_container_utf8_string_release(tmpStr);
                    tmpStr = 0;

                    if ((i+1) < octaspire_container_list_get_length(self->value.list))
                    {
                        octaspire_container_utf8_string_concatenate_c_string(result, " ");
                    }
                }

                if (!octaspire_container_utf8_string_concatenate_c_string(
                    result,
                    ")"))
                {
                    abort();
                }

                return result;
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
            {
                return octaspire_container_utf8_string_new("<function>", allocator);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
            {
                return octaspire_container_utf8_string_new("<builtin>", allocator);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_PORT:
            {
                return octaspire_dern_port_to_string(self->value.port, allocator);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
            {
                return octaspire_dern_c_data_to_string(self->value.cData, allocator);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
            {
                return octaspire_container_utf8_string_new("<special>", allocator);
            }
            break;

            case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
            {
                octaspire_helpers_verify_not_null(self->value.environment);
                return octaspire_dern_environment_to_string(self->value.environment);
            }
            break;

            default:
            {
                printf(">>>>>>>typeTag problem %i\n", (int)self->typeTag);
                // TODO XXX add support for rest of the value-types
                octaspire_helpers_verify_not_null(false);
            }
            break;
        }

    abort();
    return 0;
}

octaspire_container_utf8_string_t *octaspire_dern_value_to_string(
octaspire_dern_value_t const * const self,
octaspire_memory_allocator_t * const allocator)
{
    return octaspire_dern_private_value_to_string(self, false, allocator);
}

octaspire_container_utf8_string_t *octaspire_dern_value_to_string_plain(
octaspire_dern_value_t const * const self,
octaspire_memory_allocator_t * const allocator)
{
    return octaspire_dern_private_value_to_string(self, true, allocator);
}

bool octaspire_dern_value_is_integer(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER;
}

bool octaspire_dern_value_is_real(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL;
}

bool octaspire_dern_value_is_number(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER ||
           self->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL;
}

bool octaspire_dern_value_is_nil(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_NIL;
}

bool octaspire_dern_value_is_boolean(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_BOOLEAN;
}

bool octaspire_dern_value_is_character(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER;
}

bool octaspire_dern_value_is_string(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING;
}

bool octaspire_dern_value_is_symbol(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL;
}

bool octaspire_dern_value_is_text(
    octaspire_dern_value_t const * const self)
{
    return
        self->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER ||
        self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING    ||
        self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL;
}

bool octaspire_dern_value_is_vector(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR;
}

bool octaspire_dern_value_is_hash_map(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP;
}

bool octaspire_dern_value_is_queue(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE;
}

bool octaspire_dern_value_is_list(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST;
}

bool octaspire_dern_value_is_port(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_PORT;
}

bool octaspire_dern_value_is_environment(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT;
}

bool octaspire_dern_value_is_function(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_FUNCTION;
}

bool octaspire_dern_value_is_c_data(
    octaspire_dern_value_t const * const self)
{
    return self->typeTag == OCTASPIRE_DERN_VALUE_TAG_C_DATA;
}

void octaspire_dern_value_print(
    octaspire_dern_value_t const * const self,
    octaspire_memory_allocator_t *allocator)
{
    octaspire_container_utf8_string_t *str = octaspire_dern_value_to_string(self, allocator);
    printf("%s\n", octaspire_container_utf8_string_get_c_string(str));
    octaspire_container_utf8_string_release(str);
    str = 0;
}

uintmax_t octaspire_dern_value_get_unique_id(
    octaspire_dern_value_t const * const self)
{
    return self->uniqueId;
}

bool octaspire_dern_value_as_boolean_get_value(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_BOOLEAN);
    return self->value.boolean;
}

int32_t octaspire_dern_value_as_integer_get_value(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER);
    return self->value.integer;
}

double octaspire_dern_value_as_real_get_value(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL);
    return self->value.real;
}

double octaspire_dern_value_as_number_get_value(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(octaspire_dern_value_is_number(self));

    if (octaspire_dern_value_is_integer(self))
    {
        return (double)self->value.integer;
    }

    return self->value.real;
}

bool octaspire_dern_value_as_hash_map_remove(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const keyValue)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);

    return octaspire_container_hash_map_remove(
        self->value.hashMap,
        octaspire_dern_value_get_hash(keyValue),
        &keyValue);
}

bool octaspire_dern_value_as_hash_map_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const toBeAdded1,
    octaspire_dern_value_t * const toBeAdded2)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);

    switch (toBeAdded1->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            octaspire_helpers_verify_null(toBeAdded2);

            return octaspire_container_hash_map_add_hash_map(
                self->value.hashMap,
                toBeAdded1->value.hashMap);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            octaspire_helpers_verify_null(toBeAdded2);

            size_t const vecLen = octaspire_dern_value_as_vector_get_length(toBeAdded1);

            if (vecLen % 2 != 0)
            {
                return false;
            }

            bool result = true;
            for (size_t i = 0; i < vecLen; i += 2)
            {
                octaspire_dern_value_t *key = octaspire_dern_value_as_vector_get_element_at(toBeAdded1, i);
                octaspire_dern_value_t *val = octaspire_dern_value_as_vector_get_element_at(toBeAdded1, i + 1);

                uint32_t const hash = octaspire_dern_value_get_hash(key);

                if (!octaspire_dern_value_as_hash_map_put(
                        self,
                        hash,
                        key,
                        val))
                {
                    result = false;
                }
            }

            return result;
        }
        break;

        default:
        {
            if (!toBeAdded2)
            {
                return false;
            }

            uint32_t const hash = octaspire_dern_value_get_hash(toBeAdded1);

            if (!octaspire_dern_value_as_hash_map_put(
                    self,
                    hash,
                    toBeAdded1,
                    toBeAdded2))
            {
                return false;
            }

            return true;
        }
    }

    return false;
}

bool octaspire_dern_value_as_queue_push(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const toBeAdded)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE);

    if (octaspire_dern_value_is_atom(toBeAdded))
    {
        octaspire_dern_value_t * const copyVal =
            octaspire_dern_vm_create_new_value_copy(self->vm, toBeAdded);

        return octaspire_container_queue_push(self->value.queue, &copyVal);
    }

    return octaspire_container_queue_push(self->value.queue, &toBeAdded);
}

bool octaspire_dern_value_as_queue_pop(octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE);
    return octaspire_container_queue_pop(self->value.queue);
}

bool octaspire_dern_value_as_list_push_back(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const toBeAdded)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST);

    if (octaspire_dern_value_is_atom(toBeAdded))
    {
        octaspire_dern_value_t * const copyVal =
            octaspire_dern_vm_create_new_value_copy(self->vm, toBeAdded);

        return octaspire_container_list_push_back(self->value.list, &copyVal);
    }

    return octaspire_container_list_push_back(self->value.list, &toBeAdded);
}

bool octaspire_dern_value_as_list_pop_back(octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST);
    return octaspire_container_list_pop_back(self->value.list);
}

bool octaspire_dern_value_as_character_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER);

    switch (other->typeTag)
    {
        // TODO should adding of char, string and vector be allowed?
        // It could turn this character into a string.

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            uint32_t const charAsInt = octaspire_container_utf8_string_get_ucs_character_at_index(
                self->value.character,
                0);

            octaspire_container_utf8_string_clear(self->value.character);

            octaspire_container_utf8_string_push_back_ucs_character(
                self->value.character, 
                charAsInt + other->value.integer);

            return true;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
           octaspire_container_utf8_string_t *newStr = octaspire_container_utf8_string_new_copy(
                self->value.character,
                octaspire_dern_vm_get_allocator(self->vm));

            octaspire_container_utf8_string_release(self->value.character);
            self->value.character = 0;

            self->value.string = newStr;

            octaspire_container_utf8_string_concatenate(self->value.string, other->value.character);

            self->typeTag = OCTASPIRE_DERN_VALUE_TAG_STRING;

            return true;
        }
        break;

        default:
        {
            return false;
        }
    }
}

bool octaspire_dern_value_as_character_subtract(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER);

    switch (other->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            uint32_t const charAsInt = octaspire_container_utf8_string_get_ucs_character_at_index(
                self->value.character,
                0);

            octaspire_container_utf8_string_clear(self->value.character);

            octaspire_container_utf8_string_push_back_ucs_character(
                self->value.character,
                charAsInt - other->value.integer);

            return true;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            uint32_t const charAsInt = octaspire_container_utf8_string_get_ucs_character_at_index(
                self->value.character,
                0);

            uint32_t const otherAsInt = octaspire_container_utf8_string_get_ucs_character_at_index(
                other->value.character,
                0);

            octaspire_container_utf8_string_clear(self->value.character);

            octaspire_container_utf8_string_push_back_ucs_character(
                self->value.character,
                charAsInt - otherAsInt);

            return true;
        }
        break;

        default:
        {
            return false;
        }
    }
}

bool octaspire_dern_value_as_integer_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER);

    switch (other->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_container_utf8_string_t *chars = octaspire_container_utf8_string_new(
                "-0123456789.",
                octaspire_dern_vm_get_allocator(self->vm));

            if (octaspire_container_utf8_string_contains_only_these_chars(other->value.string, chars))
            {
                if (octaspire_container_utf8_string_contains_char(other->value.string, (uint32_t)'.'))
                {
                    self->typeTag = OCTASPIRE_DERN_VALUE_TAG_REAL;
                    self->value.real = self->value.integer;

                    self->value.real +=
                        atof(octaspire_container_utf8_string_get_c_string(other->value.string));

                    return true;
                }
                else
                {
                    self->value.integer +=
                        atol(octaspire_container_utf8_string_get_c_string(other->value.string));

                    return true;
                }
            }
            else
            {
                return false;
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            self->value.integer += other->value.integer;
            return true;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            self->typeTag = OCTASPIRE_DERN_VALUE_TAG_REAL;
            self->value.real = self->value.integer;
            self->value.real += other->value.real;
            return true;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            bool result = true;
            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(other); ++i)
            {
                if (!octaspire_dern_value_as_integer_add(
                        self,
                        octaspire_dern_value_as_vector_get_element_at(other, i)))
                {
                    result = false;
                }
            }

            return result;
        }
        break;

        default:
        {
            return false;
        }
    }
}

bool octaspire_dern_value_as_integer_subtract(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER);

    switch (other->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_container_utf8_string_t *chars = octaspire_container_utf8_string_new(
                "-0123456789.",
                octaspire_dern_vm_get_allocator(self->vm));

            if (octaspire_container_utf8_string_contains_only_these_chars(other->value.string, chars))
            {
                if (octaspire_container_utf8_string_contains_char(other->value.string, (uint32_t)'.'))
                {
                    self->typeTag = OCTASPIRE_DERN_VALUE_TAG_REAL;
                    self->value.real = self->value.integer;

                    self->value.real -=
                        atof(octaspire_container_utf8_string_get_c_string(other->value.string));

                    return true;
                }
                else
                {
                    self->value.integer -=
                        atol(octaspire_container_utf8_string_get_c_string(other->value.string));

                    return true;
                }
            }
            else
            {
                return false;
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            self->value.integer -= other->value.integer;
            return true;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            self->typeTag = OCTASPIRE_DERN_VALUE_TAG_REAL;
            self->value.real = self->value.integer;
            self->value.real -= other->value.real;
            return true;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            bool result = true;
            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(other); ++i)
            {
                if (!octaspire_dern_value_as_integer_subtract(
                        self,
                        octaspire_dern_value_as_vector_get_element_at(other, i)))
                {
                    result = false;
                }
            }

            return result;
        }
        break;

        default:
        {
            return false;
        }
    }
}

bool octaspire_dern_value_as_real_add(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL);

    switch (other->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_container_utf8_string_t *chars = octaspire_container_utf8_string_new(
                "-0123456789.",
                octaspire_dern_vm_get_allocator(self->vm));

            if (octaspire_container_utf8_string_contains_only_these_chars(other->value.string, chars))
            {
                if (octaspire_container_utf8_string_contains_char(other->value.string, (uint32_t)'.'))
                {
                    self->value.real +=
                        atof(octaspire_container_utf8_string_get_c_string(other->value.string));

                    return true;
                }
                else
                {
                    self->value.real +=
                        atol(octaspire_container_utf8_string_get_c_string(other->value.string));

                    return true;
                }
            }
            else
            {
                return false;
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            self->value.real += other->value.integer;
            return true;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            self->value.real += other->value.real;
            return true;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            bool result = true;
            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(other); ++i)
            {
                if (!octaspire_dern_value_as_real_add(
                        self,
                        octaspire_dern_value_as_vector_get_element_at(other, i)))
                {
                    result = false;
                }
            }

            return result;
        }
        break;

        default:
        {
            return false;
        }
    }
}

bool octaspire_dern_value_as_real_subtract(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const other)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL);

    switch (other->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_container_utf8_string_t *chars = octaspire_container_utf8_string_new(
                "-0123456789.",
                octaspire_dern_vm_get_allocator(self->vm));

            if (octaspire_container_utf8_string_contains_only_these_chars(other->value.string, chars))
            {
                if (octaspire_container_utf8_string_contains_char(other->value.string, (uint32_t)'.'))
                {
                    self->value.real -=
                        atof(octaspire_container_utf8_string_get_c_string(other->value.string));

                    return true;
                }
                else
                {
                    self->value.real -=
                        atol(octaspire_container_utf8_string_get_c_string(other->value.string));

                    return true;
                }
            }
            else
            {
                return false;
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            self->value.real -= other->value.integer;
            return true;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            self->value.real -= other->value.real;
            return true;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            bool result = true;
            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(other); ++i)
            {
                if (!octaspire_dern_value_as_real_subtract(
                        self,
                        octaspire_dern_value_as_vector_get_element_at(other, i)))
                {
                    result = false;
                }
            }

            return result;
        }
        break;

        default:
        {
            return false;
        }
    }
}

char const *octaspire_dern_value_as_character_get_c_string(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER);
    return octaspire_container_utf8_string_get_c_string(self->value.character);
}

bool octaspire_dern_value_as_string_push_back(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const value)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            return octaspire_container_utf8_string_concatenate(
                self->value.string,
                value->value.string);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            return octaspire_container_utf8_string_concatenate(
                self->value.string,
                value->value.symbol);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            return octaspire_container_utf8_string_concatenate(
                self->value.string,
                value->value.character);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            bool result = true;
            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(value); ++i)
            {
                if (!octaspire_dern_value_as_string_push_back(
                        self,
                        octaspire_dern_value_as_vector_get_element_at(value, i)))
                {
                    result = false;
                }
            }

            return result;
        }
        break;

        default:
        {
            octaspire_container_utf8_string_t *tmpStr =
                octaspire_dern_value_to_string(value, octaspire_dern_vm_get_allocator(self->vm));

            bool result = octaspire_container_utf8_string_concatenate(self->value.string, tmpStr);

            octaspire_container_utf8_string_release(tmpStr);
            tmpStr = 0;

            return result;
        }
    }
}

bool octaspire_dern_value_as_symbol_push_back(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const value)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            return octaspire_container_utf8_string_concatenate(
                self->value.symbol,
                value->value.string);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            return octaspire_container_utf8_string_concatenate(
                self->value.symbol,
                value->value.symbol);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            return octaspire_container_utf8_string_concatenate(
                self->value.symbol,
                value->value.character);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            bool result = true;
            for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(value); ++i)
            {
                if (!octaspire_dern_value_as_symbol_push_back(
                        self,
                        octaspire_dern_value_as_vector_get_element_at(value, i)))
                {
                    result = false;
                }
            }

            return result;
        }
        break;

        default:
        {
            octaspire_container_utf8_string_t *tmpStr =
                octaspire_dern_value_to_string(value, octaspire_dern_vm_get_allocator(self->vm));

            bool result = octaspire_container_utf8_string_concatenate(self->value.symbol, tmpStr);

            octaspire_container_utf8_string_release(tmpStr);
            tmpStr = 0;

            return result;
        }
    }
}

bool octaspire_dern_value_as_string_pop_back_ucs_character(
    octaspire_dern_value_t * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);

    return octaspire_container_utf8_string_pop_back_ucs_character(self->value.string);
}

bool octaspire_dern_value_as_string_remove_all_substrings(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_t * const value)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_container_utf8_string_remove_all_substrings(
                self->value.string,
                value->value.string);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            octaspire_container_utf8_string_remove_all_substrings(
                self->value.string,
                value->value.character);
        }
        break;

        default:
        {
            return false;
        }
    }

    return true;
}

char const *octaspire_dern_value_as_string_get_c_string(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING);
    return octaspire_container_utf8_string_get_c_string(self->value.string);
}

char const *octaspire_dern_value_as_symbol_get_c_string(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);
    return octaspire_container_utf8_string_get_c_string(self->value.symbol);
}

bool octaspire_dern_value_as_symbol_is_equal_to_c_string(
    octaspire_dern_value_t const * const self,
    char const * const str)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL);
    return octaspire_container_utf8_string_is_equal_to_c_string(self->value.symbol, str);
}

char const *octaspire_dern_value_as_text_get_c_string(
    octaspire_dern_value_t const * const self)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            return octaspire_container_utf8_string_get_c_string(self->value.character);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            return octaspire_container_utf8_string_get_c_string(self->value.string);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            return octaspire_container_utf8_string_get_c_string(self->value.symbol);
        }
        break;

        default:
        {
            octaspire_helpers_verify_true(false);
        }
        break;
    }

    return 0;
}

size_t octaspire_dern_value_as_text_get_length_in_octets(
    octaspire_dern_value_t const * const self)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            return octaspire_container_utf8_string_get_length_in_octets(self->value.character);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            return octaspire_container_utf8_string_get_length_in_octets(self->value.string);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            return octaspire_container_utf8_string_get_length_in_octets(self->value.symbol);
        }
        break;

        default:
        {
            octaspire_helpers_verify_true(false);
        }
        break;
    }

    return 0;
}

size_t octaspire_dern_value_as_vector_get_length(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    return octaspire_container_vector_get_length(self->value.vector);
}

bool octaspire_dern_value_as_vector_is_valid_index(
    octaspire_dern_value_t const * const self,
    ptrdiff_t const index)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    return octaspire_container_vector_is_valid_index(self->value.vector, index);
}

bool octaspire_dern_value_as_vector_push_front_element(
    octaspire_dern_value_t *self,
    void const *element)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_not_null(element);

    return octaspire_container_vector_push_front_element(self->value.vector, element);
}

bool octaspire_dern_value_as_vector_push_back_element(
    octaspire_dern_value_t *self,
    void const *element)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    octaspire_helpers_verify_not_null(element);

    return octaspire_container_vector_push_back_element(self->value.vector, element);
}

bool octaspire_dern_value_as_vector_remove_element_at(
    octaspire_dern_value_t *self,
    size_t const index)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    return octaspire_container_vector_remove_element_at(self->value.vector, index);
}

bool octaspire_dern_value_as_vector_pop_back_element(octaspire_dern_value_t *self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    return octaspire_container_vector_pop_back_element(self->value.vector);
}

octaspire_dern_value_t *octaspire_dern_value_as_vector_get_element_at(
    octaspire_dern_value_t * const self,
    size_t const index)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    return octaspire_container_vector_get_element_at(self->value.vector, index);
}

octaspire_dern_value_t const *octaspire_dern_value_as_vector_get_element_at_const(
    octaspire_dern_value_t const * const self,
    size_t const index)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);

    return octaspire_container_vector_get_element_at_const(self->value.vector, index);
}

octaspire_dern_value_t *octaspire_dern_value_as_vector_get_element_of_type_at(
    octaspire_dern_value_t * const self,
    octaspire_dern_value_tag_t const typeTag,
    size_t const index)
{
    octaspire_dern_value_t * result = octaspire_dern_value_as_vector_get_element_at(self, index);

    octaspire_helpers_verify_not_null(result);

    if (result->typeTag == typeTag)
    {
        return result;
    }

    return 0;
}

octaspire_dern_value_t const *octaspire_dern_value_as_vector_get_element_of_type_at_const(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_tag_t const typeTag,
    size_t const index)
{
    octaspire_dern_value_t const *result =
        octaspire_dern_value_as_vector_get_element_at_const(self,index);

    octaspire_helpers_verify_not_null(result);

    if (result->typeTag == typeTag)
    {
        return result;
    }

    return 0;
}

// TODO how about as_vector, should it have void* replaced with octaspire_dern_value_t*?
bool octaspire_dern_value_as_hash_map_put(
    octaspire_dern_value_t *self,
    uint32_t const hash,
    octaspire_dern_value_t const * const key,
    octaspire_dern_value_t *value)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);
    return octaspire_container_hash_map_put(self->value.hashMap, hash, &key, &value);
}

size_t octaspire_dern_value_as_hash_map_get_number_of_elements(
    octaspire_dern_value_t const * const self)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);
    return octaspire_container_hash_map_get_number_of_elements(self->value.hashMap);
}

octaspire_container_hash_map_element_t *octaspire_dern_value_as_hash_map_get_at_index(
    octaspire_dern_value_t * const self,
    size_t const index)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);
    return octaspire_container_hash_map_get_at_index(self->value.hashMap, index);
}

octaspire_container_hash_map_element_t *octaspire_dern_value_as_hash_map_get(
    octaspire_dern_value_t * const self,
    uint32_t const hash,
    octaspire_dern_value_t const * const key)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);
    return octaspire_container_hash_map_get(self->value.hashMap, hash, &key);
}

octaspire_container_hash_map_element_t const * octaspire_dern_value_as_hash_map_get_const(
    octaspire_dern_value_t const * const self,
    uint32_t const hash,
    octaspire_dern_value_t const * const key)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);
    return octaspire_container_hash_map_get_const(self->value.hashMap, hash, &key);
}

octaspire_dern_value_t *octaspire_dern_value_as_hash_map_get_value_for_symbol_key_using_c_string(
    octaspire_dern_value_t * const self,
    char const * const keySymbolsContentAsCString)
{
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);

    octaspire_dern_value_t * const key = octaspire_dern_vm_create_new_value_symbol_from_c_string(
        self->vm,
        keySymbolsContentAsCString);

    octaspire_helpers_verify_not_null(key);

    octaspire_container_hash_map_element_t * const element = octaspire_dern_value_as_hash_map_get(
        self,
        octaspire_dern_value_get_hash(key),
        key);

    if (!element)
    {
        return 0;
    }

    return octaspire_container_hash_map_element_get_value(element);
}

octaspire_dern_value_t const *octaspire_dern_value_as_hash_map_get_value_for_symbol_key_using_c_string_const(
    octaspire_dern_value_t const * const self,
    char const * const keySymbolsContentAsCString)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self->vm);
    octaspire_helpers_verify_true(self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);

    octaspire_dern_value_t * const key =
        octaspire_dern_vm_create_new_value_symbol_from_c_string(
            self->vm,
            keySymbolsContentAsCString);

    octaspire_helpers_verify_not_null(key);

    octaspire_dern_vm_push_value(self->vm, key);

    octaspire_container_hash_map_element_t const * const element =
        octaspire_dern_value_as_hash_map_get_const(
            self,
            octaspire_dern_value_get_hash(key),
            key);

    octaspire_dern_vm_pop_value(self->vm, key);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self->vm));

    if (!element)
    {
        return 0;
    }

    return octaspire_container_hash_map_element_get_value(element);
}

size_t octaspire_dern_value_get_length(
    octaspire_dern_value_t const * const self)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:         return 1;
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:     return 1;
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:     return 1;
        case OCTASPIRE_DERN_VALUE_TAG_REAL:        return 1;
        case OCTASPIRE_DERN_VALUE_TAG_STRING:      return octaspire_container_utf8_string_get_length_in_ucs_characters(self->value.string);
        case OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT:      return octaspire_container_utf8_string_get_length_in_ucs_characters(self->value.comment);
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:   return 1;
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:      return octaspire_container_utf8_string_get_length_in_ucs_characters(self->value.symbol);
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:       return octaspire_container_utf8_string_get_length_in_ucs_characters(self->value.error);
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:      return octaspire_container_vector_get_length(self->value.vector);
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:    return octaspire_container_hash_map_get_number_of_elements(self->value.hashMap);
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:       return octaspire_container_queue_get_length(self->value.queue);
        case OCTASPIRE_DERN_VALUE_TAG_LIST:        return octaspire_container_list_get_length(self->value.list);
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT: return octaspire_dern_environment_get_length(self->value.environment);
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:    return octaspire_dern_function_get_number_of_required_arguments(self->value.function);
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:     return self->value.special->numRequiredActualArguments;
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:     return self->value.builtin->numRequiredActualArguments;
        case OCTASPIRE_DERN_VALUE_TAG_PORT:        return (size_t)octaspire_dern_port_get_length_in_octets(self->value.port);
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
           // TODO continue from here
           return 1;
        }
    }

    abort();
    return 0;
}

bool octaspire_dern_value_mark(octaspire_dern_value_t *self)
{
    if (self->mark)
    {
        return true;
    }

    self->mark = true;

    if (self->docstr)
    {
        if (!octaspire_dern_value_mark(self->docstr))
        {
            return false;
        }
    }

    if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR)
    {
        for (size_t i = 0; i < octaspire_container_vector_get_length(self->value.vector); ++i)
        {
            octaspire_dern_value_t * const tmpVal =
                octaspire_container_vector_get_element_at(self->value.vector, i);

            octaspire_helpers_verify_not_null(tmpVal);

            if (!octaspire_dern_value_mark(tmpVal))
            {
                return false;
            }
        }
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_HASH_MAP)
    {
        octaspire_container_hash_map_element_iterator_t iter =
            octaspire_container_hash_map_element_iterator_init(self->value.hashMap);

        while (iter.element)
        {
            if (!octaspire_dern_value_mark(octaspire_container_hash_map_element_get_key(iter.element)))
            {
                return false;
            }

            if (!octaspire_dern_value_mark(octaspire_container_hash_map_element_get_value(iter.element)))
            {
                return false;
            }

            octaspire_container_hash_map_element_iterator_next(&iter);
        }
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_QUEUE)
    {
        // TODO Add iterator into queue and use it here
        for (size_t i = 0; i < octaspire_container_queue_get_length(self->value.queue); ++i)
        {
            octaspire_dern_value_t * const tmpVal =
                octaspire_container_queue_get_at(self->value.queue, i);

            octaspire_helpers_verify_not_null(tmpVal);

            if (!octaspire_dern_value_mark(tmpVal))
            {
                return false;
            }
        }
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_LIST)
    {
        // TODO More efficient iteration
        for (size_t i = 0; i < octaspire_container_list_get_length(self->value.list); ++i)
        {
            octaspire_dern_value_t * const tmpVal = octaspire_container_list_node_get_element(
                octaspire_container_list_get_at(self->value.list, i));

            octaspire_helpers_verify_not_null(tmpVal);

            if (!octaspire_dern_value_mark(tmpVal))
            {
                return false;
            }
        }
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_FUNCTION)
    {
        bool status = true;

        if (!octaspire_dern_value_mark(self->value.function->formals))
        {
            status = false;
        }

        if (!octaspire_dern_value_mark(self->value.function->body))
        {
            status = false;
        }

        if (!octaspire_dern_value_mark(self->value.function->definitionEnvironment))
        {
            status = false;
        }

        return status;
    }
    else if (self->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT)
    {
        return octaspire_dern_environment_mark(self->value.environment);
    }

    return true;
}

int octaspire_dern_value_compare(
    octaspire_dern_value_t const * const self,
    octaspire_dern_value_t const * const other)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(other);

    if (self->typeTag != other->typeTag)
    {
        return (int)(self->typeTag) - (int)(other->typeTag);
    }

    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:         return 0;
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:     return self->value.boolean - other->value.boolean;
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:     return self->value.integer - other->value.integer;
        case OCTASPIRE_DERN_VALUE_TAG_REAL:        return self->value.real    - other->value.real;
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            return strcmp(
                octaspire_container_utf8_string_get_c_string(self->value.string),
                octaspire_container_utf8_string_get_c_string(other->value.string));
        }
        case OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT:
        {
            return strcmp(
                octaspire_container_utf8_string_get_c_string(self->value.comment),
                octaspire_container_utf8_string_get_c_string(other->value.comment));
        }
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            return strcmp(
                octaspire_container_utf8_string_get_c_string(self->value.character),
                octaspire_container_utf8_string_get_c_string(other->value.character));
        }
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            return strcmp(
                octaspire_container_utf8_string_get_c_string(self->value.symbol),
                octaspire_container_utf8_string_get_c_string(other->value.symbol));
        }
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            return strcmp(
                octaspire_container_utf8_string_get_c_string(self->value.error),
                octaspire_container_utf8_string_get_c_string(other->value.error));
        }
        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:      return (ptrdiff_t)self->value.vector - (ptrdiff_t)other->value.vector;
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:    return (ptrdiff_t)self->value.hashMap - (ptrdiff_t)other->value.hashMap;
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:       return (ptrdiff_t)self->value.queue - (ptrdiff_t)other->value.queue;
        case OCTASPIRE_DERN_VALUE_TAG_LIST:        return (ptrdiff_t)self->value.list - (ptrdiff_t)other->value.list;
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT: return (ptrdiff_t)self->value.environment - (ptrdiff_t)other->value.environment;
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:    return (ptrdiff_t)self->value.function - (ptrdiff_t)other->value.function;
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:     return (ptrdiff_t)self->value.special - (ptrdiff_t)other->value.special;
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:     return (ptrdiff_t)self->value.builtin - (ptrdiff_t)other->value.builtin;
        case OCTASPIRE_DERN_VALUE_TAG_PORT:        return (ptrdiff_t)self->value.port - (ptrdiff_t)other->value.port;

        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            return octaspire_dern_c_data_compare(self->value.cData, other->value.cData);
        }
    }

    abort();
    return 0;
}

bool octaspire_dern_value_is_atom(octaspire_dern_value_t const * const self)
{
    switch (self->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        case OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        case OCTASPIRE_DERN_VALUE_TAG_PORT: // TODO XXX atom or not? Also, think about renaming this func.
        {
            return true;
        }

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            return false;
        }
    }

    abort();
    return false;
}


//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_dern_value.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_dern_vm.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/



static void octaspire_dern_vm_private_release_value(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value);



struct octaspire_dern_vm_t
{
    octaspire_container_vector_t *stack;
    octaspire_memory_allocator_t *allocator;
    octaspire_stdio_t            *stdio;
    octaspire_container_vector_t *all;
    octaspire_dern_value_t       *globalEnvironment;
    octaspire_dern_value_t       *valueNil;
    octaspire_dern_value_t       *valueTrue;
    octaspire_dern_value_t       *valueFalse;
    size_t                        numAllocatedWithoutGc;
    bool                          preventGc;
    size_t                        gcTriggerLimit;
    int32_t                       exitCode;
    bool                          quit;
    void                         *userData;
    uintmax_t                       nextFreeUniqueIdForValues;
    octaspire_dern_value_t         *functionReturn;
    bool                            fileSystemAccessAllowed;
    octaspire_container_hash_map_t *libraries;
};

octaspire_dern_value_t *octaspire_dern_vm_private_create_new_value_struct(octaspire_dern_vm_t* self, octaspire_dern_value_tag_t const typeTag);

bool octaspire_dern_vm_private_mark_all(octaspire_dern_vm_t *self);
bool octaspire_dern_vm_private_mark(octaspire_dern_vm_t *self, octaspire_dern_value_t *value);
bool octaspire_dern_vm_private_sweep(octaspire_dern_vm_t *self);
octaspire_dern_value_t *octaspire_dern_vm_private_parse_token(
    octaspire_dern_vm_t * const self,
    octaspire_dern_lexer_token_t const * const token,
    octaspire_input_t *input);

octaspire_dern_vm_config_t octaspire_dern_vm_config_default(void)
{
    octaspire_dern_vm_config_t result =
    {
        .fileSystemAccessAllowed = false
    };

    return result;
}

octaspire_dern_vm_t *octaspire_dern_vm_new(
    octaspire_memory_allocator_t *allocator,
    octaspire_stdio_t *octaspireStdio)
{
    return octaspire_dern_vm_new_with_config(
        allocator,
        octaspireStdio,
        octaspire_dern_vm_config_default());
}

octaspire_dern_vm_t *octaspire_dern_vm_new_with_config(
    octaspire_memory_allocator_t *allocator,
    octaspire_stdio_t *octaspireStdio,
    octaspire_dern_vm_config_t const config)
{
    octaspire_dern_vm_t *self =
        octaspire_memory_allocator_malloc(allocator, sizeof(octaspire_dern_vm_t));

    if (!self)
    {
        return 0;
    }

    self->allocator = allocator;
    self->stdio     = octaspireStdio;
    self->numAllocatedWithoutGc = 0;
    self->preventGc = false;
    self->gcTriggerLimit = 1024;
    self->exitCode = 0;
    self->quit = false;
    self->userData = 0;
    self->nextFreeUniqueIdForValues = 0;
    self->functionReturn = 0;
    self->fileSystemAccessAllowed = config.fileSystemAccessAllowed;

    self->libraries = octaspire_container_hash_map_new_with_octaspire_container_utf8_string_keys(
        sizeof(octaspire_dern_lib_t*),
        true,
        (octaspire_container_hash_map_element_callback_function_t)octaspire_dern_lib_release,
        self->allocator);

    octaspire_helpers_verify_not_null(self->libraries);

    self->stack = octaspire_container_vector_new_with_preallocated_elements(
        sizeof(octaspire_dern_value_t*),
        true,
        256,
        0,
        self->allocator);

    if (!self->stack)
    {
        octaspire_dern_vm_release(self);
        self = 0;
        return 0;
    }

    self->all = octaspire_container_vector_new(sizeof(octaspire_dern_value_t*), true, 0, self->allocator);

    if (!self->all)
    {
        octaspire_dern_vm_release(self);
        self = 0;
        return 0;
    }

    octaspire_dern_environment_t *env = octaspire_dern_environment_new(0, self, self->allocator);

    if (!env)
    {
        octaspire_dern_vm_release(self);
        self = 0;
        return 0;
    }

    self->globalEnvironment = octaspire_dern_vm_create_new_value_environment_from_environment(self, env);

    if (!self->globalEnvironment)
    {
        octaspire_dern_vm_release(self);
        self = 0;
        return 0;
    }

    if (!octaspire_dern_vm_push_value(self, self->globalEnvironment))
    {
        abort();
    }

    self->valueNil = octaspire_dern_vm_create_new_value_nil(self);

    if (!octaspire_dern_vm_push_value(self, self->valueNil))
    {
        abort();
    }

    self->valueNil->docstr = octaspire_dern_vm_create_new_value_string_from_c_string(
        self,
        "Represents missing value.");

    if (!octaspire_dern_vm_push_value(self, self->valueNil->docstr))
    {
        abort();
    }

    if (!octaspire_dern_environment_set(
        env,
        octaspire_dern_vm_create_new_value_symbol(self, octaspire_container_utf8_string_new(
            "nil",
            self->allocator)),
        self->valueNil))
    {
        abort();
    }

    if (!octaspire_dern_vm_pop_value(self, self->valueNil->docstr))
    {
        abort();
    }

    if (!octaspire_dern_vm_pop_value(self, self->valueNil))
    {
        abort();
    }

    self->valueTrue = octaspire_dern_vm_create_new_value_boolean(self, true);

    if (!octaspire_dern_vm_push_value(self, self->valueTrue))
    {
        abort();
    }

    self->valueTrue->docstr = octaspire_dern_vm_create_new_value_string_from_c_string(
        self,
        "Boolean true value. Opposite of false.");

    if (!octaspire_dern_vm_push_value(self, self->valueTrue->docstr))
    {
        abort();
    }

    if (!octaspire_dern_environment_set(
        env,
        octaspire_dern_vm_create_new_value_symbol(self, octaspire_container_utf8_string_new(
            "true",
            self->allocator)),
        self->valueTrue))
    {
        abort();
    }

    if (!octaspire_dern_vm_pop_value(self, self->valueTrue->docstr))
    {
        abort();
    }

    if (!octaspire_dern_vm_pop_value(self, self->valueTrue))
    {
        abort();
    }

    self->valueFalse = octaspire_dern_vm_create_new_value_boolean(self, false);

    if (!octaspire_dern_vm_push_value(self, self->valueFalse))
    {
        abort();
    }

    self->valueFalse->docstr = octaspire_dern_vm_create_new_value_string_from_c_string(
        self,
        "Boolean false value. Opposite of true.");

    if (!octaspire_dern_vm_push_value(self, self->valueFalse->docstr))
    {
        abort();
    }

    if (!octaspire_dern_environment_set(
        env,
        octaspire_dern_vm_create_new_value_symbol(self, octaspire_container_utf8_string_new(
            "false",
            self->allocator)),
        self->valueFalse))
    {
        abort();
    }

    if (!octaspire_dern_vm_pop_value(self, self->valueFalse->docstr))
    {
        abort();
    }

    if (!octaspire_dern_vm_pop_value(self, self->valueFalse))
    {
        abort();
    }


    ////////////////////////////////// Builtins and specials /////////////////////////////////////





    //////////////////////////////////////// Builtins ////////////////////////////////////////////

    // require
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "require",
        octaspire_dern_vm_builtin_require,
        1,
        "Ensure that plugin is loaded (if dern is compiled with plugin support)",
        env))
    {
        abort();
    }

    // input-file-open
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "input-file-open",
        octaspire_dern_vm_builtin_input_file_open,
        1,
        "Open file-port for reading only",
        env))
    {
        abort();
    }

    // output-file-open
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "output-file-open",
        octaspire_dern_vm_builtin_output_file_open,
        1,
        "Open file-port for writing only",
        env))
    {
        abort();
    }

    // io-file-open
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "io-file-open",
        octaspire_dern_vm_builtin_io_file_open,
        1,
        "Open file-port for input and output",
        env))
    {
        abort();
    }

    // port-supports-output?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-supports-output?",
        octaspire_dern_vm_builtin_port_supports_output_question_mark,
        1,
        "Predicate telling whether the given port supports writing or not",
        env))
    {
        abort();
    }

    // port-supports-input?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-supports-input?",
        octaspire_dern_vm_builtin_port_supports_input_question_mark,
        1,
        "Predicate telling whether the given port supports reading or not",
        env))
    {
        abort();
    }

    // port-close
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-close",
        octaspire_dern_vm_builtin_port_close,
        1,
        "Close a port",
        env))
    {
        abort();
    }

    // port-read
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-read",
        octaspire_dern_vm_builtin_port_read,
        1,
        "Read from a port one or a given number of octets",
        env))
    {
        abort();
    }

    // port-write
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-write",
        octaspire_dern_vm_builtin_port_write,
        1,
        "Write one integer or all integers from a vector to a port supporting writing",
        env))
    {
        abort();
    }

    // port-seek
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-seek",
        octaspire_dern_vm_builtin_port_seek,
        1,
        "Seek to a position from the beginning (positive integer) or "
        "from the end (negative integer) on ports supporting seeking",
        env))
    {
        abort();
    }

    // port-dist
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-dist",
        octaspire_dern_vm_builtin_port_dist,
        1,
        "Get distance from the beginning on ports that support it, or minus one",
        env))
    {
        abort();
    }

    // port-length
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-length",
        octaspire_dern_vm_builtin_port_length,
        1,
        "Get size of port in octets on ports that support this operation, or minus one",
        env))
    {
        abort();
    }

    // port-flush
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "port-flush",
        octaspire_dern_vm_builtin_port_flush,
        1,
        "Flush an output port that supports flushing",
        env))
    {
        abort();
    }

    // not
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "not",
        octaspire_dern_vm_builtin_not,
        1,
        "Reverse boolean value",
        env))
    {
        abort();
    }

    // abort
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "abort",
        octaspire_dern_vm_builtin_abort,
        1,
        "Quit execution with error message",
        env))
    {
        abort();
    }

    // return
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "return",
        octaspire_dern_vm_builtin_return,
        1,
        "Return from function early with the given value",
        env))
    {
        abort();
    }

    // vector
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "vector",
        octaspire_dern_vm_builtin_vector,
        1,
        "Create new vector of the given values.",
        env))
    {
        abort();
    }

    // and
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "and",
        octaspire_dern_vm_special_and,
        0,
        "Evaluate values until 'false' is found. Any remaining values are not evaluated. "
        "Return the last evaluated value. "
        "If there are no values, then 'true' is returned.",
        env))
    {
        abort();
    }

    // or
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "or",
        octaspire_dern_vm_special_or,
        0,
        "Evaluate values until 'true' is found. Any remaining values are not evaluated. "
        "Return the last evaluated value. "
        "If there are no values, then 'false' is returned.",
        env))
    {
        abort();
    }

    // do
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "do",
        octaspire_dern_vm_special_do,
        1,
        "Evaluate sequence of values and return the value of the last evaluation",
        env))
    {
        abort();
    }

    // nth
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "nth",
        octaspire_dern_vm_builtin_nth,
        2,
        "Index collection; get element at the given index on the given collection",
        env))
    {
        abort();
    }

    // starts-with?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "starts-with?",
        octaspire_dern_vm_builtin_starts_with_question_mark,
        1,
        "Does the first value start with the second?",
        env))
    {
        abort();
    }

    // =
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "=",
        octaspire_dern_vm_builtin_equals,
        1,
        "Set atomic values, or elements of collections (vector, map, string) at the given index/key",
        env))
    {
        abort();
    }



    // string-format
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "string-format",
        octaspire_dern_vm_builtin_string_format,
        1,
        "Create new string and allow formatting of value into it using {}",
        env))
    {
        abort();
    }

    // to-string
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "to-string",
        octaspire_dern_vm_builtin_to_string,
        1,
        "Give value or values as string(s)",
        env))
    {
        abort();
    }

    // to-integer
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "to-integer",
        octaspire_dern_vm_builtin_to_integer,
        1,
        "Give value or values as integer(s)",
        env))
    {
        abort();
    }

    // print
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "print",
        octaspire_dern_vm_builtin_print,
        0,
        "Print message for the user",
        env))
    {
        abort();
    }

    // println
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "println",
        octaspire_dern_vm_builtin_println,
        0,
        "Print message for the user and newline",
        env))
    {
        abort();
    }

    // env-new
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "env-new",
        octaspire_dern_vm_builtin_env_new,
        0,
        "Create new empty environment",
        env))
    {
        abort();
    }

    // env-current
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "env-current",
        octaspire_dern_vm_builtin_env_current,
        0,
        "Get the current environment used by the context where this is evaluated",
        env))
    {
        abort();
    }

    // env-global
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "env-global",
        octaspire_dern_vm_builtin_env_global,
        0,
        "Get the global environment",
        env))
    {
        abort();
    }

    // -=
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "-=",
        octaspire_dern_vm_builtin_minus_equals,
        1,
        "Subtract value or values from the first argument (modify it)",
        env))
    {
        abort();
    }

    // +=
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "+=",
        octaspire_dern_vm_builtin_plus_equals,
        1,
        "Add value or values into the first argument (modify it)",
        env))
    {
        abort();
    }

    // ++
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "++",
        octaspire_dern_vm_builtin_plus_plus,
        1,
        "Increase a value or values by one",
        env))
    {
        abort();
    }

    // --
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "--",
        octaspire_dern_vm_builtin_minus_minus,
        1,
        "Decrease a value or values by one",
        env))
    {
        abort();
    }

    // pop-front
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "pop-front",
        octaspire_dern_vm_builtin_pop_front,
        1,
        "Remove first element of a vector",
        env))
    {
        abort();
    }

    // mod
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "mod",
        octaspire_dern_vm_builtin_mod,
        1,
        "Calculate modulo of two integers",
        env))
    {
        abort();
    }

    // /
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "/",
        octaspire_dern_vm_builtin_slash,
        1,
        "Divide number arguments",
        env))
    {
        abort();
    }

    // *
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "*",
        octaspire_dern_vm_builtin_times,
        1,
        "Multiply number arguments",
        env))
    {
        abort();
    }

    // +
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "+",
        octaspire_dern_vm_builtin_plus,
        1,
        "Add arguments to create new value",
        env))
    {
        abort();
    }

    // -
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "-",
        octaspire_dern_vm_builtin_minus,
        1,
        "Subtract number arguments, or negate one argument",
        env))
    {
        abort();
    }

    // find
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "find",
        octaspire_dern_vm_builtin_find,
        2,
        "Find value from collection",
        env))
    {
        abort();
    }

    // split
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "split",
        octaspire_dern_vm_builtin_split,
        2,
        "Split a collection by value",
        env))
    {
        abort();
    }


    // hash-map
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "hash-map",
        octaspire_dern_vm_builtin_hash_map,
        0,
        "Create new hash map",
        env))
     {
        abort();
     }

    // queue
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "queue",
        octaspire_dern_vm_builtin_queue,
        0,
        "Create new queue",
        env))
    {
        abort();
    }

    // queue-with-max-length
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "queue-with-max-length",
        octaspire_dern_vm_builtin_queue_with_max_length,
        0,
        "Create new queue with maximum length",
        env))
    {
        abort();
    }

    // list
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "list",
        octaspire_dern_vm_builtin_list,
        0,
        "Create new list",
        env))
    {
        abort();
    }

    // exit
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "exit",
        octaspire_dern_vm_builtin_exit,
        0,
        "Quit and exit the vm execution or REPL",
        env))
    {
        abort();
    }

    // doc
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "doc",
        octaspire_dern_vm_builtin_doc,
        1,
        "Get documentation string of a value or values",
        env))
    {
        abort();
    }

    // len
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "len",
        octaspire_dern_vm_builtin_len,
        1,
        "Get length of a value or values",
        env))
    {
        abort();
    }

    // read-and-eval-path
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "read-and-eval-path",
        octaspire_dern_vm_builtin_read_and_eval_path,
        1,
        "Read and evaluate a file from the given path",
        env))
    {
        abort();
    }

    // read-and-eval-string
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "read-and-eval-string",
        octaspire_dern_vm_builtin_read_and_eval_string,
        1,
        "Read and evaluate the given string",
        env))
    {
        abort();
    }

    // copy
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "copy",
        octaspire_dern_vm_builtin_copy,
        1,
        "Create full or partial copy of a value",
        env))
    {
        abort();
    }



    //////////////////////////////////////// Specials ////////////////////////////////////////////


    // define
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "define",
        octaspire_dern_vm_special_define,
        3,
        "Bind value to name and document the binding",
        env))
    {
        abort();
    }

    // eval
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "eval",
        octaspire_dern_vm_special_eval,
        1,
        "Evaluate a value (first argument) in global environment or, if given, in then given environment",
        env))
    {
        abort();
    }

    // quote
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "quote",
        octaspire_dern_vm_special_quote,
        1,
        "Quote a value",
        env))
    {
        abort();
    }

    // select
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "select",
        octaspire_dern_vm_special_select,
        1,
        "Select one of values, default, or no value and evaluate it according to boolean test",
        env))
    {
        abort();
    }

    // if
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "if",
        octaspire_dern_vm_special_if,
        1,
        "Select value or no value and evaluate it according to boolean test",
        env))
    {
        abort();
    }

    // while
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "while",
        octaspire_dern_vm_special_while,
        2,
        "Evaluate values repeatedly as long as predicate is true",
        env))
    {
        abort();
    }

    // for
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "for",
        octaspire_dern_vm_special_for,
        3, // or 5
        "Evaluate values repeatedly over a numeric range or container",
        env))
    {
        abort();
    }

    // TODO XXX move to other builtins
    // ==
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "==",
        octaspire_dern_vm_builtin_equals_equals,
        1,
        "Predicate telling whether all the given values are equal. "
        "Takes 2..n arguments. Evaluates arguments only as long as those are equal. "
        "Does not evaluate rest of the arguments if one is not equal",
        env))
    {
        abort();
    }

    // TODO XXX move to other builtins
    // !=
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "!=",
        octaspire_dern_vm_builtin_exclamation_equals,
        1,
        "Predicate telling whether all the given values are not equal. "
        "Takes 2..n arguments. Evaluates arguments only as long as unequal is not found. "
        "Does not evaluate rest of the arguments if one is unequal",
        env))
    {
        abort();
    }

    // <
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "<",
        octaspire_dern_vm_special_less_than,
        1,
        "Predicate telling whether the arguments are less than the previous argument. "
        "Takes 2..n arguments. Evaluates arguments only as long as those are less than the previous. "
        "Does not evaluate rest of the arguments if one is larger or equal",
        env))
    {
        abort();
    }

    // >
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        ">",
        octaspire_dern_vm_special_greater_than,
        1,
        "Predicate telling whether the arguments are greater than the previous argument. "
        "Takes 2..n arguments. Evaluates arguments only as long as those are greater than the previous. "
        "Does not evaluate rest of the arguments if one is smaller or equal",
        env))
    {
        abort();
    }

    // <=
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "<=",
        octaspire_dern_vm_special_less_than_or_equal,
        1,
        "Predicate telling whether the arguments are equal or less than the previous argument. "
        "Takes 2..n arguments. Evaluates arguments only as long as those are equal or less than the previous. "
        "Does not evaluate rest of the arguments if one is larger",
        env))
    {
        abort();
    }

    // >=
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        ">=",
        octaspire_dern_vm_special_greater_than_or_equal,
        1,
        "Predicate telling whether the arguments are equal or greater than the previous argument. "
        "Takes 2..n arguments. Evaluates arguments only as long as those are equal or greater than "
        "the previous. Does not evaluate rest of the arguments if one is smaller",
        env))
    {
        abort();
    }

    // fn
    if (!octaspire_dern_vm_create_and_register_new_special(
        self,
        "fn",
        octaspire_dern_vm_special_fn,
        2,
        "Create new anonymous function",
        env))
    {
        abort();
    }

    // uid
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "uid",
        octaspire_dern_vm_builtin_uid,
        2,
        "Get unique id of a value",
        env))
    {
        abort();
    }

    // integer?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "integer?",
        octaspire_dern_vm_builtin_integer_question_mark,
        1,
        "Predicate telling whether the argument is an integer",
        env))
    {
        abort();
    }

    // real?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "real?",
        octaspire_dern_vm_builtin_real_question_mark,
        1,
        "Predicate telling whether the argument is a real",
        env))
    {
        abort();
    }

    // number?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "number?",
        octaspire_dern_vm_builtin_number_question_mark,
        1,
        "Predicate telling whether the argument is a number (integer or real)",
        env))
    {
        abort();
    }

    // nil?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "nil?",
        octaspire_dern_vm_builtin_nil_question_mark,
        1,
        "Predicate telling whether the argument is nil",
        env))
    {
        abort();
    }

    // boolean?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "boolean?",
        octaspire_dern_vm_builtin_boolean_question_mark,
        1,
        "Predicate telling whether the argument is a boolean",
        env))
    {
        abort();
    }

    // character?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "character?",
        octaspire_dern_vm_builtin_character_question_mark,
        1,
        "Predicate telling whether the argument is a character",
        env))
    {
        abort();
    }

    // string?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "string?",
        octaspire_dern_vm_builtin_string_question_mark,
        1,
        "Predicate telling whether the argument is a string",
        env))
    {
        abort();
    }

    // symbol?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "symbol?",
        octaspire_dern_vm_builtin_symbol_question_mark,
        1,
        "Predicate telling whether the argument is a symbol",
        env))
    {
        abort();
    }

    // vector?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "vector?",
        octaspire_dern_vm_builtin_vector_question_mark,
        1,
        "Predicate telling whether the argument is a vector",
        env))
    {
        abort();
    }

    // hash-map?
    if (!octaspire_dern_vm_create_and_register_new_builtin(
        self,
        "hash-map?",
        octaspire_dern_vm_builtin_hash_map_question_mark,
        1,
        "Predicate telling whether the argument is a hash map",
        env))
    {
        abort();
    }

    return self;
}

void octaspire_dern_vm_release(octaspire_dern_vm_t *self)
{
    if (!self)
    {
        return;
    }

    // At this point stack had nil and self->globalEnvironment was tried to remove
    //octaspire_dern_vm_pop_value(self, self->globalEnvironment);

    octaspire_container_vector_clear(self->stack);
    octaspire_dern_vm_gc(self);

    octaspire_container_vector_release(self->stack);

    octaspire_container_vector_release(self->all);

    octaspire_container_hash_map_release(self->libraries);
    self->libraries = 0;

    octaspire_memory_allocator_free(self->allocator, self);
}

bool octaspire_dern_vm_push_value(octaspire_dern_vm_t *self, octaspire_dern_value_t *value)
{
    return octaspire_container_vector_push_back_element(self->stack, &value);
}

bool octaspire_dern_vm_pop_value (octaspire_dern_vm_t *self, octaspire_dern_value_t *valueForBalanceCheck)
{
    if (octaspire_container_vector_peek_back_element(self->stack) != valueForBalanceCheck)
    {
        printf(
            "\n\n ----- STACK UNBALANCED! -----\n (real top)%p != (user says is top)%p\n\n",
            (void*)octaspire_container_vector_peek_back_element(self->stack),
            (void*)valueForBalanceCheck);

        printf("REAL TOP IS:\n");
        octaspire_dern_value_print(octaspire_container_vector_peek_back_element(self->stack), self->allocator);
        printf("USER SAYS THIS IS TOP:\n");
        octaspire_dern_value_print(valueForBalanceCheck, self->allocator);
    }

    if (octaspire_container_vector_peek_back_element(self->stack) != valueForBalanceCheck)
    {
        abort();
    }

    return octaspire_container_vector_pop_back_element(self->stack);
}

void const * octaspire_dern_vm_get_top_value(octaspire_dern_vm_t const * const self)
{
    return octaspire_container_vector_peek_back_element(self->stack);
}

octaspire_dern_value_t *octaspire_dern_vm_peek_value(octaspire_dern_vm_t *self)
{
    return octaspire_container_vector_peek_back_element(self->stack);
}




octaspire_dern_value_t *octaspire_dern_vm_private_create_new_value_struct(octaspire_dern_vm_t* self, octaspire_dern_value_tag_t const typeTag)
{
    if (self->numAllocatedWithoutGc >= self->gcTriggerLimit && !self->preventGc)
    {
        octaspire_dern_vm_gc(self);
        self->numAllocatedWithoutGc = 0;
    }
    else
    {
        ++(self->numAllocatedWithoutGc);
    }

    octaspire_dern_value_t *result =
        octaspire_memory_allocator_malloc(self->allocator, sizeof(octaspire_dern_value_t));

    if (!result)
    {
        octaspire_helpers_verify_not_null(false);
        return 0;
    }

    octaspire_container_vector_push_back_element(self->all, &result);

    result->typeTag                        = typeTag;
    result->mark                           = false;
    result->docstr                         = 0;
    result->vm                             = self;
    result->uniqueId                       = self->nextFreeUniqueIdForValues;

    if (self->nextFreeUniqueIdForValues == UINTMAX_MAX)
    {
        abort();
    }

    ++(self->nextFreeUniqueIdForValues);

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_copy(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *valueToBeCopied)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        valueToBeCopied->typeTag);

    octaspire_dern_vm_push_value(self, result);

    switch (result->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        {
            // NOP
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        {
            result->value.boolean = valueToBeCopied->value.boolean;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        {
            result->value.integer = valueToBeCopied->value.integer;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        {
            result->value.real = valueToBeCopied->value.real;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            result->value.string =
                octaspire_container_utf8_string_new_copy(valueToBeCopied->value.string, self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT:
        {
            result->value.comment =
                octaspire_container_utf8_string_new_copy(valueToBeCopied->value.comment, self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            result->value.character =
                octaspire_container_utf8_string_new_copy(valueToBeCopied->value.character, self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            result->value.symbol =
                octaspire_container_utf8_string_new_copy(valueToBeCopied->value.symbol, self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            result->value.error =
                octaspire_container_utf8_string_new_copy(valueToBeCopied->value.error, self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            result->value.vector = octaspire_container_vector_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                self->allocator);

            for (size_t i = 0; i < octaspire_container_vector_get_length(valueToBeCopied->value.vector); ++i)
            {
                octaspire_dern_value_t * const tmpValToCopy =
                    octaspire_container_vector_get_element_at(valueToBeCopied->value.vector, i);

                assert(tmpValToCopy);

                octaspire_dern_value_t * const tmpValCopied =
                    octaspire_dern_vm_create_new_value_copy(self, tmpValToCopy);

                if (!octaspire_container_vector_push_back_element(
                    result->value.vector,
                    &tmpValCopied))
                {
                    abort();
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            result->value.queue = octaspire_container_queue_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                self->allocator);

            for (size_t i = 0; i < octaspire_container_queue_get_length(valueToBeCopied->value.queue); ++i)
            {
                octaspire_dern_value_t * const tmpValToCopy =
                    octaspire_container_queue_get_at(valueToBeCopied->value.queue, i);

                assert(tmpValToCopy);

                octaspire_dern_value_t * const tmpValCopied =
                    octaspire_dern_vm_create_new_value_copy(self, tmpValToCopy);

                if (!octaspire_container_queue_push(
                    result->value.queue,
                    &tmpValCopied))
                {
                    abort();
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            result->value.list = octaspire_container_list_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                self->allocator);

            // TODO more efficient iteration
            for (size_t i = 0; i < octaspire_container_list_get_length(valueToBeCopied->value.list); ++i)
            {
                octaspire_dern_value_t * const tmpValToCopy =
                    octaspire_container_list_node_get_element(
                        octaspire_container_list_get_at(valueToBeCopied->value.list, i));

                assert(tmpValToCopy);

                octaspire_dern_value_t * const tmpValCopied =
                    octaspire_dern_vm_create_new_value_copy(self, tmpValToCopy);

                if (!octaspire_container_list_push_back(
                    result->value.list,
                    &tmpValCopied))
                {
                    abort();
                }
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        {
            result->value.port =
                octaspire_dern_port_new_copy(valueToBeCopied->value.port, self->allocator);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            if (!octaspire_dern_c_data_is_copying_allowed(valueToBeCopied->value.cData))
            {
                octaspire_dern_vm_pop_value(self, result);

                octaspire_container_utf8_string_t *str =
                    octaspire_dern_c_data_to_string(valueToBeCopied->value.cData, self->allocator);

                octaspire_helpers_verify_not_null(str);

                octaspire_dern_value_t * const errorVal =
                    octaspire_dern_vm_create_new_value_error_format(
                        self,
                        "C data '%s' cannot be copied.",
                        octaspire_container_utf8_string_get_c_string(str));

                octaspire_helpers_verify_not_null(errorVal);

                octaspire_container_utf8_string_release(str);
                str = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return errorVal;
            }

            result->value.cData =
                octaspire_dern_c_data_new_copy(valueToBeCopied->value.cData, self->allocator);
        }
        break;
    }

    if (valueToBeCopied->docstr)
    {
        result->docstr = octaspire_dern_vm_create_new_value_copy(self, valueToBeCopied->docstr);
    }

    if (valueToBeCopied->docvec)
    {
        result->docvec = octaspire_dern_vm_create_new_value_copy(self, valueToBeCopied->docvec);
    }

    octaspire_dern_vm_pop_value(self, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_input_file(
    octaspire_dern_vm_t *self,
    char const * const path)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_PORT);
    result->value.port = octaspire_dern_port_new_input_file(path, self->allocator);
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_output_file(
    octaspire_dern_vm_t *self,
    char const * const path)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_PORT);
    result->value.port = octaspire_dern_port_new_output_file(path, self->allocator);
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_io_file(
    octaspire_dern_vm_t *self,
    char const * const path)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_PORT);
    result->value.port = octaspire_dern_port_new_io_file(path, self->allocator);
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_nil(octaspire_dern_vm_t *self)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_NIL);
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_boolean(octaspire_dern_vm_t *self, bool const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_BOOLEAN);
    result->value.boolean = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_integer   (octaspire_dern_vm_t *self, int32_t const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_INTEGER);
    result->value.integer = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_real      (octaspire_dern_vm_t *self, double  const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_REAL);
    result->value.real = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_string    (octaspire_dern_vm_t *self, octaspire_container_utf8_string_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_STRING);
    result->value.string = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_multiline_comment    (octaspire_dern_vm_t *self, octaspire_container_utf8_string_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT);
    result->value.comment = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_string_format(
    octaspire_dern_vm_t *self,
    char const * const fmt,
    ...)
{
    va_list arguments;
    va_start(arguments, fmt);

    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new_vformat(
        self->allocator,
        fmt,
        arguments);

    va_end(arguments);

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_string(self, str);

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_string_from_c_string(
    octaspire_dern_vm_t *self,
    char const * const value)
{
    return octaspire_dern_vm_create_new_value_string(
        self,
        octaspire_container_utf8_string_new(value, self->allocator));
}




octaspire_dern_value_t *octaspire_dern_vm_create_new_value_character (octaspire_dern_vm_t *self, octaspire_container_utf8_string_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_CHARACTER);
    result->value.character = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_character_from_uint32t (octaspire_dern_vm_t *self, uint32_t const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_CHARACTER);
    result->value.character = octaspire_container_utf8_string_new("", self->allocator);
    octaspire_container_utf8_string_push_back_ucs_character(result->value.character, value);
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_symbol    (octaspire_dern_vm_t *self, octaspire_container_utf8_string_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_SYMBOL);
    result->value.symbol = value;
    return result;
}

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_symbol_from_c_string    (octaspire_dern_vm_t *self, char const * const value)
{
    return octaspire_dern_vm_create_new_value_symbol(
        self,
        octaspire_container_utf8_string_new(value, self->allocator));
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_error     (octaspire_dern_vm_t *self, octaspire_container_utf8_string_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_ERROR);
    result->value.error = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_error_format(
    octaspire_dern_vm_t *self,
    char const * const fmt,
    ...)
{
    va_list arguments;
    va_start(arguments, fmt);

    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new_vformat(
        self->allocator,
        fmt,
        arguments);

    va_end(arguments);

    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_error(self, str);

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_error_from_c_string(
    octaspire_dern_vm_t *self,
    char const * const value)
{
    return octaspire_dern_vm_create_new_value_error(
        self,
        octaspire_container_utf8_string_new(value, self->allocator));
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_vector_from_vector      (octaspire_dern_vm_t *self, octaspire_container_vector_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_VECTOR);
    result->value.vector = value;
    return result;
}






octaspire_dern_value_t *octaspire_dern_vm_create_new_value_vector_from_values(
    octaspire_dern_vm_t *self,
    size_t const numArgs,
    ...)
{
    // TODO preallocate numArgs elements?
    octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_vector(self);

    va_list arguments;
    va_start(arguments, numArgs);

    for (size_t i = 0; i < numArgs; ++i)
    {
        octaspire_dern_value_t *value = va_arg(arguments, octaspire_dern_value_t*);
        octaspire_dern_value_as_vector_push_back_element(result, &value);
    }

    va_end(arguments);

    return result;
}

















octaspire_dern_value_t *octaspire_dern_vm_create_new_value_vector      (octaspire_dern_vm_t *self)
{
    octaspire_container_vector_t *vec = octaspire_container_vector_new(
        sizeof(octaspire_dern_value_t*),
        true,
        0,
        self->allocator);

    return octaspire_dern_vm_create_new_value_vector_from_vector(self, vec);
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_hash_map_from_hash_map(octaspire_dern_vm_t *self, octaspire_container_hash_map_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_HASH_MAP);
    result->value.hashMap = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_queue_from_queue(octaspire_dern_vm_t *self, octaspire_container_queue_t * const queue)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_QUEUE);
    result->value.queue = queue;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_list_from_list(octaspire_dern_vm_t *self, octaspire_container_list_t * const list)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_LIST);
    result->value.list = list;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_hash_map(octaspire_dern_vm_t *self)
{
    octaspire_container_hash_map_t *hashMap = octaspire_container_hash_map_new(
        sizeof(octaspire_dern_value_t*),
        true,
        sizeof(octaspire_dern_value_t*),
        true,
        (octaspire_container_hash_map_key_compare_function_t)octaspire_dern_value_is_equal,
        (octaspire_container_hash_map_key_hash_function_t)octaspire_dern_value_get_hash,
        0,
        0,
        self->allocator);

    return octaspire_dern_vm_create_new_value_hash_map_from_hash_map(self, hashMap);
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_queue(octaspire_dern_vm_t *self)
{
    octaspire_container_queue_t *queue = octaspire_container_queue_new(
        sizeof(octaspire_dern_value_t*),
        true,
        0,
        self->allocator);

    return octaspire_dern_vm_create_new_value_queue_from_queue(self, queue);
}

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_queue_with_max_length (
        octaspire_dern_vm_t * const self,
        size_t const maxLength)
{
    octaspire_container_queue_t * const queue = octaspire_container_queue_new_with_max_length(
        maxLength,
        sizeof(octaspire_dern_value_t*),
        true,
        0,
        self->allocator);

    return octaspire_dern_vm_create_new_value_queue_from_queue(self, queue);
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_list(octaspire_dern_vm_t *self)
{
    octaspire_container_list_t *list = octaspire_container_list_new(
        sizeof(octaspire_dern_value_t*),
        true,
        0,
        self->allocator);

    return octaspire_dern_vm_create_new_value_list_from_list(self, list);
}

struct octaspire_dern_value_t *octaspire_dern_vm_create_new_value_environment (octaspire_dern_vm_t *self, octaspire_dern_value_t *enclosing)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(
        self,
        OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    result->value.environment =
        octaspire_dern_environment_new(enclosing, self, self->allocator);

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_environment_from_environment(octaspire_dern_vm_t *self, octaspire_dern_environment_t * const value)
{
    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);
    result->value.environment = value;
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_function(
    octaspire_dern_vm_t *self,
    octaspire_dern_function_t * const value,
    char const * const docstr,
    octaspire_container_vector_t *docVec)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t *result =
        octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_FUNCTION);

    octaspire_dern_vm_push_value(self, result);

    result->value.function = value;

    result->docstr = octaspire_dern_vm_create_new_value_string_from_c_string(self, docstr);

    result->docvec = docVec ? octaspire_dern_vm_create_new_value_vector_from_vector(self, docVec) : 0;

    octaspire_dern_vm_pop_value(self, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_special(
    octaspire_dern_vm_t *self,
    octaspire_dern_special_t * const value,
    char const * const docstr)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_SPECIAL);
    result->value.special = value;

    octaspire_dern_vm_push_value(self, result);

    result->docstr = octaspire_dern_vm_create_new_value_string_from_c_string(self, docstr);

    octaspire_dern_vm_pop_value(self, result);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_builtin(
    octaspire_dern_vm_t *self,
    octaspire_dern_builtin_t * const value,
    char const * const docstr)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t *result = octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_BUILTIN);
    result->value.builtin = value;

    octaspire_dern_vm_push_value(self, result);

    result->docstr = octaspire_dern_vm_create_new_value_string_from_c_string(self, docstr);

    octaspire_dern_vm_pop_value(self, result);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_create_new_value_c_data(
    octaspire_dern_vm_t * const self,
    char const * const pluginName,
    char const * const typeNameForPayload,
    char const * const cleanUpCallbackName,
    char const * const stdLibLenCallbackName,
    char const * const stdLibNthCallbackName,
    bool const copyingAllowed,
    void * const payload)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t * const result =
        octaspire_dern_vm_private_create_new_value_struct(self, OCTASPIRE_DERN_VALUE_TAG_C_DATA);

    octaspire_dern_lib_t *lib = octaspire_dern_vm_get_library(self, pluginName);
    octaspire_helpers_verify_not_null(lib);

    result->value.cData = octaspire_dern_c_data_new(
        pluginName,
        lib,
        typeNameForPayload,
        payload,
        cleanUpCallbackName,
        stdLibLenCallbackName,
        stdLibNthCallbackName,
        copyingAllowed,
        self->allocator);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

void octaspire_dern_vm_clear_value_to_nil(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(self);

    if (!value)
    {
        return;
    }

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:         break;
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:     break;
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:     break;
        case OCTASPIRE_DERN_VALUE_TAG_REAL:        break;

        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            octaspire_container_utf8_string_release(value->value.string);
            value->value.string = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT:
        {
            octaspire_container_utf8_string_release(value->value.comment);
            value->value.comment = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        {
            octaspire_container_utf8_string_release(value->value.character);
            value->value.character = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            octaspire_container_utf8_string_release(value->value.symbol);
            value->value.symbol = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        {
            octaspire_container_utf8_string_release(value->value.error);
            value->value.error = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            // Elements are NOT released here, because it would lead to double free.
            // GC releases the elements (those are stored in the all-vector also).
            octaspire_container_vector_clear(value->value.vector);
            octaspire_container_vector_release(value->value.vector);
            value->value.vector = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            // Elements are NOT released here, because it would lead to double free.
            // GC releases the elements (those are stored in the all-vector also).
            octaspire_container_hash_map_clear(value->value.hashMap);
            octaspire_container_hash_map_release(value->value.hashMap);
            value->value.hashMap = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_QUEUE:
        {
            // Elements are NOT released here, because it would lead to double free.
            // GC releases the elements (those are stored in the all-vector also).
            octaspire_container_queue_clear(value->value.queue);
            octaspire_container_queue_release(value->value.queue);
            value->value.queue = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_LIST:
        {
            // Elements are NOT released here, because it would lead to double free.
            // GC releases the elements (those are stored in the all-vector also).
            octaspire_container_list_clear(value->value.list);
            octaspire_container_list_release(value->value.list);
            value->value.list = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        {
            octaspire_dern_environment_release(value->value.environment);
            value->value.environment = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        {
            octaspire_dern_function_release(value->value.function);
            value->value.function = 0;

            //octaspire_dern_vm_private_release_value(self, fun->formals);
            //octaspire_dern_vm_private_release_value(self, fun->body);
            //octaspire_dern_vm_private_release_value(self, fun->definitionEnvironment);
            //fun->definitionEnvironment = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        {
            octaspire_dern_special_release(value->value.special);
            value->value.special = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        {
            octaspire_dern_builtin_release(value->value.builtin);
            value->value.builtin = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_PORT:
        {
            octaspire_dern_port_release(value->value.port);
            value->value.port = 0;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_C_DATA:
        {
            octaspire_dern_c_data_release(value->value.cData);
            value->value.cData = 0;
        }
        break;
    }

    value->typeTag = OCTASPIRE_DERN_VALUE_TAG_NIL;
}

static void octaspire_dern_vm_private_release_value(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value)
{
    if (!value)
    {
        return;
    }

    octaspire_dern_vm_clear_value_to_nil(self, value);
    value->typeTag = OCTASPIRE_DERN_VALUE_TAG_ILLEGAL;

    octaspire_memory_allocator_free(self->allocator, value);
}

bool octaspire_dern_vm_gc(octaspire_dern_vm_t *self)
{
    if (!octaspire_dern_vm_private_mark_all(self))
    {
        return false;
    }

    return octaspire_dern_vm_private_sweep(self);
}

bool octaspire_dern_vm_private_mark_all(octaspire_dern_vm_t *self)
{
    /*
    octaspire_helpers_verify_not_null(self->globalEnvironment);
    // TODO XXX global env need not be in the stack anymore
    if (self->globalEnvironment)
    {
        octaspire_dern_vm_private_mark(self, self->globalEnvironment);
    }
    */

    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    // Stack seems to grow during iter. Maybe push without pop somewhere?
    for (size_t i = 0; i < octaspire_container_vector_get_length(self->stack); ++i)
    {
        octaspire_dern_value_t *value = octaspire_container_vector_get_element_at(self->stack, i);

        if (!octaspire_dern_vm_private_mark(self, value))
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
            octaspire_helpers_verify_not_null(false);
            return false;
        }
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return true;
}

bool octaspire_dern_vm_private_mark(octaspire_dern_vm_t *self, octaspire_dern_value_t *value)
{
    OCTASPIRE_HELPERS_UNUSED_PARAMETER(self);
    return octaspire_dern_value_mark(value);
}

bool octaspire_dern_vm_private_sweep(octaspire_dern_vm_t *self)
{
    for (size_t i = 0; i < octaspire_container_vector_get_length(self->all); /* NOP */ )
    {
        octaspire_dern_value_t *value = octaspire_container_vector_get_element_at(self->all, i);

        if (value->mark)
        {
            value->mark = false;

            ++i;
        }
        else
        {
            octaspire_dern_vm_private_release_value(self, value);

            octaspire_dern_value_t *value2 =
                octaspire_container_vector_get_element_at(self->all, i);

            octaspire_helpers_verify_true(value == value2);
            if (!octaspire_container_vector_remove_element_at(self->all, i))
            {
                abort();
            }
        }
    }

    return true;
}

octaspire_dern_value_t *octaspire_dern_vm_private_parse_token(
    octaspire_dern_vm_t * const self,
    octaspire_dern_lexer_token_t const * const token,
    octaspire_input_t *input)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t *result = 0;

    if (!token)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
        return result;
    }

    switch (octaspire_dern_lexer_token_get_type_tag(token))
    {
        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN:
        {
            octaspire_container_vector_t *vec = octaspire_container_vector_new(
                sizeof(octaspire_dern_value_t*),
                true,
                0,
                self->allocator);

            if (!vec)
            {
                result = octaspire_dern_vm_create_new_value_error(
                    self,
                    octaspire_container_utf8_string_new("Allocation failure in private parse_token", self->allocator));
            }
            else
            {
                result = octaspire_dern_vm_create_new_value_vector_from_vector(self, vec);

                // Protect result (and all values inside it) from the garbage collector during
                // this phase.
                octaspire_dern_vm_push_value(self, result);

                bool error = false;
                octaspire_dern_lexer_token_t *token2 = 0;
                while (true)
                {
                    octaspire_dern_lexer_token_release(token2);
                    token2 = 0;
                    octaspire_helpers_verify_true(token2 == 0);

                    token2 = octaspire_dern_lexer_pop_next_token(input, self->allocator);

                    if (!token2)
                    {
                        // No more input
                        octaspire_dern_vm_pop_value(self, result);
                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                        return 0;
                    }
                    else if (octaspire_dern_lexer_token_get_type_tag(token2) == OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR)
                    {
                        error = true;
                        octaspire_dern_vm_pop_value(self, result);

                        result = octaspire_dern_vm_create_new_value_error(
                            self,
                            octaspire_container_utf8_string_new(
                                octaspire_dern_lexer_token_get_error_value_as_c_string(token2),
                                self->allocator));

                        octaspire_helpers_verify_not_null(result);

                        octaspire_dern_lexer_token_release(token2);
                        token2 = 0;

                        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                        return result;
                    }
                    else
                    {
                        if (octaspire_dern_lexer_token_get_type_tag(token2) == OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN)
                        {
                            octaspire_dern_vm_pop_value(self, result);

                            octaspire_dern_lexer_token_release(token2);
                            token2 = 0;

                            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                            return result;
                        }
                        else
                        {
                            octaspire_dern_value_t *element =
                                octaspire_dern_vm_private_parse_token(self, token2, input);

                            //octaspire_helpers_verify_not_null(element);

                            octaspire_dern_lexer_token_release(token2);
                            token2 = 0;

                            if (!element)
                            {
                                return element;
                            }

                            if (element->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                            {
                                return element;
                            }

                            // TODO report allocation error instead of asserting
                            if (!octaspire_container_vector_push_back_element(result->value.vector, &element))
                            {
                                abort();
                            }
                        }
                    }
                }

                if (!error)
                {
                    octaspire_dern_vm_pop_value(self, result);
                }

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE:
        {
            result = octaspire_dern_vm_create_new_value_vector(self);

            if (!result)
            {
                result = octaspire_dern_vm_create_new_value_error_from_c_string(
                    self,
                    "Allocation failure");
            }
            else
            {
                octaspire_dern_vm_push_value(self, result);

                octaspire_dern_value_t *quoteSym =
                    octaspire_dern_vm_create_new_value_symbol_from_c_string(self, "quote");

                octaspire_helpers_verify_not_null(quoteSym);

                if (!octaspire_dern_value_as_vector_push_back_element(result, &quoteSym))
                {
                    abort();
                }

                octaspire_dern_value_t *quotedValue = octaspire_dern_vm_parse(
                    self,
                    input);

                if (!quotedValue || quotedValue->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_dern_vm_pop_value(self, result);
                    result = quotedValue; // report error to caller
                }
                else
                {
                    if (!octaspire_dern_value_as_vector_push_back_element(
                        result,
                        &quotedValue))
                    {
                        abort();
                    }

                    octaspire_dern_vm_pop_value(self, result);
                }
            }
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE:
        {
            result = octaspire_dern_vm_get_value_true(self);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_FALSE:
        {
            result = octaspire_dern_vm_get_value_false(self);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL:
        {
            result = octaspire_dern_vm_get_value_nil(self);
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER:
        {
            result = octaspire_dern_vm_create_new_value_integer(
                self,
                octaspire_dern_lexer_token_get_integer_value(token));
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL:
        {
            result = octaspire_dern_vm_create_new_value_real(
                self,
                octaspire_dern_lexer_token_get_real_value(token));
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING:
        {
            result = octaspire_dern_vm_create_new_value_string(
                self,
                octaspire_container_utf8_string_new(
                    octaspire_dern_lexer_token_get_string_value_as_c_string(token),
                    self->allocator));
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER:
        {
            result = octaspire_dern_vm_create_new_value_character(
                self,
                octaspire_container_utf8_string_new(
                    octaspire_dern_lexer_token_get_character_value_as_c_string(token),
                    self->allocator));
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL:
        {
            result = octaspire_dern_vm_create_new_value_symbol(
                self,
                octaspire_container_utf8_string_new(
                    octaspire_dern_lexer_token_get_symbol_value_as_c_string(token),
                    self->allocator));
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR:
        {
            result = octaspire_dern_vm_create_new_value_error(
                self,
                octaspire_container_utf8_string_new(
                    octaspire_dern_lexer_token_get_error_value_as_c_string(token),
                    self->allocator));
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED:
        {
            return 0;
        }
        break;

        case OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT:
        {
            result = octaspire_dern_vm_create_new_value_multiline_comment(
                self,
                octaspire_container_utf8_string_new(
                    octaspire_dern_lexer_token_get_multiline_comment_value_as_c_string(token),
                    self->allocator));
        }
        break;

        // TODO XXX add rest of types
        default:
            octaspire_helpers_verify_not_null(false);
            break;
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_parse(octaspire_dern_vm_t *self, octaspire_input_t *input)
{
    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, self->allocator);

    octaspire_dern_value_t *result = octaspire_dern_vm_private_parse_token(self, token, input);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value)
{
    return octaspire_dern_vm_eval(self, value, self->globalEnvironment);
}

octaspire_dern_value_t *octaspire_dern_vm_eval(
    octaspire_dern_vm_t *self,
    octaspire_dern_value_t *value,
    octaspire_dern_value_t *environment)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_helpers_verify_true(environment->typeTag == OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT);

    if (!value)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
        //return self->valueNil;
        return 0;
    }

    octaspire_dern_vm_push_value(self, value);
    octaspire_dern_vm_push_value(self, environment);

    octaspire_dern_value_t *result = 0;

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_ILLEGAL:
        {
            abort();
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_NIL:
        case OCTASPIRE_DERN_VALUE_TAG_BOOLEAN:
        case OCTASPIRE_DERN_VALUE_TAG_INTEGER:
        case OCTASPIRE_DERN_VALUE_TAG_REAL:
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        case OCTASPIRE_DERN_VALUE_TAG_CHARACTER:
        case OCTASPIRE_DERN_VALUE_TAG_ERROR:
        // How about these? Self evaluating or not?
        case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
        case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
        case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
        case OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT:
        {
            result = value;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            result = octaspire_dern_environment_get(
                environment->value.environment,
                value);

            if (!result)
            {
                octaspire_container_utf8_string_t* str = octaspire_dern_value_to_string(
                    value,
                    self->allocator);

                result = octaspire_dern_vm_create_new_value_error(
                        self,
                        octaspire_container_utf8_string_new_format(
                            self->allocator,
                            "Unbound symbol '%s'",
                            octaspire_container_utf8_string_get_c_string(str)));

                octaspire_container_utf8_string_release(str);
                str = 0;
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            octaspire_container_vector_t *vec = value->value.vector;

            if (octaspire_container_vector_is_empty(vec))
            {
                result = octaspire_dern_vm_create_new_value_error(
                    self,
                    octaspire_container_utf8_string_new(
                        "Cannot evaluate empty vector '()'",
                        self->allocator));
            }

            octaspire_dern_value_t *removeMe = octaspire_container_vector_get_element_at(vec, 0);

            octaspire_dern_value_t *operator = octaspire_dern_vm_eval(
                self,
                removeMe,
                environment);

            if (!operator)
            {
                octaspire_dern_vm_pop_value(self, environment);
                octaspire_dern_vm_pop_value(self, value);
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return 0;
            }

            octaspire_dern_vm_push_value(self, operator);

            switch (operator->typeTag)
            {
                case OCTASPIRE_DERN_VALUE_TAG_SPECIAL:
                {
                    octaspire_container_vector_t *argVec =
                        octaspire_container_vector_new_with_preallocated_elements(
                            sizeof(octaspire_dern_value_t*),
                            true,
                            octaspire_container_vector_get_length(vec) - 1,
                            0,
                            self->allocator);

                    octaspire_dern_value_t *arguments =
                        octaspire_dern_vm_create_new_value_vector_from_vector(self, argVec);

                    octaspire_dern_vm_push_value(self, arguments);

                    for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
                    {
                        octaspire_dern_value_t * const tmpPtr = octaspire_container_vector_get_element_at(vec, i);
                        if (tmpPtr->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                        {
                            result = tmpPtr;
                            break;
                        }

                        octaspire_container_vector_push_back_element(argVec, &tmpPtr);
                    }

                    if (!result)
                    {
                        result = (operator->value.special->cFunction)(self, arguments, environment);

                        // TODO XXX add this error annotation to other places too
                        // (for example builtin and function calls)
                        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                        {
                            octaspire_container_utf8_string_t *tmpStr =
                                octaspire_dern_value_to_string(value, self->allocator);

                            octaspire_container_utf8_string_concatenate_format(
                                result->value.string,
                                "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                                octaspire_container_utf8_string_get_c_string(tmpStr));

                            octaspire_container_utf8_string_release(tmpStr);
                            tmpStr = 0;
                        }
                    }

                    octaspire_dern_vm_pop_value(self, arguments);
                }
                break;

                case OCTASPIRE_DERN_VALUE_TAG_BUILTIN:
                {
                    octaspire_container_vector_t *argVec =
                        octaspire_container_vector_new_with_preallocated_elements(
                            sizeof(octaspire_dern_value_t*),
                            true,
                            octaspire_container_vector_get_length(vec) - 1,
                            0,
                            self->allocator);

                    octaspire_dern_value_t *arguments =
                        octaspire_dern_vm_create_new_value_vector_from_vector(self, argVec);

                    octaspire_dern_vm_push_value(self, arguments);

                    for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
                    {
                        octaspire_dern_value_t *evaluated = octaspire_dern_vm_eval(
                            self,
                            octaspire_container_vector_get_element_at(vec, i),
                            environment);

                        if (evaluated->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                        {
                            result = evaluated;


                            // TODO XXX add this error annotation to other places too
                            // (for example builtin and function calls)
                            octaspire_container_utf8_string_t *tmpStr =
                                octaspire_dern_value_to_string(value, self->allocator);

                            octaspire_container_utf8_string_concatenate_format(
                                result->value.string,
                                "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                                octaspire_container_utf8_string_get_c_string(tmpStr));

                            octaspire_container_utf8_string_release(tmpStr);
                            tmpStr = 0;


                            break;
                        }

                        octaspire_container_vector_push_back_element(argVec, &evaluated);
                    }

                    if (!result)
                    {
                        result = (operator->value.builtin->cFunction)(self, arguments, environment);


                        // TODO XXX add this error annotation to other places too
                        // (for example builtin and function calls)
                        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                        {
                            octaspire_container_utf8_string_t *tmpStr =
                                octaspire_dern_value_to_string(value, self->allocator);

                            octaspire_container_utf8_string_concatenate_format(
                                result->value.string,
                                "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                                octaspire_container_utf8_string_get_c_string(tmpStr));

                            octaspire_container_utf8_string_release(tmpStr);
                            tmpStr = 0;
                        }


                        if (operator->value.builtin->cFunction == octaspire_dern_vm_builtin_return)
                        {
                            //octaspire_helpers_verify_true(self->functionReturn == 0);
                            self->functionReturn = result;
                        }
                    }

                    octaspire_dern_vm_pop_value(self, arguments);
                }
                break;

                case OCTASPIRE_DERN_VALUE_TAG_FUNCTION:
                {
                    octaspire_container_vector_t *argVec =
                        octaspire_container_vector_new_with_preallocated_elements(
                            sizeof(octaspire_dern_value_t*),
                            true,
                            octaspire_container_vector_get_length(vec) - 1,
                            0,
                            self->allocator);

                    octaspire_dern_value_t *arguments =
                        octaspire_dern_vm_create_new_value_vector_from_vector(self, argVec);

                    octaspire_dern_vm_push_value(self, arguments);

                    for (size_t i = 1; i < octaspire_container_vector_get_length(vec); ++i)
                    {
                        octaspire_dern_value_t *evaluated = octaspire_dern_vm_eval(
                            self,
                            octaspire_container_vector_get_element_at(vec, i),
                            environment);


                        if (evaluated->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                        {
                            result = evaluated;


                            // TODO XXX add this error annotation to other places too
                            // (for example builtin and function calls)
                            octaspire_container_utf8_string_t *tmpStr =
                                octaspire_dern_value_to_string(value, self->allocator);

                            octaspire_container_utf8_string_concatenate_format(
                                result->value.string,
                                "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                                octaspire_container_utf8_string_get_c_string(tmpStr));

                            octaspire_container_utf8_string_release(tmpStr);
                            tmpStr = 0;


                            break;
                        }

                        octaspire_dern_value_as_vector_push_back_element(arguments, &evaluated);
                    }

                    if (!result)
                    {
                        octaspire_dern_function_t *function = operator->value.function;

                        octaspire_helpers_verify_not_null(function);
                        octaspire_helpers_verify_not_null(function->formals);
                        // Invalid read of size 4 below
                        octaspire_helpers_verify_not_null(function->formals->value.vector);
                        octaspire_helpers_verify_not_null(function->body);
                        octaspire_helpers_verify_not_null(function->body->value.vector);
                        octaspire_helpers_verify_not_null(function->definitionEnvironment);
                        octaspire_helpers_verify_not_null(function->definitionEnvironment->value.environment);

                        octaspire_dern_environment_t *extendedEnvironment =
                            octaspire_dern_environment_new(
                                function->definitionEnvironment,
                                self,
                                self->allocator);

                        octaspire_helpers_verify_not_null(extendedEnvironment);

                        octaspire_dern_value_t *extendedEnvVal =
                            octaspire_dern_vm_create_new_value_environment_from_environment(self, extendedEnvironment);

                        octaspire_helpers_verify_not_null(extendedEnvVal);

                        octaspire_dern_vm_push_value(self, extendedEnvVal);

                        octaspire_dern_value_t *error = octaspire_dern_environment_extend(
                            extendedEnvironment,
                            function->formals,
                            arguments);

                        if (error)
                        {
                            result = error;
                        }
                        else
                        {
                            // TODO push function->body?

                            octaspire_helpers_verify_true(function->body->typeTag == OCTASPIRE_DERN_VALUE_TAG_VECTOR);
                            octaspire_helpers_verify_not_null(function->body->value.vector);

                            for (size_t i = 0; i < octaspire_container_vector_get_length(function->body->value.vector); ++i)
                            {
                                octaspire_dern_value_t *toBeEvaluated =
                                    octaspire_container_vector_get_element_at(
                                        function->body->value.vector,
                                        i);

                                octaspire_dern_vm_push_value(self, toBeEvaluated);

                                result = octaspire_dern_vm_eval(
                                    self,
                                    toBeEvaluated,
                                    extendedEnvVal);

                                if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                                {


                                    // TODO XXX add this error annotation to other places too
                                    // (for example builtin and function calls)
                                    octaspire_container_utf8_string_t *tmpStr =
                                        octaspire_dern_value_to_string(value, self->allocator);

                                    octaspire_container_utf8_string_concatenate_format(
                                        result->value.string,
                                        "\n\tAt form: >>>>>>>>>>%s<<<<<<<<<<\n",
                                        octaspire_container_utf8_string_get_c_string(tmpStr));

                                    octaspire_container_utf8_string_release(tmpStr);
                                    tmpStr = 0;


                                    octaspire_dern_vm_pop_value(self, toBeEvaluated);
                                    break;
                                }

                                octaspire_dern_vm_pop_value(self, toBeEvaluated);

                                if (self->functionReturn)
                                {
                                    result = self->functionReturn;
                                    self->functionReturn = 0;
                                    break;
                                }
                            }
                        }

                        // TODO pop function->body?

                        octaspire_dern_vm_pop_value(self, extendedEnvVal);
                        octaspire_dern_vm_pop_value(self, arguments);
                    }
                    else
                    {
                        octaspire_dern_vm_pop_value(self, arguments);
                    }
                }
                break;

                default:
                {
                    octaspire_container_utf8_string_t *str = octaspire_dern_value_to_string(
                        operator,
                        self->allocator);

                    result = octaspire_dern_vm_create_new_value_error(
                        self,
                        octaspire_container_utf8_string_new_format(
                            self->allocator,
                            "Cannot evaluate operator of type '%s' (%s)",
                            octaspire_dern_value_helper_get_type_as_c_string(operator->typeTag),
                            octaspire_container_utf8_string_get_c_string(str)));

                    octaspire_container_utf8_string_release(str);
                    str = 0;
                }
                break;
            }

            octaspire_dern_vm_pop_value(self, operator);
        }
        break;

        // TODO XXX add rest of types
        default:
        {
            result = octaspire_dern_vm_create_new_value_error(
                self,
                octaspire_container_utf8_string_new_format(
                    self->allocator,
                    "Cannot evaluate unknown type %i",
                    (int)value->typeTag));
        }
        break;
    }

    octaspire_dern_vm_pop_value(self, environment);
    octaspire_dern_vm_pop_value(self, value);


    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_read_from_octaspire_input_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    octaspire_input_t * const input)
{
    if (!input || !octaspire_input_is_good(input))
    {
        return octaspire_dern_vm_create_new_value_error_from_c_string(self, "No input");
    }

    octaspire_dern_value_t *lastGoodResult = 0;
    octaspire_dern_value_t *result = 0;

    while (octaspire_input_is_good(input))
    {
        result = octaspire_dern_vm_eval_in_global_environment(
            self,
            octaspire_dern_vm_parse(self, input));

        if (!result)
        {
            break;
        }

        lastGoodResult = result;

        if (result->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            break;
        }
    }

    //octaspire_input_release(input);
    //input = 0;

    if (!result && lastGoodResult)
    {
        return lastGoodResult;
    }

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    char const * const str)
{
    if (!str)
    {
        return octaspire_dern_vm_create_new_value_error_from_c_string(self, "No input");
    }

    // TODO should more efficient version without strlen be used?
    return octaspire_dern_vm_read_from_buffer_and_eval_in_global_environment(self, str, strlen(str));
}

octaspire_dern_value_t *octaspire_dern_vm_read_from_buffer_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    char const * const buffer,
    size_t const lengthInOctets)
{
    if (!buffer || lengthInOctets == 0)
    {
        return octaspire_dern_vm_create_new_value_error_from_c_string(self, "No input");
    }

    octaspire_input_t *input =
        octaspire_input_new_from_buffer(buffer, lengthInOctets, self->allocator);

    if (!input)
    {
        return octaspire_dern_vm_create_new_value_error_from_c_string(self, "Allocation failure of input");
    }

    octaspire_dern_value_t * const result =
        octaspire_dern_vm_read_from_octaspire_input_and_eval_in_global_environment(self, input);

    octaspire_input_release(input);
    input = 0;

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_read_from_path_and_eval_in_global_environment(
    octaspire_dern_vm_t *self,
    char const * const path)
{
    size_t bufLen = 0;
    char *buffer = octaspire_helpers_path_to_buffer(path, &bufLen, self->allocator, self->stdio);

    if (!buffer || !bufLen)
    {
        return octaspire_dern_vm_create_new_value_error_from_c_string(self, "No input");
    }

    octaspire_dern_value_t *result =
        octaspire_dern_vm_read_from_buffer_and_eval_in_global_environment(self, buffer, bufLen);

    octaspire_memory_allocator_free(self->allocator, buffer);
    buffer = 0;
    bufLen = 0;

    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_get_value_nil(
    octaspire_dern_vm_t *self)
{
    //return self->valueNil;
    return octaspire_dern_vm_create_new_value_copy(self, self->valueNil);
}

octaspire_dern_value_t *octaspire_dern_vm_get_value_true(
    octaspire_dern_vm_t *self)
{
    //return self->valueTrue;
    return octaspire_dern_vm_create_new_value_copy(self, self->valueTrue);
}

octaspire_dern_value_t *octaspire_dern_vm_get_value_false(
    octaspire_dern_vm_t *self)
{
    //return self->valueFalse;
    return octaspire_dern_vm_create_new_value_copy(self, self->valueFalse);
}

octaspire_memory_allocator_t *octaspire_dern_vm_get_allocator(
    octaspire_dern_vm_t *self)
{
    return self->allocator;
}

void octaspire_dern_vm_set_exit_code(
    octaspire_dern_vm_t *self,
    int32_t const code)
{
    self->exitCode = code;
}

int32_t octaspire_dern_vm_get_exit_code(
    octaspire_dern_vm_t const * const self)
{
    return self->exitCode;
}

bool octaspire_dern_vm_is_quit(
    octaspire_dern_vm_t const * const self)
{
    return self->quit;
}

void octaspire_dern_vm_quit(
    octaspire_dern_vm_t *self)
{
    self->quit = true;
}

// Create some helper methods.

bool octaspire_dern_vm_create_and_register_new_builtin(
    octaspire_dern_vm_t * const self,
    char const * const name,
    octaspire_dern_c_function const funcPointer,
    size_t const numRequiredActualArguments,
    char const * const docStr,
    octaspire_dern_environment_t * const targetEnv)
{
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(targetEnv);

    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_builtin_t * const builtin =
        octaspire_dern_builtin_new(funcPointer, self->allocator, numRequiredActualArguments);

    if (!builtin)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
        return false;
    }

    octaspire_dern_value_t * const symbol =
        octaspire_dern_vm_create_new_value_symbol_from_c_string(self, name);

    octaspire_dern_vm_push_value(self, symbol);

    octaspire_dern_value_t * const builtinVal =
        octaspire_dern_vm_create_new_value_builtin(self, builtin, docStr);

    octaspire_dern_vm_push_value(self, builtinVal);

    if (!octaspire_dern_environment_set(targetEnv, symbol, builtinVal))
    {
        octaspire_dern_vm_pop_value(self, builtinVal);
        octaspire_dern_vm_pop_value(self, symbol);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
        return false;
    }

    octaspire_dern_vm_pop_value(self, builtinVal);
    octaspire_dern_vm_pop_value(self, symbol);

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));

    return true;
}

bool octaspire_dern_vm_create_and_register_new_special(
    octaspire_dern_vm_t * const self,
    char const * const name,
    octaspire_dern_c_function const funcPointer,
    size_t const numRequiredActualArguments,
    char const * const docStr,
    octaspire_dern_environment_t * const targetEnv)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_special_t * const special =
        octaspire_dern_special_new(funcPointer, self->allocator, numRequiredActualArguments);

    if (!special)
    {
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
        return false;
    }

    octaspire_dern_value_t * const symbol =
        octaspire_dern_vm_create_new_value_symbol_from_c_string(self, name);

    octaspire_dern_vm_push_value(self, symbol);

    octaspire_dern_value_t * const specialVal =
        octaspire_dern_vm_create_new_value_special(self, special, docStr);

    octaspire_dern_vm_push_value(self, specialVal);

    if (!octaspire_dern_environment_set(targetEnv, symbol, specialVal))
    {
        octaspire_dern_vm_pop_value(self, specialVal);
        octaspire_dern_vm_pop_value(self, symbol);
        octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
        return false;
    }

    octaspire_dern_vm_pop_value(self, specialVal);
    octaspire_dern_vm_pop_value(self, symbol);
    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return true;
}

bool octaspire_dern_vm_create_and_define_new_integer(
    octaspire_dern_vm_t * const self,
    char const * const name,
    char const * const docstr,
    int32_t const value)
{
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(self);
    octaspire_helpers_verify_not_null(self);

    octaspire_helpers_verify_true(strlen(name) > 0);
    octaspire_helpers_verify_true(strlen(docstr) > 0);

    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new_format(
        octaspire_dern_vm_get_allocator(self),
        "(define %s [%s] %" PRId32 ")",
        name,
        docstr,
        value);

    octaspire_helpers_verify_not_null(str);

    octaspire_dern_value_t *result =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            self,
            octaspire_container_utf8_string_get_c_string(str));

    octaspire_helpers_verify_not_null(result);

    octaspire_container_utf8_string_release(str);
    str = 0;

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));

    if (octaspire_dern_value_is_boolean(result) && octaspire_dern_value_as_boolean_get_value(result))
    {
        return true;
    }

    return false;
}

size_t octaspire_dern_vm_get_stack_length(
    octaspire_dern_vm_t const * const self)
{
    return octaspire_container_vector_get_length(self->stack);
}

void octaspire_dern_vm_print_stack(
    octaspire_dern_vm_t const * const self)
{
    if (octaspire_container_vector_is_empty(self->stack))
    {
        printf("\n\n-- STACK IS EMPTY --\n\n");
        return;
    }

    printf("Stack has %zu elements\n", octaspire_container_vector_get_length(self->stack));
    for (ptrdiff_t i = (ptrdiff_t)octaspire_container_vector_get_length(self->stack) - 1; i >= 0; --i)
    {
        printf("--------------------------- #%td ------------------------\n", i);
        octaspire_dern_value_print(
            octaspire_container_vector_get_element_at(self->stack, i),
            self->allocator);
        printf("--------------------------- end ------------------------\n\n");
    }
}


octaspire_dern_value_t *octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
    octaspire_dern_vm_t * const self,
    octaspire_container_vector_t const * const vectorContainingSizeTs)
{
    octaspire_helpers_verify_true(
        self &&
        vectorContainingSizeTs &&
        sizeof(size_t) == octaspire_container_vector_get_element_size_in_octets(vectorContainingSizeTs));

    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    octaspire_dern_value_t * const result = octaspire_dern_vm_create_new_value_vector(self);
    if (!octaspire_dern_vm_push_value(self, result))
    {
        abort();
    }

    for (size_t i = 0; i < octaspire_container_vector_get_length(vectorContainingSizeTs); ++i)
    {
        size_t const idx = *(size_t*)octaspire_container_vector_get_element_at_const(vectorContainingSizeTs, i);

        octaspire_dern_value_t *tmpVal =
            octaspire_dern_vm_create_new_value_integer(self, idx);

        octaspire_helpers_verify_not_null(tmpVal);

        if (!octaspire_dern_value_as_vector_push_back_element(
                result,
                &tmpVal))
        {
            abort();
        }
    }

    if (!octaspire_dern_vm_pop_value(self, result))
    {
        abort();
    }

    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
    return result;
}

octaspire_dern_value_t *octaspire_dern_vm_find_from_value(
    octaspire_dern_vm_t * const self,
    octaspire_dern_value_t * const value,
    octaspire_dern_value_t const * const key)
{
    octaspire_helpers_verify_true(self && value && key);
    size_t const stackLength = octaspire_dern_vm_get_stack_length(self);

    switch (value->typeTag)
    {
        case OCTASPIRE_DERN_VALUE_TAG_STRING:
        {
            if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER)
            {
                octaspire_container_vector_t *foundIndices = octaspire_container_utf8_string_find_char(
                    value->value.string,
                    key->value.character,
                    0);

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_container_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING)
            {
                octaspire_container_vector_t *foundIndices = octaspire_container_utf8_string_find_string(
                    value->value.string,
                    key->value.string,
                    0,
                    octaspire_container_utf8_string_get_length_in_ucs_characters(key->value.string));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_container_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
            {
                octaspire_container_vector_t *foundIndices = octaspire_container_utf8_string_find_string(
                    value->value.string,
                    key->value.symbol,
                    0,
                    octaspire_container_utf8_string_get_length_in_ucs_characters(key->value.symbol));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_container_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER)
            {
                octaspire_container_utf8_string_t *tmpStr =
                    octaspire_container_utf8_string_new_format(
                        self->allocator,
                        "%" PRId32 "",
                        key->value.integer);

                octaspire_container_vector_t *foundIndices = octaspire_container_utf8_string_find_string(
                    value->value.string,
                    tmpStr,
                    0,
                    octaspire_container_utf8_string_get_length_in_ucs_characters(tmpStr));

                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_container_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL)
            {
                octaspire_container_utf8_string_t *tmpStr =
                    octaspire_container_utf8_string_new_format(
                        self->allocator,
                        "%g",
                        key->value.real);

                octaspire_container_vector_t *foundIndices = octaspire_container_utf8_string_find_string(
                    value->value.string,
                    tmpStr,
                    0,
                    octaspire_container_utf8_string_get_length_in_ucs_characters(tmpStr));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_container_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return octaspire_dern_vm_create_new_value_error_format(
                    self,
                    "Type '%s' cannot be searched from type 'string'",
                    octaspire_dern_value_helper_get_type_as_c_string(key->typeTag));
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_SYMBOL:
        {
            if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_CHARACTER)
            {
                octaspire_container_vector_t *foundIndices = octaspire_container_utf8_string_find_char(
                    value->value.symbol,
                    key->value.character,
                    0);

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_container_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_STRING)
            {
                octaspire_container_vector_t *foundIndices = octaspire_container_utf8_string_find_string(
                    value->value.symbol,
                    key->value.string,
                    0,
                    octaspire_container_utf8_string_get_length_in_ucs_characters(key->value.string));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_container_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_SYMBOL)
            {
                octaspire_container_vector_t *foundIndices = octaspire_container_utf8_string_find_string(
                    value->value.symbol,
                    key->value.symbol,
                    0,
                    octaspire_container_utf8_string_get_length_in_ucs_characters(key->value.symbol));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_container_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_INTEGER)
            {
                octaspire_container_utf8_string_t *tmpStr =
                    octaspire_container_utf8_string_new_format(
                        self->allocator,
                        "%" PRId32 "",
                        key->value.integer);

                octaspire_container_vector_t *foundIndices = octaspire_container_utf8_string_find_string(
                    value->value.symbol,
                    tmpStr,
                    0,
                    octaspire_container_utf8_string_get_length_in_ucs_characters(tmpStr));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_container_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else if (key->typeTag == OCTASPIRE_DERN_VALUE_TAG_REAL)
            {
                octaspire_container_utf8_string_t *tmpStr =
                    octaspire_container_utf8_string_new_format(
                        self->allocator,
                        "%g",
                        key->value.real);

                octaspire_container_vector_t *foundIndices = octaspire_container_utf8_string_find_string(
                    value->value.symbol,
                    tmpStr,
                    0,
                    octaspire_container_utf8_string_get_length_in_ucs_characters(tmpStr));

                octaspire_dern_value_t * const result =
                    octaspire_dern_vm_helper_create_new_value_vector_of_integers_from_vector_of_size_t(
                        self,
                        foundIndices);

                octaspire_helpers_verify_not_null(result);

                octaspire_container_vector_release(foundIndices);
                foundIndices = 0;

                octaspire_container_utf8_string_release(tmpStr);
                tmpStr = 0;

                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }
            else
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return octaspire_dern_vm_create_new_value_error_format(
                    self,
                    "Type '%s' cannot be searched from type 'symbol'",
                    octaspire_dern_value_helper_get_type_as_c_string(key->typeTag));
            }
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_VECTOR:
        {
            octaspire_dern_value_t *result = octaspire_dern_vm_create_new_value_vector(self);

            octaspire_dern_vm_push_value(self, result);

            for (size_t i = 0; i < octaspire_container_vector_get_length(value->value.vector); ++i)
            {
                octaspire_dern_value_t * const element =
                    octaspire_container_vector_get_element_at(value->value.vector, i);

                if (octaspire_dern_value_is_equal(element, key))
                {
                    octaspire_dern_value_t *tmpVal = octaspire_dern_vm_create_new_value_integer(self, i);
                    octaspire_dern_value_as_vector_push_back_element(result, &tmpVal);
                }
            }

            octaspire_dern_vm_pop_value(self, result);
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
            return result;
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_HASH_MAP:
        {
            uint32_t const hash = octaspire_dern_value_get_hash(key);

            octaspire_container_hash_map_element_t * const element =
                octaspire_container_hash_map_get(value->value.hashMap, hash, &key);

            if (element)
            {
                octaspire_dern_value_t * const resVal =
                    octaspire_container_hash_map_element_get_value(element);

                if (resVal)
                {
                    octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                    return resVal;
                }
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
            return octaspire_dern_vm_get_value_nil(self);
        }
        break;

        case OCTASPIRE_DERN_VALUE_TAG_ENVIRONMENT:
        {
            octaspire_dern_value_t *result =
                octaspire_dern_environment_get(value->value.environment, key);

            if (result)
            {
                octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
                return result;
            }

            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
            return octaspire_dern_vm_get_value_nil(self);
        }
        break;

        default:
        {
            octaspire_helpers_verify_true(stackLength == octaspire_dern_vm_get_stack_length(self));
            return octaspire_dern_vm_create_new_value_error_format(
                self,
                "'find' doesn't support search from type '%s'",
                octaspire_dern_value_helper_get_type_as_c_string(value->typeTag));
        }
        break;
    }
}

octaspire_dern_value_t *octaspire_dern_vm_get_global_environment(
    octaspire_dern_vm_t *self)
{
    return self->globalEnvironment;
}

octaspire_dern_value_t const *octaspire_dern_vm_get_global_environment_const(
    octaspire_dern_vm_t const * const self)
{
    return self->globalEnvironment;
}

void  octaspire_dern_vm_set_user_data(octaspire_dern_vm_t * const self, void *userData)
{
    self->userData = userData;
}

void *octaspire_dern_vm_get_user_data(octaspire_dern_vm_t const * const self)
{
    return self->userData;
}

octaspire_dern_value_t *octaspire_dern_vm_get_function_return(
    octaspire_dern_vm_t * const self)
{
    return self->functionReturn;
}

void octaspire_dern_vm_set_function_return(
    octaspire_dern_vm_t * const self,
    octaspire_dern_value_t * const value)
{
    if (!value)
    {
        // Only VM is allowed to set functionReturn to NULL
        abort();
    }

    self->functionReturn = value;
}

void octaspire_dern_vm_set_prevent_gc(octaspire_dern_vm_t * const self, bool const prevent)
{
    self->preventGc = prevent;
}

void octaspire_dern_vm_set_gc_trigger_limit(octaspire_dern_vm_t * const self, size_t const numAllocs)
{
    self->gcTriggerLimit = numAllocs;
}

bool octaspire_dern_vm_is_file_system_access_allowed(octaspire_dern_vm_t const * const self)
{
    return self->fileSystemAccessAllowed;
}

bool octaspire_dern_vm_add_library(
    octaspire_dern_vm_t *self,
    char const * const name,
    octaspire_dern_lib_t *library)
{
    if (octaspire_dern_vm_has_library(self, name))
    {
        return false;
    }

    octaspire_container_utf8_string_t *str =
        octaspire_container_utf8_string_new(name, self->allocator);

    return octaspire_container_hash_map_put(
        self->libraries,
        octaspire_container_utf8_string_get_hash(str),
        &str,
        &library);
}

bool octaspire_dern_vm_has_library(
    octaspire_dern_vm_t const * const self,
    char const * const name)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
        name,
        self->allocator);

    octaspire_helpers_verify_not_null(str);

    bool const result = (octaspire_container_hash_map_get(
            self->libraries,
            octaspire_container_utf8_string_get_hash(str),
            &str) != 0);

    octaspire_container_utf8_string_release(str);
    str = 0;

    return result;
}

octaspire_dern_lib_t *octaspire_dern_vm_get_library(
    octaspire_dern_vm_t * const self,
    char const * const name)
{
    octaspire_container_utf8_string_t *str = octaspire_container_utf8_string_new(
        name,
        self->allocator);

    octaspire_helpers_verify_not_null(str);

    octaspire_container_hash_map_element_t *element = octaspire_container_hash_map_get(
        self->libraries,
        octaspire_container_utf8_string_get_hash(str),
        &str);

    octaspire_container_utf8_string_release(str);
    str = 0;

    return octaspire_container_hash_map_element_get_value(element);
}

octaspire_stdio_t *octaspire_dern_vm_get_stdio(octaspire_dern_vm_t * const self)
{
    return self->stdio;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_dern_vm.c
//////////////////////////////////////////////////////////////////////////////////////////////////




#endif // OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION


#ifdef OCTASPIRE_DERN_AMALGAMATED_REPL_IMPLEMENTATION

#ifndef OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION
#define OCTASPIRE_DERN_AMALGAMATED_IMPLEMENTATION 1
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../external/octaspire_dern_banner_color.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/***********************************************************************
 * This banner is generated with toilet using font standard.flf and by
 * coloring the result with lolcat. The header of font standard.flf is:
 *
    ===============================================================================
    flf2a$ 6 5 16 15 11 0 24463 229
    Standard by Glenn Chappell & Ian Chai 3/93 -- based on Frank's .sig
    Includes ISO Latin-1
    figlet release 2.1 -- 12 Aug 1994
    Modified for figlet 2.2 by John Cowan <cowan@ccil.org>
      to add Latin-{2,3,4,5} support (Unicode U+0100-017F).
    Permission is hereby given to modify this font, as long as the
    modifier's name is placed on a comment line.

    Modified by Paul Burton <solution@earthlink.net> 12/96 to include new parameter
    supported by FIGlet and FIGWin.  May also be slightly modified for better use
    of new full-width/kern/smush alternatives, but default output is NOT changed.
    ===============================================================================


    This file is part of Octaspire Dern and is licensed with:

    *******************************************************************************
    Octaspire Dern - Programming language
    Copyright 2017 www.octaspire.com

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    ******************************************************************************
***********************************************************************/
unsigned char octaspire_dern_banner_color[] = {
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x39, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x39, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x33, 0x6d, 0x5f, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x34, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x0d, 0x0a, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x2f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x36, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5c, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x39, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x7c, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d,
  0x28, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x29, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x33, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x34, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x38, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x0d, 0x0a, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36,
  0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36,
  0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x39, 0x6d, 0x2f,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33,
  0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x7c,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33,
  0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x2f,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33,
  0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x60, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33,
  0x39, 0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33,
  0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x27, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x5f,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x34, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x27, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x34, 0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5f,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x7c,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x7c,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x38, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x2f, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5c, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34,
  0x38, 0x6d, 0x27, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x7c,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38,
  0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x38, 0x33, 0x6d, 0x27, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b,
  0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20,
  0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38,
  0x33, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b,
  0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x0d, 0x0a,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x7c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x36, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x39, 0x6d, 0x7c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x28, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x28, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39,
  0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39,
  0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x5c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x29, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x7c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5f, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38,
  0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38,
  0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x38, 0x34, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x7c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x0d, 0x0a, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x36, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x36, 0x39, 0x6d, 0x5c, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x2f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x33, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x39, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x39, 0x6d, 0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d,
  0x2c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x33, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d,
  0x2e, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x2f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d,
  0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d,
  0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5c, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x7c, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x38, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d,
  0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d,
  0x5c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x34, 0x38, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x38, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x5f, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d,
  0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x38, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x38, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b,
  0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x7c, 0x1b, 0x5b,
  0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d,
  0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x38, 0x33, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38,
  0x3b, 0x35, 0x3b, 0x31, 0x31, 0x39, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x31, 0x31, 0x38, 0x6d, 0x7c,
  0x1b, 0x5b, 0x30, 0x6d, 0x0d, 0x0a, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x77, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x77, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x33, 0x6d, 0x77, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x2e, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33, 0x6d, 0x6f, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x33,
  0x6d, 0x63, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x74, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x61, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x73, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39,
  0x6d, 0x70, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x69, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x72, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39, 0x6d, 0x65, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x39,
  0x6d, 0x2e, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x33, 0x39, 0x6d, 0x63, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x6f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x33, 0x38, 0x6d, 0x6d, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x2f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x64, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x65, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x72, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x6e, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x5f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34, 0x6d, 0x7c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x34,
  0x6d, 0x52, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x34, 0x6d, 0x45, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x33, 0x6d, 0x50, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x4c, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x66, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x6f, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x72, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x39, 0x6d, 0x74, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x68, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39, 0x6d, 0x65, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x39,
  0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x44, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x65, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x72, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38,
  0x6d, 0x6e, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x50, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38, 0x6d, 0x72, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x34, 0x38,
  0x6d, 0x6f, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x34, 0x38, 0x6d, 0x67, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x38, 0x34, 0x6d, 0x72, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x61, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x38, 0x33, 0x6d, 0x6d, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x69, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x6e, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x67, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x38, 0x33, 0x6d, 0x20, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x4c, 0x1b, 0x5b, 0x30, 0x6d,
  0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33, 0x6d, 0x61, 0x1b,
  0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x38, 0x33,
  0x6d, 0x6e, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35,
  0x3b, 0x38, 0x33, 0x6d, 0x67, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x31, 0x31, 0x39, 0x6d, 0x75, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x31, 0x31, 0x38, 0x6d,
  0x61, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b,
  0x31, 0x31, 0x38, 0x6d, 0x67, 0x1b, 0x5b, 0x30, 0x6d, 0x1b, 0x5b, 0x33,
  0x38, 0x3b, 0x35, 0x3b, 0x31, 0x31, 0x38, 0x6d, 0x65, 0x1b, 0x5b, 0x30,
  0x6d, 0x1b, 0x5b, 0x33, 0x38, 0x3b, 0x35, 0x3b, 0x31, 0x31, 0x38, 0x6d,
  0x2e, 0x1b, 0x5b, 0x30, 0x6d, 0x0d, 0x0a
};
unsigned int octaspire_dern_banner_color_len = 5959;
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../external/octaspire_dern_banner_color.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../external/octaspire_dern_banner_white.h
//////////////////////////////////////////////////////////////////////////////////////////////////
/***********************************************************************
 * This banner is generated with toilet using font standard.flf.
 * The header of font standard.flf is:
 *
    ===============================================================================
    flf2a$ 6 5 16 15 11 0 24463 229
    Standard by Glenn Chappell & Ian Chai 3/93 -- based on Frank's .sig
    Includes ISO Latin-1
    figlet release 2.1 -- 12 Aug 1994
    Modified for figlet 2.2 by John Cowan <cowan@ccil.org>
      to add Latin-{2,3,4,5} support (Unicode U+0100-017F).
    Permission is hereby given to modify this font, as long as the
    modifier's name is placed on a comment line.

    Modified by Paul Burton <solution@earthlink.net> 12/96 to include new parameter
    supported by FIGlet and FIGWin.  May also be slightly modified for better use
    of new full-width/kern/smush alternatives, but default output is NOT changed.
    ===============================================================================


    This file is part of Octaspire Dern and is licensed with:

    *******************************************************************************
    Octaspire Dern - Programming language
    Copyright 2017 www.octaspire.com

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    ******************************************************************************
***********************************************************************/
unsigned char octaspire_dern_banner_white[] = {
  0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x5f,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x2f, 0x20, 0x5f, 0x20,
  0x5c, 0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x7c, 0x20, 0x7c, 0x5f, 0x20, 0x5f,
  0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f,
  0x20, 0x28, 0x5f, 0x29, 0x5f, 0x20, 0x5f, 0x5f, 0x20, 0x5f, 0x5f, 0x5f,
  0x20, 0x20, 0x7c, 0x20, 0x20, 0x5f, 0x20, 0x5c, 0x20, 0x20, 0x5f, 0x5f,
  0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x20,
  0x20, 0x0a, 0x7c, 0x20, 0x7c, 0x20, 0x7c, 0x20, 0x7c, 0x2f, 0x20, 0x5f,
  0x5f, 0x7c, 0x20, 0x5f, 0x5f, 0x2f, 0x20, 0x5f, 0x60, 0x20, 0x2f, 0x20,
  0x5f, 0x5f, 0x7c, 0x20, 0x27, 0x5f, 0x20, 0x5c, 0x7c, 0x20, 0x7c, 0x20,
  0x27, 0x5f, 0x5f, 0x2f, 0x20, 0x5f, 0x20, 0x5c, 0x20, 0x7c, 0x20, 0x7c,
  0x20, 0x7c, 0x20, 0x7c, 0x2f, 0x20, 0x5f, 0x20, 0x5c, 0x20, 0x27, 0x5f,
  0x5f, 0x7c, 0x20, 0x27, 0x5f, 0x20, 0x5c, 0x20, 0x0a, 0x7c, 0x20, 0x7c,
  0x5f, 0x7c, 0x20, 0x7c, 0x20, 0x28, 0x5f, 0x5f, 0x7c, 0x20, 0x7c, 0x7c,
  0x20, 0x28, 0x5f, 0x7c, 0x20, 0x5c, 0x5f, 0x5f, 0x20, 0x5c, 0x20, 0x7c,
  0x5f, 0x29, 0x20, 0x7c, 0x20, 0x7c, 0x20, 0x7c, 0x20, 0x7c, 0x20, 0x20,
  0x5f, 0x5f, 0x2f, 0x20, 0x7c, 0x20, 0x7c, 0x5f, 0x7c, 0x20, 0x7c, 0x20,
  0x20, 0x5f, 0x5f, 0x2f, 0x20, 0x7c, 0x20, 0x20, 0x7c, 0x20, 0x7c, 0x20,
  0x7c, 0x20, 0x7c, 0x0a, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x2f, 0x20, 0x5c,
  0x5f, 0x5f, 0x5f, 0x7c, 0x5c, 0x5f, 0x5f, 0x5c, 0x5f, 0x5f, 0x2c, 0x5f,
  0x7c, 0x5f, 0x5f, 0x5f, 0x2f, 0x20, 0x2e, 0x5f, 0x5f, 0x2f, 0x7c, 0x5f,
  0x7c, 0x5f, 0x7c, 0x20, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x7c, 0x20, 0x7c,
  0x5f, 0x5f, 0x5f, 0x5f, 0x2f, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x7c, 0x5f,
  0x7c, 0x20, 0x20, 0x7c, 0x5f, 0x7c, 0x20, 0x7c, 0x5f, 0x7c, 0x0a, 0x20,
  0x20, 0x77, 0x77, 0x77, 0x2e, 0x6f, 0x63, 0x74, 0x61, 0x73, 0x70, 0x69,
  0x72, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x64, 0x65, 0x72, 0x6e, 0x7c,
  0x5f, 0x7c, 0x52, 0x45, 0x50, 0x4c, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74,
  0x68, 0x65, 0x20, 0x44, 0x65, 0x72, 0x6e, 0x20, 0x50, 0x72, 0x6f, 0x67,
  0x72, 0x61, 0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x20, 0x4c, 0x61, 0x6e, 0x67,
  0x75, 0x61, 0x67, 0x65, 0x2e, 0x0a
};
unsigned int octaspire_dern_banner_white_len = 402;
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../external/octaspire_dern_banner_white.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../src/octaspire_dern_repl.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

#define ANSI_COLOR_RED    "\x1B[31m"
#define ANSI_COLOR_GREEN  "\x1B[32m"
#define ANSI_COLOR_YELLOW "\x1B[33m"
#define ANSI_COLOR_WHITE  "\x1B[37m"
#define ANSI_COLOR_DGRAY  "\x1B[1;30m"
#define ANSI_COLOR_RESET  "\x1B[0m"

typedef enum
{
    OCTASPIRE_DERN_REPL_MESSAGE_INFO,
    OCTASPIRE_DERN_REPL_MESSAGE_OUTPUT,
    OCTASPIRE_DERN_REPL_MESSAGE_ERROR,
    OCTASPIRE_DERN_REPL_MESSAGE_FATAL
}
octaspire_dern_repl_message_t;

void octaspire_dern_repl_print_message_c_str(
    char const * const message,
    octaspire_dern_repl_message_t const messageType,
    bool const useColors)
{
    if (useColors)
    {
        switch (messageType)
        {
            case OCTASPIRE_DERN_REPL_MESSAGE_INFO:
            {
                printf(ANSI_COLOR_DGRAY);
            }
            break;

            case OCTASPIRE_DERN_REPL_MESSAGE_OUTPUT:
            {
                printf(ANSI_COLOR_GREEN);
            }
            break;

            case OCTASPIRE_DERN_REPL_MESSAGE_ERROR:
            {
                printf(ANSI_COLOR_RED);
            }
            break;

            case OCTASPIRE_DERN_REPL_MESSAGE_FATAL:
            {
                printf(ANSI_COLOR_YELLOW);
            }
            break;
        }
    }

    printf("%s", message);

    if (useColors)
    {
        printf(ANSI_COLOR_RESET);
    }
}

void octaspire_dern_repl_print_message(
    octaspire_container_utf8_string_t const * const message,
    octaspire_dern_repl_message_t const messageType,
    bool const useColors)
{
    octaspire_dern_repl_print_message_c_str(
        octaspire_container_utf8_string_get_c_string(message),
        messageType,
        useColors);
}

void octaspire_dern_repl_print_version(bool const useColors)
{
    printf("  ");
    octaspire_dern_repl_print_message_c_str(
        OCTASPIRE_DERN_CONFIG_VERSION_STR,
        OCTASPIRE_DERN_REPL_MESSAGE_INFO,
        useColors);

    printf("\n");
}

void octaspire_dern_repl_print_banner(bool const useColors)
{
    printf("\n");
    if (useColors)
    {
        for (size_t i = 0; i < octaspire_dern_banner_color_len; ++i)
        {
            putchar(octaspire_dern_banner_color[i]);
        }
    }
    else
    {
        for (size_t i = 0; i < octaspire_dern_banner_white_len; ++i)
        {
            putchar(octaspire_dern_banner_white[i]);
        }
    }

    octaspire_dern_repl_print_message_c_str(
        "  \n"
        "  Licensed under the Apache License, Version 2.0. Distributed on\n"
        "  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND.\n\n",
        OCTASPIRE_DERN_REPL_MESSAGE_INFO, useColors);
}

void octaspire_dern_repl_print_usage(char const * const binaryName, bool const useColors)
{
    octaspire_dern_repl_print_banner(useColors);
    octaspire_dern_repl_print_version(useColors);
    printf("\nusage: %s [option] ... [file] ...\n", binaryName);
    printf("\nwhere [option] is one of the values listed below and every\n");
    printf("[file] is loaded and evaluated before the REPL is started or closed.\n");
    printf("If any of -e string or [file] is used, REPL is not started unless -i is used.\n\n");
    printf("-c        --color-diagnostics             : use colors on unix like systems\n");
    printf("-i        --interactive                   : start REPL after any -e string or [file]s are evaluated\n");
    printf("-e string --evaluate string               : evaluate a string without entering the REPL (unless -i is given)\n");
    printf("-f        --allow-file-system-access      : Allow code to access file system (read and write files)\n");
    printf("-v        --version                       : print version information and exit\n");
    printf("-h        --help                          : print this help message and exit\n");
}


// Globals for the REPL. ////////////////////////////
octaspire_container_vector_t      *stringsToBeEvaluated = 0;
octaspire_memory_allocator_t      *allocatorBootOnly    = 0;
octaspire_container_utf8_string_t *line                 = 0;
octaspire_stdio_t                 *stdio                = 0;
octaspire_input_t                 *input                = 0;
octaspire_dern_vm_t               *vm                   = 0;
octaspire_memory_allocator_t      *allocator            = 0;

static void octaspire_dern_repl_private_cleanup(void)
{
    octaspire_container_vector_release(stringsToBeEvaluated);
    stringsToBeEvaluated = 0;

    octaspire_memory_allocator_release(allocatorBootOnly);
    allocatorBootOnly = 0;

    octaspire_dern_vm_release(vm);
    vm = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_stdio_release(stdio);
    stdio = 0;

    octaspire_memory_allocator_release(allocator);
    allocator = 0;
}

#ifdef OCTASPIRE_PLAN9_IMPLEMENTATION
void main(int argc, char *argv[])
#else
int main(int argc, char *argv[])
#endif
{
#ifndef OCTASPIRE_PLAN9_IMPLEMENTATION
    setlocale(LC_ALL, "");
#endif
    bool useColors               = false;
    int  userFilesStartIdx       = -1;
    bool enterReplAlways         = false;
    bool evaluate                = false;

    octaspire_dern_vm_config_t vmConfig = octaspire_dern_vm_config_default();

#ifdef OCTASPIRE_PLAN9_IMPLEMENTATION
    if (atexit(octaspire_dern_repl_private_cleanup) == 0)
#else
    if (atexit(octaspire_dern_repl_private_cleanup) != 0)
#endif
    {
        octaspire_dern_repl_print_message_c_str(
            "Cannot register the 'atexit' function",
            OCTASPIRE_DERN_REPL_MESSAGE_FATAL,
            useColors);

        exit(EXIT_FAILURE);
    }

    allocatorBootOnly = octaspire_memory_allocator_new(0);

    if (!allocatorBootOnly)
    {
        octaspire_dern_repl_print_message_c_str(
            "Cannot create boot allocator",
            OCTASPIRE_DERN_REPL_MESSAGE_FATAL,
            useColors);

        exit(EXIT_FAILURE);
    }

    stringsToBeEvaluated = octaspire_container_vector_new(
        sizeof(octaspire_container_utf8_string_t*),
        true,
        (octaspire_container_vector_element_callback_t)octaspire_container_utf8_string_release,
        allocatorBootOnly);

    if (!stringsToBeEvaluated)
    {
        octaspire_dern_repl_print_message_c_str(
            "Cannot create evaluation vector",
            OCTASPIRE_DERN_REPL_MESSAGE_FATAL,
            useColors);

        exit(EXIT_FAILURE);
    }

    if (argc > 1)
    {
        for (int i = 1; i < argc; ++i)
        {
            if (evaluate)
            {
                evaluate = false;

                octaspire_container_utf8_string_t *tmp = octaspire_container_utf8_string_new(
                    argv[i],
                    allocatorBootOnly);

                if (!tmp)
                {
                    octaspire_dern_repl_print_message_c_str(
                        "Cannot create string to be evaluated",
                        OCTASPIRE_DERN_REPL_MESSAGE_FATAL,
                        useColors);

                    exit(EXIT_FAILURE);
                }

                octaspire_container_vector_push_back_element(stringsToBeEvaluated, &tmp);
            }
            else if (strcmp(argv[i], "-c") == 0 || strcmp(argv[i], "--color-diagnostics") == 0)
            {
                useColors = true;
            }
            else if (strcmp(argv[i], "-i") == 0 || strcmp(argv[i], "--interactive") == 0)
            {
                enterReplAlways = true;
            }
            else if (strcmp(argv[i], "-e") == 0 || strcmp(argv[i], "--evaluate") == 0)
            {
                evaluate = true;
            }
            else if (strcmp(argv[i], "-f") == 0 || strcmp(argv[i], "--allow-file-system-access") == 0)
            {
                vmConfig.fileSystemAccessAllowed = true;
            }
            else if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--version") == 0)
            {
                octaspire_dern_repl_print_version(useColors);
                exit(EXIT_SUCCESS);
            }
            else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0)
            {
                octaspire_dern_repl_print_usage(argv[0], useColors);
                exit(EXIT_SUCCESS);
            }
            else
            {
                if (argv[i][0] == '-')
                {
                    printf("Unknown argument %s\n\n", argv[i]);
                    octaspire_dern_repl_print_usage(argv[0], useColors);
                    exit(EXIT_FAILURE);
                }
                else
                {
                    if (userFilesStartIdx < 0)
                    {
                        userFilesStartIdx = i;
                    }
                }
            }
        }
    }

    allocator = octaspire_memory_allocator_new(0);

    if (!allocator)
    {
        octaspire_dern_repl_print_message_c_str(
            "Allocation failure\n",
            OCTASPIRE_DERN_REPL_MESSAGE_FATAL,
            useColors);

        exit(EXIT_FAILURE);
    }

    line  = 0;
    stdio = octaspire_stdio_new(allocator);
    input = octaspire_input_new_from_c_string("", allocator);
    vm    = octaspire_dern_vm_new_with_config(allocator, stdio, vmConfig);

    // Eval all files given as cmdline args
    for (size_t i = 0; i < octaspire_container_vector_get_length(stringsToBeEvaluated); ++i)
    {
        octaspire_container_utf8_string_t const * const str =
            octaspire_container_vector_get_element_at_const(stringsToBeEvaluated, i);

        octaspire_dern_value_t *value =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
                vm,
                octaspire_container_utf8_string_get_c_string(str));

        assert(value);

        if (value->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
        {
            octaspire_container_utf8_string_t *str = octaspire_dern_value_to_string(value, allocator);

            octaspire_dern_repl_print_message(str, OCTASPIRE_DERN_REPL_MESSAGE_ERROR, useColors);

            printf("\n");

            octaspire_container_utf8_string_release(str);
            str = 0;

            exit(EXIT_FAILURE);
        }
    }

    if (userFilesStartIdx >= 0)
    {
        for (int i = userFilesStartIdx; i < argc; ++i)
        {
            octaspire_dern_value_t *value =
                octaspire_dern_vm_read_from_path_and_eval_in_global_environment(vm, argv[i]);

            assert(value);

            if (value->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
            {
                octaspire_container_utf8_string_t *str = octaspire_dern_value_to_string(value, allocator);

                octaspire_dern_repl_print_message(str, OCTASPIRE_DERN_REPL_MESSAGE_ERROR, useColors);

                printf("\n");

                octaspire_container_utf8_string_release(str);
                str = 0;

                exit(EXIT_FAILURE);
            }
        }

    }

    if (octaspire_container_vector_get_length(stringsToBeEvaluated) > 0 || userFilesStartIdx >= 0)
    {
        if (!enterReplAlways)
        {
            goto octaspire_dern_repl_cleanup;
        }
    }

    octaspire_dern_repl_print_banner(useColors);
    octaspire_dern_repl_print_version(useColors);

    octaspire_dern_repl_print_message_c_str(
        "\n  Quit by pressing CTRL-d on empty line\n"
        "  or by writing (exit) and then enter.\n\n",
        OCTASPIRE_DERN_REPL_MESSAGE_INFO, useColors);

    do
    {
newInput:
        octaspire_dern_repl_print_message_c_str("> ", OCTASPIRE_DERN_REPL_MESSAGE_INFO, useColors);
moreInput:
        line = octaspire_stdio_read_line(stdio, stdin);

        if (!line)
        {
            break;
        }

        if (line && octaspire_container_utf8_string_get_length_in_ucs_characters(line) > 0)
        {
            octaspire_input_push_back_from_string(input, line);

            octaspire_dern_value_t *value = octaspire_dern_vm_parse(vm, input);

            if (!value)
            {
                octaspire_input_rewind(input);
                octaspire_dern_repl_print_message_c_str("| ", OCTASPIRE_DERN_REPL_MESSAGE_INFO, useColors);
                goto moreInput;
            }
            else if (value->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
            {
                octaspire_container_utf8_string_t *str = octaspire_dern_value_to_string(value, allocator);

                octaspire_dern_repl_print_message(str, OCTASPIRE_DERN_REPL_MESSAGE_ERROR, useColors);

                printf("\n");

                octaspire_container_utf8_string_release(str);
                str = 0;

                octaspire_input_clear(input);
                goto newInput;
            }
            else
            {
                octaspire_dern_vm_push_value(vm, value);

                octaspire_dern_value_t *evaluatedValue = octaspire_dern_vm_eval_in_global_environment(
                        vm,
                        value);

                if (!evaluatedValue)
                {
                    octaspire_dern_vm_pop_value(vm, evaluatedValue); // evaluatedValue
                    octaspire_input_rewind(input);
                    octaspire_dern_repl_print_message_c_str("+ ", OCTASPIRE_DERN_REPL_MESSAGE_INFO, useColors);
                    goto moreInput;
                    break;
                }
                else if (value->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    printf("--------------------\n");
                    octaspire_dern_value_print(evaluatedValue, octaspire_dern_vm_get_allocator(vm));
                    octaspire_input_clear(input);
                    goto newInput;
                }

                octaspire_dern_vm_push_value(vm, evaluatedValue);

                assert(evaluatedValue);

                octaspire_container_utf8_string_t *str =
                    octaspire_dern_value_to_string(evaluatedValue, allocator);

                assert(str);

                if (evaluatedValue->typeTag == OCTASPIRE_DERN_VALUE_TAG_ERROR)
                {
                    octaspire_dern_repl_print_message(str, OCTASPIRE_DERN_REPL_MESSAGE_ERROR, useColors);
                }
                else
                {
                    octaspire_dern_repl_print_message(str, OCTASPIRE_DERN_REPL_MESSAGE_OUTPUT, useColors);
                }

                printf("\n");

                octaspire_container_utf8_string_release(str);
                str = 0;

                octaspire_dern_vm_pop_value(vm, evaluatedValue); // evaluatedValue
                octaspire_dern_vm_pop_value(vm, value); // value

                octaspire_input_clear(input);
            }
        }

        octaspire_container_utf8_string_release(line);
        line = 0;
    }
    while (!octaspire_dern_vm_is_quit(vm));


octaspire_dern_repl_cleanup:
    // A label can only be part of a statement
    for (size_t i = 0; i < 1; ++i)
    {
    }

    int32_t exitCode = EXIT_FAILURE;

    if (vm)
    {
        exitCode = octaspire_dern_vm_get_exit_code(vm);
    }

    octaspire_dern_repl_private_cleanup();

#ifdef OCTASPIRE_PLAN9_IMPLEMENTATION
    exits(exitCode == EXIT_SUCCESS ? "" : "error");
#else
    return exitCode;
#endif
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../src/octaspire_dern_repl.c
//////////////////////////////////////////////////////////////////////////////////////////////////



#endif // OCTASPIRE_DERN_AMALGAMATED_REPL_IMPLEMENTATION








#ifdef OCTASPIRE_DERN_AMALGAMATED_UNIT_TEST_IMPLEMENTATION

//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../external/greatest.h
//////////////////////////////////////////////////////////////////////////////////////////////////
// This file is modified by www.octaspire.com. The original copyright is:

/*
 * Copyright (c) 2011-2016 Scott Vokes <vokes.s@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

// Modifications are released under similar license:

/*
 * Copyright (c) 2017 www.octaspire.com
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef GREATEST_H
#define GREATEST_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef GREATEST_ENABLE_ANSI_COLORS
#define GREATEST_ANSI_COLOR_RED    "\x1B[31m"
#define GREATEST_ANSI_COLOR_GREEN  "\x1B[32m"
#define GREATEST_ANSI_COLOR_YELLOW "\x1B[33m"
#define GREATEST_ANSI_COLOR_DGRAY  "\x1B[1;30m"
#define GREATEST_ANSI_COLOR_RESET  "\x1B[0m"
#else
#define GREATEST_ANSI_COLOR_RED    ""
#define GREATEST_ANSI_COLOR_GREEN  ""
#define GREATEST_ANSI_COLOR_YELLOW ""
#define GREATEST_ANSI_COLOR_DGRAY  ""
#define GREATEST_ANSI_COLOR_RESET  ""
#endif

/* 1.2.2 */
#define GREATEST_VERSION_MAJOR 1
#define GREATEST_VERSION_MINOR 2
#define GREATEST_VERSION_PATCH 2

/* A unit testing system for C, contained in 1 file.
 * It doesn't use dynamic allocation or depend on anything
 * beyond ANSI C89.
 *
 * An up-to-date version can be found at:
 *     https://github.com/silentbicycle/greatest/
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/***********
 * Options *
 ***********/

/* Default column width for non-verbose output. */
#ifndef GREATEST_DEFAULT_WIDTH
#define GREATEST_DEFAULT_WIDTH 72
#endif

/* FILE *, for test logging. */
#ifndef GREATEST_STDOUT
#define GREATEST_STDOUT stdout
#endif

/* Remove GREATEST_ prefix from most commonly used symbols? */
#ifndef GREATEST_USE_ABBREVS
#define GREATEST_USE_ABBREVS 1
#endif

/* Set to 0 to disable all use of setjmp/longjmp. */
#ifndef GREATEST_USE_LONGJMP
#define GREATEST_USE_LONGJMP 1
#endif

#ifdef GREATEST_USE_LONGJMP
#include <setjmp.h>
#endif

/* Set to 0 to disable all use of time.h / clock(). */
#ifndef GREATEST_USE_TIME
#define GREATEST_USE_TIME 1
#endif

#ifdef GREATEST_USE_TIME
#include <time.h>
#endif

/* Floating point type, for ASSERT_IN_RANGE. */
#ifndef GREATEST_FLOAT
#define GREATEST_FLOAT double
#define GREATEST_FLOAT_FMT "%g"
#endif

/*********
 * Types *
 *********/

/* Info for the current running suite. */
typedef struct greatest_suite_info {
    unsigned int tests_run;
    unsigned int passed;
    unsigned int failed;
    unsigned int skipped;

#ifdef GREATEST_USE_TIME
    /* timers, pre/post running suite and individual tests */
    clock_t pre_suite;
    clock_t post_suite;
    clock_t pre_test;
    clock_t post_test;
#endif
} greatest_suite_info;

/* Type for a suite function. */
typedef void (greatest_suite_cb)(void);

/* Types for setup/teardown callbacks. If non-NULL, these will be run
 * and passed the pointer to their additional data. */
typedef void (greatest_setup_cb)(void *udata);
typedef void (greatest_teardown_cb)(void *udata);

/* Type for an equality comparison between two pointers of the same type.
 * Should return non-0 if equal, otherwise 0.
 * UDATA is a closure value, passed through from ASSERT_EQUAL_T[m]. */
typedef int greatest_equal_cb(const void *exp, const void *got, void *udata);

/* Type for a callback that prints a value pointed to by T.
 * Return value has the same meaning as printf's.
 * UDATA is a closure value, passed through from ASSERT_EQUAL_T[m]. */
typedef int greatest_printf_cb(const void *t, void *udata);

/* Callbacks for an arbitrary type; needed for type-specific
 * comparisons via GREATEST_ASSERT_EQUAL_T[m].*/
typedef struct greatest_type_info {
    greatest_equal_cb *equal;
    greatest_printf_cb *print;
} greatest_type_info;

typedef struct greatest_memory_cmp_env {
    const unsigned char *exp;
    const unsigned char *got;
    size_t size;
} greatest_memory_cmp_env;

/* Callbacks for string and raw memory types. */
extern greatest_type_info greatest_type_info_string;
extern greatest_type_info greatest_type_info_memory;

typedef enum {
    GREATEST_FLAG_FIRST_FAIL = 0x01,
    GREATEST_FLAG_LIST_ONLY = 0x02
} greatest_flag_t;

/* Struct containing all test runner state. */
typedef struct greatest_run_info {
    unsigned char flags;
    unsigned char verbosity;
    unsigned char pad_0[2];

    unsigned int tests_run;     /* total test count */

    /* currently running test suite */
    greatest_suite_info suite;

    /* overall pass/fail/skip counts */
    unsigned int passed;
    unsigned int failed;
    unsigned int skipped;
    unsigned int assertions;

    /* info to print about the most recent failure */
    unsigned int fail_line;
    unsigned int pad_1;
    const char *fail_file;
    const char *msg;

    /* current setup/teardown hooks and userdata */
    greatest_setup_cb *setup;
    void *setup_udata;
    greatest_teardown_cb *teardown;
    void *teardown_udata;

    /* formatting info for ".....s...F"-style output */
    unsigned int col;
    unsigned int width;

    /* only run a specific suite or test */
    const char *suite_filter;
    const char *test_filter;

#ifdef GREATEST_USE_TIME
    /* overall timers */
    clock_t begin;
    clock_t end;
#endif

#ifdef GREATEST_USE_LONGJMP
    int pad_jmp_buf;
    char octaspire_padding[4];
    jmp_buf jump_dest;
#endif
} greatest_run_info;

struct greatest_report_t {
    /* overall pass/fail/skip counts */
    unsigned int passed;
    unsigned int failed;
    unsigned int skipped;
    unsigned int assertions;
};

/* Global var for the current testing context.
 * Initialized by GREATEST_MAIN_DEFS(). */
extern greatest_run_info greatest_info;

/* Type for ASSERT_ENUM_EQ's ENUM_STR argument. */
typedef const char *greatest_enum_str_fun(int value);

/**********************
 * Exported functions *
 **********************/

/* These are used internally by greatest. */
void greatest_do_pass(const char *name);
void greatest_do_fail(const char *name);
void greatest_do_skip(const char *name);
int greatest_pre_test(const char *name);
void greatest_post_test(const char *name, int res);
void greatest_usage(const char *name);
int greatest_do_assert_equal_t(const void *exp, const void *got,
    greatest_type_info *type_info, void *udata);

/* These are part of the public greatest API. */
void GREATEST_SET_SETUP_CB(greatest_setup_cb *cb, void *udata);
void GREATEST_SET_TEARDOWN_CB(greatest_teardown_cb *cb, void *udata);
int greatest_all_passed(void);
void greatest_set_test_filter(const char *name);
void greatest_set_suite_filter(const char *name);
void greatest_get_report(struct greatest_report_t *report);
unsigned int greatest_get_verbosity(void);
void greatest_set_verbosity(unsigned int verbosity);
void greatest_set_flag(greatest_flag_t flag);


/********************
* Language Support *
********************/

/**********
 * Macros *
 **********/

/* Define a suite. */
#define GREATEST_SUITE(NAME) void NAME(void); void NAME(void)

/* Declare a suite, provided by another compilation unit. */
#define GREATEST_SUITE_EXTERN(NAME) void NAME(void)

/* Start defining a test function.
 * The arguments are not included, to allow parametric testing. */
#define GREATEST_TEST static enum greatest_test_res

/* PASS/FAIL/SKIP result from a test. Used internally. */
typedef enum greatest_test_res {
    GREATEST_TEST_RES_PASS = 0,
    GREATEST_TEST_RES_FAIL = -1,
    GREATEST_TEST_RES_SKIP = 1
} greatest_test_res;

/* Run a suite. */
#define GREATEST_RUN_SUITE(S_NAME) greatest_run_suite(S_NAME, #S_NAME)

/* Run a test in the current suite. */
#define GREATEST_RUN_TEST(TEST)                                         \
    do {                                                                \
        if (greatest_pre_test(#TEST) == 1) {                            \
            enum greatest_test_res res = GREATEST_SAVE_CONTEXT();       \
            if (res == GREATEST_TEST_RES_PASS) {                        \
                res = TEST();                                           \
            }                                                           \
            greatest_post_test(#TEST, res);                             \
        } else if (GREATEST_LIST_ONLY()) {                              \
            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
        }                                                               \
    } while (0)

/* Ignore a test, don't warn about it being unused. */
#define GREATEST_IGNORE_TEST(TEST) (void)TEST

/* Run a test in the current suite with one void * argument,
 * which can be a pointer to a struct with multiple arguments. */
#define GREATEST_RUN_TEST1(TEST, ENV)                                   \
    do {                                                                \
        if (greatest_pre_test(#TEST) == 1) {                            \
            int res = TEST(ENV);                                        \
            greatest_post_test(#TEST, res);                             \
        } else if (GREATEST_LIST_ONLY()) {                              \
            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
        }                                                               \
    } while (0)

#ifdef GREATEST_VA_ARGS
#define GREATEST_RUN_TESTp(TEST, ...)                                   \
    do {                                                                \
        if (greatest_pre_test(#TEST) == 1) {                            \
            int res = TEST(__VA_ARGS__);                                \
            greatest_post_test(#TEST, res);                             \
        } else if (GREATEST_LIST_ONLY()) {                              \
            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
        }                                                               \
    } while (0)
#endif


/* Check if the test runner is in verbose mode. */
#define GREATEST_IS_VERBOSE() ((greatest_info.verbosity) > 0)
#define GREATEST_LIST_ONLY()                                            \
    (greatest_info.flags & GREATEST_FLAG_LIST_ONLY)
#define GREATEST_FIRST_FAIL()                                           \
    (greatest_info.flags & GREATEST_FLAG_FIRST_FAIL)
#define GREATEST_FAILURE_ABORT()                                        \
    (greatest_info.suite.failed > 0 && GREATEST_FIRST_FAIL())

/* Message-less forms of tests defined below. */
#define GREATEST_PASS() GREATEST_PASSm(NULL)
#define GREATEST_FAIL() GREATEST_FAILm(NULL)
#define GREATEST_SKIP() GREATEST_SKIPm(NULL)
#define GREATEST_ASSERT(COND)                                           \
    GREATEST_ASSERTm(#COND, COND)
#define GREATEST_ASSERT_OR_LONGJMP(COND)                                \
    GREATEST_ASSERT_OR_LONGJMPm(#COND, COND)
#define GREATEST_ASSERT_FALSE(COND)                                     \
    GREATEST_ASSERT_FALSEm(#COND, COND)
#define GREATEST_ASSERT_EQ(EXP, GOT)                                    \
    GREATEST_ASSERT_EQm(#EXP " != " #GOT, EXP, GOT)
#define GREATEST_ASSERT_EQ_FMT(EXP, GOT, FMT)                           \
    GREATEST_ASSERT_EQ_FMTm(#EXP " != " #GOT, EXP, GOT, FMT)
#define GREATEST_ASSERT_IN_RANGE(EXP, GOT, TOL)                         \
    GREATEST_ASSERT_IN_RANGEm(#EXP " != " #GOT " +/- " #TOL, EXP, GOT, TOL)
#define GREATEST_ASSERT_EQUAL_T(EXP, GOT, TYPE_INFO, UDATA)             \
    GREATEST_ASSERT_EQUAL_Tm(#EXP " != " #GOT, EXP, GOT, TYPE_INFO, UDATA)
#define GREATEST_ASSERT_STR_EQ(EXP, GOT)                                \
    GREATEST_ASSERT_STR_EQm(#EXP " != " #GOT, EXP, GOT)
#define GREATEST_ASSERT_STRN_EQ(EXP, GOT, SIZE)                         \
    GREATEST_ASSERT_STRN_EQm(#EXP " != " #GOT, EXP, GOT, SIZE)
#define GREATEST_ASSERT_MEM_EQ(EXP, GOT, SIZE)                          \
    GREATEST_ASSERT_MEM_EQm(#EXP " != " #GOT, EXP, GOT, SIZE)
#define GREATEST_ASSERT_ENUM_EQ(EXP, GOT, ENUM_STR)                     \
    GREATEST_ASSERT_ENUM_EQm(#EXP " != " #GOT, EXP, GOT, ENUM_STR)

/* The following forms take an additional message argument first,
 * to be displayed by the test runner. */

/* Fail if a condition is not true, with message. */
#define GREATEST_ASSERTm(MSG, COND)                                     \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if (!(COND)) { GREATEST_FAILm(MSG); }                           \
    } while (0)

/* Fail if a condition is not true, longjmping out of test. */
#define GREATEST_ASSERT_OR_LONGJMPm(MSG, COND)                          \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if (!(COND)) { GREATEST_FAIL_WITH_LONGJMPm(MSG); }              \
    } while (0)

/* Fail if a condition is not false, with message. */
#define GREATEST_ASSERT_FALSEm(MSG, COND)                               \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if ((COND)) { GREATEST_FAILm(MSG); }                            \
    } while (0)

/* Fail if EXP != GOT (equality comparison by ==). */
#define GREATEST_ASSERT_EQm(MSG, EXP, GOT)                              \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if ((EXP) != (GOT)) { GREATEST_FAILm(MSG); }                    \
    } while (0)

/* Fail if EXP != GOT (equality comparison by ==).
 * Warning: FMT, EXP, and GOT will be evaluated more
 * than once on failure. */
#define GREATEST_ASSERT_EQ_FMTm(MSG, EXP, GOT, FMT)                     \
    do {                                                                \
        greatest_info.assertions++;                                     \
        if ((EXP) != (GOT)) {                                           \
            fprintf(GREATEST_STDOUT, "\nExpected: ");                   \
            fprintf(GREATEST_STDOUT, FMT, EXP);                         \
            fprintf(GREATEST_STDOUT, "\n     Got: ");                   \
            fprintf(GREATEST_STDOUT, FMT, GOT);                         \
            fprintf(GREATEST_STDOUT, "\n");                             \
            GREATEST_FAILm(MSG);                                        \
        }                                                               \
    } while (0)

/* Fail if EXP is not equal to GOT, printing enum IDs. */
#define GREATEST_ASSERT_ENUM_EQm(MSG, EXP, GOT, ENUM_STR)               \
    do {                                                                \
        int greatest_EXP = (int)(EXP);                                  \
        int greatest_GOT = (int)(GOT);                                  \
        greatest_enum_str_fun *greatest_ENUM_STR = ENUM_STR;            \
        if (greatest_EXP != greatest_GOT) {                             \
            fprintf(GREATEST_STDOUT, "\nExpected: %s",                  \
                greatest_ENUM_STR(greatest_EXP));                       \
            fprintf(GREATEST_STDOUT, "\n     Got: %s\n",                \
                greatest_ENUM_STR(greatest_GOT));                       \
            GREATEST_FAILm(MSG);                                        \
        }                                                               \
    } while (0)                                                         \

/* Fail if GOT not in range of EXP +|- TOL. */
#define GREATEST_ASSERT_IN_RANGEm(MSG, EXP, GOT, TOL)                   \
    do {                                                                \
        GREATEST_FLOAT greatest_EXP = (EXP);                            \
        GREATEST_FLOAT greatest_GOT = (GOT);                            \
        GREATEST_FLOAT greatest_TOL = (TOL);                            \
        greatest_info.assertions++;                                     \
        if ((greatest_EXP > greatest_GOT &&                             \
                greatest_EXP - greatest_GOT > greatest_TOL) ||          \
            (greatest_EXP < greatest_GOT &&                             \
                greatest_GOT - greatest_EXP > greatest_TOL)) {          \
            fprintf(GREATEST_STDOUT,                                    \
                "\nExpected: " GREATEST_FLOAT_FMT                       \
                " +/- " GREATEST_FLOAT_FMT                              \
                "\n     Got: " GREATEST_FLOAT_FMT                       \
                "\n",                                                   \
                greatest_EXP, greatest_TOL, greatest_GOT);              \
            GREATEST_FAILm(MSG);                                        \
        }                                                               \
    } while (0)

/* Fail if EXP is not equal to GOT, according to strcmp. */
#define GREATEST_ASSERT_STR_EQm(MSG, EXP, GOT)                          \
    do {                                                                \
        GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT,                         \
            &greatest_type_info_string, NULL);                          \
    } while (0)                                                         \

/* Fail if EXP is not equal to GOT, according to strcmp. */
#define GREATEST_ASSERT_STRN_EQm(MSG, EXP, GOT, SIZE)                   \
    do {                                                                \
        size_t size = SIZE;                                             \
        GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT,                         \
            &greatest_type_info_string, &size);                         \
    } while (0)                                                         \

/* Fail if EXP is not equal to GOT, according to memcmp. */
#define GREATEST_ASSERT_MEM_EQm(MSG, EXP, GOT, SIZE)                    \
    do {                                                                \
        greatest_memory_cmp_env env;                                    \
        env.exp = (const unsigned char *)EXP;                           \
        env.got = (const unsigned char *)GOT;                           \
        env.size = SIZE;                                                \
        GREATEST_ASSERT_EQUAL_Tm(MSG, env.exp, env.got,                 \
            &greatest_type_info_memory, &env);                          \
    } while (0)                                                         \

/* Fail if EXP is not equal to GOT, according to a comparison
 * callback in TYPE_INFO. If they are not equal, optionally use a
 * print callback in TYPE_INFO to print them. */
#define GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT, TYPE_INFO, UDATA)       \
    do {                                                                \
        greatest_type_info *type_info = (TYPE_INFO);                    \
        greatest_info.assertions++;                                     \
        if (!greatest_do_assert_equal_t(EXP, GOT,                       \
                type_info, UDATA)) {                                    \
            if (type_info == NULL || type_info->equal == NULL) {        \
                GREATEST_FAILm("type_info->equal callback missing!");   \
            } else {                                                    \
                GREATEST_FAILm(MSG);                                    \
            }                                                           \
        }                                                               \
    } while (0)                                                         \

/* Pass. */
#define GREATEST_PASSm(MSG)                                             \
    do {                                                                \
        greatest_info.msg = MSG;                                        \
        return GREATEST_TEST_RES_PASS;                                  \
    } while (0)

/* Fail. */
#define GREATEST_FAILm(MSG)                                             \
    do {                                                                \
        greatest_info.fail_file = __FILE__;                             \
        greatest_info.fail_line = __LINE__;                             \
        greatest_info.msg = MSG;                                        \
        return GREATEST_TEST_RES_FAIL;                                  \
    } while (0)

/* Optional GREATEST_FAILm variant that longjmps. */
#ifdef GREATEST_USE_LONGJMP
#define GREATEST_FAIL_WITH_LONGJMP() GREATEST_FAIL_WITH_LONGJMPm(NULL)
#define GREATEST_FAIL_WITH_LONGJMPm(MSG)                                \
    do {                                                                \
        greatest_info.fail_file = __FILE__;                             \
        greatest_info.fail_line = __LINE__;                             \
        greatest_info.msg = MSG;                                        \
        longjmp(greatest_info.jump_dest, GREATEST_TEST_RES_FAIL);       \
    } while (0)
#endif

/* Skip the current test. */
#define GREATEST_SKIPm(MSG)                                             \
    do {                                                                \
        greatest_info.msg = MSG;                                        \
        return GREATEST_TEST_RES_SKIP;                                  \
    } while (0)

/* Check the result of a subfunction using ASSERT, etc. */
#define GREATEST_CHECK_CALL(RES)                                        \
    do {                                                                \
        enum greatest_test_res greatest_RES = RES;                      \
        if (greatest_RES != GREATEST_TEST_RES_PASS) {                   \
            return greatest_RES;                                        \
        }                                                               \
    } while (0)                                                         \

#ifdef GREATEST_USE_TIME
#define GREATEST_SET_TIME(NAME)                                         \
    NAME = clock();                                                     \
    if (NAME == (clock_t) -1) {                                         \
        fprintf(GREATEST_STDOUT,                                        \
            "clock error: %s\n", #NAME);                                \
        exit(EXIT_FAILURE);                                             \
    }

#define GREATEST_CLOCK_DIFF(C1, C2)                                     \
    fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_DGRAY " (%lu ticks, %.3f sec)" GREATEST_ANSI_COLOR_RESET, \
        (long unsigned int) (C2) - (long unsigned int)(C1),             \
        (double)((C2) - (C1)) / (1.0 * (double)CLOCKS_PER_SEC))
#else
#define GREATEST_SET_TIME(UNUSED)
#define GREATEST_CLOCK_DIFF(UNUSED1, UNUSED2)
#endif

#ifdef GREATEST_USE_LONGJMP
#define GREATEST_SAVE_CONTEXT()                                         \
        /* setjmp returns 0 (GREATEST_TEST_RES_PASS) on first call */   \
        /* so the test runs, then RES_FAIL from FAIL_WITH_LONGJMP. */   \
        ((enum greatest_test_res)(setjmp(greatest_info.jump_dest)))
#else
#define GREATEST_SAVE_CONTEXT()                                         \
    /*a no-op, since setjmp/longjmp aren't being used */                \
    GREATEST_TEST_RES_PASS
#endif

/* Include several function definitions in the main test file. */
#define GREATEST_MAIN_DEFS()                                            \
                                                                        \
/* Is FILTER a subset of NAME? */                                       \
static int greatest_name_match(const char *name,                        \
    const char *filter) {                                               \
    size_t offset = 0;                                                  \
    size_t filter_len = strlen(filter);                                 \
    while (name[offset] != '\0') {                                      \
        if (name[offset] == filter[0]) {                                \
            if (0 == strncmp(&name[offset], filter, filter_len)) {      \
                return 1;                                               \
            }                                                           \
        }                                                               \
        offset++;                                                       \
    }                                                                   \
                                                                        \
    return 0;                                                           \
}                                                                       \
                                                                        \
int greatest_pre_test(const char *name) {                               \
    if (!GREATEST_LIST_ONLY()                                           \
        && (!GREATEST_FIRST_FAIL() || greatest_info.suite.failed == 0)  \
        && (greatest_info.test_filter == NULL ||                        \
            greatest_name_match(name, greatest_info.test_filter))) {    \
        GREATEST_SET_TIME(greatest_info.suite.pre_test);                \
        if (greatest_info.setup) {                                      \
            greatest_info.setup(greatest_info.setup_udata);             \
        }                                                               \
        return 1;               /* test should be run */                \
    } else {                                                            \
        return 0;               /* skipped */                           \
    }                                                                   \
}                                                                       \
                                                                        \
void greatest_post_test(const char *name, int res) {                    \
    GREATEST_SET_TIME(greatest_info.suite.post_test);                   \
    if (greatest_info.teardown) {                                       \
        void *udata = greatest_info.teardown_udata;                     \
        greatest_info.teardown(udata);                                  \
    }                                                                   \
                                                                        \
    if (res <= GREATEST_TEST_RES_FAIL) {                                \
        greatest_do_fail(name);                                         \
    } else if (res >= GREATEST_TEST_RES_SKIP) {                         \
        greatest_do_skip(name);                                         \
    } else if (res == GREATEST_TEST_RES_PASS) {                         \
        greatest_do_pass(name);                                         \
    }                                                                   \
    greatest_info.suite.tests_run++;                                    \
    greatest_info.col++;                                                \
    if (GREATEST_IS_VERBOSE()) {                                        \
        GREATEST_CLOCK_DIFF(greatest_info.suite.pre_test,               \
            greatest_info.suite.post_test);                             \
        fprintf(GREATEST_STDOUT, "\n");                                 \
    } else if (greatest_info.col % greatest_info.width == 0) {          \
        fprintf(GREATEST_STDOUT, "\n");                                 \
        greatest_info.col = 0;                                          \
    }                                                                   \
    fflush(GREATEST_STDOUT);                                            \
}                                                                       \
                                                                        \
static void report_suite(void) {                                        \
    if (greatest_info.suite.tests_run > 0) {                            \
        fprintf(GREATEST_STDOUT,                                        \
            "\n%u test%s - %u passed, %u failed, %u skipped",           \
            greatest_info.suite.tests_run,                              \
            greatest_info.suite.tests_run == 1 ? "" : "s",              \
            greatest_info.suite.passed,                                 \
            greatest_info.suite.failed,                                 \
            greatest_info.suite.skipped);                               \
        GREATEST_CLOCK_DIFF(greatest_info.suite.pre_suite,              \
            greatest_info.suite.post_suite);                            \
        fprintf(GREATEST_STDOUT, "\n");                                 \
    }                                                                   \
}                                                                       \
                                                                        \
static void update_counts_and_reset_suite(void) {                       \
    greatest_info.setup = NULL;                                         \
    greatest_info.setup_udata = NULL;                                   \
    greatest_info.teardown = NULL;                                      \
    greatest_info.teardown_udata = NULL;                                \
    greatest_info.passed += greatest_info.suite.passed;                 \
    greatest_info.failed += greatest_info.suite.failed;                 \
    greatest_info.skipped += greatest_info.suite.skipped;               \
    greatest_info.tests_run += greatest_info.suite.tests_run;           \
    memset(&greatest_info.suite, 0, sizeof(greatest_info.suite));       \
    greatest_info.col = 0;                                              \
}                                                                       \
                                                                        \
static void greatest_run_suite(greatest_suite_cb *suite_cb,             \
                               const char *suite_name) {                \
    if (greatest_info.suite_filter &&                                   \
        !greatest_name_match(suite_name, greatest_info.suite_filter)) { \
        return;                                                         \
    }                                                                   \
    update_counts_and_reset_suite();                                    \
    if (GREATEST_FIRST_FAIL() && greatest_info.failed > 0) { return; }  \
    fprintf(GREATEST_STDOUT, "\n" GREATEST_ANSI_COLOR_YELLOW "* Suite %s:" GREATEST_ANSI_COLOR_RESET "\n", suite_name);  \
    GREATEST_SET_TIME(greatest_info.suite.pre_suite);                   \
    suite_cb();                                                         \
    GREATEST_SET_TIME(greatest_info.suite.post_suite);                  \
    report_suite();                                                     \
}                                                                       \
                                                                        \
void greatest_do_pass(const char *name) {                               \
    if (GREATEST_IS_VERBOSE()) {                                        \
        fprintf(GREATEST_STDOUT, "PASS %s: %s",                         \
            name, greatest_info.msg ? greatest_info.msg : "");          \
    } else {                                                            \
        fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_GREEN "." GREATEST_ANSI_COLOR_RESET);  \
    }                                                                   \
    greatest_info.suite.passed++;                                       \
}                                                                       \
                                                                        \
void greatest_do_fail(const char *name) {                               \
    if (GREATEST_IS_VERBOSE()) {                                        \
        fprintf(GREATEST_STDOUT,                                        \
            "FAIL %s: %s (%s:%u)",                                      \
            name, greatest_info.msg ? greatest_info.msg : "",           \
            greatest_info.fail_file, greatest_info.fail_line);          \
    } else {                                                            \
        fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_RED "F" GREATEST_ANSI_COLOR_RESET);    \
        greatest_info.col++;                                            \
        /* add linebreak if in line of '.'s */                          \
        if (greatest_info.col != 0) {                                   \
            fprintf(GREATEST_STDOUT, "\n");                             \
            greatest_info.col = 0;                                      \
        }                                                               \
        fprintf(GREATEST_STDOUT, GREATEST_ANSI_COLOR_RED "FAIL" GREATEST_ANSI_COLOR_RESET " %s: %s (%s:%u)\n",  \
            name,                                                       \
            greatest_info.msg ? greatest_info.msg : "",                 \
            greatest_info.fail_file, greatest_info.fail_line);          \
    }                                                                   \
    greatest_info.suite.failed++;                                       \
}                                                                       \
                                                                        \
void greatest_do_skip(const char *name) {                               \
    if (GREATEST_IS_VERBOSE()) {                                        \
        fprintf(GREATEST_STDOUT, "SKIP %s: %s",                         \
            name,                                                       \
            greatest_info.msg ?                                         \
            greatest_info.msg : "" );                                   \
    } else {                                                            \
        fprintf(GREATEST_STDOUT, "s");                                  \
    }                                                                   \
    greatest_info.suite.skipped++;                                      \
}                                                                       \
                                                                        \
int greatest_do_assert_equal_t(const void *exp, const void *got,        \
        greatest_type_info *type_info, void *udata) {                   \
    int eq = 0;                                                         \
    if (type_info == NULL || type_info->equal == NULL) {                \
        return 0;                                                       \
    }                                                                   \
    eq = type_info->equal(exp, got, udata);                             \
    if (!eq) {                                                          \
        if (type_info->print != NULL) {                                 \
            fprintf(GREATEST_STDOUT, "\nExpected: ");                   \
            (void)type_info->print(exp, udata);                         \
            fprintf(GREATEST_STDOUT, "\n     Got: ");                   \
            (void)type_info->print(got, udata);                         \
            fprintf(GREATEST_STDOUT, "\n");                             \
        } else {                                                        \
            fprintf(GREATEST_STDOUT,                                    \
                "GREATEST_ASSERT_EQUAL_T failure at %s:%u\n",           \
                greatest_info.fail_file,                                \
                greatest_info.fail_line);                               \
        }                                                               \
    }                                                                   \
    return eq;                                                          \
}                                                                       \
                                                                        \
void greatest_usage(const char *name) {                                 \
    fprintf(GREATEST_STDOUT,                                            \
        "Usage: %s [-hlfv] [-s SUITE] [-t TEST]\n"                      \
        "  -h, --help  print this Help\n"                               \
        "  -l          List suites and their tests, then exit\n"        \
        "  -f          Stop runner after first failure\n"               \
        "  -v          Verbose output\n"                                \
        "  -s SUITE    only run suites containing string SUITE\n"       \
        "  -t TEST     only run tests containing string TEST\n",        \
        name);                                                          \
}                                                                       \
                                                                        \
static void greatest_parse_args(int argc, char **argv) {                \
    int i = 0;                                                          \
    for (i = 1; i < argc; i++) {                                        \
        if (0 == strncmp("-t", argv[i], 2)) {                           \
            if (argc <= i + 1) {                                        \
                greatest_usage(argv[0]);                                \
                exit(EXIT_FAILURE);                                     \
            }                                                           \
            greatest_info.test_filter = argv[i+1];                      \
            i++;                                                        \
        } else if (0 == strncmp("-s", argv[i], 2)) {                    \
            if (argc <= i + 1) {                                        \
                greatest_usage(argv[0]);                                \
                exit(EXIT_FAILURE);                                     \
            }                                                           \
            greatest_info.suite_filter = argv[i+1];                     \
            i++;                                                        \
        } else if (0 == strncmp("-f", argv[i], 2)) {                    \
            greatest_info.flags |= GREATEST_FLAG_FIRST_FAIL;            \
        } else if (0 == strncmp("-v", argv[i], 2)) {                    \
            greatest_info.verbosity++;                                  \
        } else if (0 == strncmp("-l", argv[i], 2)) {                    \
            greatest_info.flags |= GREATEST_FLAG_LIST_ONLY;             \
        } else if (0 == strncmp("-h", argv[i], 2) ||                    \
                   0 == strncmp("--help", argv[i], 6)) {                \
            greatest_usage(argv[0]);                                    \
            exit(EXIT_SUCCESS);                                         \
        } else if (0 == strncmp("--", argv[i], 2)) {                    \
            break;                                                      \
        } else {                                                        \
            fprintf(GREATEST_STDOUT,                                    \
                "Unknown argument '%s'\n", argv[i]);                    \
            greatest_usage(argv[0]);                                    \
            exit(EXIT_FAILURE);                                         \
        }                                                               \
    }                                                                   \
}                                                                       \
                                                                        \
int greatest_all_passed(void) { return (greatest_info.failed == 0); }   \
                                                                        \
void greatest_set_test_filter(const char *name) {                       \
    greatest_info.test_filter = name;                                   \
}                                                                       \
                                                                        \
void greatest_set_suite_filter(const char *name) {                      \
    greatest_info.suite_filter = name;                                  \
}                                                                       \
                                                                        \
void greatest_get_report(struct greatest_report_t *report) {            \
    if (report) {                                                       \
        report->passed = greatest_info.passed;                          \
        report->failed = greatest_info.failed;                          \
        report->skipped = greatest_info.skipped;                        \
        report->assertions = greatest_info.assertions;                  \
    }                                                                   \
}                                                                       \
                                                                        \
unsigned int greatest_get_verbosity(void) {                             \
    return greatest_info.verbosity;                                     \
}                                                                       \
                                                                        \
void greatest_set_verbosity(unsigned int verbosity) {                   \
    greatest_info.verbosity = (unsigned char)verbosity;                 \
}                                                                       \
                                                                        \
void greatest_set_flag(greatest_flag_t flag) {                          \
    greatest_info.flags |= flag;                                        \
}                                                                       \
                                                                        \
void GREATEST_SET_SETUP_CB(greatest_setup_cb *cb, void *udata) {        \
    greatest_info.setup = cb;                                           \
    greatest_info.setup_udata = udata;                                  \
}                                                                       \
                                                                        \
void GREATEST_SET_TEARDOWN_CB(greatest_teardown_cb *cb,                 \
                                    void *udata) {                      \
    greatest_info.teardown = cb;                                        \
    greatest_info.teardown_udata = udata;                               \
}                                                                       \
                                                                        \
static int greatest_string_equal_cb(const void *exp, const void *got,   \
    void *udata) {                                                      \
    size_t *size = (size_t *)udata;                                     \
    return (size != NULL                                                \
        ? (0 == strncmp((const char *)exp, (const char *)got, *size))   \
        : (0 == strcmp((const char *)exp, (const char *)got)));         \
}                                                                       \
                                                                        \
static int greatest_string_printf_cb(const void *t, void *udata) {      \
    (void)udata; /* note: does not check \0 termination. */             \
    return fprintf(GREATEST_STDOUT, "%s", (const char *)t);             \
}                                                                       \
                                                                        \
greatest_type_info greatest_type_info_string = {                        \
    greatest_string_equal_cb,                                           \
    greatest_string_printf_cb,                                          \
};                                                                      \
                                                                        \
static int greatest_memory_equal_cb(const void *exp, const void *got,   \
    void *udata) {                                                      \
    greatest_memory_cmp_env *env = (greatest_memory_cmp_env *)udata;    \
    return (0 == memcmp(exp, got, env->size));                          \
}                                                                       \
                                                                        \
static int greatest_memory_printf_cb(const void *t, void *udata) {      \
    greatest_memory_cmp_env *env = (greatest_memory_cmp_env *)udata;    \
    const unsigned char *buf = (const unsigned char *)t;                \
    unsigned char diff_mark = ' ';                                      \
    FILE *out = GREATEST_STDOUT;                                        \
    size_t i, line_i, line_len = 0;                                     \
    int len = 0;   /* format hexdump with differences highlighted */    \
    for (i = 0; i < env->size; i+= line_len) {                          \
        diff_mark = ' ';                                                \
        line_len = env->size - i;                                       \
        if (line_len > 16) { line_len = 16; }                           \
        for (line_i = i; line_i < i + line_len; line_i++) {             \
            if (env->exp[line_i] != env->got[line_i]) diff_mark = 'X';  \
        }                                                               \
        len += fprintf(out, "\n%04x %c ", (unsigned int)i, diff_mark);  \
        for (line_i = i; line_i < i + line_len; line_i++) {             \
            int m = env->exp[line_i] == env->got[line_i]; /* match? */  \
            len += fprintf(out, "%02x%c", buf[line_i], m ? ' ' : '<');  \
        }                                                               \
        for (line_i = 0; line_i < 16 - line_len; line_i++) {            \
            len += fprintf(out, "   ");                                 \
        }                                                               \
        fprintf(out, " ");                                              \
        for (line_i = i; line_i < i + line_len; line_i++) {             \
            unsigned char c = buf[line_i];                              \
            len += fprintf(out, "%c", isprint(c) ? c : '.');            \
        }                                                               \
    }                                                                   \
    len += fprintf(out, "\n");                                          \
    return len;                                                         \
}                                                                       \
                                                                        \
greatest_type_info greatest_type_info_memory = {                        \
    greatest_memory_equal_cb,                                           \
    greatest_memory_printf_cb,                                          \
};                                                                      \
                                                                        \
greatest_run_info greatest_info

/* Init internals. */
#define GREATEST_INIT()                                                 \
    do {                                                                \
        /* Suppress unused function warning if features aren't used */  \
        (void)greatest_run_suite;                                       \
        (void)greatest_parse_args;                                      \
                                                                        \
        memset(&greatest_info, 0, sizeof(greatest_info));               \
        greatest_info.width = GREATEST_DEFAULT_WIDTH;                   \
        GREATEST_SET_TIME(greatest_info.begin);                         \
    } while (0)                                                         \

/* Handle command-line arguments, etc. */
#define GREATEST_MAIN_BEGIN()                                           \
    do {                                                                \
        GREATEST_INIT();                                                \
        greatest_parse_args(argc, argv);                                \
    } while (0)

/* Report passes, failures, skipped tests, the number of
 * assertions, and the overall run time. */
#define GREATEST_PRINT_REPORT()                                         \
    do {                                                                \
        if (!GREATEST_LIST_ONLY()) {                                    \
            update_counts_and_reset_suite();                            \
            GREATEST_SET_TIME(greatest_info.end);                       \
            fprintf(GREATEST_STDOUT,                                    \
                "\nTotal: %u test%s",                                   \
                greatest_info.tests_run,                                \
                greatest_info.tests_run == 1 ? "" : "s");               \
            GREATEST_CLOCK_DIFF(greatest_info.begin,                    \
                greatest_info.end);                                     \
            fprintf(GREATEST_STDOUT, ", %u assertion%s\n",              \
                greatest_info.assertions,                               \
                greatest_info.assertions == 1 ? "" : "s");              \
            fprintf(GREATEST_STDOUT,                                    \
                GREATEST_ANSI_COLOR_GREEN "Pass: %u, fail: %u, skip: %u.\n" GREATEST_ANSI_COLOR_RESET,  \
                greatest_info.passed,                                   \
                greatest_info.failed, greatest_info.skipped);           \
        }                                                               \
    } while (0)

/* Report results, exit with exit status based on results. */
#define GREATEST_MAIN_END()                                             \
    do {                                                                \
        GREATEST_PRINT_REPORT();                                        \
        return (greatest_all_passed() ? EXIT_SUCCESS : EXIT_FAILURE);   \
    } while (0)

/* Make abbreviations without the GREATEST_ prefix for the
 * most commonly used symbols. */
#ifdef GREATEST_USE_ABBREVS
#define TEST           GREATEST_TEST
#define SUITE          GREATEST_SUITE
#define SUITE_EXTERN   GREATEST_SUITE_EXTERN
#define RUN_TEST       GREATEST_RUN_TEST
#define RUN_TEST1      GREATEST_RUN_TEST1
#define RUN_SUITE      GREATEST_RUN_SUITE
#define IGNORE_TEST    GREATEST_IGNORE_TEST
#define ASSERT         GREATEST_ASSERT
#define ASSERTm        GREATEST_ASSERTm
#define ASSERT_FALSE   GREATEST_ASSERT_FALSE
#define ASSERT_EQ      GREATEST_ASSERT_EQ
#define ASSERT_EQ_FMT  GREATEST_ASSERT_EQ_FMT
#define ASSERT_IN_RANGE GREATEST_ASSERT_IN_RANGE
#define ASSERT_EQUAL_T GREATEST_ASSERT_EQUAL_T
#define ASSERT_STR_EQ  GREATEST_ASSERT_STR_EQ
#define ASSERT_STRN_EQ GREATEST_ASSERT_STRN_EQ
#define ASSERT_MEM_EQ  GREATEST_ASSERT_MEM_EQ
#define ASSERT_ENUM_EQ GREATEST_ASSERT_ENUM_EQ
#define ASSERT_FALSEm  GREATEST_ASSERT_FALSEm
#define ASSERT_EQm     GREATEST_ASSERT_EQm
#define ASSERT_EQ_FMTm GREATEST_ASSERT_EQ_FMTm
#define ASSERT_IN_RANGEm GREATEST_ASSERT_IN_RANGEm
#define ASSERT_EQUAL_Tm GREATEST_ASSERT_EQUAL_Tm
#define ASSERT_STR_EQm GREATEST_ASSERT_STR_EQm
#define ASSERT_STRN_EQm GREATEST_ASSERT_STRN_EQm
#define ASSERT_MEM_EQm GREATEST_ASSERT_MEM_EQm
#define ASSERT_ENUM_EQm GREATEST_ASSERT_ENUM_EQm
#define PASS           GREATEST_PASS
#define FAIL           GREATEST_FAIL
#define SKIP           GREATEST_SKIP
#define PASSm          GREATEST_PASSm
#define FAILm          GREATEST_FAILm
#define SKIPm          GREATEST_SKIPm
#define SET_SETUP      GREATEST_SET_SETUP_CB
#define SET_TEARDOWN   GREATEST_SET_TEARDOWN_CB
#define CHECK_CALL     GREATEST_CHECK_CALL

#ifdef GREATEST_VA_ARGS
#define RUN_TESTp      GREATEST_RUN_TESTp
#endif

#ifdef GREATEST_USE_LONGJMP
#define ASSERT_OR_LONGJMP  GREATEST_ASSERT_OR_LONGJMP
#define ASSERT_OR_LONGJMPm GREATEST_ASSERT_OR_LONGJMPm
#define FAIL_WITH_LONGJMP  GREATEST_FAIL_WITH_LONGJMP
#define FAIL_WITH_LONGJMPm GREATEST_FAIL_WITH_LONGJMPm
#endif

#endif /* USE_ABBREVS */

#ifdef __cplusplus
}
#endif

#endif
//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../external/greatest.h
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_dern_lexer.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_memory_allocator_t *octaspireDernLexerTestAllocator = 0;

TEST octaspire_dern_lexer_token_new_test(void)
{
    octaspire_dern_lexer_token_tag_t       const expectedTypeTag  = OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN;
    octaspire_dern_lexer_token_position_t  const expectedLine     = {987, 987};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {123, 123};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {300, 300};

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        expectedTypeTag,
        0,
        expectedLine,
        expectedColumn,
        expectedUcsIndex,
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT_EQ     (expectedTypeTag,  token->typeTag);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ     (octaspireDernLexerTestAllocator,        token->allocator);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_new_allocation_failure_on_first_allocation_test(void)
{
    octaspire_dern_lexer_token_tag_t       const expectedTypeTag  = OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN;
    octaspire_dern_lexer_token_position_t  const expectedLine     = {987, 987};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {123, 123};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {300, 300};

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator, 1, 0);
    ASSERT_EQ(1, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator));

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        expectedTypeTag,
        0,
        expectedLine,
        expectedColumn,
        expectedUcsIndex,
        octaspireDernLexerTestAllocator);

    ASSERT_FALSE(token);

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_new_allocation_failure_on_second_allocation_when_tag_is_string_test(void)
{
    octaspire_dern_lexer_token_tag_t       const expectedTypeTag  = OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING;
    octaspire_dern_lexer_token_position_t  const expectedLine     = {987, 987};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {123, 123};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {300, 300};

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator));

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        expectedTypeTag,
        "some text",
        expectedLine,
        expectedColumn,
        expectedUcsIndex,
        octaspireDernLexerTestAllocator);

    ASSERT_FALSE(token);

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_new_allocation_failure_on_second_allocation_when_tag_is_error_test(void)
{
    octaspire_dern_lexer_token_tag_t      const expectedTypeTag  = OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR;
    octaspire_dern_lexer_token_position_t const expectedLine     = {987, 987};
    octaspire_dern_lexer_token_position_t const expectedColumn   = {123, 123};
    octaspire_dern_lexer_token_position_t const expectedUcsIndex = {300, 300};

    octaspire_memory_allocator_set_number_and_type_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator, 2, 0x01);
    ASSERT_EQ(2, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator));

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        expectedTypeTag,
        "some text",
        expectedLine,
        expectedColumn,
        expectedUcsIndex,
        octaspireDernLexerTestAllocator);

    ASSERT_FALSE(token);

    ASSERT_EQ(0, octaspire_memory_allocator_get_number_of_future_allocations_to_be_rigged(octaspireDernLexerTestAllocator));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_get_type_tag_test(void)
{
    octaspire_dern_lexer_token_tag_t      const expectedTypeTag  = OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN;

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        expectedTypeTag,
        0,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT_EQ(expectedTypeTag, octaspire_dern_lexer_token_get_type_tag(token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_get_type_tag_as_c_string_test(void)
{
    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
        0,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT_STR_EQ("OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN", octaspire_dern_lexer_token_get_type_tag_as_c_string(token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_get_integer_value_test(void)
{
    int32_t const expected = 765;

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER,
        &expected,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT_EQ(expected, octaspire_dern_lexer_token_get_integer_value(token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_get_line_test(void)
{
    octaspire_dern_lexer_token_position_t  const expectedLine     = {32003, 32004};

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
        0,
        expectedLine,
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_position_is_equal(
        &expectedLine,
        octaspire_dern_lexer_token_get_position_line(token)));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_get_column_test(void)
{
    octaspire_dern_lexer_token_position_t  const expectedColumn     = {32003, 32004};

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
        0,
        octaspire_dern_lexer_token_position_init(123, 123),
        expectedColumn,
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_position_is_equal(
        &expectedColumn,
        octaspire_dern_lexer_token_get_position_column(token)));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_to_string_with_lparen_token_test(void)
{
    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
        0,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    octaspire_container_utf8_string_t *str = octaspire_dern_lexer_token_to_string(token);

    ASSERT(str);

    char const * const expected =
        "token: line=987,987 column=123,123 ucsIndex=300,300 "
        "type=OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN value=left parenthesis";

    ASSERT_STR_EQ(expected, octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_to_string_with_rparen_token_test(void)
{
    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN,
        0,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    octaspire_container_utf8_string_t *str = octaspire_dern_lexer_token_to_string(token);

    ASSERT(str);

    char const * const expected =
        "token: line=987,987 column=123,123 ucsIndex=300,300 "
        "type=OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN value=right parenthesis";

    ASSERT_STR_EQ(expected, octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_to_string_with_integer_token_test(void)
{
    int32_t const expected = 16987;

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER,
        &expected,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    octaspire_container_utf8_string_t *str = octaspire_dern_lexer_token_to_string(token);

    ASSERT(str);

    ASSERT_STR_EQ(
        "token: line=987,987 column=123,123 ucsIndex=300,300 "
        "type=OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER value=integer 16987",
        octaspire_container_utf8_string_get_c_string(str));

    octaspire_container_utf8_string_release(str);
    str = 0;

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_to_string_with_error_token_test(void)
{
    char const * const value = "some error";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        "some error",
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_token_to_string_with_unknow_token_test(void)
{
    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
        128,
        0,
        octaspire_dern_lexer_token_position_init(987, 987),
        octaspire_dern_lexer_token_position_init(123, 123),
        octaspire_dern_lexer_token_position_init(300, 300),
        octaspireDernLexerTestAllocator);

    ASSERT_FALSE(token);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_left_parenthesis_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
        0,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(0, 0),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "(",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_right_parenthesis_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN,
        0,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(0, 0),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        ")",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_left_parenthesis_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_LPAREN,
        0,
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(5, 5),
        octaspire_dern_lexer_token_position_init(6, 6),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t  (   \n \t  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_right_parenthesis_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_RPAREN,
        0,
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(5, 5),
        octaspire_dern_lexer_token_position_init(6, 6),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t  )   \n \t  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_quote_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE,
        0,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(0, 0),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "'",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_quote_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_QUOTE,
        0,
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(5, 5),
        octaspire_dern_lexer_token_position_init(6, 6),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t  '   \n \t  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_true_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE,
        0,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 4),
        octaspire_dern_lexer_token_position_init(0, 3),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "true",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_true_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_TRUE,
        0,
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(5, 8),
        octaspire_dern_lexer_token_position_init(6, 9),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t  true   \n \t  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_nil_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL,
        0,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 3),
        octaspire_dern_lexer_token_position_init(0, 2),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "nil",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_nil_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_NIL,
        0,
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(5, 7),
        octaspire_dern_lexer_token_position_init(6, 8),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t  nil   \n \t  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_symbol_length_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL,
        "length",
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 6),
        octaspire_dern_lexer_token_position_init(0, 5),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "length",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_symbol_length_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_SYMBOL,
        "length",
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(5, 10),
        octaspire_dern_lexer_token_position_init(6, 11),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t  length   \n \t  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}


TEST octaspire_dern_lexer_pop_next_token_integer_12_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "12",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 2};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {0, 1};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(12,                                     token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_12_dot_3_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "12.3",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 4};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {0, 3};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(12.3, token->value.real, 0.000001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_759_after_whitespace_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "   \t   759", // 3 spaces + 1 tab + 3 spaces
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {8, 10};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {7, 9};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(759,                                    token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_759_dot_2_after_whitespace_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "   \t   759.2", // 3 spaces + 1 tab + 3 spaces
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {8, 12};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {7, 11};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(759.2, token->value.real, 0.00001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_759_amid_whitespace_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "   \t   759   \t   ", // 3 spaces + 1 tab + 3 spaces
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {8, 10};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {7, 9};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(759,                                    token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_759_dot_2_amid_whitespace_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "   \t   759.2   \t   ", // 3 spaces + 1 tab + 3 spaces
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {8, 12};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {7, 11};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(759.2, token->value.real, 0.00001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_multiline_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  #! here is comment\n 1024!#  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {2, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {3, 7};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {5, 30};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_MULTILINE_COMMENT, token->typeTag);
    ASSERT_STR_EQ(
        " here is comment\n 1024",
        octaspire_container_utf8_string_get_c_string(token->value.comment));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_multiline_comment_more_input_required_two_chars_missing_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  #! here is comment\n 1024",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {2, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {3, 5};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {5, 28};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED, token->typeTag);
    ASSERT_STR_EQ(
        "Multiline comment that is not closed with !#",
        octaspire_container_utf8_string_get_c_string(token->value.moreInputRequired));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_multiline_comment_more_input_required_one_char_missing_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  #! here is comment\n 1024!",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {2, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {3, 6};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {5, 29};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_MORE_INPUT_REQUIRED, token->typeTag);
    ASSERT_STR_EQ(
        "Number sign '#' expected after '!' to close multiline comment",
        octaspire_container_utf8_string_get_c_string(token->value.moreInputRequired));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_1024_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n1024",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 4};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 26};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(1024,                                   token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_1024_dot_987_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n1024.987",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 8};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 30};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(1024.987, token->value.real, 0.0001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_0_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n0",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 1};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 23};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(0,                                   token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_0_dot_0_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n0.0",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 3};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 25};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(0.0, token->value.real, 0.0000001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_minus_1024_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n-1024",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3, 3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1, 5};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 27};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(-1024,                                  token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_minus_1024_dot_987_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n-1024.987",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3,  3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1,  9};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 31};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(-1024.987, token->value.real, 0.0001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_1234567890_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n1234567890",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3,  3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1,  10};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 32};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(1234567890,                            token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_integer_minus_1234567890_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n-1234567890",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3,  3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1,  11};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 33};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
    ASSERT_EQ(-1234567890,                            token->value.integer);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_12345_dot_67890_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n12345.67890",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3,  3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1,  11};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 33};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(12345.67890, token->value.real, 0.000001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_real_minus_12345_dot_67890_after_whitespace_and_comment_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "  \n  ; here is comment\n-12345.67890",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    octaspire_dern_lexer_token_position_t  const expectedLine     = {3,  3};
    octaspire_dern_lexer_token_position_t  const expectedColumn   = {1,  12};
    octaspire_dern_lexer_token_position_t  const expectedUcsIndex = {23, 34};

    ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
    ASSERT        (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

    ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
    ASSERT_IN_RANGE(-12345.67890, token->value.real, 0.000001);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_five_integers_11_22_33_44_55_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "11 22 33 44 55",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < 5; ++i)
    {
        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
        ASSERT(token);

        octaspire_dern_lexer_token_position_t const expectedLine     = {1,           1};
        octaspire_dern_lexer_token_position_t const expectedColumn   = {1 + (i * 3), 2 + (i * 3)};
        octaspire_dern_lexer_token_position_t const expectedUcsIndex = {0 + (i * 3), 1 + (i * 3)};

        ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

        ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
        ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
        ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

        ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_INTEGER, token->typeTag);
        ASSERT_EQ(((int32_t)i + 1) * 11,                           token->value.integer);

        octaspire_dern_lexer_token_release(token);
        token = 0;
    }

    ASSERT_FALSE(octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator));

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_five_reals_11_dot_1_22_dot_2_33_dot_3_44_dot_4_55_dot_5_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "11.1 22.2 33.3 44.4 55.5",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < 5; ++i)
    {
        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
        ASSERT(token);

        octaspire_dern_lexer_token_position_t const expectedLine     = {1,           1};
        octaspire_dern_lexer_token_position_t const expectedColumn   = {1 + (i * 5), 4 + (i * 5)};
        octaspire_dern_lexer_token_position_t const expectedUcsIndex = {0 + (i * 5), 3 + (i * 5)};

        ASSERT_EQ(octaspireDernLexerTestAllocator,                              token->allocator);

        ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedLine,     token->line));
        ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedColumn,   token->column));
        ASSERT   (octaspire_dern_lexer_token_position_is_equal(&expectedUcsIndex, token->ucsIndex));

        ASSERT_EQ(OCTASPIRE_DERN_LEXER_TOKEN_TAG_REAL, token->typeTag);
        ASSERT_IN_RANGE(((double)i + 1.0) * 11.1,      token->value.real, 0.0000001);

        octaspire_dern_lexer_token_release(token);
        token = 0;
    }

    for (size_t i = 0; i < 5; ++i)
    {
        ASSERT_FALSE(octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator));
    }

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_failure_on_integer_12_with_character_a_after_test(void)
{
    char const * const value = "Number cannot contain character 'a'";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 3),
        octaspire_dern_lexer_token_position_init(0, 2),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "12a",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_failure_on_illegal_real_12_dot_2_dot_2_test(void)
{
    char const * const value = "Number can contain only one '.' character";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 5),
        octaspire_dern_lexer_token_position_init(0, 4),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "12.2.2",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_failure_on_illegal_integer_minus_12_minus_22_test(void)
{
    char const * const value = "Number can contain only one '-' character";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 4),
        octaspire_dern_lexer_token_position_init(0, 3),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "-12-22",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_failure_on_illegal_real_minus_12_dot_22_minus_33_test(void)
{
    char const * const value = "Number can contain only one '-' character";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 7),
        octaspire_dern_lexer_token_position_init(0, 6),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "-12.22-33",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_failure_on_illegal_integer_12_minus_22_test(void)
{
    char const * const value = "Number can have '-' character only in the beginning";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 3),
        octaspire_dern_lexer_token_position_init(0, 2),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "12-22",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_failure_on_illegal_integer_12_dot_22_minus_22_test(void)
{
    char const * const value = "Number can have '-' character only in the beginning";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 6),
        octaspire_dern_lexer_token_position_init(0, 5),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "12.22-22",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_string_cat_and_dog_test(void)
{
    char const * const value = "Cat and dog.";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_STRING,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 14),
        octaspire_dern_lexer_token_position_init(0, 13),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "[Cat and dog.]",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_character_a_test(void)
{
    char const * const value = "a";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 3),
        octaspire_dern_lexer_token_position_init(0, 2),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|a|",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_character_vertical_line_test(void)
{
    char const * const value = "|";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 5),
        octaspire_dern_lexer_token_position_init(0, 4),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|bar|",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_character_newline_test(void)
{
    char const * const value = "\n";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 9),
        octaspire_dern_lexer_token_position_init(0, 8),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|newline|",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_character_tabulator_test(void)
{
    char const * const value = "\t";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 5),
        octaspire_dern_lexer_token_position_init(0, 4),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|tab|",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_character_a_amid_whitespace_test(void)
{
    char const * const value = "a";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
        value,
        octaspire_dern_lexer_token_position_init(2, 2),
        octaspire_dern_lexer_token_position_init(6, 8),
        octaspire_dern_lexer_token_position_init(7, 9),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        " \n \t \t |a| \n \t ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_five_characters_a_b_c_d_e_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected[5];

    for (size_t i = 0; i < 5; ++i)
    {
        char const value[2] = {(char)((char)97 + (char)i) , '\0'};

        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                value,
                octaspire_dern_lexer_token_position_init(2, 2),
                octaspire_dern_lexer_token_position_init(1 + (i * 4), 3 + (i * 4)),
                octaspire_dern_lexer_token_position_init(1 + (i * 4), 3 + (i * 4)),
                octaspireDernLexerTestAllocator);

        expected[i] = token;

        ASSERT(expected[i]);
    }

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "\n|a| |b| |c| |d| |e|  ",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < 5; ++i)
    {
        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
        ASSERT(token);

        ASSERT(octaspire_dern_lexer_token_is_equal(expected[i], token));

        octaspire_dern_lexer_token_release(token);
        token = 0;
    }

    octaspire_input_release(input);
    input = 0;

    for (size_t i = 0; i < 5; ++i)
    {
        octaspire_dern_lexer_token_release(expected[i]);
        expected[i] = 0;
    }

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_five_characters_a_b_c_d_e_no_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected[5];

    for (size_t i = 0; i < 5; ++i)
    {
        char const value[2] = {(char)((char)97 + (char)i) , '\0'};

        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
                OCTASPIRE_DERN_LEXER_TOKEN_TAG_CHARACTER,
                value,
                octaspire_dern_lexer_token_position_init(1, 1),
                octaspire_dern_lexer_token_position_init(1 + (i * 3), 3 + (i * 3)),
                octaspire_dern_lexer_token_position_init(0 + (i * 3), 2 + (i * 3)),
                octaspireDernLexerTestAllocator);

        expected[i] = token;

        ASSERT(expected[i]);
    }

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|a||b||c||d||e|",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < 5; ++i)
    {
        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
        ASSERT(token);

        ASSERT(octaspire_dern_lexer_token_is_equal(expected[i], token));

        octaspire_dern_lexer_token_release(token);
        token = 0;
    }

    octaspire_input_release(input);
    input = 0;

    for (size_t i = 0; i < 5; ++i)
    {
        octaspire_dern_lexer_token_release(expected[i]);
        expected[i] = 0;
    }

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_character_a_end_of_input_before_end_delimiter_returns_null_token_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|a",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT_FALSE(token);

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_illegal_character_constant_now_line_no_whitespace_test(void)
{
    char const * const value = "Unknown character constant |now line|";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 10),
        octaspire_dern_lexer_token_position_init(0, 9),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "|now line|",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_illegal_character_empty_character_test(void)
{
    char const * const value = "Character cannot be empty: ||";
    octaspire_dern_lexer_token_t *expected = octaspire_dern_lexer_token_new(
        OCTASPIRE_DERN_LEXER_TOKEN_TAG_ERROR,
        value,
        octaspire_dern_lexer_token_position_init(1, 1),
        octaspire_dern_lexer_token_position_init(1, 2),
        octaspire_dern_lexer_token_position_init(0, 1),
        octaspireDernLexerTestAllocator);
    ASSERT(expected);

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "||",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
    ASSERT(token);

    ASSERT(octaspire_dern_lexer_token_is_equal(expected, token));

    octaspire_dern_lexer_token_release(token);
    token = 0;

    octaspire_input_release(input);
    input = 0;

    octaspire_dern_lexer_token_release(expected);
    expected = 0;

    PASS();
}

TEST octaspire_dern_lexer_pop_next_token_all_token_types_amid_whitespace_test(void)
{
    octaspire_dern_lexer_token_t *expected[12];

    uint32_t const     integerVal = 123;
    double const       realVal    = 987.456;
    char const * const strVal     = "here is a string";
    char const * const charVal    = "+";
    char const * const symbolVal  = "here_is_a_symbol";
    char const * const errorVal   = "Number cannot contain character 'a'";

    void const * const values[12] =
    {
        0,
        0,
        0,
        0,
        0,
        0,
        &integerVal,
        &realVal,
        strVal,
        charVal,
        symbolVal,
        errorVal
    };

    octaspire_dern_lexer_token_position_t linePositions[12] =
    {
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1},
        {1, 1}
    };

    octaspire_dern_lexer_token_position_t columnPositions[12] =
    {
        {1, 1},
        {3, 3},
        {5, 5},
        {7, 10},
        {12, 16},
        {18, 20},
        {22, 24},
        {26, 32},
        {34, 51},
        {53, 55},
        {57, 72},
        {74, 76}
    };

    // + 6
    octaspire_dern_lexer_token_position_t ucsIndexPositions[12] =
    {
        {0, 0},
        {2, 2},
        {4, 4},
        {6, 9},
        {11, 15},
        {17, 19},
        {21, 23},
        {25, 31},
        {33, 50},
        {52, 54},
        {56, 71},
        {73, 75}
    };

    ASSERT((sizeof(expected) / sizeof(expected[0])) == (sizeof(values) / sizeof(values[0])));
    ASSERT((sizeof(expected) / sizeof(expected[0])) == (sizeof(linePositions) / sizeof(linePositions[0])));
    ASSERT((sizeof(expected) / sizeof(expected[0])) == (sizeof(columnPositions) / sizeof(columnPositions[0])));
    ASSERT((sizeof(expected) / sizeof(expected[0])) == (sizeof(ucsIndexPositions) / sizeof(ucsIndexPositions[0])));

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_token_new(
            (octaspire_dern_lexer_token_tag_t)i,
            values[i],
            linePositions[i],
            columnPositions[i],
            ucsIndexPositions[i],
            octaspireDernLexerTestAllocator);

        expected[i] = token;

        ASSERT(expected[i]);
    }

    octaspire_input_t *input = octaspire_input_new_from_c_string(
        "( ) ' true false nil 123 987.456 [here is a string] |+| here_is_a_symbol 12a",
        octaspireDernLexerTestAllocator);

    ASSERT(input);

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_lexer_token_t *token = octaspire_dern_lexer_pop_next_token(input, octaspireDernLexerTestAllocator);
        ASSERT(token);

        ASSERT(octaspire_dern_lexer_token_is_equal(expected[i], token));

        octaspire_dern_lexer_token_release(token);
        token = 0;
    }

    octaspire_input_release(input);
    input = 0;

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_lexer_token_release(expected[i]);
        expected[i] = 0;
    }

    PASS();
}

GREATEST_SUITE(octaspire_dern_lexer_suite)
{
    octaspireDernLexerTestAllocator = octaspire_memory_allocator_new(0);
    assert(octaspireDernLexerTestAllocator);

    RUN_TEST(octaspire_dern_lexer_token_new_test);
    RUN_TEST(octaspire_dern_lexer_token_new_allocation_failure_on_first_allocation_test);
    RUN_TEST(octaspire_dern_lexer_token_new_allocation_failure_on_second_allocation_when_tag_is_string_test);
    RUN_TEST(octaspire_dern_lexer_token_new_allocation_failure_on_second_allocation_when_tag_is_error_test);
    RUN_TEST(octaspire_dern_lexer_token_get_type_tag_test);
    RUN_TEST(octaspire_dern_lexer_token_get_type_tag_as_c_string_test);
    RUN_TEST(octaspire_dern_lexer_token_get_integer_value_test);
    RUN_TEST(octaspire_dern_lexer_token_get_line_test);
    RUN_TEST(octaspire_dern_lexer_token_get_column_test);
    RUN_TEST(octaspire_dern_lexer_token_to_string_with_lparen_token_test);
    RUN_TEST(octaspire_dern_lexer_token_to_string_with_rparen_token_test);
    RUN_TEST(octaspire_dern_lexer_token_to_string_with_integer_token_test);
    RUN_TEST(octaspire_dern_lexer_token_to_string_with_error_token_test);
    RUN_TEST(octaspire_dern_lexer_token_to_string_with_unknow_token_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_left_parenthesis_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_right_parenthesis_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_left_parenthesis_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_right_parenthesis_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_quote_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_quote_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_true_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_true_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_nil_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_nil_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_symbol_length_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_symbol_length_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_12_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_12_dot_3_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_759_after_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_759_dot_2_after_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_759_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_759_dot_2_amid_whitespace_test);

    RUN_TEST(octaspire_dern_lexer_pop_next_token_multiline_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_multiline_comment_more_input_required_two_chars_missing_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_multiline_comment_more_input_required_one_char_missing_test);

    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_1024_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_1024_dot_987_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_0_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_0_dot_0_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_minus_1024_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_minus_1024_dot_987_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_minus_1234567890_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_integer_1234567890_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_12345_dot_67890_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_real_minus_12345_dot_67890_after_whitespace_and_comment_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_five_integers_11_22_33_44_55_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_five_reals_11_dot_1_22_dot_2_33_dot_3_44_dot_4_55_dot_5_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_failure_on_integer_12_with_character_a_after_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_failure_on_illegal_real_12_dot_2_dot_2_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_failure_on_illegal_integer_minus_12_minus_22_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_failure_on_illegal_real_minus_12_dot_22_minus_33_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_failure_on_illegal_integer_12_minus_22_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_failure_on_illegal_integer_12_dot_22_minus_22_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_string_cat_and_dog_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_character_a_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_character_vertical_line_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_character_newline_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_character_tabulator_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_character_a_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_five_characters_a_b_c_d_e_amid_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_five_characters_a_b_c_d_e_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_character_a_end_of_input_before_end_delimiter_returns_null_token_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_illegal_character_constant_now_line_no_whitespace_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_illegal_character_empty_character_test);
    RUN_TEST(octaspire_dern_lexer_pop_next_token_all_token_types_amid_whitespace_test);

    octaspire_memory_allocator_release(octaspireDernLexerTestAllocator);
    octaspireDernLexerTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_dern_lexer.c
//////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////
// START OF        ../test/test_dern_vm.c
//////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************
Octaspire Dern - Programming language
Copyright 2017 www.octaspire.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
******************************************************************************/

static octaspire_memory_allocator_t *octaspireDernVmTestAllocator = 0;
static octaspire_stdio_t            *octaspireDernVmTestStdio     = 0;

TEST octaspire_dern_vm_new_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    ASSERT(vm->stack);
    ASSERT_EQ(octaspireDernVmTestAllocator, vm->allocator);
    ASSERT(vm->all);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_create_new_value_boolean_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    for (size_t i = 0; i < 256; ++i)
    {
        octaspire_dern_value_t *value = octaspire_dern_vm_create_new_value_boolean(vm, i % 2);

        ASSERT(value);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, value->typeTag);
        ASSERT_EQ(i % 2, value->value.boolean);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_create_new_value_integer_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    for (int32_t i = 0; i < 256; ++i)
    {
        octaspire_dern_value_t *value = octaspire_dern_vm_create_new_value_integer(vm, i);

        ASSERT(value);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, value->typeTag);
        ASSERT_EQ(i, value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_create_new_value_boolean_and_push_one_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *pushedValue = 0;

    for (size_t i = 0; i < 256; ++i)
    {
        octaspire_dern_value_t *value =
            octaspire_dern_vm_create_new_value_boolean(vm, i % 2);

        if (i == 10)
        {
            ASSERT(octaspire_dern_vm_push_value(vm, value));
            pushedValue = value;
        }
    }

    // Make sure we can use the pushed value (it is not freed)
    ASSERT(pushedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, pushedValue->typeTag);
    ASSERT_EQ(10 % 2, pushedValue->value.boolean);
    //ASSERT(octaspire_dern_value_get_hash(pushedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_vm_parse_and_eval_true_amid_whitespace_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string("  \t \n  \t true  ", octaspireDernVmTestAllocator);

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_environment_t *wrappedEnv = octaspire_dern_environment_new(0, vm, octaspireDernVmTestAllocator);

    octaspire_dern_value_t *environment =
        octaspire_dern_vm_create_new_value_environment_from_environment(vm, wrappedEnv);

    ASSERT(environment);

    ASSERT(octaspire_dern_vm_push_value(vm, environment));

    octaspire_dern_value_t *parsedValue = octaspire_dern_vm_parse(vm, input);

    ASSERT(parsedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, parsedValue->typeTag);
    ASSERT_EQ(true,                             parsedValue->value.boolean);

    ASSERT(octaspire_dern_vm_push_value(vm, parsedValue));

    octaspire_dern_value_t *evaluatedValue = octaspire_dern_vm_eval(vm, parsedValue, environment);

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    ASSERT(octaspire_dern_vm_push_value(vm, evaluatedValue));

    ASSERT_EQ(evaluatedValue, octaspire_dern_vm_peek_value(vm));
    octaspire_dern_vm_pop_value(vm, evaluatedValue);

    ASSERT_EQ(parsedValue, octaspire_dern_vm_peek_value(vm));
    octaspire_dern_vm_pop_value(vm, parsedValue);

    ASSERT_EQ(environment, octaspire_dern_vm_peek_value(vm));
    octaspire_dern_vm_pop_value(vm, environment);

    octaspire_dern_vm_release(vm);
    vm = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_vm_special_if_two_elements_false_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if false true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_if_two_elements_true_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if true |g|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("g", octaspire_dern_value_as_character_get_c_string(evaluatedValue)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    
    PASS();
}

TEST octaspire_dern_vm_special_if_three_elements_false_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if false |r| |g|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("g", octaspire_dern_value_as_character_get_c_string(evaluatedValue)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    
    PASS();
}

TEST octaspire_dern_vm_special_if_three_elements_true_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if true |r| |g|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("r", octaspire_dern_value_as_character_get_c_string(evaluatedValue)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    
    PASS();
}

TEST octaspire_dern_vm_special_if_three_elements_with_function_resulting_true_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if (fn () true) |r| |g|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("r", octaspire_dern_value_as_character_get_c_string(evaluatedValue)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_if_three_elements_with_function_call_resulting_true_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if ((fn () true)) |r| |g|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("r", octaspire_dern_value_as_character_get_c_string(evaluatedValue)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_if_called_with_one_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'if' expects two or three arguments. 1 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(if true)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_if_called_with_integer_as_the_first_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(if 10 true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "First argument to special 'if' must evaluate into boolean value. Now it evaluated "
        "into type integer.\n"
        "\tAt form: >>>>>>>>>>(if 10 true)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_one_true_selector_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select true [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_one_false_selector_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select false [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_one_default_selector_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select default [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_one_false_and_one_default_selectors_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select false [p] default [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_one_false_and_one_true_and_one_default_selectors_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select false [p] true [a] default [b])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_one_false_and_one_true_selectors_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select false [p] true [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_function_selectors_evaluating_into_false_and_true_to_string_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f1 [f1] '() (fn () false))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define t1 [t1] '() (fn () true))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select (f1) [p] (t1) [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_function_selectors_failure_on_unknown_symbol_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f1 [f1] '() (fn () false))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define t1 [t1] '() (fn () true))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select (f1) [p] (f2) [a])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Cannot evaluate operator of type 'error' (<error>: Unbound symbol 'f2')\n"
        "\tAt form: >>>>>>>>>>(select (f1) [p] (f2) [a])<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_called_with_zero_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'select' expects at least two arguments and the number of arguments must be "
        "multiple of two. Now 0 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(select)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_called_with_one_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'select' expects at least two arguments and the number of arguments must be "
        "multiple of two. Now 1 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(select true)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_called_with_three_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select true [a] default)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'select' expects at least two arguments and the number of arguments must be "
        "multiple of two. Now 3 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(select true [a] default)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_called_non_boolean_selector_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select 1 [a] 2 [b])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Selectors of special 'select' must evaluate into booleans. Type 'integer' was given.\n"
        "\tAt form: >>>>>>>>>>(select 1 [a] 2 [b])<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_select_called_with_default_as_first_selector_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(select default [a] 2 [b])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "'default' must be the last selector in special 'select'.\n"
        "\tAt form: >>>>>>>>>>(select default [a] 2 [b])<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_integer_value_test(void)
{
    octaspire_input_t *input = octaspire_input_new_from_c_string("(define x [test] 10)", octaspireDernVmTestAllocator);

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *parsedValue = octaspire_dern_vm_parse(vm, input);

    ASSERT(parsedValue);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_eval_in_global_environment(vm, parsedValue);

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "x");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(10,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    octaspire_input_release(input);
    input = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_integer_value_with_explicit_target_global_env_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define (env-global) x [test] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "x");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(10,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(doc x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("test", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_my_inc_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define my-inc [my own inc-function] '(value [the value to increase]) (fn (value) (++ value)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(doc my-inc)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "my own inc-function\n"
        "Arguments are:\n"
        "value -> the value to increase",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(my-inc 111)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(112,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_factorial_function_with_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define factorial [factorial function] '(n [calculate n!]) (fn (n) (if (== n 0) 1 (* n (factorial (- n 1))))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(doc factorial)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "factorial function\n"
        "Arguments are:\n"
        "n -> calculate n!",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    int32_t const expected[] = {1, 1, 2, 6, 24, 120, 720, 5040};

    char const * const input[] =
    {
        "(factorial 0)",
        "(factorial 1)",
        "(factorial 2)",
        "(factorial 3)",
        "(factorial 4)",
        "(factorial 5)",
        "(factorial 6)",
        "(factorial 7)",
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, input[i]);

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(expected[i],                      evaluatedValue->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_factorial_function_with_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define factorial [factorial function] '(n [calculate n!]) (fn (n) (if (<= n 0.0) 1.0 (* n (factorial (- n 1))))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(doc factorial)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "factorial function\n"
        "Arguments are:\n"
        "n -> calculate n!",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    double const expected[] = {1, 1, 2, 6, 24, 120, 720, 5040};

    char const * const input[] =
    {
        "(factorial 0.0)",
        "(factorial 1.0)",
        "(factorial 2.0)",
        "(factorial 3.0)",
        "(factorial 4.0)",
        "(factorial 5.0)",
        "(factorial 6.0)",
        "(factorial 7.0)",
    };

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, input[i]);

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
        ASSERT_IN_RANGE(expected[i],             evaluatedValue->value.real, 0.000001);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_two_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define' expects three, four, or five arguments. 2 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(define x 10)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_five_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define myEnv [myEnv] (env-new))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define myEnv f [f] '() (fn () 128))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Make sure f is NOT defined in global environment
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "f");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Unbound symbol 'f'",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    // Make sure f IS defined in myEnv-environment
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval f myEnv)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_FUNCTION, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval (f) myEnv)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(128,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_four_arguments_first_being_integer_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define 10 [x] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define': (define [optional-target-env] symbol...) name to be defined should be "
        "symbol or vector to be evaluated. Type 'integer' was given.\n"
        "\tAt form: >>>>>>>>>>(define 10 [x] 10)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_five_arguments_second_being_integer_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define myEnv [myEnv] (env-new))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define myEnv 10 [f] '() (fn () 128))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define': (define [optional-target-env] name...) Name must be symbol or vector to "
        "be evaluated. Type 'integer' was given.\n"
        "\tAt form: >>>>>>>>>>(define myEnv 10 [f] (quote ()) (fn () 128))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_three_arguments_error_at_last_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] (noSuchFuNcTion))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Cannot evaluate operator of type 'error' (<error>: Unbound symbol 'noSuchFuNcTion')\n"
        "\tAt form: >>>>>>>>>>(define x [x] (noSuchFuNcTion))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_three_arguments_docstring_integer_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x 10 20)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define': (define [optional-target-env] symbol docstring...) docstring must be "
        "string. Type 'integer' was given.\n"
        "\tAt form: >>>>>>>>>>(define x 10 20)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_three_arguments_name_evaluates_into_integer_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define ((fn () 10)) [x] 20)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define': (define [optional-target-env] symbol...) vector for name to be "
        "defined should evaluate into symbol. Type 'integer' was result of evaluation.\n"
        "\tAt form: >>>>>>>>>>(define ((fn () 10)) [x] 20)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_three_arguments_docstring_is_integer_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define ((fn () 'x)) 10 20)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define': (define [optional-target-env] symbol docstring...) docstring must be "
        "string. Type 'integer' was given.\n"
        "\tAt form: >>>>>>>>>>(define ((fn () (quote x))) 10 20)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_three_arguments_error_in_last_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define ((fn () 'x)) [x] (noSuchFuNcTion))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Cannot evaluate operator of type 'error' (<error>: Unbound symbol 'noSuchFuNcTion')\n"
        "\tAt form: >>>>>>>>>>(define ((fn () (quote x))) [x] (noSuchFuNcTion))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_three_arguments_trying_to_bind_a_function_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define ((fn () 'f)) [f] (fn () true))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "At definition of function 'f': functions cannot be defined with the three-argument "
        "function. Use four-argument function.\n"
        "\tAt form: >>>>>>>>>>(define ((fn () (quote f))) [f] (fn () true))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_four_arguments_integer_as_first_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define ((fn () 10)) [f] '() (fn () true))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define': (define [optional-target-env] name...) Vector for name must evaluate "
        "into symbol. Now it evaluated into type 'integer'.\n"
        "\tAt form: >>>>>>>>>>(define ((fn () 10)) [f] (quote ()) (fn () true))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_four_arguments_integer_as_docstring_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define ((fn () 'f)) 10 '() (fn () true))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define': (define [optional-target-env] name docstring...) docstring must be "
        "string. Type 'integer' was given.\n"
        "\tAt form: >>>>>>>>>>(define ((fn () (quote f))) 10 (quote ()) (fn () true))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_define_called_with_four_arguments_docstring_integer_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f 10 '() (fn () 20))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'define': (define [optional-target-env] name docstring...) docstring must be "
        "string. Type 'integer' was given.\n"
        "\tAt form: >>>>>>>>>>(define f 10 (quote ()) (fn () 20))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_quote_called_without_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(quote)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'quote' expects one argument. 0 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(quote)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_plus_integer_value_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(define x [test] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (int32_t i = 0; i < 100; ++i)
    {
        evaluatedValue =
            octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(++ x)");

        ASSERT(evaluatedValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(10 + 1 + i,                       evaluatedValue->value.integer);
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "x");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(110,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_doc_for_integer_value_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x-coordinate] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(doc x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "x-coordinate",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_read_and_eval_path_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    // TODO what about the path separator? Cross platform?
    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(read-and-eval-path [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_read_and_eval_path_test.dern])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(200,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_read_and_eval_string_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(read-and-eval-string [(++ 10)])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(11,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_1_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ 1)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(1, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_10_2_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ 10 2 2)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(2.5, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_0_2_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ 0 2 2)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(0, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_100_10_0dot5_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ 100 10 0.5)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(20, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_100_minus10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ 100 -10)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(-10, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin '/' expects at least one numeric argument (integer or real).\n"
        "\tAt form: >>>>>>>>>>(/)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_0_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ 0)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "First argument to builtin '/' cannot be zero. It would cause division by zero.\n"
        "\tAt form: >>>>>>>>>>(/ 0)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_10_2_0_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ 10 2 0)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Argument number 3 to builtin '/' cannot be zero. It would cause division by zero.\n"
        "\tAt form: >>>>>>>>>>(/ 10 2 0)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_slash_10_2_character_a_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(/ 10 2 |a|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin '/' expects numeric arguments (integer or real). 3th argument has type character.\n"
        "\tAt form: >>>>>>>>>>(/ 10 2 |a|)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_mod_5_mod_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(mod 5 3)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_mod_0_mod_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(mod 0 3)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_mod_3_mod_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(mod 3 3)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_mod_4_mod_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(mod 4 3)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_mod_4_mod_0_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(mod 4 0)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The second argument to builtin 'mod' cannot be zero. "
        "It would cause division by zero.\n"
        "\tAt form: >>>>>>>>>>(mod 4 0)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_1_2_3_4_minus_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ 1 2 3 4 -2)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(8,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_1_2_3_4_minus_2_2dot5_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ 1 2 3 4 -2 2.5)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_EQ(10.5,                          evaluatedValue->value.real);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_string_cat_dog_and_string_space_and_string_zebra_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ [cat, dog] [ ] [and zebra])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "cat, dog and zebra",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_string_ca_and_character_t_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ [ca] |t|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "cat",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_empty_string_and_characters_k_i_t_t_e_n_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+ [] |k| |i| |t| |t| |e| |n|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "kitten",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_string_cat_dog_cat_and_string_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(- [cat dog cat] [cat])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(" dog ", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_string_abcabcabc_and_character_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(- [abcabcabc] |a|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("bcbcbc", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_string_abcabcabc_and_character_a_and_character_b_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(- [abcabcabc] |a| |b|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("ccc", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_string_abcabcabc_and_character_a_and_character_b_and_caharacter_c_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(- [abcabcabc] |a| |b| |c|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_1_2_3_4_minus_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(- 1 2 3 4 -2)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(-6,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_1_2_3_4_minus_2_2dot5_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(- 1 2 3 4 -2 2.5)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_EQ(-8.5,                          evaluatedValue->value.real);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_abcdeaaba_character_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [abcdeaaba] |a|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 5, 6, 8};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_abcdeaaba_character_y_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [abcdeaaba] |y|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_string_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [cat dog cat zebra cat] [cat])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 8, 18};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_string_parrot_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [cat dog cat zebra cat] [parrot])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_quoted_symbol_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [cat dog cat zebra cat] 'cat)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 8, 18};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_quoted_symbol_parrot_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [cat dog cat zebra cat] 'parrot)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_123_124_abc_123_99_123_integer_123_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [123 124 abc 123 99 123] 123)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 12, 19};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_123_124_abc_123_99_123_integer_777_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [123 124 abc 123 99 123] 777)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_3dot14_abc_3dot13_3dot14_3dot146_3dot14_real_3dot14_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [3.14 abc 3.13 3.14 3.146 3.14] 3.14)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 14, 19, 25};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_string_3dot14_abc_3dot13_3dot14_3dot146_3dot14_real_7dot11_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find [3.14 abc 3.13 3.14 3.146 3.14] 7.11)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_abc_def_aaxa_char_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'abc_def_aaxa |a|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 8, 9, 11};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_abc_def_aaxa_char_y_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'abc_def_aaxa |y|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_string_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_dog_cat_cat_zebra_cat [cat])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 8, 12, 22};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_string_parrot_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_dog_cat_cat_zebra_cat [parrot])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_symbol_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_dog_cat_cat_zebra_cat 'cat)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 8, 12, 22};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_symbol_parrot_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_dog_cat_cat_zebra_cat 'parrot)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_123_dog_cat_123_123_cat_zebra_123_integer_123_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_123_dog_cat_123_123_cat_zebra_123 123)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {4, 16, 20, 34};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_321_dog_cat_321_321_cat_zebra_321_integer_123_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_321_dog_cat_321_321_cat_zebra_321 123)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_3dot14_dog_cat_3dot14_3dot14_cat_zebra_3dot14_real_3dot14_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_3.14_dog_cat_3.14_3.14_cat_zebra_3.14 3.14)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {4, 17, 22, 37};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_symbol_cat_3dot14_dog_cat_3dot14_3dot14_cat_zebra_3dot14_real_4dot14_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find 'cat_3.14_dog_cat_3.14_3.14_cat_zebra_3.14 4.14)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_vector_of_chars_a_b_c_a_a_g_u_a_char_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find '(|a| |b| |c| |a| |a| |g| |u| |a|) |a|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(4, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 3, 4, 7};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_vector_of_chars_a_b_c_a_a_g_u_a_char_x_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find '(|a| |b| |c| |a| |a| |g| |u| |a|) |x|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_vector_of_strings_cat_dog_cat_zebra_parrot_cat_string_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find '([cat] [dog] [cat] [zebra] [parrot] [cat]) [cat])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 2, 5};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_vector_of_strings_cat_dog_cat_zebra_parrot_cat_string_kitten_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find '([cat] [dog] [cat] [zebra] [parrot] [cat]) [kitten])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_vector_of_symbols_cat_dog_cat_zebra_parrot_cat_symbol_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find '(cat dog cat zebra parrot cat) 'cat)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    int32_t const expected[] = {0, 2, 5};

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t const * const value =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(value);

        ASSERT_EQ(expected[i], value->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_vector_of_symbols_cat_dog_cat_zebra_parrot_cat_symbol_mouse_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find '(cat dog cat zebra parrot cat) 'mouse)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_container_vector_get_length(evaluatedValue->value.vector));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_chars_a_b_c_d_char_c_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map |a| 1 |b| 2 |c| 3 |d| 4) |c|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_chars_a_b_c_d_char_x_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map |a| 1 |b| 2 |c| 3 |d| 4) |x|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_chars_a_b_c_d_char_b_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map |a| true |b| false |c| nil |d| 4) |b|)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_strings_cat_dog_zebra_kitten_string_zebra_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map [cat] |a| [dog] |b| [zebra] |c| [kitten] |d|) [zebra])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("c", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_strings_cat_dog_zebra_kitten_string_parrot_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map [cat] |a| [dog] |b| [zebra] |c| [kitten] |d|) [parrot])");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_integers_1_2_3_4_integer_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map 1 [cat] 2 [dog] 3 [zebra] 4 [kitten]) 2)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("dog", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_integers_1_2_3_4_integer_5_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map 1 [cat] 2 [dog] 3 [zebra] 4 [kitten]) 5)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_reals_2dot1_2dot2_2dot3_2dot4_real_2dot2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map 2.1 1   2.2 2   2.3 3   2.4 4) 2.2)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_hash_map_of_reals_2dot1_2dot2_2dot3_2dot4_real_2dot5_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (hash-map 2.1 1   2.2 2   2.3 3   2.4 4) 2.5)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_global_environment_symbol_find_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (env-global) 'find)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BUILTIN, evaluatedValue->typeTag);
    ASSERT_EQ(octaspire_dern_vm_builtin_find,   evaluatedValue->value.builtin->cFunction);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_global_environment_defined_symbol_xyz_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define xyz [xyz] '(1 2 3))");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (env-global) 'xyz)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (int32_t i = 0; i < 3; ++i)
    {
        octaspire_dern_value_t const * const tmp =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(tmp);
        ASSERT_EQ(i + 1, tmp->value.integer);
    }


    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_find_from_global_environment_symbol_notfound_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(find (env-global) 'notfound)");

    ASSERT(evaluatedValue);

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_while_with_one_value_to_repeat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define i [i] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(while (<= i 100) (++ i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(101,                              evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "i");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(101,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_while_with_two_values_to_repeat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define i [i] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define j [j] 1000)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(while (<= i 100) (++ i) (-- j))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(101,                              evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "i");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(101,                              evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "j");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(899,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_while_called_with_one_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(while true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'while' expects at least two arguments. 1 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(while true)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_while_called_with_integer_as_first_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(while 1 (++ x))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "First argument to special 'while' must evaluate into boolean value. Now it evaluated "
        "into type integer.\n"
        "\tAt form: >>>>>>>>>>(while 1 (++ x))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_hash_map_empty_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(hash-map)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(0, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_hash_map_one_element_symbol_one_1_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(hash-map 'one 1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_container_hash_map_element_t *element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 0);

    ASSERT(element);

    evaluatedValue = octaspire_container_hash_map_element_get_key(element);
    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);
    ASSERT_STR_EQ("one", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue = octaspire_container_hash_map_element_get_value(element);
    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1, evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_hash_map_one_element_1_symbol_one_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(hash-map 1 'one)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_container_hash_map_element_t *element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 0);

    ASSERT(element);

    evaluatedValue = octaspire_container_hash_map_element_get_key(element);
    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1, evaluatedValue->value.integer);

    evaluatedValue = octaspire_container_hash_map_element_get_value(element);
    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);
    ASSERT_STR_EQ("one", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_hash_map_two_elements_strings_dog_barks_and_sun_shines_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(hash-map [dog] [barks] [sun] [shines])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(2, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    ASSERT(octaspire_dern_vm_push_value(vm, evaluatedValue));

    char const * const keys[] =
    {
        "dog",
        "sun"
    };

    char const * const expected[] =
    {
        "barks",
        "shines"
    };

    ASSERT_EQ(sizeof(keys) / sizeof(keys[0]), sizeof(expected) / sizeof(expected[0]));

    for (size_t i = 0; i < (sizeof(expected) / sizeof(expected[0])); ++i)
    {
        octaspire_dern_value_t *keyValue = octaspire_dern_vm_create_new_value_string_from_c_string(
            vm,
            keys[i]);

        ASSERT(keyValue);

        octaspire_container_hash_map_element_t *element = octaspire_dern_value_as_hash_map_get(
            evaluatedValue,
            octaspire_dern_value_get_hash(keyValue),
            keyValue);

        ASSERT(element);

        octaspire_dern_value_t *valueValue = octaspire_container_hash_map_element_get_value(element);
        ASSERT(valueValue);
        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, valueValue->typeTag);
        ASSERT_STR_EQ(expected[i], octaspire_container_utf8_string_get_c_string(valueValue->value.string));
    }

    ASSERT(octaspire_dern_vm_pop_value(vm, evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_characters_t_bar_newline_tab_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[ca|t||bar|dog and parrot |newline||tab| 123]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "cat|dog and parrot \n\t 123",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_characters_c_a_t__a_n_d__d_o_g_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|c||a||t|| ||a||n||d|| ||d||o||g|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "cat and dog",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_newline_failure_on_missing_end_delimiter_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|newline]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Problem with a character embedded in string: (character is not complete)",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_yy_failure_on_unknown_char_constant_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|yy|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Problem with a character embedded in string: (Unknown character constant |yy|)",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_in_hex_A9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|A9|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "¬©",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_in_hex_a9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|a9|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "¬©",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|a|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "a",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_in_hex_0x10000_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|10000|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "êÄÄ",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_literal_with_embedded_character_in_hex_failure_on_too_many_hex_digits_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "[|123456789|]");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR,   evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Problem with a character embedded in string: (Number of hex digits (9) in character definition may not be larger than eight)",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_empty_vector_of_strings_and_integer_10_and_string_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v [v] '())");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "v");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(0,                               octaspire_dern_value_as_vector_get_length(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= v 10 [cat])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(11,                              octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(evaluatedValue); ++i)
    {
        octaspire_dern_value_t const * const element =
            octaspire_dern_value_as_vector_get_element_at_const(
                evaluatedValue,
                i);

        ASSERT(element);

        if (octaspire_dern_value_as_vector_is_valid_index(evaluatedValue, i + 1))
        {
            ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, element->typeTag);
        }
        else
        {
            ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, element->typeTag);

            ASSERT_STR_EQ(
                "cat",
                octaspire_container_utf8_string_get_c_string(element->value.string));
        }
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_vector_of_strings_and_integer_1_and_string_cat_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v [v] '([first] [second] [third]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "v");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3,                               octaspire_dern_value_as_vector_get_length(evaluatedValue));

    octaspire_dern_value_t const *vecElemVal =
        octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 0);

    ASSERT(vecElemVal);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, vecElemVal->typeTag);
    ASSERT_STR_EQ("first", octaspire_dern_value_as_string_get_c_string(vecElemVal));

    vecElemVal = octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 1);
    ASSERT(vecElemVal);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, vecElemVal->typeTag);
    ASSERT_STR_EQ("second", octaspire_dern_value_as_string_get_c_string(vecElemVal));

    vecElemVal = octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 2);
    ASSERT(vecElemVal);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, vecElemVal->typeTag);
    ASSERT_STR_EQ("third", octaspire_dern_value_as_string_get_c_string(vecElemVal));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= v 1 [cat])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(3,                               octaspire_dern_value_as_vector_get_length(evaluatedValue));

    vecElemVal = octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 0);
    ASSERT(vecElemVal);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, vecElemVal->typeTag);
    ASSERT_STR_EQ("first", octaspire_dern_value_as_string_get_c_string(vecElemVal));

    vecElemVal = octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 1);
    ASSERT(vecElemVal);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, vecElemVal->typeTag);
    ASSERT_STR_EQ("cat", octaspire_dern_value_as_string_get_c_string(vecElemVal));

    vecElemVal = octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 2);
    ASSERT(vecElemVal);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, vecElemVal->typeTag);
    ASSERT_STR_EQ("third", octaspire_dern_value_as_string_get_c_string(vecElemVal));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_hash_map_and_same_key_inserted_multiple_times_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define target [target] (hash-map |a| 1))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    // First addition
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= target |a| 2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "target");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    octaspire_container_hash_map_t * hashMap = evaluatedValue->value.hashMap;

    ASSERT_EQ(1, octaspire_container_hash_map_get_number_of_elements(hashMap));

    octaspire_container_hash_map_element_t *element =
        octaspire_container_hash_map_get_at_index(hashMap, 0);

    ASSERT(element);

    octaspire_dern_value_t *key = octaspire_container_hash_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, key->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(key->value.string));

    octaspire_dern_value_t *value = octaspire_container_hash_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, value->typeTag);
    ASSERT_EQ(2,                                 value->value.integer);



    // Second addition
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= target |a| 3)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "target");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    hashMap = evaluatedValue->value.hashMap;

    ASSERT_EQ(1, octaspire_container_hash_map_get_number_of_elements(hashMap));

    element =
        octaspire_container_hash_map_get_at_index(hashMap, 0);

    ASSERT(element);

    key = octaspire_container_hash_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, key->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(key->value.string));

    value = octaspire_container_hash_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, value->typeTag);
    ASSERT_EQ(3,                                 value->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_hash_map_and_hash_map_with_elements_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define target [target] (hash-map))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define source [source] (hash-map 1 |a| 2 |b|))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= target source)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "target");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    octaspire_container_hash_map_t * const hashMap = evaluatedValue->value.hashMap;

    ASSERT_EQ(2, octaspire_container_hash_map_get_number_of_elements(hashMap));

    octaspire_container_hash_map_element_t *element =
        octaspire_container_hash_map_get_at_index(hashMap, 1);

    ASSERT(element);

    octaspire_dern_value_t *key = octaspire_container_hash_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, key->typeTag);
    ASSERT_EQ(1,                                key->value.integer);

    octaspire_dern_value_t *value = octaspire_container_hash_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(value->value.character));

    element =
        octaspire_container_hash_map_get_at_index(hashMap, 0);

    ASSERT(element);

    key = octaspire_container_hash_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, key->typeTag);
    ASSERT_EQ(2,                                key->value.integer);

    value = octaspire_container_hash_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("b", octaspire_container_utf8_string_get_c_string(value->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_hash_map_and_empty_hash_map_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define target [target] (hash-map 1 |a|))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define source [source] (hash-map))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= target source)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "target");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);

    octaspire_container_hash_map_t * const hashMap = evaluatedValue->value.hashMap;

    ASSERT_EQ(0, octaspire_container_hash_map_get_number_of_elements(hashMap));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_vector_and_vector_with_elements_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define target [target] '())");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define source [source] '(1 |a|))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= target source)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "target");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    ASSERT_EQ(2, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    octaspire_dern_value_t const * value =
        octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 0);

    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, value->typeTag);
    ASSERT_EQ(1,                                value->value.integer);

    value =
        octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 1);

    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(value->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_vector_and_empty_vector_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define target [target] '(1 2 3))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define source [source] '())");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= target source)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "target");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    ASSERT_EQ(0, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_with_string_and_index_and_character_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [s] [Pong])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= s 1 |√∂|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("P√∂ng", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("P√∂ng", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_character_x_and_integer_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define c [c] |x|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= c 2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("v", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_character_x_and_character_exclamation_mark_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define c [c] |x|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= c |!|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);
    ASSERT_STR_EQ("W", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_real_3_dot_14_and_reals_1_dot_0_and_zero_dot_14_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define r [r] 3.14)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= r 1.0 0.14)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_REAL, evaluatedValue->typeTag);
    ASSERT_IN_RANGE(2.0, evaluatedValue->value.real, 0.000001);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_integer_10_and_integers_1_and_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define i [i] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= i 1 2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(7, evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_vector_1_1_2_2_2_3_and_values_1_and_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v [v] '(1 1 2 2 2 3))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= v 1 2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    octaspire_dern_value_t const * const value = octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, 0);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER,  value->typeTag);
    ASSERT_EQ(3,                                 value->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_string_abcd_and_characters_a_and_b_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [s] [abcd])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= s |a| |b|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("cd", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_minus_equals_with_hash_map_1_a_2_b_3_c_and_value_1_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h [h] (hash-map 1 |a| 2 |b| 3 |c|))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(-= h 2 3)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_container_hash_map_element_t const * const element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 0);

    ASSERT(element);

    octaspire_dern_value_t const * const key = octaspire_container_hash_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER,  key->typeTag);
    ASSERT_EQ(1,                                 key->value.integer);

    octaspire_dern_value_t const * const value = octaspire_container_hash_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(value->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_hash_map_and_hash_map_1_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h [h] (hash-map))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= h (hash-map 1 |a|))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_container_hash_map_element_t const * const element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 0);

    ASSERT(element);

    octaspire_dern_value_t const * const key = octaspire_container_hash_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER,  key->typeTag);
    ASSERT_EQ(1,                                 key->value.integer);

    octaspire_dern_value_t const * const value = octaspire_container_hash_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(value->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_hash_map_and_1_a_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h [h] (hash-map))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= h 1 |a|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(1, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_container_hash_map_element_t const * const element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 0);

    ASSERT(element);

    octaspire_dern_value_t const * const key = octaspire_container_hash_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER,  key->typeTag);
    ASSERT_EQ(1,                                 key->value.integer);

    octaspire_dern_value_t const * const value = octaspire_container_hash_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(value->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_hash_map_and_list_1_a_2_b_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h [h] (hash-map))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= h '(1 |a| 2 |b|))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_HASH_MAP, evaluatedValue->typeTag);
    ASSERT_EQ(2, octaspire_dern_value_as_hash_map_get_number_of_elements(evaluatedValue));

    octaspire_container_hash_map_element_t const * element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 1);

    ASSERT(element);

    octaspire_dern_value_t const * key = octaspire_container_hash_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER,  key->typeTag);
    ASSERT_EQ(1,                                 key->value.integer);

    octaspire_dern_value_t const * value = octaspire_container_hash_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(value->value.character));

    element =
        octaspire_dern_value_as_hash_map_get_at_index(evaluatedValue, 0);

    ASSERT(element);

    key = octaspire_container_hash_map_element_get_key(element);
    ASSERT(key);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER,  key->typeTag);
    ASSERT_EQ(2,                                 key->value.integer);

    value = octaspire_container_hash_map_element_get_value(element);
    ASSERT(value);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, value->typeTag);
    ASSERT_STR_EQ("b", octaspire_container_utf8_string_get_c_string(value->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_vector_1_2_3_and_4_5_6_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v [v] '(1 2 3))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= v 4 5 6)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(6,                               octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(evaluatedValue); ++i)
    {
        octaspire_dern_value_t const * const element =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT   (element);
        ASSERT_EQ((int32_t)(i+1), element->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_string_def_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target string] [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s [def])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abcdef";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_symbol_def_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target string] [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s 'def)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abcdef";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_character_d_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target string] [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s |d|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abcd";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_vector_of_strings_def_ghi_jkl_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target string] [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s '([def] [ghi] [jkl]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abcdefghijkl";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_nil_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target string] [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s nil)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abcnil";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_booleans_true_and_false_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target string] [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s true false)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abctruefalse";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_integer_128_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target string] [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s 128)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abc128";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_real_3dot14_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target string] [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s 3.14)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    char const * const expected = "abc3.14";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}





TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_string_def_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target symbol] 'abc)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s [def])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abcdef";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_symbol_def_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target symbol] 'abc)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s 'def)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abcdef";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_character_d_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target symbol] 'abc)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s |d|)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abcd";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_vector_of_strings_def_ghi_jkl_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target symbol] 'abc)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s '([def] [ghi] [jkl]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abcdefghijkl";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_nil_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target symbol] 'abc)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s nil)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abcnil";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_booleans_true_and_false_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target symbol] 'abc)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s true false)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abctruefalse";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_integer_128_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target symbol] 'abc)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s 128)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abc128";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_real_3dot14_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [target symbol] 'abc)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN,  evaluatedValue->typeTag);
    ASSERT_EQ(true,                              evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= s 3.14)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    char const * const expected = "abc3.14";

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_SYMBOL, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        expected,
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.symbol));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}










TEST octaspire_dern_vm_builtin_plus_equals_with_bad_input_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(+= (hash-map 1 ¬¶a|) (hash-map 2 |b|))");
    // bad input here      ^^^

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR,  evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Unknown character constant |) (hash-map 2 |",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_run_user_factorial_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_path_and_eval_in_global_environment(
            vm,
            OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_dern_vm_run_user_factorial_function_test.dern");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(101,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_from_0_to_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v [v] '())");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i from 0 to 10 (+= v i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(11,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "v");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(11, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (int32_t i = 0; i < 11; ++i)
    {
        octaspire_dern_value_t const * const tmp =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(tmp);
        ASSERT_EQ(i, tmp->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_from_0_to_10_with_step_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v [v] '())");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i from 0 to 10 step 2 (+= v i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(6,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "v");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(6, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (int32_t i = 0, cmp = 0; i < 6; ++i, cmp += 2)
    {
        octaspire_dern_value_t const * const tmp =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(tmp);
        ASSERT_EQ(cmp, tmp->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_from_0_to_10_with_step_minus_2_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v [v] '())");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i from 0 to 10 step -2 (+= v i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The 'step' of special 'for' must be larger than zero. Now it is -2.\n"
        "\tAt form: >>>>>>>>>>(for i from 0 to 10 step -2 (+= v i))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_from_10_to_0_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v [v] '())");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i from 10 to 0 (+= v i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(11,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "v");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(11, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (int32_t i = 0; i < 11; ++i)
    {
        octaspire_dern_value_t const * const tmp =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(tmp);
        ASSERT_EQ(10 - i, tmp->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_from_10_to_0_with_step_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v [v] '())");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i from 10 to 0 step 2 (+= v i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(6,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "v");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);
    ASSERT_EQ(6, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    for (int32_t i = 0, cmp = 0; i < 6; ++i, cmp += 2)
    {
        octaspire_dern_value_t const * const tmp =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                evaluatedValue,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                i);

        ASSERT(tmp);
        ASSERT_EQ(10 - cmp, tmp->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_from_10_to_0_with_step_minus_2_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define v [v] '())");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i from 10 to 0 step -2 (+= v i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The 'step' of special 'for' must be larger than zero. Now it is -2.\n"
        "\tAt form: >>>>>>>>>>(for i from 10 to 0 step -2 (+= v i))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}


TEST octaspire_dern_vm_special_for_in_with_string_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [s] [])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define n [n] [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in n (+= s i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "abc",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_string_step_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [s] [])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define n [n] [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in n step 2 (+= s i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "ac",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_string_step_minus_2_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [s] [])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define n [n] [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in n step -2 (+= s i))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The 'step' of special 'for' must be larger than zero. Now it is -2.\n"
        "\tAt form: >>>>>>>>>>(for i in n step -2 (+= s i))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_vector_of_strings_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [s] [])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define n [n] '([John] [Mike] [Ellie]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in n (+= s i [ ]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "John Mike Ellie ",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_vector_of_strings_step_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [s] [])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define n [n] '([John] [Mike] [Ellie]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in n step 2 (+= s i [ ]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "John Ellie ",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_vector_of_strings_step_minus_2_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [s] [])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define n [n] '([John] [Mike] [Ellie]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in n step -2 (+= s i [ ]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "The 'step' of special 'for' must be larger than zero. Now it is -2.\n"
        "\tAt form: >>>>>>>>>>(for i in n step -2 (+= s i [ ]))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_environment_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e [e] (env-new))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 [e2] (env-new))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    // a is 1
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e a [a] 1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // b is 2
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e b [b] 2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // c is 3
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e c [c] 3)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in e (define e2 (nth 0 i) [-] (nth 1 i)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string e2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "---------- environment ----------\n"
        "a -> 1\n"
        "b -> 2\n"
        "c -> 3\n"
        "---------------------------------\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_environment_step_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e [e] (env-new))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 [e2] (env-new))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    // a is 1
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e a [a] 1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // b is 2
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e b [b] 2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // c is 3
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e c [c] 3)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in e step 2 (define e2 (nth 0 i) [-] (nth 1 i)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    // octaspire_container_hash_map_t is not ordered map, so we cannot know for sure which
    // two values are the first ones in the map.

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_environment_step_minus_2_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e [e] (env-new))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e2 [e2] (env-new))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    // a is 1
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e a [a] 1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // b is 2
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e b [b] 2)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // c is 3
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e c [c] 3)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in e step -2 (define e2 (nth 0 i) [-] (nth 1 i)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "The 'step' of special 'for' must be larger than zero. Now it is -2.\n"
        "\tAt form: >>>>>>>>>>(for i in e step -2 (define e2 (nth 0 i) [-] (nth 1 i)))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_hash_map_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h [h] (hash-map 'a 1 'b 2 'c 3))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e [e] (env-new))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in h (define e (nth 0 i) [-] (nth 1 i)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string e)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "---------- environment ----------\n"
        "a -> 1\n"
        "b -> 2\n"
        "c -> 3\n"
        "---------------------------------\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_hash_map_step_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h [h] (hash-map 'a 1 'b 2 'c 3))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e [e] (env-new))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in h step 2 (define e (nth 0 i) [-] (nth 1 i)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    // octaspire_container_hash_map_t is not ordered map, so we cannot know for sure which
    // two values are the first ones in the map.

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_in_with_hash_map_step_minus_2_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define h [h] (hash-map 'a 1 'b 2 'c 3))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define e [e] (env-new))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i in h step -2 (define e (nth 0 i) [-] (nth 1 i)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The 'step' of special 'for' must be larger than zero. Now it is -2.\n"
        "\tAt form: >>>>>>>>>>(for i in h step -2 (define e (nth 0 i) [-] (nth 1 i)))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_called_without_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'for' expects at least four (for iterating container or port) or five (for "
        "iterating numeric range) arguments. 0 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(for)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_called_with_one_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'for' expects at least four (for iterating container or port) or five (for "
        "iterating numeric range) arguments. 1 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(for i)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_second_argument_not_symbol_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for i 10 0 to 20 true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Second argument to special 'for' must be symbol 'in' or 'from'. Now it has type integer.\n"
        "\tAt form: >>>>>>>>>>(for i 10 0 to 20 true)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_for_called_with_integer_as_first_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(for 1 from 0 to 10 true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "First argument to special 'for' must be symbol value. Now it has type integer.\n"
        "\tAt form: >>>>>>>>>>(for 1 from 0 to 10 true)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error)); 

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_error_in_function_body_is_reported_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '(x [x]) (fn (x) (NoSuchFunction x)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f 1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    // TODO type of 'error' or 'vector'?
    ASSERT_STR_EQ(
        "Cannot evaluate operator of type 'error' (<error>: Unbound symbol 'NoSuchFunction')\n"
        "\tAt form: >>>>>>>>>>(f 1)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_nth_called_with_0_and_string_abc_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nth 0 [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "a",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_nth_called_with_1_and_string_abc_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nth 1 [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "b",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_nth_called_with_2_and_string_abc_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nth 2 [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "c",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_nth_called_with_3_and_string_abc_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nth 3 [abc])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'nth' cannot index string of length 3 from index 3.\n"
        "\tAt form: >>>>>>>>>>(nth 3 [abc])<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_nth_called_with_0_and_vector_1_2_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nth 0 '(1 2 3))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_nth_called_with_1_and_vector_1_2_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nth 1 '(1 2 3))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_nth_called_with_2_and_vector_1_2_3_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nth 2 '(1 2 3))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_nth_called_with_3_and_vector_1_2_3_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nth 3 '(1 2 3))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'nth' cannot index vector of length 3 from index 3.\n"
        "\tAt form: >>>>>>>>>>(nth 3 (quote (1 2 3)))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_nth_called_with_0_and_hash_map_1a_2b_3c_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nth 0 (hash-map 1 |a| 2 |b| 3 |c|))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "b",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_nth_called_with_1_and_hash_map_1a_2b_3c_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nth 1 (hash-map 1 |a| 2 |b| 3 |c|))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "c",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_nth_called_with_2_and_hash_map_1a_2b_3c_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nth 2 (hash-map 1 |a| 2 |b| 3 |c|))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_CHARACTER, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "a",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.character));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_nth_called_with_3_and_hash_map_1a_2b_3c_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nth 3 (hash-map 1 |a| 2 |b| 3 |c|))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'nth' cannot index hash map of length 3 from index 3.\n"
        "\tAt form: >>>>>>>>>>(nth 3 (hash-map 1 |a| 2 |b| 3 |c|))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_changing_atom_doesnt_change_another_defined_from_it_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define original [original] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define copied [copied] original)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(= original 999)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(999,                              evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "copied");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(10,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_in_special_do_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter [counter] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '() (fn () (do (++ counter) (return 99) (++ counter))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_do_error_stops_evaluation_and_is_reported_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter [counter] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(do (++ counter))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(do (++ counter) (NoSuchFunction) (++ counter))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Cannot evaluate operator of type 'error' (<error>: Unbound symbol 'NoSuchFunction')\n"
        "\tAt form: >>>>>>>>>>(NoSuchFunction)<<<<<<<<<<\n\n"
        "\tAt form: >>>>>>>>>>(do (++ counter) (NoSuchFunction) (++ counter))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(2,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter [counter] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '() (fn () (++ counter) (return 99) (++ counter)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_in_special_for_with_numeric_range_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter [counter] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '() (fn () (for i from 0 to 10 (++ counter) (if (== i 5) (return 99)))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(6,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_in_special_for_with_collection_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter [counter] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '() (fn () (for i in '(1 2 3 4 5 6) (+= counter i) (if (== i 4) (return 99)))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(10,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_in_special_for_with_string_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter [counter] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '() (fn () (for i in [abcdef] (+= counter 1) (if (== i |d|) (return 99)))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(4,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_in_special_for_with_environment_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter [counter] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '() (fn () (define a [a] 1) (define b [b] 2) (define c [c] 3) (for i in (env-current) (+= counter 1) (if (== counter 1) (return 99)))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_in_special_for_with_hash_map_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter [counter] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '() (fn () (for i in (hash-map |a| 1 |b| 2 |c| 3) (+= counter 1) (if (== counter 1) (return 99)))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

// TODO XXX add new test that is similar to above, but uses (for i in container ...
// TODO XXX other loops and other functions need to handle return?

TEST octaspire_dern_vm_builtin_return_in_special_while_inside_function_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter [counter] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '() (fn () (while (< counter 100) (++ counter) (return 99))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(99,                               evaluatedValue->value.integer);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_called_without_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter [counter] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '() (fn () (while (< counter 100) (++ counter) (return))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_NIL, evaluatedValue->typeTag);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_return_called_with_two_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define counter [counter] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '() (fn () (while (< counter 100) (++ counter) (return 1 2))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'return' expects zero or one arguments. 2 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(return 1 2)<<<<<<<<<<\n"
        "\n"
        "\tAt form: >>>>>>>>>>(while (< counter 100) (++ counter) (return 1 2))<<<<<<<<<<\n"
        "\n"
        "\tAt form: >>>>>>>>>>(f)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "counter");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(1,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_function_taking_one_regular_and_varargs_called_with_four_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '(x [x] y [rest of the args] ... [varargs]) (fn (x y ...)\n"
            "(define result [result] [])\n"
            "(+= result (string-format x)) (+= result (string-format y))\n"
            "result))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f 1 2 3 4)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "1(2 3 4)",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_function_taking_one_regular_and_varargs_called_with_one_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '(x [x] y [rest of the args] ... [varargs]) (fn (x y ...)\n"
            "(define result [result] [])\n"
            "(+= result (string-format x)) (+= result (string-format y))\n"
            "result))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f 1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "1()",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_function_taking_one_regular_and_varargs_called_with_zero_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '(x [x] y [rest of the args] ... [varargs]) (fn (x y ...)\n"
            "(define result [result] [])\n"
            "(+= result (string-format x)) (+= result (string-format y))\n"
            "result))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Function expects 1 arguments. Now 0 arguments were given.",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_newly_created_function_returned_from_another_function_and_used_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define creator [creator] '() (fn () (fn (val) (+ 11 val))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "((creator) 7)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(18,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_recursive_function_used_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a [a] '(x [x]) (fn (x) (if (< x 10) (a (+ x 1)) x)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(a 1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(10,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_mutually_recursive_functions_used_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define a [a] '(val [val]) (fn (val) (b (+ val 1))))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define b [b] '(x [x]) (fn (x) (if (< x 10) (a x) x)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(b 1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(10,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_and_called_without_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(and)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_or_called_without_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(or)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_not_called_without_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(not)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Builtin 'not' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(not)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_and_called_with_one_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(and x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(9,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_or_called_with_one_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(and x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(9,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_and_called_with_one_false_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] false)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(and x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_or_called_with_one_false_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] false)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(or x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_not_called_with_one_false_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] false)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(not x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_not_called_with_one_true_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(not x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_not_called_with_one_integer_argument_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(not x)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'not' expects boolean argument.\n"
        "\tAt form: >>>>>>>>>>(not x)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_not_called_with_two_boolean_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] false)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define y [y] true)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(vm, "(not x y)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'not' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(not x y)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_and_called_with_three_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [s] [])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '(x [x]) (fn (x) (+= s x) x))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(and (f [a]) (f [b]) (f [c]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("c", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("abc", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_or_called_with_three_arguments_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [s] [])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '(x [x]) (fn (x) (+= s x) (if (== x [c]) x false)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(or (f [a]) (f [b]) (f [c]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("c", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("abc", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_and_called_with_three_arguments_with_false_as_second_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [s] [])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '(x [x]) (fn (x) (+= s x) x))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(and (f [a]) false (f [c]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_or_called_with_three_arguments_with_true_as_second_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define s [s] [])");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '(x [x]) (fn (x) (+= s x) false))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(or (f [a]) true (f [c]))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "s");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("a", octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_called_with_two_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10.02)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> x 10.01)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_called_with_two_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> x 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_called_with_integer_10_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> x 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_called_with_integer_9_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> x 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_called_with_real_9dot9_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_called_with_real_10dot1_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10.1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(> x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}






TEST octaspire_dern_vm_special_greater_than_or_equal_called_with_two_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10.02)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x 10.01)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x 10.02)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x 10.03)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_or_equal_called_with_two_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x 11)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_or_equal_called_with_integer_10_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_or_equal_called_with_integer_9_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_or_equal_called_with_real_9dot9_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_greater_than_or_equal_called_with_real_10dot1_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10.1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(>= x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

















TEST octaspire_dern_vm_special_less_than_called_with_two_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10.01)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< x 10.02)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_called_with_two_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_called_with_integer_9_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< x 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_called_with_integer_10_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< x 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_called_with_real_10dot1_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10.1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_called_with_real_9dot9_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(< x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}












TEST octaspire_dern_vm_special_less_than_or_equal_called_with_two_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10.01)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x 10.02)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x 10.01)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x 10.0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_or_equal_called_with_two_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x 8)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_or_equal_called_with_integer_9_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_or_equal_called_with_integer_10_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_or_equal_called_with_real_10dot1_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10.1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_less_than_or_equal_called_with_real_9dot9_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<= x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}






TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10.01)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x 10.01)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x 10.02)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_two_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_buildin_equals_equals_called_with_integer_9_and_reals_9dot1_and_9dot0_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x 9.1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x 9.0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals__called_with_integer_10_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_real_10dot1_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10.1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_equals_equals_called_with_real_9dot9_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(== x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}







TEST octaspire_dern_vm_builtin_exclamation_equals_called_with_two_reals_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10.01)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x 10.02)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x 10.01)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_exclamation_equals_called_with_two_integers_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_buildin_exclamation_equals_called_with_integer_9_and_reals_9dot1_and_9dot0_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x 9.1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x 9.0)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_exclamation_equals_called_with_integer_10_and_real_9dot9_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_exclamation_equals_called_with_real_10dot1_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 10.1)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_builtin_exclamation_equals_called_with_real_9dot9_and_integer_10_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define x [x] 9.9)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(!= x 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_error_during_user_function_call_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [my function] '() (fn () (NoSuchFunction)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Cannot evaluate operator of type 'error' (<error>: Unbound symbol 'NoSuchFunction')\n"
        "\tAt form: >>>>>>>>>>(f)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_error_during_builtin_call_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(++)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Builtin '++' expects at least one argument.\n"
        "\tAt form: >>>>>>>>>>(++)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_error_during_special_call_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(<)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Special '<' expects at least two arguments.\n"
        "\tAt form: >>>>>>>>>>(<)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_error_during_special_call_during_user_function_call_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] '() (fn () (<)))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Special '<' expects at least two arguments.\n"
        "\tAt form: >>>>>>>>>>(<)<<<<<<<<<<\n"
        "\n"
        "\tAt form: >>>>>>>>>>(f)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_plus_1_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval (+ 1 2))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_plus_1_2_in_given_global_env_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval (+ 1 2) (env-global))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                                evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_value_from_given_local_env_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define myEnv [myEnv] (env-new))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define myEnv myVal [myVal] 128)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval myVal myEnv)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(128,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_eval_eval_f_1_2_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define myFn [myFn] +)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval ((eval myFn) 1 2))");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(3,                              evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_failure_on_integer_on_second_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval (+ 1 1) 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Second argument to special 'eval' must evaluate into environment value.\n"
        "Now it evaluated into type integer.\n"
        "\tAt form: >>>>>>>>>>(eval (+ 1 1) 10)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_failure_on_unbound_symbol_on_second_argument_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval (+ 1 1) pi)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Unbound symbol 'pi'\n"
        "\tAt form: >>>>>>>>>>(eval (+ 1 1) pi)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_special_eval_called_with_three_arguments_failure_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(eval (+ 1 1) (env-global) 10)");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Special 'eval' expects one or two arguments. 3 arguments were given.\n"
        "\tAt form: >>>>>>>>>>(eval (+ 1 1) (env-global) 10)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_create_new_value_copy_called_with_vector_value_of_int_values_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t * const originalVal = octaspire_dern_vm_create_new_value_vector(vm);

    octaspire_dern_vm_push_value(vm, originalVal);

    for (int32_t i = 0; i < 10; ++i)
    {
        octaspire_dern_value_t *tmpVal = octaspire_dern_vm_create_new_value_integer(vm, i);

        ASSERT(octaspire_dern_value_as_vector_push_back_element(originalVal, &tmpVal));
    }

    octaspire_dern_value_t * const copiedVal =
        octaspire_dern_vm_create_new_value_copy(vm, originalVal);

    octaspire_dern_vm_push_value(vm, copiedVal);

    ASSERT(copiedVal);
    ASSERT(originalVal != copiedVal);

    ASSERT_EQ(
        octaspire_dern_value_as_vector_get_length(originalVal),
        octaspire_dern_value_as_vector_get_length(copiedVal));

    for (size_t i = 0; i < octaspire_dern_value_as_vector_get_length(copiedVal); ++i)
    {
        octaspire_dern_value_t const * const original =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                originalVal,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                0);

        octaspire_dern_value_t const * const copied =
            octaspire_dern_value_as_vector_get_element_of_type_at_const(
                copiedVal,
                OCTASPIRE_DERN_VALUE_TAG_INTEGER,
                0);

        ASSERT(original && copied);
        ASSERT(original != copied);
        ASSERT_EQ(original->value.integer, copied->value.integer);
    }

    octaspire_dern_vm_pop_value(vm, copiedVal);
    octaspire_dern_vm_pop_value(vm, originalVal);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_multiline_comment_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "#!/bin/octaspire-dern-repl\n!#");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_MULTILINE_COMMENT, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "/bin/octaspire-dern-repl\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.comment));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_multiline_comment_missing_chars_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "#!/bin/octaspire-dern-repl\n!");

    ASSERT_EQ(0, evaluatedValue);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "#!/bin/octaspire-dern-repl\n");

    ASSERT_EQ(0, evaluatedValue);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_io_file_open_failure_because_file_system_access_is_denied_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Builtin 'io-file-open' cannot be executed; file system access is denied by VM. "
        "Enable file system access in VM before trying to run this code.\n"
        "\tAt form: >>>>>>>>>>(io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt])<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_io_file_open_success_because_file_system_access_is_allowed_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_input_file_open_failure_because_file_system_access_is_denied_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(input-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Builtin 'input-file-open' cannot be executed; file system access is denied by VM. "
        "Enable file system access in VM before trying to run this code.\n"
        "\tAt form: >>>>>>>>>>(input-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt])<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_input_file_open_success_because_file_system_access_is_allowed_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (input-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_output_file_open_failure_because_file_system_access_is_denied_test(void)
{
    octaspire_dern_vm_t *vm = octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(output-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "Builtin 'output-file-open' cannot be executed; file system access is denied by VM. "
        "Enable file system access in VM before trying to run this code.\n"
        "\tAt form: >>>>>>>>>>(output-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt])<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_output_file_open_success_because_file_system_access_is_allowed_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (output-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_input_question_mark_called_with_output_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (output-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-input? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_input_question_mark_called_with_input_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (input-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-input? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_input_question_mark_called_with_io_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-input? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_input_question_mark_called_with_integer_failure_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] 10)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-input? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'port-supports-input?' expects port argument.\n"
        "\tAt form: >>>>>>>>>>(port-supports-input? f)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_input_question_mark_called_without_arguments_failure_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-input?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'port-supports-input?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(port-supports-input?)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_output_question_mark_called_with_input_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (input-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-output? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_output_question_mark_called_with_output_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (output-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-output? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_output_question_mark_called_with_io_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-output? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_output_question_mark_called_with_integer_failure_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] 10)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-output? f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'port-supports-output?' expects port argument.\n"
        "\tAt form: >>>>>>>>>>(port-supports-output? f)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_supports_output_question_mark_called_without_arguments_failure_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-supports-output?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'port-supports-output?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(port-supports-output?)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_close_called_with_io_file_port_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "<input-output-port:" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt (7 octets)>",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    // Close port
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-close f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    // Check the closed port
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "<NOT-OPEN-port:" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt (-1 octets)>",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    // Check that reading from closed file port fails
    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);
        ASSERT_STR_EQ(
            "Builtin 'port-read' failed to read the requested one octet.\n"
            "\tAt form: >>>>>>>>>>(port-read f)<<<<<<<<<<\n",
            octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));
    }

    // Check that closing again fails
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-close f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_dist_called_with_a_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    int32_t dist = 0;

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-dist f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(dist,                             evaluatedValue->value.integer);

        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);

        ++dist;
    }

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-dist f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ(dist,                             evaluatedValue->value.integer);

        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);

        ++dist;
    }

    // Close port
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-close f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-dist f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ((int32_t)-1,                      evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_seek_called_with_a_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);



    // From beginning
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-seek f 0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-dist f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0,                                evaluatedValue->value.integer);



    // From end
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-seek f -1)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-dist f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(7,                                evaluatedValue->value.integer);



    // Backward from current pos
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-seek f -1 'from-current)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-dist f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(6,                                evaluatedValue->value.integer);


    // Forward from current pos
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-seek f 1 'from-current)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-dist f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(7,                                evaluatedValue->value.integer);

    // Close port
    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-close f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-seek f 0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_input_file_open_with_file_system_access_allowed_failure_on_missing_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (input-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "no-such-file.nono]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "<NOT-OPEN-port:" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "no-such-file.nono (-1 octets)>",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_write_failure_on_input_file_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (input-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    for (size_t i = 0; i < 3; ++i)
    {
        evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(port-read f)");

        ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
        ASSERT_EQ((int32_t)(65 + i),                evaluatedValue->value.integer);
    }

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "f");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_PORT, evaluatedValue->typeTag);

    int32_t const fileLengthInOctets =
        octaspire_dern_port_get_length_in_octets(evaluatedValue->value.port);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-write f 70)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "The first argument to builtin 'port-write' must be a port supporting writing.\n"
        "\tAt form: >>>>>>>>>>(port-write f 70)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    // Make sure that the file has still the same size as before the write attempt
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "f");

    ASSERT(evaluatedValue);
    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_PORT, evaluatedValue->typeTag);

    ASSERT_EQ(
        fileLengthInOctets,
        octaspire_dern_port_get_length_in_octets(evaluatedValue->value.port));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_port_length_test(void)
{
    octaspire_dern_vm_config_t config = octaspire_dern_vm_config_default();
    config.fileSystemAccessAllowed = true;

    octaspire_dern_vm_t *vm = octaspire_dern_vm_new_with_config(octaspireDernVmTestAllocator, octaspireDernVmTestStdio, config);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define f [f] (io-file-open [" OCTASPIRE_DERN_CONFIG_TEST_RES_PATH "octaspire_io_file_open_test.txt]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-length f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(7,                                evaluatedValue->value.integer);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-close f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(port-length f)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(-1,                               evaluatedValue->value.integer);

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_integer_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(integer? 0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? 10)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? -1)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? -1.0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? 0.0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? 10.0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? |0|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? [0])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'integer?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(integer?)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(integer? 1 2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'integer?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(integer? 1 2)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_real_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(real? 0.0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? 10.0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? -1.1)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? -1)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? 0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? 10)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? |0|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? [0.0])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'real?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(real?)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(real? 1.1 1.2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'real?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(real? 1.1 1.2)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_number_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(number? 0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? 0.0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? -1.1)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? -1)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? 2048)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? -100)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? |0|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? [0.0])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'number?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(number?)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(number? 1.1 1.2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'number?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(number? 1.1 1.2)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_nil_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(nil? nil)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? 0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? [nil])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? -1)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? 2048)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? |a|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define myNil [myNil] nil)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? myNil)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'nil?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(nil?)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(nil? 1.1 1.2)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'nil?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(nil? 1.1 1.2)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_boolean_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(boolean? true)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? false)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? [true])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? -1)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? 2048)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? |a|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define myBool [myBool] true)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? myBool)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'boolean?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(boolean?)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(boolean? true true)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'boolean?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(boolean? true true)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_character_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(character? |a|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? |0|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? [true])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? |newline|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? 2048)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? 0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define myChar [myChar] |a|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? myChar)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'character?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(character?)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(character? |a| |b|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'character?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(character? |a| |b|)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_string_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(string? [])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? [0])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? |a|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? |newline|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? 2048)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? 0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define myStr [myStr] [abc])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? myStr)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'string?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(string?)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(string? [a] [b])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'string?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(string? [a] [b])<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_symbol_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(symbol? 'a)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? 'abc123)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? |a|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? |newline|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? 2048)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? 0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define mySym [mySym] 10)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? 'mySym)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'symbol?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(symbol?)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(symbol? 'a 'b)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'symbol?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(symbol? (quote a) (quote b))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_vector_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(vector? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? '(1))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? '(1 2 3))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? |newline|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? 2048)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? 0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define mySym [mySym] '(99 98 97 96))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? mySym)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? (hash-map))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'vector?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(vector?)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(vector? '() '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'vector?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(vector? (quote ()) (quote ()))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_hash_map_question_mark_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(hash-map? (hash-map))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? (hash-map 0 |a|))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? (hash-map 0 |a| 1 [abc]))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? |newline|)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? 2048)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? 0)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                            evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(define myHashMap [myHashMap] (hash-map |a| 0))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? myHashMap)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? '())");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(false,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map?)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'hash-map?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(hash-map?)<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(hash-map? (hash-map) (hash-map))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_ERROR, evaluatedValue->typeTag);

    ASSERT_STR_EQ(
        "Builtin 'hash-map?' expects one argument.\n"
        "\tAt form: >>>>>>>>>>(hash-map? (hash-map) (hash-map))<<<<<<<<<<\n",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.error));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_queue_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q [queue] (queue))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(len q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0,                                evaluatedValue->value.integer);



    // 1. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 1])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1])",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));



    // 2. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 2])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1] [line 2])",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));



    // 3. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 3])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1] [line 2] [line 3])",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));



    // 4. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 4])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1] [line 2] [line 3] [line 4])",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_queue_with_max_length_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define q [queue] (queue-with-max-length 3))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(len q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0,                                evaluatedValue->value.integer);



    // 1. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 1])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1])",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));



    // 2. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 2])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1] [line 2])",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));



    // 3. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 3])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 1] [line 2] [line 3])",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));



    // 4. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= q [line 4])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_QUEUE, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string q)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(queue [line 2] [line 3] [line 4])",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_list_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(define l [list] (list))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_BOOLEAN, evaluatedValue->typeTag);
    ASSERT_EQ(true,                             evaluatedValue->value.boolean);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(len l)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_INTEGER, evaluatedValue->typeTag);
    ASSERT_EQ(0,                                evaluatedValue->value.integer);



    // 1. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= l [line 1])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_LIST, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string l)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(list [line 1])",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));



    // 2. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= l [line 2])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_LIST, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string l)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(list [line 1] [line 2])",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));



    // 3. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= l [line 3])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_LIST, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string l)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(list [line 1] [line 2] [line 3])",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));



    // 4. line
    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(+= l [line 4])");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_LIST, evaluatedValue->typeTag);

    evaluatedValue = octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
        vm,
        "(to-string l)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ(
        "(list [line 1] [line 2] [line 3] [line 4])",
        octaspire_container_utf8_string_get_c_string(evaluatedValue->value.string));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

TEST octaspire_dern_vm_copy_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (copy '(1 2 3)))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("(1 2 3)", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (copy '(1 2 3) (fn (v i) (< i 2))))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("(1 2)", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (copy '(1 2 3) (fn (v i) (== v 2))))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("(2)", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (copy [abc] (fn (v i) (< i 2))))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("[ab]", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(to-string (copy [abc] (fn (v i) (== v |b|))))");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_STRING, evaluatedValue->typeTag);
    ASSERT_STR_EQ("[b]", octaspire_dern_value_as_string_get_c_string(evaluatedValue));

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}


TEST octaspire_dern_vm_split_called_with_string_and_char_test(void)
{
    octaspire_dern_vm_t *vm =
        octaspire_dern_vm_new(octaspireDernVmTestAllocator, octaspireDernVmTestStdio);

    octaspire_dern_value_t *evaluatedValue =
        octaspire_dern_vm_read_from_c_string_and_eval_in_global_environment(
            vm,
            "(split [here is some text] | |)");

    ASSERT_EQ(OCTASPIRE_DERN_VALUE_TAG_VECTOR, evaluatedValue->typeTag);

    size_t const expectedNumOfElems = 4;

    ASSERT_EQ(expectedNumOfElems, octaspire_dern_value_as_vector_get_length(evaluatedValue));

    char const * const expected[] = {"here", "is", "some", "text" };

    for (size_t i = 0; i < expectedNumOfElems; ++i)
    {
        ASSERT_STR_EQ(
            expected[i],
            octaspire_dern_value_as_string_get_c_string(
                octaspire_dern_value_as_vector_get_element_at_const(evaluatedValue, i)));
    }

    octaspire_dern_vm_release(vm);
    vm = 0;

    PASS();
}

GREATEST_SUITE(octaspire_dern_vm_suite)
{
    octaspireDernVmTestAllocator = octaspire_memory_allocator_new(0);
    octaspireDernVmTestStdio     = octaspire_stdio_new(octaspireDernVmTestAllocator);

    assert(octaspireDernVmTestAllocator);
    assert(octaspireDernVmTestStdio);

    RUN_TEST(octaspire_dern_vm_new_test);
    RUN_TEST(octaspire_dern_vm_create_new_value_boolean_test);
    RUN_TEST(octaspire_dern_vm_create_new_value_integer_test);
    RUN_TEST(octaspire_dern_vm_create_new_value_boolean_and_push_one_test);
    RUN_TEST(octaspire_dern_vm_vm_parse_and_eval_true_amid_whitespace_test);

    RUN_TEST(octaspire_dern_vm_special_if_two_elements_false_test);
    RUN_TEST(octaspire_dern_vm_special_if_two_elements_true_test);
    RUN_TEST(octaspire_dern_vm_special_if_three_elements_false_test);
    RUN_TEST(octaspire_dern_vm_special_if_three_elements_true_test);
    RUN_TEST(octaspire_dern_vm_special_if_three_elements_with_function_resulting_true_test);
    RUN_TEST(octaspire_dern_vm_special_if_three_elements_with_function_call_resulting_true_test);
    RUN_TEST(octaspire_dern_vm_special_if_called_with_one_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_special_if_called_with_integer_as_the_first_argument_failure_test);

    RUN_TEST(octaspire_dern_vm_special_select_one_true_selector_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_one_false_selector_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_one_default_selector_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_one_false_and_one_default_selectors_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_one_false_and_one_true_and_one_default_selectors_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_one_false_and_one_true_selectors_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_function_selectors_evaluating_into_false_and_true_to_string_a_test);
    RUN_TEST(octaspire_dern_vm_special_select_function_selectors_failure_on_unknown_symbol_test);
    RUN_TEST(octaspire_dern_vm_special_select_called_with_zero_arguments_failure_test);
    RUN_TEST(octaspire_dern_vm_special_select_called_with_one_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_special_select_called_with_three_arguments_failure_test);
    RUN_TEST(octaspire_dern_vm_special_select_called_non_boolean_selector_failure_test);
    RUN_TEST(octaspire_dern_vm_special_select_called_with_default_as_first_selector_failure_test);

    RUN_TEST(octaspire_dern_vm_special_define_integer_value_test);
    RUN_TEST(octaspire_dern_vm_special_define_integer_value_with_explicit_target_global_env_test);
    RUN_TEST(octaspire_dern_vm_special_define_my_inc_function_test);
    RUN_TEST(octaspire_dern_vm_special_define_factorial_function_with_integers_test);
    RUN_TEST(octaspire_dern_vm_special_define_factorial_function_with_reals_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_two_arguments_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_five_arguments_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_four_arguments_first_being_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_five_arguments_second_being_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_three_arguments_error_at_last_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_three_arguments_docstring_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_three_arguments_name_evaluates_into_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_three_arguments_docstring_is_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_three_arguments_error_in_last_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_three_arguments_trying_to_bind_a_function_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_four_arguments_integer_as_first_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_four_arguments_integer_as_docstring_failure_test);
    RUN_TEST(octaspire_dern_vm_special_define_called_with_four_arguments_docstring_integer_failure_test);

    RUN_TEST(octaspire_dern_vm_special_quote_called_without_arguments_failure_test);

    RUN_TEST(octaspire_dern_vm_builtin_plus_plus_integer_value_test);
    RUN_TEST(octaspire_dern_vm_builtin_doc_for_integer_value_test);
    RUN_TEST(octaspire_dern_vm_builtin_read_and_eval_path_test);
    RUN_TEST(octaspire_dern_vm_builtin_read_and_eval_string_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_1_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_10_2_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_0_2_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_100_10_0dot5_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_100_minus10_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_0_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_10_2_0_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_slash_10_2_character_a_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_mod_5_mod_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_mod_0_mod_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_mod_3_mod_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_mod_4_mod_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_mod_4_mod_0_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_1_2_3_4_minus_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_1_2_3_4_minus_2_2dot5_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_string_cat_dog_and_string_space_and_string_zebra_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_string_ca_and_character_t_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_empty_string_and_characters_k_i_t_t_e_n_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_string_cat_dog_cat_and_string_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_string_abcabcabc_and_character_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_string_abcabcabc_and_character_a_and_character_b_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_string_abcabcabc_and_character_a_and_character_b_and_caharacter_c_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_1_2_3_4_minus_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_1_2_3_4_minus_2_2dot5_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_abcdeaaba_character_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_abcdeaaba_character_y_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_string_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_string_parrot_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_quoted_symbol_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_cat_dog_cat_zebra_cat_quoted_symbol_parrot_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_123_124_abc_123_99_123_integer_123_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_123_124_abc_123_99_123_integer_777_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_3dot14_abc_3dot13_3dot14_3dot146_3dot14_real_3dot14_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_string_3dot14_abc_3dot13_3dot14_3dot146_3dot14_real_7dot11_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_abc_def_aaxa_char_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_abc_def_aaxa_char_y_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_string_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_string_parrot_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_symbol_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_dog_cat_cat_zebra_cat_symbol_parrot_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_123_dog_cat_123_123_cat_zebra_123_integer_123_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_321_dog_cat_321_321_cat_zebra_321_integer_123_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_3dot14_dog_cat_3dot14_3dot14_cat_zebra_3dot14_real_3dot14_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_symbol_cat_3dot14_dog_cat_3dot14_3dot14_cat_zebra_3dot14_real_4dot14_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_vector_of_chars_a_b_c_a_a_g_u_a_char_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_vector_of_chars_a_b_c_a_a_g_u_a_char_x_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_vector_of_strings_cat_dog_cat_zebra_parrot_cat_string_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_vector_of_strings_cat_dog_cat_zebra_parrot_cat_string_kitten_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_vector_of_symbols_cat_dog_cat_zebra_parrot_cat_symbol_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_vector_of_symbols_cat_dog_cat_zebra_parrot_cat_symbol_mouse_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_chars_a_b_c_d_char_c_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_chars_a_b_c_d_char_x_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_chars_a_b_c_d_char_b_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_strings_cat_dog_zebra_kitten_string_zebra_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_strings_cat_dog_zebra_kitten_string_parrot_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_integers_1_2_3_4_integer_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_integers_1_2_3_4_integer_5_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_reals_2dot1_2dot2_2dot3_2dot4_real_2dot2_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_hash_map_of_reals_2dot1_2dot2_2dot3_2dot4_real_2dot5_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_global_environment_symbol_find_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_global_environment_defined_symbol_xyz_test);
    RUN_TEST(octaspire_dern_vm_builtin_find_from_global_environment_symbol_notfound_test);

    RUN_TEST(octaspire_dern_vm_special_while_with_one_value_to_repeat_test);
    RUN_TEST(octaspire_dern_vm_special_while_with_two_values_to_repeat_test);
    RUN_TEST(octaspire_dern_vm_special_while_called_with_one_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_special_while_called_with_integer_as_first_argument_failure_test);

    RUN_TEST(octaspire_dern_vm_builtin_hash_map_empty_test);
    RUN_TEST(octaspire_dern_vm_builtin_hash_map_one_element_symbol_one_1_test);
    RUN_TEST(octaspire_dern_vm_builtin_hash_map_one_element_1_symbol_one_test);
    RUN_TEST(octaspire_dern_vm_builtin_hash_map_two_elements_strings_dog_barks_and_sun_shines_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_characters_t_bar_newline_tab_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_characters_c_a_t__a_n_d__d_o_g_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_newline_failure_on_missing_end_delimiter_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_yy_failure_on_unknown_char_constant_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_in_hex_A9_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_in_hex_a9_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_a_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_in_hex_0x10000_test);
    RUN_TEST(octaspire_dern_vm_string_literal_with_embedded_character_in_hex_failure_on_too_many_hex_digits_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_empty_vector_of_strings_and_integer_10_and_string_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_vector_of_strings_and_integer_1_and_string_cat_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_hash_map_and_same_key_inserted_multiple_times_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_hash_map_and_hash_map_with_elements_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_hash_map_and_empty_hash_map_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_vector_and_vector_with_elements_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_vector_and_empty_vector_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_with_string_and_index_and_character_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_character_x_and_integer_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_character_x_and_character_exclamation_mark_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_real_3_dot_14_and_reals_1_dot_0_and_zero_dot_14_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_integer_10_and_integers_1_and_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_vector_1_1_2_2_2_3_and_values_1_and_2_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_string_abcd_and_characters_a_and_b_test);
    RUN_TEST(octaspire_dern_vm_builtin_minus_equals_with_hash_map_1_a_2_b_3_c_and_value_1_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_hash_map_and_hash_map_1_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_hash_map_and_1_a_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_hash_map_and_list_1_a_2_b_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_vector_1_2_3_and_4_5_6_test);

    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_string_def_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_symbol_def_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_character_d_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_vector_of_strings_def_ghi_jkl_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_nil_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_booleans_true_and_false_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_integer_128_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_string_abc_and_real_3dot14_test);

    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_string_def_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_symbol_def_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_character_d_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_vector_of_strings_def_ghi_jkl_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_nil_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_booleans_true_and_false_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_integer_128_test);
    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_symbol_abc_and_real_3dot14_test);


    RUN_TEST(octaspire_dern_vm_builtin_plus_equals_with_bad_input_test);
    RUN_TEST(octaspire_dern_vm_run_user_factorial_function_test);

    RUN_TEST(octaspire_dern_vm_special_for_from_0_to_10_test);
    RUN_TEST(octaspire_dern_vm_special_for_from_0_to_10_with_step_2_test);
    RUN_TEST(octaspire_dern_vm_special_for_from_0_to_10_with_step_minus_2_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_from_10_to_0_test);
    RUN_TEST(octaspire_dern_vm_special_for_from_10_to_0_with_step_2_test);
    RUN_TEST(octaspire_dern_vm_special_for_from_10_to_0_with_step_minus_2_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_string_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_string_step_2_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_string_step_minus_2_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_vector_of_strings_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_vector_of_strings_step_2_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_vector_of_strings_step_minus_2_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_environment_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_environment_step_2_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_environment_step_minus_2_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_hash_map_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_hash_map_step_2_test);
    RUN_TEST(octaspire_dern_vm_special_for_in_with_hash_map_step_minus_2_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_called_without_arguments_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_called_with_one_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_second_argument_not_symbol_failure_test);
    RUN_TEST(octaspire_dern_vm_special_for_called_with_integer_as_first_argument_failure_test);


    RUN_TEST(octaspire_dern_vm_error_in_function_body_is_reported_test);
    RUN_TEST(octaspire_dern_vm_builtin_nth_called_with_0_and_string_abc_test);
    RUN_TEST(octaspire_dern_vm_builtin_nth_called_with_1_and_string_abc_test);
    RUN_TEST(octaspire_dern_vm_builtin_nth_called_with_2_and_string_abc_test);
    RUN_TEST(octaspire_dern_vm_builtin_nth_called_with_3_and_string_abc_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_nth_called_with_0_and_vector_1_2_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_nth_called_with_1_and_vector_1_2_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_nth_called_with_2_and_vector_1_2_3_test);
    RUN_TEST(octaspire_dern_vm_builtin_nth_called_with_3_and_vector_1_2_3_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_nth_called_with_0_and_hash_map_1a_2b_3c_test);
    RUN_TEST(octaspire_dern_vm_builtin_nth_called_with_1_and_hash_map_1a_2b_3c_test);
    RUN_TEST(octaspire_dern_vm_builtin_nth_called_with_2_and_hash_map_1a_2b_3c_test);
    RUN_TEST(octaspire_dern_vm_builtin_nth_called_with_3_and_hash_map_1a_2b_3c_failure_test);
    RUN_TEST(octaspire_dern_vm_changing_atom_doesnt_change_another_defined_from_it_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_do_inside_function_test);
    RUN_TEST(octaspire_dern_vm_special_do_error_stops_evaluation_and_is_reported_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_for_with_numeric_range_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_for_with_collection_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_for_with_string_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_for_with_environment_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_for_with_hash_map_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_in_special_while_inside_function_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_called_without_argument_test);
    RUN_TEST(octaspire_dern_vm_builtin_return_called_with_two_arguments_failure_test);
    RUN_TEST(octaspire_dern_vm_function_taking_one_regular_and_varargs_called_with_four_arguments_test);
    RUN_TEST(octaspire_dern_vm_function_taking_one_regular_and_varargs_called_with_one_argument_test);
    RUN_TEST(octaspire_dern_vm_function_taking_one_regular_and_varargs_called_with_zero_arguments_test);

    RUN_TEST(octaspire_dern_vm_newly_created_function_returned_from_another_function_and_used_test);
    RUN_TEST(octaspire_dern_vm_recursive_function_used_test);
    RUN_TEST(octaspire_dern_vm_mutually_recursive_functions_used_test);

    RUN_TEST(octaspire_dern_vm_special_and_called_without_arguments_test);
    RUN_TEST(octaspire_dern_vm_special_or_called_without_arguments_test);
    RUN_TEST(octaspire_dern_vm_builtin_not_called_without_arguments_failure_test);

    RUN_TEST(octaspire_dern_vm_special_and_called_with_one_argument_test);
    RUN_TEST(octaspire_dern_vm_special_or_called_with_one_argument_test);

    RUN_TEST(octaspire_dern_vm_special_and_called_with_one_false_argument_test);
    RUN_TEST(octaspire_dern_vm_special_or_called_with_one_false_argument_test);
    RUN_TEST(octaspire_dern_vm_builtin_not_called_with_one_false_argument_test);
    RUN_TEST(octaspire_dern_vm_builtin_not_called_with_one_true_argument_test);
    RUN_TEST(octaspire_dern_vm_builtin_not_called_with_one_integer_argument_failure_test);
    RUN_TEST(octaspire_dern_vm_builtin_not_called_with_two_boolean_arguments_failure_test);

    RUN_TEST(octaspire_dern_vm_special_and_called_with_three_arguments_test);
    RUN_TEST(octaspire_dern_vm_special_or_called_with_three_arguments_test);

    RUN_TEST(octaspire_dern_vm_special_and_called_with_three_arguments_with_false_as_second_test);
    RUN_TEST(octaspire_dern_vm_special_or_called_with_three_arguments_with_true_as_second_test);

    RUN_TEST(octaspire_dern_vm_special_greater_than_called_with_two_reals_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_called_with_two_integers_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_called_with_integer_10_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_called_with_integer_9_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_called_with_real_9dot9_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_called_with_real_10dot1_and_integer_10_test);

    RUN_TEST(octaspire_dern_vm_special_greater_than_or_equal_called_with_two_reals_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_or_equal_called_with_two_integers_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_or_equal_called_with_integer_10_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_or_equal_called_with_integer_9_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_or_equal_called_with_real_9dot9_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_special_greater_than_or_equal_called_with_real_10dot1_and_integer_10_test);

    RUN_TEST(octaspire_dern_vm_special_less_than_called_with_two_reals_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_called_with_two_integers_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_called_with_integer_9_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_called_with_integer_10_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_called_with_real_10dot1_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_called_with_real_9dot9_and_integer_10_test);

    RUN_TEST(octaspire_dern_vm_special_less_than_or_equal_called_with_two_reals_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_or_equal_called_with_two_integers_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_or_equal_called_with_integer_9_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_or_equal_called_with_integer_10_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_or_equal_called_with_real_10dot1_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_special_less_than_or_equal_called_with_real_9dot9_and_integer_10_test);

    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_reals_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_two_integers_test);
    RUN_TEST(octaspire_dern_vm_buildin_equals_equals_called_with_integer_9_and_reals_9dot1_and_9dot0_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals__called_with_integer_10_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_real_10dot1_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_builtin_equals_equals_called_with_real_9dot9_and_integer_10_test);

    RUN_TEST(octaspire_dern_vm_builtin_exclamation_equals_called_with_two_reals_test);
    RUN_TEST(octaspire_dern_vm_builtin_exclamation_equals_called_with_two_integers_test);
    RUN_TEST(octaspire_dern_vm_buildin_exclamation_equals_called_with_integer_9_and_reals_9dot1_and_9dot0_test);
    RUN_TEST(octaspire_dern_vm_builtin_exclamation_equals_called_with_integer_10_and_real_9dot9_test);
    RUN_TEST(octaspire_dern_vm_builtin_exclamation_equals_called_with_real_10dot1_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_builtin_exclamation_equals_called_with_real_9dot9_and_integer_10_test);
    RUN_TEST(octaspire_dern_vm_error_during_user_function_call_test);
    RUN_TEST(octaspire_dern_vm_error_during_builtin_call_test);
    RUN_TEST(octaspire_dern_vm_error_during_special_call_test);
    RUN_TEST(octaspire_dern_vm_error_during_special_call_during_user_function_call_test);
    RUN_TEST(octaspire_dern_vm_special_eval_plus_1_2_test);
    RUN_TEST(octaspire_dern_vm_special_eval_plus_1_2_in_given_global_env_test);
    RUN_TEST(octaspire_dern_vm_special_eval_value_from_given_local_env_test);
    RUN_TEST(octaspire_dern_vm_special_eval_eval_eval_f_1_2_test);
    RUN_TEST(octaspire_dern_vm_special_eval_failure_on_integer_on_second_argument_test);
    RUN_TEST(octaspire_dern_vm_special_eval_failure_on_unbound_symbol_on_second_argument_test);
    RUN_TEST(octaspire_dern_vm_special_eval_called_with_three_arguments_failure_test);

    RUN_TEST(octaspire_dern_vm_create_new_value_copy_called_with_vector_value_of_int_values_test);

    RUN_TEST(octaspire_dern_vm_multiline_comment_test);
    RUN_TEST(octaspire_dern_vm_multiline_comment_missing_chars_test);

    RUN_TEST(octaspire_dern_vm_io_file_open_failure_because_file_system_access_is_denied_test);
    RUN_TEST(octaspire_dern_vm_io_file_open_success_because_file_system_access_is_allowed_test);
    RUN_TEST(octaspire_dern_vm_input_file_open_failure_because_file_system_access_is_denied_test);
    RUN_TEST(octaspire_dern_vm_input_file_open_success_because_file_system_access_is_allowed_test);
    RUN_TEST(octaspire_dern_vm_output_file_open_failure_because_file_system_access_is_denied_test);
    RUN_TEST(octaspire_dern_vm_output_file_open_success_because_file_system_access_is_allowed_test);

    RUN_TEST(octaspire_dern_vm_port_supports_input_question_mark_called_with_output_file_test);
    RUN_TEST(octaspire_dern_vm_port_supports_input_question_mark_called_with_input_file_test);
    RUN_TEST(octaspire_dern_vm_port_supports_input_question_mark_called_with_io_file_test);
    RUN_TEST(octaspire_dern_vm_port_supports_input_question_mark_called_with_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_port_supports_input_question_mark_called_without_arguments_failure_test);

    RUN_TEST(octaspire_dern_vm_port_supports_output_question_mark_called_with_input_file_test);
    RUN_TEST(octaspire_dern_vm_port_supports_output_question_mark_called_with_output_file_test);
    RUN_TEST(octaspire_dern_vm_port_supports_output_question_mark_called_with_io_file_test);
    RUN_TEST(octaspire_dern_vm_port_supports_output_question_mark_called_with_integer_failure_test);
    RUN_TEST(octaspire_dern_vm_port_supports_output_question_mark_called_without_arguments_failure_test);

    RUN_TEST(octaspire_dern_vm_port_close_called_with_io_file_port_test);
    RUN_TEST(octaspire_dern_vm_port_dist_called_with_a_file_test);
    RUN_TEST(octaspire_dern_vm_port_seek_called_with_a_file_test);

    RUN_TEST(octaspire_dern_vm_input_file_open_with_file_system_access_allowed_failure_on_missing_file_test);
    RUN_TEST(octaspire_dern_vm_port_write_failure_on_input_file_test);
    RUN_TEST(octaspire_dern_vm_port_length_test);

    RUN_TEST(octaspire_dern_vm_integer_question_mark_test);
    RUN_TEST(octaspire_dern_vm_real_question_mark_test);
    RUN_TEST(octaspire_dern_vm_number_question_mark_test);
    RUN_TEST(octaspire_dern_vm_nil_question_mark_test);
    RUN_TEST(octaspire_dern_vm_boolean_question_mark_test);
    RUN_TEST(octaspire_dern_vm_character_question_mark_test);
    RUN_TEST(octaspire_dern_vm_string_question_mark_test);
    RUN_TEST(octaspire_dern_vm_symbol_question_mark_test);
    RUN_TEST(octaspire_dern_vm_vector_question_mark_test);
    RUN_TEST(octaspire_dern_vm_hash_map_question_mark_test);

    RUN_TEST(octaspire_dern_vm_queue_test);
    RUN_TEST(octaspire_dern_vm_queue_with_max_length_test);
    RUN_TEST(octaspire_dern_vm_list_test);

    RUN_TEST(octaspire_dern_vm_copy_test);

    RUN_TEST(octaspire_dern_vm_split_called_with_string_and_char_test);

    octaspire_stdio_release(octaspireDernVmTestStdio);
    octaspireDernVmTestStdio = 0;

    octaspire_memory_allocator_release(octaspireDernVmTestAllocator);
    octaspireDernVmTestAllocator = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// END OF          ../test/test_dern_vm.c
//////////////////////////////////////////////////////////////////////////////////////////////////






void octaspire_dern_amalgamated_write_test_file(
    char const * const name,
    char const * const buffer,
    size_t const bufferSize)
{
    FILE *stream = fopen(name, "wb");

    if (!stream)
    {
        abort();
    }

    if (!buffer || !bufferSize)
    {
        if (fclose(stream) != 0)
        {
            abort();
        }

        stream = 0;

        printf("  Wrote empty file '%s'\n", name);

        return;
    }
    else
    {
        if (fwrite(buffer, sizeof(char), bufferSize, stream) != bufferSize)
        {
            fclose(stream);
            stream = 0;
            abort();
        }
    }

    if (fclose(stream) != 0)
    {
        abort();
    }

    stream = 0;

    printf("  Wrote file '%s'\n", name);
}


GREATEST_MAIN_DEFS();

int main(int argc, char **argv)
{
    // This banner is created with figlet using font 'small'
    unsigned char octaspire_dern_amalgamated_version_banner[] = {
      0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5f, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x20, 0x2f,
      0x20, 0x5f, 0x20, 0x5c, 0x20, 0x5f, 0x5f, 0x7c, 0x20, 0x7c, 0x5f, 0x20,
      0x5f, 0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x5f, 0x5f, 0x20, 0x5f, 0x5f,
      0x28, 0x5f, 0x29, 0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x20,
      0x7c, 0x20, 0x20, 0x20, 0x5c, 0x20, 0x5f, 0x5f, 0x5f, 0x20, 0x5f, 0x20,
      0x5f, 0x20, 0x5f, 0x20, 0x5f, 0x20, 0x20, 0x0a, 0x7c, 0x20, 0x28, 0x5f,
      0x29, 0x20, 0x2f, 0x20, 0x5f, 0x7c, 0x20, 0x20, 0x5f, 0x2f, 0x20, 0x5f,
      0x60, 0x20, 0x28, 0x5f, 0x2d, 0x3c, 0x20, 0x27, 0x5f, 0x20, 0x5c, 0x20,
      0x7c, 0x20, 0x27, 0x5f, 0x2f, 0x20, 0x2d, 0x5f, 0x29, 0x20, 0x7c, 0x20,
      0x7c, 0x29, 0x20, 0x2f, 0x20, 0x2d, 0x5f, 0x29, 0x20, 0x27, 0x5f, 0x7c,
      0x20, 0x27, 0x20, 0x5c, 0x20, 0x0a, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x2f,
      0x5c, 0x5f, 0x5f, 0x7c, 0x5c, 0x5f, 0x5f, 0x5c, 0x5f, 0x5f, 0x2c, 0x5f,
      0x2f, 0x5f, 0x5f, 0x2f, 0x20, 0x2e, 0x5f, 0x5f, 0x2f, 0x5f, 0x7c, 0x5f,
      0x7c, 0x20, 0x5c, 0x5f, 0x5f, 0x5f, 0x7c, 0x20, 0x7c, 0x5f, 0x5f, 0x5f,
      0x2f, 0x5c, 0x5f, 0x5f, 0x5f, 0x7c, 0x5f, 0x7c, 0x20, 0x7c, 0x5f, 0x7c,
      0x7c, 0x5f, 0x7c, 0x0a, 0x20, 0x20, 0x41, 0x6d, 0x61, 0x6c, 0x67, 0x61,
      0x6d, 0x61, 0x74, 0x65, 0x64, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
      0x6e, 0x7c, 0x5f, 0x7c, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x2d, 0x61, 0x6c,
      0x6f, 0x6e, 0x65, 0x20, 0x75, 0x6e, 0x69, 0x74, 0x20, 0x74, 0x65, 0x73,
      0x74, 0x20, 0x72, 0x75, 0x6e, 0x6e, 0x65, 0x72, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x0a, '\0'
    };





    printf(
        "%s  %s\n\n",
        octaspire_dern_amalgamated_version_banner,
        OCTASPIRE_DERN_CONFIG_VERSION_STR);

    printf(
        "  This is stand-alone unit test runner for the amalgamated version of\n"
        "  Octaspire Dern. Some of the unit tests test reading of files from\n"
        "  the filesystem. The full source distribution has these files in\n"
        "  the 'test/resource' directory. But because this amalgamated\n"
        "  distribution can have only one file, to be able to run all\n"
        "  the tests succesfully something must be done. What do you\n"
        "  want to do? Select 'a', 'b', 'c' or any other key:\n"
        "\n"
        "  a) Let this program to write those files to disk to the current working\n"
        "     directory. All existing files with the same name will be OVERWRITTEN.\n"
        "     The files to be written are of form 'octaspire_XYZ_test.abc', where XYZ\n"
        "     is the name of the test and abc is some suffix.\n"
        "\n"
        "  b) Let those tests to fail on missing files, or succeed if the files are\n"
        "     already present in the current working directory.\n"
        "\n"
        "  c) Abort and quit this program.\n"
        "\n"
        "  > ");

    int const c = getchar();

    switch (c)
    {
        case 'a':
        {
            printf("Writing test files to current working directory...\n");



            char const octaspire_dern_vm_run_user_factorial_function_test_dern[] = {
              0x28, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x20, 0x66, 0x61, 0x63, 0x74,
              0x20, 0x5b, 0x66, 0x61, 0x63, 0x74, 0x5d, 0x20, 0x27, 0x28, 0x6e, 0x20,
              0x5b, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x61,
              0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x65, 0x20, 0x6e, 0x21, 0x5d, 0x29,
              0x20, 0x28, 0x66, 0x6e, 0x20, 0x28, 0x6e, 0x29, 0x20, 0x28, 0x69, 0x66,
              0x20, 0x28, 0x3d, 0x3d, 0x20, 0x6e, 0x20, 0x30, 0x29, 0x20, 0x31, 0x20,
              0x28, 0x2a, 0x20, 0x6e, 0x20, 0x28, 0x66, 0x61, 0x63, 0x74, 0x20, 0x28,
              0x2d, 0x20, 0x6e, 0x20, 0x31, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x0a,
              0x28, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x20, 0x69, 0x20, 0x5b, 0x69,
              0x5d, 0x20, 0x30, 0x29, 0x0a, 0x28, 0x77, 0x68, 0x69, 0x6c, 0x65, 0x20,
              0x28, 0x3c, 0x3d, 0x20, 0x69, 0x20, 0x31, 0x30, 0x30, 0x29, 0x20, 0x28,
              0x66, 0x61, 0x63, 0x74, 0x20, 0x31, 0x30, 0x29, 0x20, 0x28, 0x2b, 0x2b,
              0x20, 0x69, 0x29, 0x29, 0x0a
            };
            size_t const octaspire_dern_vm_run_user_factorial_function_test_dern_len = 149;

            octaspire_dern_amalgamated_write_test_file(
                "octaspire_dern_vm_run_user_factorial_function_test.dern",
                 octaspire_dern_vm_run_user_factorial_function_test_dern,
                 octaspire_dern_vm_run_user_factorial_function_test_dern_len);





            char const octaspire_read_and_eval_path_test_dern[] = {
              0x28, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x20, 0x79, 0x20, 0x5b, 0x79,
              0x5d, 0x20, 0x31, 0x30, 0x30, 0x29, 0x0a, 0x79, 0x0a, 0x28, 0x64, 0x65,
              0x66, 0x69, 0x6e, 0x65, 0x20, 0x78, 0x20, 0x5b, 0x78, 0x5d, 0x20, 0x32,
              0x30, 0x30, 0x29, 0x0a, 0x78, 0x0a
            };
            size_t const octaspire_read_and_eval_path_test_dern_len = 42;

            octaspire_dern_amalgamated_write_test_file(
                "octaspire_read_and_eval_path_test.dern",
                 octaspire_read_and_eval_path_test_dern,
                 octaspire_read_and_eval_path_test_dern_len);





            char const octaspire_io_file_open_test_txt[] = {
              0x41, 0x42, 0x43, 0x41, 0x42, 0x43, 0x0a
            };
            size_t const octaspire_io_file_open_test_txt_len = 7;

            octaspire_dern_amalgamated_write_test_file(
                "octaspire_io_file_open_test.txt",
                 octaspire_io_file_open_test_txt,
                 octaspire_io_file_open_test_txt_len);


            printf("Done.\n");
        }
        break;

        case 'b':
        {
            printf("Tests reading files will fail, if the required files are not available.\n");
        }
        break;

        case 'c':
        default:
        {
            printf("Going to quit now, as requested\n");
            return EXIT_FAILURE;
        }
        break;
    }










    GREATEST_MAIN_BEGIN();
    RUN_SUITE(octaspire_dern_lexer_suite);
    RUN_SUITE(octaspire_dern_vm_suite);
    GREATEST_MAIN_END();
}


#endif // OCTASPIRE_DERN_AMALGAMATED_UNIT_TEST_IMPLEMENTATION

